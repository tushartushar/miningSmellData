Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The method has 111 lines of code.
Long Method,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The method has 155 lines of code.
Long Method,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The method has 113 lines of code.
Complex Method,OpenGlobe.Core,AxisAlignedBoundingBox,C:\repos\virtualglobebook_OpenGlobe\Source\Core\BoundingVolumes\AxisAlignedBoundingBox.cs,AxisAlignedBoundingBox,Cyclomatic complexity of the method is 10
Complex Method,OpenGlobe.Core,EarClipping,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClipping.cs,Triangulate,Cyclomatic complexity of the method is 10
Complex Method,OpenGlobe.Core,EarClippingOnEllipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClippingOnEllipsoid.cs,Triangulate,Cyclomatic complexity of the method is 10
Complex Method,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,Cyclomatic complexity of the method is 12
Complex Method,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,Cyclomatic complexity of the method is 17
Complex Method,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,Cyclomatic complexity of the method is 8
Long Parameter List,OpenGlobe.Core,ContainmentTests,C:\repos\virtualglobebook_OpenGlobe\Source\Core\CollisionDetection\ContainmentTests.cs,PointInsideThreeSidedInfinitePyramid,The method has 5 parameters. Parameters: point' pyramidApex' pyramidBase0' pyramidBase1' pyramidBase2
Long Parameter List,OpenGlobe.Core,IntersectionTests,C:\repos\virtualglobebook_OpenGlobe\Source\Core\CollisionDetection\IntersectionTests.cs,TryRayPlane,The method has 5 parameters. Parameters: rayOrigin' rayDirection' planeNormal' planeD' intersectionPoint
Long Parameter List,OpenGlobe.Core,Matrix23<T>,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix23.cs,Matrix23,The method has 6 parameters. Parameters: column0row0' column1row0' column0row1' column1row1' column0row2' column1row2
Long Parameter List,OpenGlobe.Core,Matrix24<T>,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix24.cs,Matrix24,The method has 8 parameters. Parameters: column0row0' column1row0' column0row1' column1row1' column0row2' column1row2' column0row3' column1row3
Long Parameter List,OpenGlobe.Core,Matrix32<T>,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix32.cs,Matrix32,The method has 6 parameters. Parameters: column0row0' column1row0' column2row0' column0row1' column1row1' column2row1
Long Parameter List,OpenGlobe.Core,Matrix34<T>,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix34.cs,Matrix34,The method has 12 parameters. Parameters: column0row0' column1row0' column2row0' column0row1' column1row1' column2row1' column0row2' column1row2' column2row2' column0row3' column1row3' column2row3
Long Parameter List,OpenGlobe.Core,Matrix3D,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix3D.cs,Matrix3D,The method has 9 parameters. Parameters: column0row0' column1row0' column2row0' column0row1' column1row1' column2row1' column0row2' column1row2' column2row2
Long Parameter List,OpenGlobe.Core,Matrix3F,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix3F.cs,Matrix3F,The method has 9 parameters. Parameters: column0row0' column1row0' column2row0' column0row1' column1row1' column2row1' column0row2' column1row2' column2row2
Long Parameter List,OpenGlobe.Core,Matrix42<T>,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix42.cs,Matrix42,The method has 8 parameters. Parameters: column0row0' column1row0' column2row0' column3row0' column0row1' column1row1' column2row1' column3row1
Long Parameter List,OpenGlobe.Core,Matrix43<T>,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix43.cs,Matrix43,The method has 12 parameters. Parameters: column0row0' column1row0' column2row0' column3row0' column0row1' column1row1' column2row1' column3row1' column0row2' column1row2' column2row2' column3row2
Long Parameter List,OpenGlobe.Core,Matrix4D,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,Matrix4D,The method has 16 parameters. Parameters: column0row0' column1row0' column2row0' column3row0' column0row1' column1row1' column2row1' column3row1' column0row2' column1row2' column2row2' column3row2' column0row3' column1row3' column2row3' column3row3
Long Parameter List,OpenGlobe.Core,Matrix4D,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreateOrthographicOffCenter,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,OpenGlobe.Core,Matrix4F,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4F.cs,Matrix4F,The method has 16 parameters. Parameters: column0row0' column1row0' column2row0' column3row0' column0row1' column1row1' column2row1' column3row1' column0row2' column1row2' column2row2' column3row2' column0row3' column1row3' column2row3' column3row3
Long Parameter List,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,AddFaceTriangles,The method has 5 parameters. Parameters: leftBottomToTop' bottomLeftToRight' rightBottomToTop' topLeftToRight' CubeMapMesh
Long Statement,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The length of the statement  "                // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value. " is 124.
Long Statement,OpenGlobe.Core,Interval,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Interval.cs,GetHashCode,The length of the statement  "            return _minimum.GetHashCode() ^ _maximum.GetHashCode() ^ _minimumEndpoint.GetHashCode() ^ _maximumEndpoint.GetHashCode(); " is 121.
Long Statement,OpenGlobe.Core,Matrix4D,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,ToString,The length of the statement  "                "Rows: \n({0:n}' {1:n}' {2:n}' {3:n}) \n({4:n}' {5:n}' {6:n}' {7:n}) \n({8:n}' {9:n}' {10:n}' {11:n}) \n({12:n}' {13:n}' {14:n}' {15:n})"' " is 138.
Long Statement,OpenGlobe.Core,Matrix4F,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4F.cs,ToString,The length of the statement  "                "Rows: \n({0:n}' {1:n}' {2:n}' {3:n}) \n({4:n}' {5:n}' {6:n}' {7:n}) \n({8:n}' {9:n}' {10:n}' {11:n}) \n({12:n}' {13:n}' {14:n}' {15:n})"' " is 138.
Long Statement,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & CubeMapEllipsoidVertexAttributes.TextureCoordinate) == CubeMapEllipsoidVertexAttributes.TextureCoordinate) " is 130.
Long Statement,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The length of the statement  "                VertexAttributeHalfFloatVector2 textureCoordinateAttribute = new VertexAttributeHalfFloatVector2("textureCoordinate"' numberOfVertices); " is 136.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & GeographicGridEllipsoidVertexAttributes.Position) != GeographicGridEllipsoidVertexAttributes.Position) " is 126.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "            IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * NumberOfTriangles(numberOfSlicePartitions' numberOfStackPartitions)); " is 125.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & GeographicGridEllipsoidVertexAttributes.Normal) == GeographicGridEllipsoidVertexAttributes.Normal) " is 122.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & GeographicGridEllipsoidVertexAttributes.TextureCoordinate) == GeographicGridEllipsoidVertexAttributes.TextureCoordinate) " is 144.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "                VertexAttributeHalfFloatVector2 textureCoordinateAttribute = new VertexAttributeHalfFloatVector2("textureCoordinate"' numberOfVertices); " is 136.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "                    indices.AddTriangle(new TriangleIndicesUnsignedInt(bottomRowOffset + j' bottomRowOffset + j + 1' topRowOffset + j + 1)); " is 120.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "                indices.AddTriangle(new TriangleIndicesUnsignedInt(bottomRowOffset + numberOfSlicePartitions - 1' bottomRowOffset' topRowOffset)); " is 130.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "                indices.AddTriangle(new TriangleIndicesUnsignedInt(bottomRowOffset + numberOfSlicePartitions - 1' topRowOffset' topRowOffset + numberOfSlicePartitions - 1)); " is 157.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "            indices.AddTriangle(new TriangleIndicesUnsignedInt(lastPosition' lastPosition - numberOfSlicePartitions' lastPosition - 1)); " is 124.
Long Statement,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & SubdivisionEllipsoidVertexAttributes.Position) != SubdivisionEllipsoidVertexAttributes.Position) " is 120.
Long Statement,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & SubdivisionEllipsoidVertexAttributes.TextureCoordinate) == SubdivisionEllipsoidVertexAttributes.TextureCoordinate) " is 138.
Long Statement,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The length of the statement  "                VertexAttributeHalfFloatVector2 textureCoordinateAttribute = new VertexAttributeHalfFloatVector2("textureCoordinate"' numberOfVertices); " is 136.
Long Statement,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & SubdivisionSphereVertexAttributes.TextureCoordinate) == SubdivisionSphereVertexAttributes.TextureCoordinate) " is 132.
Long Statement,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The length of the statement  "                VertexAttributeHalfFloatVector2 textureCoordinateAttribute = new VertexAttributeHalfFloatVector2("textureCoordinate"' numberOfVertices); " is 136.
Magic Number,OpenGlobe.Core,IntersectionTests,C:\repos\virtualglobebook_OpenGlobe\Source\Core\CollisionDetection\IntersectionTests.cs,TryRayPlane,The following statement contains a magic number: if (Math.Abs(denominator) < 0.00000000000000000001)              {                  //                  // Ray is parallel to plane.  The ray may be in the polygon's plane.                  //                  intersectionPoint = Vector3D.Zero;                  return false;              }
Magic Number,OpenGlobe.Core,Ellipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,Intersections,The following statement contains a magic number: double b = 2.0 *                         (origin.X * direction.X * _oneOverRadiiSquared.X +                          origin.Y * direction.Y * _oneOverRadiiSquared.Y +                          origin.Z * direction.Z * _oneOverRadiiSquared.Z);
Magic Number,OpenGlobe.Core,Ellipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,Intersections,The following statement contains a magic number: double discriminant = b * b - 4 * a * c;
Magic Number,OpenGlobe.Core,Ellipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,Intersections,The following statement contains a magic number: if (discriminant < 0.0)              {                  // no intersections                  return new double[0];               }              else if (discriminant == 0.0)              {                  // one intersection at a tangent point                  return new double[1] { -0.5 * b / a };              }
Magic Number,OpenGlobe.Core,Ellipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,Intersections,The following statement contains a magic number: double t = -0.5 * (b + (b > 0.0 ? 1.0 : -1.0) * Math.Sqrt(discriminant));
Magic Number,OpenGlobe.Core,Ellipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,Intersections,The following statement contains a magic number: if (root1 < root2)              {                  return new double[2] { root1' root2 };              }              else              {                  return new double[2] { root2' root1 };              }
Magic Number,OpenGlobe.Core,Ellipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,Intersections,The following statement contains a magic number: if (root1 < root2)              {                  return new double[2] { root1' root2 };              }              else              {                  return new double[2] { root2' root1 };              }
Magic Number,OpenGlobe.Core,Ellipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,ScaleToGeodeticSurface,The following statement contains a magic number: do              {                  alpha -= (s / dSdA);                    da = 1.0 + (alpha * _oneOverRadiiSquared.X);                  db = 1.0 + (alpha * _oneOverRadiiSquared.Y);                  dc = 1.0 + (alpha * _oneOverRadiiSquared.Z);                    double da2 = da * da;                  double db2 = db * db;                  double dc2 = dc * dc;                    double da3 = da * da2;                  double db3 = db * db2;                  double dc3 = dc * dc2;                    s = x2 / (_radiiSquared.X * da2) +                      y2 / (_radiiSquared.Y * db2) +                      z2 / (_radiiSquared.Z * dc2) - 1.0;                    dSdA = -2.0 *                      (x2 / (_radiiToTheFourth.X * da3) +                       y2 / (_radiiToTheFourth.Y * db3) +                       z2 / (_radiiToTheFourth.Z * dc3));              }              while (Math.Abs(s) > 1e-10);
Magic Number,OpenGlobe.Core,Ellipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,ScaleToGeodeticSurface,The following statement contains a magic number: do              {                  alpha -= (s / dSdA);                    da = 1.0 + (alpha * _oneOverRadiiSquared.X);                  db = 1.0 + (alpha * _oneOverRadiiSquared.Y);                  dc = 1.0 + (alpha * _oneOverRadiiSquared.Z);                    double da2 = da * da;                  double db2 = db * db;                  double dc2 = dc * dc;                    double da3 = da * da2;                  double db3 = db * db2;                  double dc3 = dc * dc2;                    s = x2 / (_radiiSquared.X * da2) +                      y2 / (_radiiSquared.Y * db2) +                      z2 / (_radiiSquared.Z * dc2) - 1.0;                    dSdA = -2.0 *                      (x2 / (_radiiToTheFourth.X * da3) +                       y2 / (_radiiToTheFourth.Y * db3) +                       z2 / (_radiiToTheFourth.Z * dc3));              }              while (Math.Abs(s) > 1e-10);
Magic Number,OpenGlobe.Core,Ellipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,ComputeCurve,The following statement contains a magic number: List<Vector3D> positions = new List<Vector3D>(2 + n);
Magic Number,OpenGlobe.Core,VertexAttributeRGB,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\VertexAttributes\VertexAttributeRGB.cs,VertexAttributeRGB,The following statement contains a magic number: if (capacity > int.MaxValue / 3)              {                  throw new ArgumentOutOfRangeException("capacity"' "capacity causes int overflow.");              }
Magic Number,OpenGlobe.Core,VertexAttributeRGBA,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\VertexAttributes\VertexAttributeRGBA.cs,VertexAttributeRGBA,The following statement contains a magic number: if (capacity > int.MaxValue / 4)              {                  throw new ArgumentOutOfRangeException("capacity"' "capacity causes int overflow.");              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: int sign = (int)((bits >> 48) & 0x00008000);
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: int exponent = (int)(((bits >> 52) & 0x7FF) - (1023 - 15));
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: int exponent = (int)(((bits >> 52) & 0x7FF) - (1023 - 15));
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: int exponent = (int)(((bits >> 52) & 0x7FF) - (1023 - 15));
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: if (exponent <= 0)              {                  if (exponent < -10)                  {                      // E is less than -10. The absolute value of F is less than Half.MinValue                      // (F may be a small normalized float' a denormalized float or a zero).                      //                      // We convert F to a half zero with the same sign as F.                        return (UInt16)sign;                  }                    // E is between -10 and 0. F is a normalized double whose magnitude is less than Half.MinNormalizedValue.                  //                  // We convert F to a denormalized half.                    // Add an explicit leading 1 to the significand.                    mantissa = mantissa | 0x10000000000000;                    // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value.                  //                  // Rounding may cause the significand to overflow and make our number normalized. Because of the way a half's bits                  // are laid out' we don't have to treat this case separately; the code below will handle it correctly.                    int t = 43 - exponent;                  long a = (1L << (t - 1)) - 1;                  long b = (mantissa >> t) & 1;                    mantissa = (mantissa + a + b) >> t;                    // Assemble the half from S' E (==zero) and M.                    return (ushort)(sign | (int)mantissa);              }              else if (exponent == 0x7ff - (1023 - 15))              {                  if (mantissa == 0)                  {                      // F is an infinity; convert F to a half infinity with the same sign as F.                        return (ushort)(sign | 0x7c00);                  }                  else                  {                      // F is a NAN; we produce a half NAN that preserves the sign bit and the 10 leftmost bits of the                      // significand of F' with one exception: If the 10 leftmost bits are all zero' the NAN would turn                       // into an infinity' so we have to set at least one bit in the significand.                        int mantissa32 = (int)(mantissa >> 42);                      return (ushort)(sign | 0x7c00 | mantissa32 | ((mantissa == 0) ? 1 : 0));                  }              }              else              {                  // E is greater than zero.  F is a normalized double. We try to convert F to a normalized half.                    // Round to M to the nearest 10-bit value. In case of a tie' round to the nearest even value.                    mantissa = mantissa + 0x1FFFFFFFFFF + ((mantissa >> 42) & 1);                    if ((mantissa & 0x10000000000000) != 0)                  {                      mantissa = 0;        // overflow in significand'                      exponent += 1;        // adjust exponent                  }                    // exponent overflow                  if (exponent > 30) throw new ArithmeticException("Half: Hardware floating-point overflow.");                    // Assemble the half from S' E and M.                    return (ushort)(sign | (exponent << 10) | (int)(mantissa >> 42));              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: if (exponent <= 0)              {                  if (exponent < -10)                  {                      // E is less than -10. The absolute value of F is less than Half.MinValue                      // (F may be a small normalized float' a denormalized float or a zero).                      //                      // We convert F to a half zero with the same sign as F.                        return (UInt16)sign;                  }                    // E is between -10 and 0. F is a normalized double whose magnitude is less than Half.MinNormalizedValue.                  //                  // We convert F to a denormalized half.                    // Add an explicit leading 1 to the significand.                    mantissa = mantissa | 0x10000000000000;                    // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value.                  //                  // Rounding may cause the significand to overflow and make our number normalized. Because of the way a half's bits                  // are laid out' we don't have to treat this case separately; the code below will handle it correctly.                    int t = 43 - exponent;                  long a = (1L << (t - 1)) - 1;                  long b = (mantissa >> t) & 1;                    mantissa = (mantissa + a + b) >> t;                    // Assemble the half from S' E (==zero) and M.                    return (ushort)(sign | (int)mantissa);              }              else if (exponent == 0x7ff - (1023 - 15))              {                  if (mantissa == 0)                  {                      // F is an infinity; convert F to a half infinity with the same sign as F.                        return (ushort)(sign | 0x7c00);                  }                  else                  {                      // F is a NAN; we produce a half NAN that preserves the sign bit and the 10 leftmost bits of the                      // significand of F' with one exception: If the 10 leftmost bits are all zero' the NAN would turn                       // into an infinity' so we have to set at least one bit in the significand.                        int mantissa32 = (int)(mantissa >> 42);                      return (ushort)(sign | 0x7c00 | mantissa32 | ((mantissa == 0) ? 1 : 0));                  }              }              else              {                  // E is greater than zero.  F is a normalized double. We try to convert F to a normalized half.                    // Round to M to the nearest 10-bit value. In case of a tie' round to the nearest even value.                    mantissa = mantissa + 0x1FFFFFFFFFF + ((mantissa >> 42) & 1);                    if ((mantissa & 0x10000000000000) != 0)                  {                      mantissa = 0;        // overflow in significand'                      exponent += 1;        // adjust exponent                  }                    // exponent overflow                  if (exponent > 30) throw new ArithmeticException("Half: Hardware floating-point overflow.");                    // Assemble the half from S' E and M.                    return (ushort)(sign | (exponent << 10) | (int)(mantissa >> 42));              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: if (exponent <= 0)              {                  if (exponent < -10)                  {                      // E is less than -10. The absolute value of F is less than Half.MinValue                      // (F may be a small normalized float' a denormalized float or a zero).                      //                      // We convert F to a half zero with the same sign as F.                        return (UInt16)sign;                  }                    // E is between -10 and 0. F is a normalized double whose magnitude is less than Half.MinNormalizedValue.                  //                  // We convert F to a denormalized half.                    // Add an explicit leading 1 to the significand.                    mantissa = mantissa | 0x10000000000000;                    // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value.                  //                  // Rounding may cause the significand to overflow and make our number normalized. Because of the way a half's bits                  // are laid out' we don't have to treat this case separately; the code below will handle it correctly.                    int t = 43 - exponent;                  long a = (1L << (t - 1)) - 1;                  long b = (mantissa >> t) & 1;                    mantissa = (mantissa + a + b) >> t;                    // Assemble the half from S' E (==zero) and M.                    return (ushort)(sign | (int)mantissa);              }              else if (exponent == 0x7ff - (1023 - 15))              {                  if (mantissa == 0)                  {                      // F is an infinity; convert F to a half infinity with the same sign as F.                        return (ushort)(sign | 0x7c00);                  }                  else                  {                      // F is a NAN; we produce a half NAN that preserves the sign bit and the 10 leftmost bits of the                      // significand of F' with one exception: If the 10 leftmost bits are all zero' the NAN would turn                       // into an infinity' so we have to set at least one bit in the significand.                        int mantissa32 = (int)(mantissa >> 42);                      return (ushort)(sign | 0x7c00 | mantissa32 | ((mantissa == 0) ? 1 : 0));                  }              }              else              {                  // E is greater than zero.  F is a normalized double. We try to convert F to a normalized half.                    // Round to M to the nearest 10-bit value. In case of a tie' round to the nearest even value.                    mantissa = mantissa + 0x1FFFFFFFFFF + ((mantissa >> 42) & 1);                    if ((mantissa & 0x10000000000000) != 0)                  {                      mantissa = 0;        // overflow in significand'                      exponent += 1;        // adjust exponent                  }                    // exponent overflow                  if (exponent > 30) throw new ArithmeticException("Half: Hardware floating-point overflow.");                    // Assemble the half from S' E and M.                    return (ushort)(sign | (exponent << 10) | (int)(mantissa >> 42));              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: if (exponent <= 0)              {                  if (exponent < -10)                  {                      // E is less than -10. The absolute value of F is less than Half.MinValue                      // (F may be a small normalized float' a denormalized float or a zero).                      //                      // We convert F to a half zero with the same sign as F.                        return (UInt16)sign;                  }                    // E is between -10 and 0. F is a normalized double whose magnitude is less than Half.MinNormalizedValue.                  //                  // We convert F to a denormalized half.                    // Add an explicit leading 1 to the significand.                    mantissa = mantissa | 0x10000000000000;                    // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value.                  //                  // Rounding may cause the significand to overflow and make our number normalized. Because of the way a half's bits                  // are laid out' we don't have to treat this case separately; the code below will handle it correctly.                    int t = 43 - exponent;                  long a = (1L << (t - 1)) - 1;                  long b = (mantissa >> t) & 1;                    mantissa = (mantissa + a + b) >> t;                    // Assemble the half from S' E (==zero) and M.                    return (ushort)(sign | (int)mantissa);              }              else if (exponent == 0x7ff - (1023 - 15))              {                  if (mantissa == 0)                  {                      // F is an infinity; convert F to a half infinity with the same sign as F.                        return (ushort)(sign | 0x7c00);                  }                  else                  {                      // F is a NAN; we produce a half NAN that preserves the sign bit and the 10 leftmost bits of the                      // significand of F' with one exception: If the 10 leftmost bits are all zero' the NAN would turn                       // into an infinity' so we have to set at least one bit in the significand.                        int mantissa32 = (int)(mantissa >> 42);                      return (ushort)(sign | 0x7c00 | mantissa32 | ((mantissa == 0) ? 1 : 0));                  }              }              else              {                  // E is greater than zero.  F is a normalized double. We try to convert F to a normalized half.                    // Round to M to the nearest 10-bit value. In case of a tie' round to the nearest even value.                    mantissa = mantissa + 0x1FFFFFFFFFF + ((mantissa >> 42) & 1);                    if ((mantissa & 0x10000000000000) != 0)                  {                      mantissa = 0;        // overflow in significand'                      exponent += 1;        // adjust exponent                  }                    // exponent overflow                  if (exponent > 30) throw new ArithmeticException("Half: Hardware floating-point overflow.");                    // Assemble the half from S' E and M.                    return (ushort)(sign | (exponent << 10) | (int)(mantissa >> 42));              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: if (exponent <= 0)              {                  if (exponent < -10)                  {                      // E is less than -10. The absolute value of F is less than Half.MinValue                      // (F may be a small normalized float' a denormalized float or a zero).                      //                      // We convert F to a half zero with the same sign as F.                        return (UInt16)sign;                  }                    // E is between -10 and 0. F is a normalized double whose magnitude is less than Half.MinNormalizedValue.                  //                  // We convert F to a denormalized half.                    // Add an explicit leading 1 to the significand.                    mantissa = mantissa | 0x10000000000000;                    // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value.                  //                  // Rounding may cause the significand to overflow and make our number normalized. Because of the way a half's bits                  // are laid out' we don't have to treat this case separately; the code below will handle it correctly.                    int t = 43 - exponent;                  long a = (1L << (t - 1)) - 1;                  long b = (mantissa >> t) & 1;                    mantissa = (mantissa + a + b) >> t;                    // Assemble the half from S' E (==zero) and M.                    return (ushort)(sign | (int)mantissa);              }              else if (exponent == 0x7ff - (1023 - 15))              {                  if (mantissa == 0)                  {                      // F is an infinity; convert F to a half infinity with the same sign as F.                        return (ushort)(sign | 0x7c00);                  }                  else                  {                      // F is a NAN; we produce a half NAN that preserves the sign bit and the 10 leftmost bits of the                      // significand of F' with one exception: If the 10 leftmost bits are all zero' the NAN would turn                       // into an infinity' so we have to set at least one bit in the significand.                        int mantissa32 = (int)(mantissa >> 42);                      return (ushort)(sign | 0x7c00 | mantissa32 | ((mantissa == 0) ? 1 : 0));                  }              }              else              {                  // E is greater than zero.  F is a normalized double. We try to convert F to a normalized half.                    // Round to M to the nearest 10-bit value. In case of a tie' round to the nearest even value.                    mantissa = mantissa + 0x1FFFFFFFFFF + ((mantissa >> 42) & 1);                    if ((mantissa & 0x10000000000000) != 0)                  {                      mantissa = 0;        // overflow in significand'                      exponent += 1;        // adjust exponent                  }                    // exponent overflow                  if (exponent > 30) throw new ArithmeticException("Half: Hardware floating-point overflow.");                    // Assemble the half from S' E and M.                    return (ushort)(sign | (exponent << 10) | (int)(mantissa >> 42));              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: if (exponent <= 0)              {                  if (exponent < -10)                  {                      // E is less than -10. The absolute value of F is less than Half.MinValue                      // (F may be a small normalized float' a denormalized float or a zero).                      //                      // We convert F to a half zero with the same sign as F.                        return (UInt16)sign;                  }                    // E is between -10 and 0. F is a normalized double whose magnitude is less than Half.MinNormalizedValue.                  //                  // We convert F to a denormalized half.                    // Add an explicit leading 1 to the significand.                    mantissa = mantissa | 0x10000000000000;                    // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value.                  //                  // Rounding may cause the significand to overflow and make our number normalized. Because of the way a half's bits                  // are laid out' we don't have to treat this case separately; the code below will handle it correctly.                    int t = 43 - exponent;                  long a = (1L << (t - 1)) - 1;                  long b = (mantissa >> t) & 1;                    mantissa = (mantissa + a + b) >> t;                    // Assemble the half from S' E (==zero) and M.                    return (ushort)(sign | (int)mantissa);              }              else if (exponent == 0x7ff - (1023 - 15))              {                  if (mantissa == 0)                  {                      // F is an infinity; convert F to a half infinity with the same sign as F.                        return (ushort)(sign | 0x7c00);                  }                  else                  {                      // F is a NAN; we produce a half NAN that preserves the sign bit and the 10 leftmost bits of the                      // significand of F' with one exception: If the 10 leftmost bits are all zero' the NAN would turn                       // into an infinity' so we have to set at least one bit in the significand.                        int mantissa32 = (int)(mantissa >> 42);                      return (ushort)(sign | 0x7c00 | mantissa32 | ((mantissa == 0) ? 1 : 0));                  }              }              else              {                  // E is greater than zero.  F is a normalized double. We try to convert F to a normalized half.                    // Round to M to the nearest 10-bit value. In case of a tie' round to the nearest even value.                    mantissa = mantissa + 0x1FFFFFFFFFF + ((mantissa >> 42) & 1);                    if ((mantissa & 0x10000000000000) != 0)                  {                      mantissa = 0;        // overflow in significand'                      exponent += 1;        // adjust exponent                  }                    // exponent overflow                  if (exponent > 30) throw new ArithmeticException("Half: Hardware floating-point overflow.");                    // Assemble the half from S' E and M.                    return (ushort)(sign | (exponent << 10) | (int)(mantissa >> 42));              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: if (exponent <= 0)              {                  if (exponent < -10)                  {                      // E is less than -10. The absolute value of F is less than Half.MinValue                      // (F may be a small normalized float' a denormalized float or a zero).                      //                      // We convert F to a half zero with the same sign as F.                        return (UInt16)sign;                  }                    // E is between -10 and 0. F is a normalized double whose magnitude is less than Half.MinNormalizedValue.                  //                  // We convert F to a denormalized half.                    // Add an explicit leading 1 to the significand.                    mantissa = mantissa | 0x10000000000000;                    // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value.                  //                  // Rounding may cause the significand to overflow and make our number normalized. Because of the way a half's bits                  // are laid out' we don't have to treat this case separately; the code below will handle it correctly.                    int t = 43 - exponent;                  long a = (1L << (t - 1)) - 1;                  long b = (mantissa >> t) & 1;                    mantissa = (mantissa + a + b) >> t;                    // Assemble the half from S' E (==zero) and M.                    return (ushort)(sign | (int)mantissa);              }              else if (exponent == 0x7ff - (1023 - 15))              {                  if (mantissa == 0)                  {                      // F is an infinity; convert F to a half infinity with the same sign as F.                        return (ushort)(sign | 0x7c00);                  }                  else                  {                      // F is a NAN; we produce a half NAN that preserves the sign bit and the 10 leftmost bits of the                      // significand of F' with one exception: If the 10 leftmost bits are all zero' the NAN would turn                       // into an infinity' so we have to set at least one bit in the significand.                        int mantissa32 = (int)(mantissa >> 42);                      return (ushort)(sign | 0x7c00 | mantissa32 | ((mantissa == 0) ? 1 : 0));                  }              }              else              {                  // E is greater than zero.  F is a normalized double. We try to convert F to a normalized half.                    // Round to M to the nearest 10-bit value. In case of a tie' round to the nearest even value.                    mantissa = mantissa + 0x1FFFFFFFFFF + ((mantissa >> 42) & 1);                    if ((mantissa & 0x10000000000000) != 0)                  {                      mantissa = 0;        // overflow in significand'                      exponent += 1;        // adjust exponent                  }                    // exponent overflow                  if (exponent > 30) throw new ArithmeticException("Half: Hardware floating-point overflow.");                    // Assemble the half from S' E and M.                    return (ushort)(sign | (exponent << 10) | (int)(mantissa >> 42));              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: if (exponent <= 0)              {                  if (exponent < -10)                  {                      // E is less than -10. The absolute value of F is less than Half.MinValue                      // (F may be a small normalized float' a denormalized float or a zero).                      //                      // We convert F to a half zero with the same sign as F.                        return (UInt16)sign;                  }                    // E is between -10 and 0. F is a normalized double whose magnitude is less than Half.MinNormalizedValue.                  //                  // We convert F to a denormalized half.                    // Add an explicit leading 1 to the significand.                    mantissa = mantissa | 0x10000000000000;                    // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value.                  //                  // Rounding may cause the significand to overflow and make our number normalized. Because of the way a half's bits                  // are laid out' we don't have to treat this case separately; the code below will handle it correctly.                    int t = 43 - exponent;                  long a = (1L << (t - 1)) - 1;                  long b = (mantissa >> t) & 1;                    mantissa = (mantissa + a + b) >> t;                    // Assemble the half from S' E (==zero) and M.                    return (ushort)(sign | (int)mantissa);              }              else if (exponent == 0x7ff - (1023 - 15))              {                  if (mantissa == 0)                  {                      // F is an infinity; convert F to a half infinity with the same sign as F.                        return (ushort)(sign | 0x7c00);                  }                  else                  {                      // F is a NAN; we produce a half NAN that preserves the sign bit and the 10 leftmost bits of the                      // significand of F' with one exception: If the 10 leftmost bits are all zero' the NAN would turn                       // into an infinity' so we have to set at least one bit in the significand.                        int mantissa32 = (int)(mantissa >> 42);                      return (ushort)(sign | 0x7c00 | mantissa32 | ((mantissa == 0) ? 1 : 0));                  }              }              else              {                  // E is greater than zero.  F is a normalized double. We try to convert F to a normalized half.                    // Round to M to the nearest 10-bit value. In case of a tie' round to the nearest even value.                    mantissa = mantissa + 0x1FFFFFFFFFF + ((mantissa >> 42) & 1);                    if ((mantissa & 0x10000000000000) != 0)                  {                      mantissa = 0;        // overflow in significand'                      exponent += 1;        // adjust exponent                  }                    // exponent overflow                  if (exponent > 30) throw new ArithmeticException("Half: Hardware floating-point overflow.");                    // Assemble the half from S' E and M.                    return (ushort)(sign | (exponent << 10) | (int)(mantissa >> 42));              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: if (exponent <= 0)              {                  if (exponent < -10)                  {                      // E is less than -10. The absolute value of F is less than Half.MinValue                      // (F may be a small normalized float' a denormalized float or a zero).                      //                      // We convert F to a half zero with the same sign as F.                        return (UInt16)sign;                  }                    // E is between -10 and 0. F is a normalized double whose magnitude is less than Half.MinNormalizedValue.                  //                  // We convert F to a denormalized half.                    // Add an explicit leading 1 to the significand.                    mantissa = mantissa | 0x10000000000000;                    // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value.                  //                  // Rounding may cause the significand to overflow and make our number normalized. Because of the way a half's bits                  // are laid out' we don't have to treat this case separately; the code below will handle it correctly.                    int t = 43 - exponent;                  long a = (1L << (t - 1)) - 1;                  long b = (mantissa >> t) & 1;                    mantissa = (mantissa + a + b) >> t;                    // Assemble the half from S' E (==zero) and M.                    return (ushort)(sign | (int)mantissa);              }              else if (exponent == 0x7ff - (1023 - 15))              {                  if (mantissa == 0)                  {                      // F is an infinity; convert F to a half infinity with the same sign as F.                        return (ushort)(sign | 0x7c00);                  }                  else                  {                      // F is a NAN; we produce a half NAN that preserves the sign bit and the 10 leftmost bits of the                      // significand of F' with one exception: If the 10 leftmost bits are all zero' the NAN would turn                       // into an infinity' so we have to set at least one bit in the significand.                        int mantissa32 = (int)(mantissa >> 42);                      return (ushort)(sign | 0x7c00 | mantissa32 | ((mantissa == 0) ? 1 : 0));                  }              }              else              {                  // E is greater than zero.  F is a normalized double. We try to convert F to a normalized half.                    // Round to M to the nearest 10-bit value. In case of a tie' round to the nearest even value.                    mantissa = mantissa + 0x1FFFFFFFFFF + ((mantissa >> 42) & 1);                    if ((mantissa & 0x10000000000000) != 0)                  {                      mantissa = 0;        // overflow in significand'                      exponent += 1;        // adjust exponent                  }                    // exponent overflow                  if (exponent > 30) throw new ArithmeticException("Half: Hardware floating-point overflow.");                    // Assemble the half from S' E and M.                    return (ushort)(sign | (exponent << 10) | (int)(mantissa >> 42));              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: int sign = (ui16 >> 15) & 0x00000001;
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: int exponent = (ui16 >> 10) & 0x0000001f;
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: if (exponent == 0)              {                  if (mantissa == 0)                  {                      // Plus or minus zero                        return sign << 31;                  }                  else                  {                      // Denormalized number -- renormalize it                        while ((mantissa & 0x00000400) == 0)                      {                          mantissa <<= 1;                          exponent -= 1;                      }                        exponent += 1;                      mantissa &= ~0x00000400;                  }              }              else if (exponent == 31)              {                  if (mantissa == 0)                  {                      // Positive or negative infinity                        return (sign << 31) | 0x7f800000;                  }                  else                  {                      // Nan -- preserve sign and significand bits                        return (sign << 31) | 0x7f800000 | (mantissa << 13);                  }              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: if (exponent == 0)              {                  if (mantissa == 0)                  {                      // Plus or minus zero                        return sign << 31;                  }                  else                  {                      // Denormalized number -- renormalize it                        while ((mantissa & 0x00000400) == 0)                      {                          mantissa <<= 1;                          exponent -= 1;                      }                        exponent += 1;                      mantissa &= ~0x00000400;                  }              }              else if (exponent == 31)              {                  if (mantissa == 0)                  {                      // Positive or negative infinity                        return (sign << 31) | 0x7f800000;                  }                  else                  {                      // Nan -- preserve sign and significand bits                        return (sign << 31) | 0x7f800000 | (mantissa << 13);                  }              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: if (exponent == 0)              {                  if (mantissa == 0)                  {                      // Plus or minus zero                        return sign << 31;                  }                  else                  {                      // Denormalized number -- renormalize it                        while ((mantissa & 0x00000400) == 0)                      {                          mantissa <<= 1;                          exponent -= 1;                      }                        exponent += 1;                      mantissa &= ~0x00000400;                  }              }              else if (exponent == 31)              {                  if (mantissa == 0)                  {                      // Positive or negative infinity                        return (sign << 31) | 0x7f800000;                  }                  else                  {                      // Nan -- preserve sign and significand bits                        return (sign << 31) | 0x7f800000 | (mantissa << 13);                  }              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: if (exponent == 0)              {                  if (mantissa == 0)                  {                      // Plus or minus zero                        return sign << 31;                  }                  else                  {                      // Denormalized number -- renormalize it                        while ((mantissa & 0x00000400) == 0)                      {                          mantissa <<= 1;                          exponent -= 1;                      }                        exponent += 1;                      mantissa &= ~0x00000400;                  }              }              else if (exponent == 31)              {                  if (mantissa == 0)                  {                      // Positive or negative infinity                        return (sign << 31) | 0x7f800000;                  }                  else                  {                      // Nan -- preserve sign and significand bits                        return (sign << 31) | 0x7f800000 | (mantissa << 13);                  }              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: if (exponent == 0)              {                  if (mantissa == 0)                  {                      // Plus or minus zero                        return sign << 31;                  }                  else                  {                      // Denormalized number -- renormalize it                        while ((mantissa & 0x00000400) == 0)                      {                          mantissa <<= 1;                          exponent -= 1;                      }                        exponent += 1;                      mantissa &= ~0x00000400;                  }              }              else if (exponent == 31)              {                  if (mantissa == 0)                  {                      // Positive or negative infinity                        return (sign << 31) | 0x7f800000;                  }                  else                  {                      // Nan -- preserve sign and significand bits                        return (sign << 31) | 0x7f800000 | (mantissa << 13);                  }              }
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: exponent = exponent + (127 - 15);
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: exponent = exponent + (127 - 15);
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: mantissa = mantissa << 13;
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: return (sign << 31) | (exponent << 23) | mantissa;
Magic Number,OpenGlobe.Core,Half,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: return (sign << 31) | (exponent << 23) | mantissa;
Magic Number,OpenGlobe.Core,Matrix4D,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreatePerspectiveFieldOfView,The following statement contains a magic number: double bottom = Math.Tan(fovy * 0.5);
Magic Number,OpenGlobe.Core,Matrix4D,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreatePerspectiveFieldOfView,The following statement contains a magic number: return new Matrix4D(                  f / aspect' 0.0'                             0.0' 0.0'                  0.0'          f'                             0.0' 0.0'                  0.0'        0.0' (zFar + zNear) / (zNear - zFar)' (2.0 * zFar * zNear) / (zNear - zFar)'                  0.0'        0.0'                            -1.0' 0.0);
Magic Number,OpenGlobe.Core,Matrix4D,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreateOrthographicOffCenter,The following statement contains a magic number: return new Matrix4D(                  2.0 * a' 0.0'      0.0'     tx'                  0.0'     2.0 * b'  0.0'     ty'                  0.0'     0.0'     -2.0 * c' tz'                  0.0'     0.0'      0.0'     1.0);
Magic Number,OpenGlobe.Core,Matrix4D,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreateOrthographicOffCenter,The following statement contains a magic number: return new Matrix4D(                  2.0 * a' 0.0'      0.0'     tx'                  0.0'     2.0 * b'  0.0'     ty'                  0.0'     0.0'     -2.0 * c' tz'                  0.0'     0.0'      0.0'     1.0);
Magic Number,OpenGlobe.Core,Matrix4D,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreateOrthographicOffCenter,The following statement contains a magic number: return new Matrix4D(                  2.0 * a' 0.0'      0.0'     tx'                  0.0'     2.0 * b'  0.0'     ty'                  0.0'     0.0'     -2.0 * c' tz'                  0.0'     0.0'      0.0'     1.0);
Magic Number,OpenGlobe.Core,EarClipping,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClipping.cs,Triangulate,The following statement contains a magic number: if (remainingPositions.Count < 3)              {                  throw new ArgumentOutOfRangeException("positions"' "At least three positions are required.");              }
Magic Number,OpenGlobe.Core,EarClipping,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClipping.cs,Triangulate,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * (remainingPositions.Count - 2));
Magic Number,OpenGlobe.Core,EarClipping,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClipping.cs,Triangulate,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * (remainingPositions.Count - 2));
Magic Number,OpenGlobe.Core,EarClipping,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClipping.cs,Triangulate,The following statement contains a magic number: while (remainingPositions.Count > 3)              {                  Vector2D p0 = previousNode.Value.Vector;                  Vector2D p1 = node.Value.Vector;                  Vector2D p2 = nextNode.Value.Vector;                    if (IsTipConvex(p0' p1' p2))                  {                      bool isEar = true;                      for (LinkedListNode<IndexedVector<Vector2D>> n = ((nextNode.Next != null) ? nextNode.Next : remainingPositions.First);                          n != previousNode;                          n = ((n.Next != null) ? n.Next : remainingPositions.First))                      {                          if (ContainmentTests.PointInsideTriangle(n.Value.Vector' p0' p1' p2))                          {                              isEar = false;                              break;                          }                      }                        if (isEar)                      {                          indices.AddTriangle(new TriangleIndicesUnsignedInt(previousNode.Value.Index' node.Value.Index' nextNode.Value.Index));                          remainingPositions.Remove(node);                            node = nextNode;                          nextNode = (nextNode.Next != null) ? nextNode.Next : remainingPositions.First;                          continue;                      }                  }                    previousNode = (previousNode.Next != null) ? previousNode.Next : remainingPositions.First;                  node = (node.Next != null) ? node.Next : remainingPositions.First;                  nextNode = (nextNode.Next != null) ? nextNode.Next : remainingPositions.First;                    if (--bailCount == 0)                  {                      break;                  }              }
Magic Number,OpenGlobe.Core,EarClippingOnEllipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClippingOnEllipsoid.cs,Triangulate,The following statement contains a magic number: if (remainingPositions.Count < 3)              {                  throw new ArgumentOutOfRangeException("positions"' "At least three positions are required.");              }
Magic Number,OpenGlobe.Core,EarClippingOnEllipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClippingOnEllipsoid.cs,Triangulate,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * (remainingPositions.Count - 2));
Magic Number,OpenGlobe.Core,EarClippingOnEllipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClippingOnEllipsoid.cs,Triangulate,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * (remainingPositions.Count - 2));
Magic Number,OpenGlobe.Core,EarClippingOnEllipsoid,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClippingOnEllipsoid.cs,Triangulate,The following statement contains a magic number: while (remainingPositions.Count > 3)              {                  Vector3D p0 = previousNode.Value.Vector;                  Vector3D p1 = node.Value.Vector;                  Vector3D p2 = nextNode.Value.Vector;                    if (IsTipConvex(p0' p1' p2))                  {                      bool isEar = true;                      for (LinkedListNode<IndexedVector<Vector3D>> n = ((nextNode.Next != null) ? nextNode.Next : remainingPositions.First);                          n != previousNode;                          n = ((n.Next != null) ? n.Next : remainingPositions.First))                      {                          if (ContainmentTests.PointInsideThreeSidedInfinitePyramid(n.Value.Vector' Vector3D.Zero' p0' p1' p2))                          {                              isEar = false;                              break;                          }                      }                        if (isEar)                      {                          indices.AddTriangle(new TriangleIndicesUnsignedInt(previousNode.Value.Index' node.Value.Index' nextNode.Value.Index));                          remainingPositions.Remove(node);                            node = nextNode;                          nextNode = (nextNode.Next != null) ? nextNode.Next : remainingPositions.First;                          continue;                      }                  }                    previousNode = (previousNode.Next != null) ? previousNode.Next : remainingPositions.First;                  node = (node.Next != null) ? node.Next : remainingPositions.First;                  nextNode = (nextNode.Next != null) ? nextNode.Next : remainingPositions.First;                    if (--bailCount == 0)                  {                      break;                  }              }
Magic Number,OpenGlobe.Core,SimplePolygonAlgorithms,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\SimplePolygonAlgorithms.cs,Cleanup,The following statement contains a magic number: if (positionsList.Count < 3)              {                  throw new ArgumentOutOfRangeException("positions"' "At least three positions are required.");              }
Magic Number,OpenGlobe.Core,SimplePolygonAlgorithms,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\SimplePolygonAlgorithms.cs,ComputeArea,The following statement contains a magic number: if (positionsList.Count < 3)              {                  throw new ArgumentOutOfRangeException("positions"' "At least three positions are required.");              }
Magic Number,OpenGlobe.Core,SimplePolygonAlgorithms,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\SimplePolygonAlgorithms.cs,ComputeArea,The following statement contains a magic number: return area * 0.5;
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: if (indices.Values.Count < 3)              {                  throw new ArgumentOutOfRangeException("indices"' "At least three indices are required.");              }
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: if (indices.Values.Count % 3 != 0)              {                  throw new ArgumentException("indices"' "The number of indices must be divisable by three.");              }
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: Queue<TriangleIndicesUnsignedInt> triangles = new Queue<TriangleIndicesUnsignedInt>(indices.Values.Count / 3);
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: Queue<TriangleIndicesUnsignedInt> done = new Queue<TriangleIndicesUnsignedInt>(indices.Values.Count / 3);
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: for (int i = 0; i < indicesValues.Count; i += 3)              {                  triangles.Enqueue(new TriangleIndicesUnsignedInt(indicesValues[i]' indicesValues[i + 1]' indicesValues[i + 2]));              }
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: for (int i = 0; i < indicesValues.Count; i += 3)              {                  triangles.Enqueue(new TriangleIndicesUnsignedInt(indicesValues[i]' indicesValues[i + 1]' indicesValues[i + 2]));              }
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: while (triangles.Count != 0)              {                  TriangleIndicesUnsignedInt triangle = triangles.Dequeue();                    Vector3D v0 = subdividedPositions[triangle.I0];                  Vector3D v1 = subdividedPositions[triangle.I1];                  Vector3D v2 = subdividedPositions[triangle.I2];                    double g0 = v0.AngleBetween(v1);                  double g1 = v1.AngleBetween(v2);                  double g2 = v2.AngleBetween(v0);                                 double max = Math.Max(g0' Math.Max(g1' g2));                    if (max > granularity)                  {                      if (g0 == max)                      {                          Edge edge = new Edge(Math.Min(triangle.I0' triangle.I1)' Math.Max(triangle.I0' triangle.I1));                          int i;                          if (!edges.TryGetValue(edge' out i))                          {                              subdividedPositions.Add((v0 + v1) * 0.5);                              i = subdividedPositions.Count - 1;                              edges.Add(edge' i);                          }                            triangles.Enqueue(new TriangleIndicesUnsignedInt(triangle.I0' i' triangle.I2));                          triangles.Enqueue(new TriangleIndicesUnsignedInt(i' triangle.I1' triangle.I2));                      }                      else if (g1 == max)                      {                          Edge edge = new Edge(Math.Min(triangle.I1' triangle.I2)' Math.Max(triangle.I1' triangle.I2));                          int i;                          if (!edges.TryGetValue(edge' out i))                          {                              subdividedPositions.Add((v1 + v2) * 0.5);                              i = subdividedPositions.Count - 1;                              edges.Add(edge' i);                          }                            triangles.Enqueue(new TriangleIndicesUnsignedInt(triangle.I1' i' triangle.I0));                          triangles.Enqueue(new TriangleIndicesUnsignedInt(i' triangle.I2' triangle.I0));                      }                      else if (g2 == max)                      {                          Edge edge = new Edge(Math.Min(triangle.I2' triangle.I0)' Math.Max(triangle.I2' triangle.I0));                          int i;                          if (!edges.TryGetValue(edge' out i))                          {                              subdividedPositions.Add((v2 + v0) * 0.5);                              i = subdividedPositions.Count - 1;                              edges.Add(edge' i);                          }                            triangles.Enqueue(new TriangleIndicesUnsignedInt(triangle.I2' i' triangle.I1));                          triangles.Enqueue(new TriangleIndicesUnsignedInt(i' triangle.I0' triangle.I1));                      }                  }                  else                  {                      done.Enqueue(triangle);                  }              }
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: while (triangles.Count != 0)              {                  TriangleIndicesUnsignedInt triangle = triangles.Dequeue();                    Vector3D v0 = subdividedPositions[triangle.I0];                  Vector3D v1 = subdividedPositions[triangle.I1];                  Vector3D v2 = subdividedPositions[triangle.I2];                    double g0 = v0.AngleBetween(v1);                  double g1 = v1.AngleBetween(v2);                  double g2 = v2.AngleBetween(v0);                                 double max = Math.Max(g0' Math.Max(g1' g2));                    if (max > granularity)                  {                      if (g0 == max)                      {                          Edge edge = new Edge(Math.Min(triangle.I0' triangle.I1)' Math.Max(triangle.I0' triangle.I1));                          int i;                          if (!edges.TryGetValue(edge' out i))                          {                              subdividedPositions.Add((v0 + v1) * 0.5);                              i = subdividedPositions.Count - 1;                              edges.Add(edge' i);                          }                            triangles.Enqueue(new TriangleIndicesUnsignedInt(triangle.I0' i' triangle.I2));                          triangles.Enqueue(new TriangleIndicesUnsignedInt(i' triangle.I1' triangle.I2));                      }                      else if (g1 == max)                      {                          Edge edge = new Edge(Math.Min(triangle.I1' triangle.I2)' Math.Max(triangle.I1' triangle.I2));                          int i;                          if (!edges.TryGetValue(edge' out i))                          {                              subdividedPositions.Add((v1 + v2) * 0.5);                              i = subdividedPositions.Count - 1;                              edges.Add(edge' i);                          }                            triangles.Enqueue(new TriangleIndicesUnsignedInt(triangle.I1' i' triangle.I0));                          triangles.Enqueue(new TriangleIndicesUnsignedInt(i' triangle.I2' triangle.I0));                      }                      else if (g2 == max)                      {                          Edge edge = new Edge(Math.Min(triangle.I2' triangle.I0)' Math.Max(triangle.I2' triangle.I0));                          int i;                          if (!edges.TryGetValue(edge' out i))                          {                              subdividedPositions.Add((v2 + v0) * 0.5);                              i = subdividedPositions.Count - 1;                              edges.Add(edge' i);                          }                            triangles.Enqueue(new TriangleIndicesUnsignedInt(triangle.I2' i' triangle.I1));                          triangles.Enqueue(new TriangleIndicesUnsignedInt(i' triangle.I0' triangle.I1));                      }                  }                  else                  {                      done.Enqueue(triangle);                  }              }
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: while (triangles.Count != 0)              {                  TriangleIndicesUnsignedInt triangle = triangles.Dequeue();                    Vector3D v0 = subdividedPositions[triangle.I0];                  Vector3D v1 = subdividedPositions[triangle.I1];                  Vector3D v2 = subdividedPositions[triangle.I2];                    double g0 = v0.AngleBetween(v1);                  double g1 = v1.AngleBetween(v2);                  double g2 = v2.AngleBetween(v0);                                 double max = Math.Max(g0' Math.Max(g1' g2));                    if (max > granularity)                  {                      if (g0 == max)                      {                          Edge edge = new Edge(Math.Min(triangle.I0' triangle.I1)' Math.Max(triangle.I0' triangle.I1));                          int i;                          if (!edges.TryGetValue(edge' out i))                          {                              subdividedPositions.Add((v0 + v1) * 0.5);                              i = subdividedPositions.Count - 1;                              edges.Add(edge' i);                          }                            triangles.Enqueue(new TriangleIndicesUnsignedInt(triangle.I0' i' triangle.I2));                          triangles.Enqueue(new TriangleIndicesUnsignedInt(i' triangle.I1' triangle.I2));                      }                      else if (g1 == max)                      {                          Edge edge = new Edge(Math.Min(triangle.I1' triangle.I2)' Math.Max(triangle.I1' triangle.I2));                          int i;                          if (!edges.TryGetValue(edge' out i))                          {                              subdividedPositions.Add((v1 + v2) * 0.5);                              i = subdividedPositions.Count - 1;                              edges.Add(edge' i);                          }                            triangles.Enqueue(new TriangleIndicesUnsignedInt(triangle.I1' i' triangle.I0));                          triangles.Enqueue(new TriangleIndicesUnsignedInt(i' triangle.I2' triangle.I0));                      }                      else if (g2 == max)                      {                          Edge edge = new Edge(Math.Min(triangle.I2' triangle.I0)' Math.Max(triangle.I2' triangle.I0));                          int i;                          if (!edges.TryGetValue(edge' out i))                          {                              subdividedPositions.Add((v2 + v0) * 0.5);                              i = subdividedPositions.Count - 1;                              edges.Add(edge' i);                          }                            triangles.Enqueue(new TriangleIndicesUnsignedInt(triangle.I2' i' triangle.I1));                          triangles.Enqueue(new TriangleIndicesUnsignedInt(i' triangle.I0' triangle.I1));                      }                  }                  else                  {                      done.Enqueue(triangle);                  }              }
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt subdividedIndices = new IndicesUnsignedInt(done.Count * 3);
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: using (FileStream fs = new FileStream(filename' FileMode.Open' FileAccess.Read))              {                  //                  // File Header:                  //                  // Position  Field         Value        Type     Byte Order                  // --------  -----         -----        ----     ----------                  // Byte 0    File Code     9994         Integer  Big                  // Byte 4    Unused        0            Integer  Big                  // Byte 8    Unused        0            Integer  Big                  // Byte 12   Unused        0            Integer  Big                  // Byte 16   Unused        0            Integer  Big                  // Byte 20   Unused        0            Integer  Big                  // Byte 24   File Length   File Length  Integer  Big                  // Byte 28   Version       1000         Integer  Little                  // Byte 32   Shape Type    Shape Type   Integer  Little                  // Byte 36   Bounding Box  Xmin         Double   Little                  // Byte 44   Bounding Box  Ymin         Double   Little                  // Byte 52   Bounding Box  Xmax         Double   Little                  // Byte 60   Bounding Box  Ymax         Double   Little                  // Byte 68*  Bounding Box  Zmin         Double   Little                  // Byte 76*  Bounding Box  Zmax         Double   Little                  // Byte 84*  Bounding Box  Mmin         Double   Little                  // Byte 92*  Bounding Box  Mmax         Double   Little                  //                  // * Unused' with value 0.0' if not Measured or Z type                  //                  byte[] fileHeader = Read(fs' _fileHeaderLength);                  if (fileHeader == null)                  {                      throw new InvalidDataException("Could not read shapefile header.");                  }                    int fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                  if (fileCode != _fileCode)                  {                      //                      // Swap byte order and try again.                      //                      _byteOrder = ByteOrder.BigEndian;                        fileCode = ToInteger(fileHeader' 0' ByteOrder.BigEndian);                        if (fileCode != _fileCode)                      {                          throw new InvalidDataException("Could not read shapefile file code.  Is this a valid shapefile?");                      }                  }                    int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;                    int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);                  if (version != _version)                  {                      throw new InvalidDataException("Shapefile version " + version + " is not supported.  Only version " + _version + " is supported.");                  }                    _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);                    double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);                  double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);                  double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);                  double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);                    // TODO: Publicly expose these                  //double zMin = NoDataToZero(ToDouble(fileHeader' 68' ByteOrder.LittleEndian));                  //double zMax = NoDataToZero(ToDouble(fileHeader' 76' ByteOrder.LittleEndian));                  //double mMin = NoDataToZero(ToDouble(fileHeader' 84' ByteOrder.LittleEndian));                  //double mMax = NoDataToZero(ToDouble(fileHeader' 92' ByteOrder.LittleEndian));                    if (fileLengthInBytes == _fileHeaderLength)                  {                      //                      // If the shapefile is empty (that is' has no records)'                       // the values for xMin' yMin' xMax' and yMax are unspecified.                      //                      // I like zero better.                      //                      xMin = 0.0;                      yMin = 0.0;                      xMax = 0.0;                      yMax = 0.0;                  }                    _extent = new RectangleD(new Vector2D(xMin' yMin)' new Vector2D(xMax' yMax));                    //                  // Read each header...                  //                    //                  // Record Header:                  //                  // Position  Field           Value           Type     Byte Order                  // --------  -----           -----           ----     ----------                  // Byte 0    Record Number   Record Number   Integer  Big                  // Byte 4    Content Length  Content Length  Integer  Big                  //                  _shapes = new List<Shape>();                  byte[] recordHeader;                    while ((recordHeader = Read(fs' _recordHeaderLength)) != null)                  {                      int recordNumber = ToInteger(recordHeader' 0' ByteOrder.BigEndian);                      int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;                      byte[] record = Read(fs' contextLengthInBytes);                        ShapeType recordShapeType = (ShapeType)ToInteger(record' 0' ByteOrder.LittleEndian);                      switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }                  }              }
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToInteger,The following statement contains a magic number: byte[] swapped = new byte[4];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToInteger,The following statement contains a magic number: swapped[0] = buffer[offset + 3];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToInteger,The following statement contains a magic number: swapped[1] = buffer[offset + 2];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToInteger,The following statement contains a magic number: swapped[2] = buffer[offset + 1];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToInteger,The following statement contains a magic number: swapped[3] = buffer[offset];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: byte[] swapped = new byte[4];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[0] = buffer[offset + 7];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[1] = buffer[offset + 6];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[2] = buffer[offset + 5];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[2] = buffer[offset + 5];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[3] = buffer[offset + 4];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[3] = buffer[offset + 4];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[4] = buffer[offset + 3];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[4] = buffer[offset + 3];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[5] = buffer[offset + 2];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[5] = buffer[offset + 2];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[6] = buffer[offset + 1];
Magic Number,OpenGlobe.Core,Shapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[7] = buffer[offset];
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: VertexAttributeDoubleVector3 positionsAttribute = new VertexAttributeDoubleVector3("position"' 8);
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: IndicesUnsignedShort indices = new IndicesUnsignedShort(36);
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: Vector3D corner = 0.5 * length;
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 5' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 5' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 5' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 6' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 6' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 6' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 0' 3));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 3' 2));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 3' 2));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 6' 5));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 6' 5));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 2' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 2' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 3' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 3' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 3' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 7' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 7' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 7' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(3' 0' 4));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(3' 0' 4));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(3' 4' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(3' 4' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(3' 4' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(0' 1' 5));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(0' 5' 4));
Magic Number,OpenGlobe.Core,BoxTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(0' 5' 4));
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * NumberOfTriangles(numberOfPartitions));
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge1to2 = AddEdgePositions(1' 2' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge2to3 = AddEdgePositions(2' 3' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge2to3 = AddEdgePositions(2' 3' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge3to0 = AddEdgePositions(3' 0' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge4to5 = AddEdgePositions(4' 5' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge4to5 = AddEdgePositions(4' 5' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge5to6 = AddEdgePositions(5' 6' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge5to6 = AddEdgePositions(5' 6' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge6to7 = AddEdgePositions(6' 7' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge6to7 = AddEdgePositions(6' 7' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge7to4 = AddEdgePositions(7' 4' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge7to4 = AddEdgePositions(7' 4' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge0to4 = AddEdgePositions(0' 4' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge1to5 = AddEdgePositions(1' 5' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge2to6 = AddEdgePositions(2' 6' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge2to6 = AddEdgePositions(2' 6' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge3to7 = AddEdgePositions(3' 7' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge3to7 = AddEdgePositions(3' 7' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,AddEdgePositions,The following statement contains a magic number: int[] indices = new int[2 + (numberOfPartitions - 1)];
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,NumberOfTriangles,The following statement contains a magic number: return 6 * 2 * numberOfPartitions * numberOfPartitions;
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,NumberOfTriangles,The following statement contains a magic number: return 6 * 2 * numberOfPartitions * numberOfPartitions;
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,NumberOfVertices,The following statement contains a magic number: int numberOfVertices = 8;
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,NumberOfVertices,The following statement contains a magic number: numberOfVertices += 12 * numberOfPartitionsMinusOne;
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,NumberOfVertices,The following statement contains a magic number: numberOfVertices += 6 * numberOfPartitionsMinusOne * numberOfPartitionsMinusOne;
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The following statement contains a magic number: if (numberOfSlicePartitions < 3)              {                  throw new ArgumentOutOfRangeException("numberOfSlicePartitions");              }
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The following statement contains a magic number: if (numberOfStackPartitions < 2)              {                  throw new ArgumentOutOfRangeException("numberOfStackPartitions");              }
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * NumberOfTriangles(numberOfSlicePartitions' numberOfStackPartitions));
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The following statement contains a magic number: for (int i = 0; i < numberOfStackPartitions - 2; ++i)              {                  int topRowOffset = (i * numberOfSlicePartitions) + 1;                  int bottomRowOffset = ((i + 1) * numberOfSlicePartitions) + 1;                    for (int j = 0; j < numberOfSlicePartitions - 1; ++j)                  {                      indices.AddTriangle(new TriangleIndicesUnsignedInt(bottomRowOffset + j' bottomRowOffset + j + 1' topRowOffset + j + 1));                      indices.AddTriangle(new TriangleIndicesUnsignedInt(bottomRowOffset + j' topRowOffset + j + 1' topRowOffset + j));                  }                  indices.AddTriangle(new TriangleIndicesUnsignedInt(bottomRowOffset + numberOfSlicePartitions - 1' bottomRowOffset' topRowOffset));                  indices.AddTriangle(new TriangleIndicesUnsignedInt(bottomRowOffset + numberOfSlicePartitions - 1' topRowOffset' topRowOffset + numberOfSlicePartitions - 1));              }
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,NumberOfTriangles,The following statement contains a magic number: int numberOfTriangles = 2 * numberOfSlicePartitions;
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,NumberOfTriangles,The following statement contains a magic number: numberOfTriangles += 2 * ((numberOfStackPartitions - 2) * numberOfSlicePartitions);
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,NumberOfTriangles,The following statement contains a magic number: numberOfTriangles += 2 * ((numberOfStackPartitions - 2) * numberOfSlicePartitions);
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,NumberOfVertices,The following statement contains a magic number: return 2 + ((numberOfStackPartitions - 1) * numberOfSlicePartitions);
Magic Number,OpenGlobe.Core,RectangleTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\RectangleTessellator.cs,Compute,The following statement contains a magic number: int numberOfIndices = (numberOfPartitionsX * numberOfPartitionsY) * 6;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * SubdivisionUtility.NumberOfTriangles(numberOfSubdivisions));
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: const double negativeOneThird = -1.0 / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Vector3D n1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Vector3D n1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Vector3D n1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 1' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 3' 1)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  IList<Vector3D> positions = subdivisionMesh.Positions;                  Vector3D n01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();                  Vector3D n12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();                  Vector3D n20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();                    Vector3D p01 = n01.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                  Vector3D p12 = n12.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                  Vector3D p20 = n20.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                    positions.Add(p01);                  positions.Add(p12);                  positions.Add(p20);                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    if ((subdivisionMesh.Normals != null) || (subdivisionMesh.TextureCoordinate != null))                  {                      Vector3D d01 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p01);                      Vector3D d12 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p12);                      Vector3D d20 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p20);                        if (subdivisionMesh.Normals != null)                      {                          subdivisionMesh.Normals.Add(d01.ToVector3H());                          subdivisionMesh.Normals.Add(d12.ToVector3H());                          subdivisionMesh.Normals.Add(d20.ToVector3H());                      }                        if (subdivisionMesh.TextureCoordinate != null)                      {                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d01));                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d12));                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d20));                      }                  }                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  subdivisionMesh.Indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  IList<Vector3D> positions = subdivisionMesh.Positions;                  Vector3D n01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();                  Vector3D n12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();                  Vector3D n20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();                    Vector3D p01 = n01.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                  Vector3D p12 = n12.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                  Vector3D p20 = n20.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                    positions.Add(p01);                  positions.Add(p12);                  positions.Add(p20);                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    if ((subdivisionMesh.Normals != null) || (subdivisionMesh.TextureCoordinate != null))                  {                      Vector3D d01 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p01);                      Vector3D d12 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p12);                      Vector3D d20 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p20);                        if (subdivisionMesh.Normals != null)                      {                          subdivisionMesh.Normals.Add(d01.ToVector3H());                          subdivisionMesh.Normals.Add(d12.ToVector3H());                          subdivisionMesh.Normals.Add(d20.ToVector3H());                      }                        if (subdivisionMesh.TextureCoordinate != null)                      {                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d01));                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d12));                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d20));                      }                  }                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  subdivisionMesh.Indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  IList<Vector3D> positions = subdivisionMesh.Positions;                  Vector3D n01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();                  Vector3D n12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();                  Vector3D n20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();                    Vector3D p01 = n01.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                  Vector3D p12 = n12.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                  Vector3D p20 = n20.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                    positions.Add(p01);                  positions.Add(p12);                  positions.Add(p20);                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    if ((subdivisionMesh.Normals != null) || (subdivisionMesh.TextureCoordinate != null))                  {                      Vector3D d01 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p01);                      Vector3D d12 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p12);                      Vector3D d20 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p20);                        if (subdivisionMesh.Normals != null)                      {                          subdivisionMesh.Normals.Add(d01.ToVector3H());                          subdivisionMesh.Normals.Add(d12.ToVector3H());                          subdivisionMesh.Normals.Add(d20.ToVector3H());                      }                        if (subdivisionMesh.TextureCoordinate != null)                      {                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d01));                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d12));                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d20));                      }                  }                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  subdivisionMesh.Indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  IList<Vector3D> positions = subdivisionMesh.Positions;                  Vector3D n01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();                  Vector3D n12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();                  Vector3D n20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();                    Vector3D p01 = n01.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                  Vector3D p12 = n12.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                  Vector3D p20 = n20.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                    positions.Add(p01);                  positions.Add(p12);                  positions.Add(p20);                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    if ((subdivisionMesh.Normals != null) || (subdivisionMesh.TextureCoordinate != null))                  {                      Vector3D d01 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p01);                      Vector3D d12 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p12);                      Vector3D d20 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p20);                        if (subdivisionMesh.Normals != null)                      {                          subdivisionMesh.Normals.Add(d01.ToVector3H());                          subdivisionMesh.Normals.Add(d12.ToVector3H());                          subdivisionMesh.Normals.Add(d20.ToVector3H());                      }                        if (subdivisionMesh.TextureCoordinate != null)                      {                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d01));                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d12));                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d20));                      }                  }                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  subdivisionMesh.Indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  IList<Vector3D> positions = subdivisionMesh.Positions;                  Vector3D n01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();                  Vector3D n12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();                  Vector3D n20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();                    Vector3D p01 = n01.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                  Vector3D p12 = n12.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                  Vector3D p20 = n20.MultiplyComponents(subdivisionMesh.Ellipsoid.Radii);                    positions.Add(p01);                  positions.Add(p12);                  positions.Add(p20);                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    if ((subdivisionMesh.Normals != null) || (subdivisionMesh.TextureCoordinate != null))                  {                      Vector3D d01 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p01);                      Vector3D d12 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p12);                      Vector3D d20 = subdivisionMesh.Ellipsoid.GeodeticSurfaceNormal(p20);                        if (subdivisionMesh.Normals != null)                      {                          subdivisionMesh.Normals.Add(d01.ToVector3H());                          subdivisionMesh.Normals.Add(d12.ToVector3H());                          subdivisionMesh.Normals.Add(d20.ToVector3H());                      }                        if (subdivisionMesh.TextureCoordinate != null)                      {                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d01));                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d12));                          subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(d20));                      }                  }                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  subdivisionMesh.Indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * SubdivisionUtility.NumberOfTriangles(numberOfSubdivisions));
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: const double negativeOneThird = -1.0 / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Vector3D p1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Vector3D p1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Vector3D p1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 1' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 3' 1)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  IList<Vector3D> positions = subdivisionMesh.Positions;                  Vector3D p01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();                  Vector3D p12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();                  Vector3D p20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();                    positions.Add(p01);                  positions.Add(p12);                  positions.Add(p20);                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    if (subdivisionMesh.Normals != null)                  {                      subdivisionMesh.Normals.Add(p01.ToVector3H());                      subdivisionMesh.Normals.Add(p12.ToVector3H());                      subdivisionMesh.Normals.Add(p20.ToVector3H());                  }                    if (subdivisionMesh.TextureCoordinate != null)                  {                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p01));                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p12));                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p20));                  }                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  subdivisionMesh.Indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  IList<Vector3D> positions = subdivisionMesh.Positions;                  Vector3D p01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();                  Vector3D p12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();                  Vector3D p20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();                    positions.Add(p01);                  positions.Add(p12);                  positions.Add(p20);                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    if (subdivisionMesh.Normals != null)                  {                      subdivisionMesh.Normals.Add(p01.ToVector3H());                      subdivisionMesh.Normals.Add(p12.ToVector3H());                      subdivisionMesh.Normals.Add(p20.ToVector3H());                  }                    if (subdivisionMesh.TextureCoordinate != null)                  {                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p01));                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p12));                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p20));                  }                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  subdivisionMesh.Indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  IList<Vector3D> positions = subdivisionMesh.Positions;                  Vector3D p01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();                  Vector3D p12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();                  Vector3D p20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();                    positions.Add(p01);                  positions.Add(p12);                  positions.Add(p20);                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    if (subdivisionMesh.Normals != null)                  {                      subdivisionMesh.Normals.Add(p01.ToVector3H());                      subdivisionMesh.Normals.Add(p12.ToVector3H());                      subdivisionMesh.Normals.Add(p20.ToVector3H());                  }                    if (subdivisionMesh.TextureCoordinate != null)                  {                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p01));                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p12));                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p20));                  }                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  subdivisionMesh.Indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  IList<Vector3D> positions = subdivisionMesh.Positions;                  Vector3D p01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();                  Vector3D p12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();                  Vector3D p20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();                    positions.Add(p01);                  positions.Add(p12);                  positions.Add(p20);                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    if (subdivisionMesh.Normals != null)                  {                      subdivisionMesh.Normals.Add(p01.ToVector3H());                      subdivisionMesh.Normals.Add(p12.ToVector3H());                      subdivisionMesh.Normals.Add(p20.ToVector3H());                  }                    if (subdivisionMesh.TextureCoordinate != null)                  {                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p01));                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p12));                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p20));                  }                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  subdivisionMesh.Indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  IList<Vector3D> positions = subdivisionMesh.Positions;                  Vector3D p01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();                  Vector3D p12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();                  Vector3D p20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();                    positions.Add(p01);                  positions.Add(p12);                  positions.Add(p20);                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    if (subdivisionMesh.Normals != null)                  {                      subdivisionMesh.Normals.Add(p01.ToVector3H());                      subdivisionMesh.Normals.Add(p12.ToVector3H());                      subdivisionMesh.Normals.Add(p20.ToVector3H());                  }                    if (subdivisionMesh.TextureCoordinate != null)                  {                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p01));                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p12));                      subdivisionMesh.TextureCoordinate.Add(SubdivisionUtility.ComputeTextureCoordinate(p20));                  }                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  subdivisionMesh.Indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * SubdivisionUtility.NumberOfTriangles(numberOfSubdivisions));
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: const double negativeOneThird = -1.0 / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: positions.Add(new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird));
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: positions.Add(new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird));
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: positions.Add(new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird));
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(0' 1' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(0' 3' 1)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  positions.Add(((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize());                  positions.Add(((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize());                  positions.Add(((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize());                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  positions.Add(((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize());                  positions.Add(((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize());                  positions.Add(((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize());                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  positions.Add(((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize());                  positions.Add(((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize());                  positions.Add(((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize());                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  positions.Add(((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize());                  positions.Add(((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize());                  positions.Add(((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize());                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Subdivide,The following statement contains a magic number: if (level > 0)              {                  positions.Add(((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize());                  positions.Add(((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize());                  positions.Add(((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize());                    int i01 = positions.Count - 3;                  int i12 = positions.Count - 2;                  int i20 = positions.Count - 1;                    //                  // Subdivide input triangle into four triangles                  //                  --level;                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(triangle.I0' i01' i20)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i01' triangle.I1' i12)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i01' i12' i20)' level);                  Subdivide(positions' indices' new TriangleIndicesUnsignedInt(i20' i12' triangle.I2)' level);              }              else              {                  indices.AddTriangle(triangle);              }
Magic Number,OpenGlobe.Core,SubdivisionUtility,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,NumberOfTriangles,The following statement contains a magic number: for (int i = 0; i <= numberOfSubdivisions; ++i)              {                  numberOfTriangles += Convert.ToInt32(Math.Pow(4' i));              }
Magic Number,OpenGlobe.Core,SubdivisionUtility,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,NumberOfTriangles,The following statement contains a magic number: numberOfTriangles *= 4;
Magic Number,OpenGlobe.Core,SubdivisionUtility,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,NumberOfVertices,The following statement contains a magic number: for (int i = 0; i < numberOfSubdivisions; ++i)              {                  numberOfVertices += Convert.ToInt32(Math.Pow(4' i));              }
Magic Number,OpenGlobe.Core,SubdivisionUtility,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,NumberOfVertices,The following statement contains a magic number: numberOfVertices = 4 + (12 * numberOfVertices);
Magic Number,OpenGlobe.Core,SubdivisionUtility,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,NumberOfVertices,The following statement contains a magic number: numberOfVertices = 4 + (12 * numberOfVertices);
Magic Number,OpenGlobe.Core,SubdivisionUtility,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,ComputeTextureCoordinate,The following statement contains a magic number: return new Vector2H((Math.Atan2(position.Y' position.X) / Trig.TwoPi) + 0.5'                                  (Math.Asin(position.Z) / Math.PI) + 0.5);
Magic Number,OpenGlobe.Core,SubdivisionUtility,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,ComputeTextureCoordinate,The following statement contains a magic number: return new Vector2H((Math.Atan2(position.Y' position.X) / Trig.TwoPi) + 0.5'                                  (Math.Asin(position.Z) / Math.PI) + 0.5);
Magic Number,OpenGlobe.Core,Vector2B,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector2B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 2) + Convert.ToInt32(_y);
Magic Number,OpenGlobe.Core,Vector3B,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector3B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 4) + (Convert.ToInt32(_y) * 2) + Convert.ToInt32(_z);
Magic Number,OpenGlobe.Core,Vector3B,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector3B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 4) + (Convert.ToInt32(_y) * 2) + Convert.ToInt32(_z);
Magic Number,OpenGlobe.Core,Vector4B,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector4B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 8) + (Convert.ToInt32(_y) * 4) + (Convert.ToInt32(_z) * 2) + Convert.ToInt32(_w);
Magic Number,OpenGlobe.Core,Vector4B,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector4B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 8) + (Convert.ToInt32(_y) * 4) + (Convert.ToInt32(_z) * 2) + Convert.ToInt32(_w);
Magic Number,OpenGlobe.Core,Vector4B,C:\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector4B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 8) + (Convert.ToInt32(_y) * 4) + (Convert.ToInt32(_z) * 2) + Convert.ToInt32(_w);
