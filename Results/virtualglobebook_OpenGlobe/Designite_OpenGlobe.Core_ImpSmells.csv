Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenGlobe.Core,TriangleMeshSubdivision,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The method has 111 lines of code.
Long Method,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The method has 155 lines of code.
Long Method,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The method has 113 lines of code.
Complex Method,OpenGlobe.Core,AxisAlignedBoundingBox,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\BoundingVolumes\AxisAlignedBoundingBox.cs,AxisAlignedBoundingBox,Cyclomatic complexity of the method is 10
Complex Method,OpenGlobe.Core,EarClipping,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClipping.cs,Triangulate,Cyclomatic complexity of the method is 10
Complex Method,OpenGlobe.Core,EarClippingOnEllipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClippingOnEllipsoid.cs,Triangulate,Cyclomatic complexity of the method is 10
Complex Method,OpenGlobe.Core,TriangleMeshSubdivision,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,Cyclomatic complexity of the method is 16
Complex Method,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,Cyclomatic complexity of the method is 13
Complex Method,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,Cyclomatic complexity of the method is 17
Complex Method,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,Cyclomatic complexity of the method is 8
Long Parameter List,OpenGlobe.Core,ContainmentTests,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\CollisionDetection\ContainmentTests.cs,PointInsideThreeSidedInfinitePyramid,The method has 5 parameters. Parameters: point' pyramidApex' pyramidBase0' pyramidBase1' pyramidBase2
Long Parameter List,OpenGlobe.Core,IntersectionTests,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\CollisionDetection\IntersectionTests.cs,TryRayPlane,The method has 5 parameters. Parameters: rayOrigin' rayDirection' planeNormal' planeD' intersectionPoint
Long Parameter List,OpenGlobe.Core,Matrix23<T>,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix23.cs,Matrix23,The method has 6 parameters. Parameters: column0row0' column1row0' column0row1' column1row1' column0row2' column1row2
Long Parameter List,OpenGlobe.Core,Matrix24<T>,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix24.cs,Matrix24,The method has 8 parameters. Parameters: column0row0' column1row0' column0row1' column1row1' column0row2' column1row2' column0row3' column1row3
Long Parameter List,OpenGlobe.Core,Matrix32<T>,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix32.cs,Matrix32,The method has 6 parameters. Parameters: column0row0' column1row0' column2row0' column0row1' column1row1' column2row1
Long Parameter List,OpenGlobe.Core,Matrix34<T>,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix34.cs,Matrix34,The method has 12 parameters. Parameters: column0row0' column1row0' column2row0' column0row1' column1row1' column2row1' column0row2' column1row2' column2row2' column0row3' column1row3' column2row3
Long Parameter List,OpenGlobe.Core,Matrix3D,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix3D.cs,Matrix3D,The method has 9 parameters. Parameters: column0row0' column1row0' column2row0' column0row1' column1row1' column2row1' column0row2' column1row2' column2row2
Long Parameter List,OpenGlobe.Core,Matrix3F,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix3F.cs,Matrix3F,The method has 9 parameters. Parameters: column0row0' column1row0' column2row0' column0row1' column1row1' column2row1' column0row2' column1row2' column2row2
Long Parameter List,OpenGlobe.Core,Matrix42<T>,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix42.cs,Matrix42,The method has 8 parameters. Parameters: column0row0' column1row0' column2row0' column3row0' column0row1' column1row1' column2row1' column3row1
Long Parameter List,OpenGlobe.Core,Matrix43<T>,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix43.cs,Matrix43,The method has 12 parameters. Parameters: column0row0' column1row0' column2row0' column3row0' column0row1' column1row1' column2row1' column3row1' column0row2' column1row2' column2row2' column3row2
Long Parameter List,OpenGlobe.Core,Matrix4D,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,Matrix4D,The method has 16 parameters. Parameters: column0row0' column1row0' column2row0' column3row0' column0row1' column1row1' column2row1' column3row1' column0row2' column1row2' column2row2' column3row2' column0row3' column1row3' column2row3' column3row3
Long Parameter List,OpenGlobe.Core,Matrix4D,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreateOrthographicOffCenter,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,OpenGlobe.Core,Matrix4F,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4F.cs,Matrix4F,The method has 16 parameters. Parameters: column0row0' column1row0' column2row0' column3row0' column0row1' column1row1' column2row1' column3row1' column0row2' column1row2' column2row2' column3row2' column0row3' column1row3' column2row3' column3row3
Long Parameter List,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,AddFaceTriangles,The method has 5 parameters. Parameters: leftBottomToTop' bottomLeftToRight' rightBottomToTop' topLeftToRight' CubeMapMesh
Long Statement,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The length of the statement  "                // Round to M to the nearest (10+E)-bit value (with E between -10 and 0); in case of a tie' round to the nearest even value. " is 124.
Long Statement,OpenGlobe.Core,Interval,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Interval.cs,GetHashCode,The length of the statement  "            return _minimum.GetHashCode() ^ _maximum.GetHashCode() ^ _minimumEndpoint.GetHashCode() ^ _maximumEndpoint.GetHashCode(); " is 121.
Long Statement,OpenGlobe.Core,Matrix4D,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,ToString,The length of the statement  "                "Rows: \n({0:n}' {1:n}' {2:n}' {3:n}) \n({4:n}' {5:n}' {6:n}' {7:n}) \n({8:n}' {9:n}' {10:n}' {11:n}) \n({12:n}' {13:n}' {14:n}' {15:n})"' " is 138.
Long Statement,OpenGlobe.Core,Matrix4F,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4F.cs,ToString,The length of the statement  "                "Rows: \n({0:n}' {1:n}' {2:n}' {3:n}) \n({4:n}' {5:n}' {6:n}' {7:n}) \n({8:n}' {9:n}' {10:n}' {11:n}) \n({12:n}' {13:n}' {14:n}' {15:n})"' " is 138.
Long Statement,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & CubeMapEllipsoidVertexAttributes.TextureCoordinate) == CubeMapEllipsoidVertexAttributes.TextureCoordinate) " is 130.
Long Statement,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The length of the statement  "                VertexAttributeHalfFloatVector2 textureCoordinateAttribute = new VertexAttributeHalfFloatVector2("textureCoordinate"' numberOfVertices); " is 136.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & GeographicGridEllipsoidVertexAttributes.Position) != GeographicGridEllipsoidVertexAttributes.Position) " is 126.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "            IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * NumberOfTriangles(numberOfSlicePartitions' numberOfStackPartitions)); " is 125.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & GeographicGridEllipsoidVertexAttributes.Normal) == GeographicGridEllipsoidVertexAttributes.Normal) " is 122.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & GeographicGridEllipsoidVertexAttributes.TextureCoordinate) == GeographicGridEllipsoidVertexAttributes.TextureCoordinate) " is 144.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "                VertexAttributeHalfFloatVector2 textureCoordinateAttribute = new VertexAttributeHalfFloatVector2("textureCoordinate"' numberOfVertices); " is 136.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "                    indices.AddTriangle(new TriangleIndicesUnsignedInt(bottomRowOffset + j' bottomRowOffset + j + 1' topRowOffset + j + 1)); " is 120.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "                indices.AddTriangle(new TriangleIndicesUnsignedInt(bottomRowOffset + numberOfSlicePartitions - 1' bottomRowOffset' topRowOffset)); " is 130.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "                indices.AddTriangle(new TriangleIndicesUnsignedInt(bottomRowOffset + numberOfSlicePartitions - 1' topRowOffset' topRowOffset + numberOfSlicePartitions - 1)); " is 157.
Long Statement,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The length of the statement  "            indices.AddTriangle(new TriangleIndicesUnsignedInt(lastPosition' lastPosition - numberOfSlicePartitions' lastPosition - 1)); " is 124.
Long Statement,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & SubdivisionEllipsoidVertexAttributes.Position) != SubdivisionEllipsoidVertexAttributes.Position) " is 120.
Long Statement,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & SubdivisionEllipsoidVertexAttributes.TextureCoordinate) == SubdivisionEllipsoidVertexAttributes.TextureCoordinate) " is 138.
Long Statement,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The length of the statement  "                VertexAttributeHalfFloatVector2 textureCoordinateAttribute = new VertexAttributeHalfFloatVector2("textureCoordinate"' numberOfVertices); " is 136.
Long Statement,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The length of the statement  "            if ((vertexAttributes & SubdivisionSphereVertexAttributes.TextureCoordinate) == SubdivisionSphereVertexAttributes.TextureCoordinate) " is 132.
Long Statement,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The length of the statement  "                VertexAttributeHalfFloatVector2 textureCoordinateAttribute = new VertexAttributeHalfFloatVector2("textureCoordinate"' numberOfVertices); " is 136.
Magic Number,OpenGlobe.Core,IntersectionTests,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\CollisionDetection\IntersectionTests.cs,TryRayPlane,The following statement contains a magic number: Math.Abs(denominator) < 0.00000000000000000001
Magic Number,OpenGlobe.Core,Ellipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,Intersections,The following statement contains a magic number: double b = 2.0 *                         (origin.X * direction.X * _oneOverRadiiSquared.X +                          origin.Y * direction.Y * _oneOverRadiiSquared.Y +                          origin.Z * direction.Z * _oneOverRadiiSquared.Z);
Magic Number,OpenGlobe.Core,Ellipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,Intersections,The following statement contains a magic number: double discriminant = b * b - 4 * a * c;
Magic Number,OpenGlobe.Core,Ellipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,Intersections,The following statement contains a magic number: double t = -0.5 * (b + (b > 0.0 ? 1.0 : -1.0) * Math.Sqrt(discriminant));
Magic Number,OpenGlobe.Core,Ellipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,Intersections,The following statement contains a magic number: return new double[2] { root1' root2 };
Magic Number,OpenGlobe.Core,Ellipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,ScaleToGeodeticSurface,The following statement contains a magic number: dSdA = -2.0 *                      (x2 / (_radiiToTheFourth.X * da3) +                       y2 / (_radiiToTheFourth.Y * db3) +                       z2 / (_radiiToTheFourth.Z * dc3));
Magic Number,OpenGlobe.Core,Ellipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\Ellipsoid.cs,ComputeCurve,The following statement contains a magic number: List<Vector3D> positions = new List<Vector3D>(2 + n);
Magic Number,OpenGlobe.Core,VertexAttributeRGB,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\VertexAttributes\VertexAttributeRGB.cs,VertexAttributeRGB,The following statement contains a magic number: capacity > int.MaxValue / 3
Magic Number,OpenGlobe.Core,VertexAttributeRGBA,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Geometry\VertexAttributes\VertexAttributeRGBA.cs,VertexAttributeRGBA,The following statement contains a magic number: capacity > int.MaxValue / 4
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: int sign = (int)((bits >> 48) & 0x00008000);
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: int exponent = (int)(((bits >> 52) & 0x7FF) - (1023 - 15));
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: int exponent = (int)(((bits >> 52) & 0x7FF) - (1023 - 15));
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: int exponent = (int)(((bits >> 52) & 0x7FF) - (1023 - 15));
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: exponent < -10
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,DoubleToHalf,The following statement contains a magic number: int t = 43 - exponent;
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: int sign = (ui16 >> 15) & 0x00000001;
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: int exponent = (ui16 >> 10) & 0x0000001f;
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: return sign << 31;
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: exponent = exponent + (127 - 15);
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: exponent = exponent + (127 - 15);
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: mantissa = mantissa << 13;
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: return (sign << 31) | (exponent << 23) | mantissa;
Magic Number,OpenGlobe.Core,Half,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Half.cs,HalfToFloat,The following statement contains a magic number: return (sign << 31) | (exponent << 23) | mantissa;
Magic Number,OpenGlobe.Core,Matrix4D,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreatePerspectiveFieldOfView,The following statement contains a magic number: double bottom = Math.Tan(fovy * 0.5);
Magic Number,OpenGlobe.Core,Matrix4D,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreatePerspectiveFieldOfView,The following statement contains a magic number: return new Matrix4D(                  f / aspect' 0.0'                             0.0' 0.0'                  0.0'          f'                             0.0' 0.0'                  0.0'        0.0' (zFar + zNear) / (zNear - zFar)' (2.0 * zFar * zNear) / (zNear - zFar)'                  0.0'        0.0'                            -1.0' 0.0);
Magic Number,OpenGlobe.Core,Matrix4D,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreateOrthographicOffCenter,The following statement contains a magic number: return new Matrix4D(                  2.0 * a' 0.0'      0.0'     tx'                  0.0'     2.0 * b'  0.0'     ty'                  0.0'     0.0'     -2.0 * c' tz'                  0.0'     0.0'      0.0'     1.0);
Magic Number,OpenGlobe.Core,Matrix4D,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreateOrthographicOffCenter,The following statement contains a magic number: return new Matrix4D(                  2.0 * a' 0.0'      0.0'     tx'                  0.0'     2.0 * b'  0.0'     ty'                  0.0'     0.0'     -2.0 * c' tz'                  0.0'     0.0'      0.0'     1.0);
Magic Number,OpenGlobe.Core,Matrix4D,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Matrices\Matrix4D.cs,CreateOrthographicOffCenter,The following statement contains a magic number: return new Matrix4D(                  2.0 * a' 0.0'      0.0'     tx'                  0.0'     2.0 * b'  0.0'     ty'                  0.0'     0.0'     -2.0 * c' tz'                  0.0'     0.0'      0.0'     1.0);
Magic Number,OpenGlobe.Core,EarClipping,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClipping.cs,Triangulate,The following statement contains a magic number: remainingPositions.Count < 3
Magic Number,OpenGlobe.Core,EarClipping,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClipping.cs,Triangulate,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * (remainingPositions.Count - 2));
Magic Number,OpenGlobe.Core,EarClipping,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClipping.cs,Triangulate,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * (remainingPositions.Count - 2));
Magic Number,OpenGlobe.Core,EarClipping,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClipping.cs,Triangulate,The following statement contains a magic number: remainingPositions.Count > 3
Magic Number,OpenGlobe.Core,EarClippingOnEllipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClippingOnEllipsoid.cs,Triangulate,The following statement contains a magic number: remainingPositions.Count < 3
Magic Number,OpenGlobe.Core,EarClippingOnEllipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClippingOnEllipsoid.cs,Triangulate,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * (remainingPositions.Count - 2));
Magic Number,OpenGlobe.Core,EarClippingOnEllipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClippingOnEllipsoid.cs,Triangulate,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * (remainingPositions.Count - 2));
Magic Number,OpenGlobe.Core,EarClippingOnEllipsoid,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\EarClippingOnEllipsoid.cs,Triangulate,The following statement contains a magic number: remainingPositions.Count > 3
Magic Number,OpenGlobe.Core,SimplePolygonAlgorithms,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\SimplePolygonAlgorithms.cs,Cleanup,The following statement contains a magic number: positionsList.Count < 3
Magic Number,OpenGlobe.Core,SimplePolygonAlgorithms,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\SimplePolygonAlgorithms.cs,ComputeArea,The following statement contains a magic number: positionsList.Count < 3
Magic Number,OpenGlobe.Core,SimplePolygonAlgorithms,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\SimplePolygonAlgorithms.cs,ComputeArea,The following statement contains a magic number: return area * 0.5;
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: indices.Values.Count < 3
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: indices.Values.Count % 3 != 0
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: Queue<TriangleIndicesUnsignedInt> triangles = new Queue<TriangleIndicesUnsignedInt>(indices.Values.Count / 3);
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: Queue<TriangleIndicesUnsignedInt> done = new Queue<TriangleIndicesUnsignedInt>(indices.Values.Count / 3);
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: triangles.Enqueue(new TriangleIndicesUnsignedInt(indicesValues[i]' indicesValues[i + 1]' indicesValues[i + 2]));
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: subdividedPositions.Add((v0 + v1) * 0.5);
Magic Number,OpenGlobe.Core,TriangleMeshSubdivision,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Polygons\TriangleMeshSubdivision.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt subdividedIndices = new IndicesUnsignedInt(done.Count * 3);
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: int fileLengthInBytes = ToInteger(fileHeader' 24' ByteOrder.BigEndian) * 2;
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: int version = ToInteger(fileHeader' 28' ByteOrder.LittleEndian);
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: _shapeType = (ShapeType)ToInteger(fileHeader' 32' ByteOrder.LittleEndian);
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: double xMin = ToDouble(fileHeader' 36' ByteOrder.LittleEndian);
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: double yMin = ToDouble(fileHeader' 44' ByteOrder.LittleEndian);
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: double xMax = ToDouble(fileHeader' 52' ByteOrder.LittleEndian);
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: double yMax = ToDouble(fileHeader' 60' ByteOrder.LittleEndian);
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: int contextLengthInBytes = ToInteger(recordHeader' 4' ByteOrder.BigEndian) * 2;
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,Shapefile,The following statement contains a magic number: switch (recordShapeType)                      {                          case ShapeType.NullShape:                              //                              // Filter out null shapes.  Otherwise' every client                              // would have to deal with them.                              //                              break;                            case ShapeType.Point:                              _shapes.Add(new PointShape(recordNumber'                                   new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))));                              break;                            case ShapeType.Polyline:                          case ShapeType.Polygon:                              RectangleD extent = new RectangleD(                                  new Vector2D(                                      ToDouble(record' 4' ByteOrder.LittleEndian)'                                      ToDouble(record' 12' ByteOrder.LittleEndian))'                                  new Vector2D(                                      ToDouble(record' 20' ByteOrder.LittleEndian)'                                      ToDouble(record' 28' ByteOrder.LittleEndian)));                              int numberOfParts = ToInteger(record' 36' ByteOrder.LittleEndian);                              int numberOfPoints = ToInteger(record' 40' ByteOrder.LittleEndian);                                int[] parts = new int[numberOfParts];                              Vector2D[] points = new Vector2D[numberOfPoints];                                //                              // These two loops can be optimized if the machine is little endian.                              //                              for (int i = 0; i < numberOfParts; ++i)                              {                                  parts[i] = ToInteger(record' 44 + (4 * i)' ByteOrder.LittleEndian);                              }                                int pointsOffset = 44 + (4 * numberOfParts);                              for (int i = 0; i < numberOfPoints; ++i)                              {                                  points[i] = new Vector2D(                                      ToDouble(record' pointsOffset + (16 * i)' ByteOrder.LittleEndian)'                                      ToDouble(record' pointsOffset + (16 * i) + 8' ByteOrder.LittleEndian));                              }                                if (recordShapeType == ShapeType.Polyline)                              {                                  _shapes.Add(new PolylineShape(recordNumber' extent' parts' points));                              }                              else                              {                                  _shapes.Add(new PolygonShape(recordNumber' extent' parts' points));                              }                                break;                            default:                              throw new NotImplementedException("The shapefile type is not supported.  Only null' point' polyline' and polygon are supported.");                      }
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToInteger,The following statement contains a magic number: byte[] swapped = new byte[4];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToInteger,The following statement contains a magic number: swapped[0] = buffer[offset + 3];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToInteger,The following statement contains a magic number: swapped[1] = buffer[offset + 2];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToInteger,The following statement contains a magic number: swapped[2] = buffer[offset + 1];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToInteger,The following statement contains a magic number: swapped[3] = buffer[offset];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: byte[] swapped = new byte[4];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[0] = buffer[offset + 7];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[1] = buffer[offset + 6];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[2] = buffer[offset + 5];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[2] = buffer[offset + 5];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[3] = buffer[offset + 4];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[3] = buffer[offset + 4];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[4] = buffer[offset + 3];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[4] = buffer[offset + 3];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[5] = buffer[offset + 2];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[5] = buffer[offset + 2];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[6] = buffer[offset + 1];
Magic Number,OpenGlobe.Core,Shapefile,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Shapefile\Shapfile.cs,ToDouble,The following statement contains a magic number: swapped[7] = buffer[offset];
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: VertexAttributeDoubleVector3 positionsAttribute = new VertexAttributeDoubleVector3("position"' 8);
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: IndicesUnsignedShort indices = new IndicesUnsignedShort(36);
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: Vector3D corner = 0.5 * length;
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 5' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 5' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 5' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 6' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 6' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(4' 6' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 0' 3));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 3' 2));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 3' 2));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 6' 5));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 6' 5));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 2' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(1' 2' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 3' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 3' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 3' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 7' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 7' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(2' 7' 6));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(3' 0' 4));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(3' 0' 4));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(3' 4' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(3' 4' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(3' 4' 7));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(0' 1' 5));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(0' 5' 4));
Magic Number,OpenGlobe.Core,BoxTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\BoxTessellator.cs,Compute,The following statement contains a magic number: indices.AddTriangle(new TriangleIndicesUnsignedShort(0' 5' 4));
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * NumberOfTriangles(numberOfPartitions));
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge1to2 = AddEdgePositions(1' 2' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge2to3 = AddEdgePositions(2' 3' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge2to3 = AddEdgePositions(2' 3' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge3to0 = AddEdgePositions(3' 0' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge4to5 = AddEdgePositions(4' 5' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge4to5 = AddEdgePositions(4' 5' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge5to6 = AddEdgePositions(5' 6' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge5to6 = AddEdgePositions(5' 6' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge6to7 = AddEdgePositions(6' 7' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge6to7 = AddEdgePositions(6' 7' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge7to4 = AddEdgePositions(7' 4' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge7to4 = AddEdgePositions(7' 4' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge0to4 = AddEdgePositions(0' 4' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge1to5 = AddEdgePositions(1' 5' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge2to6 = AddEdgePositions(2' 6' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge2to6 = AddEdgePositions(2' 6' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge3to7 = AddEdgePositions(3' 7' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,Compute,The following statement contains a magic number: int[] edge3to7 = AddEdgePositions(3' 7' CubeMapMesh);
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,AddEdgePositions,The following statement contains a magic number: int[] indices = new int[2 + (numberOfPartitions - 1)];
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,NumberOfTriangles,The following statement contains a magic number: return 6 * 2 * numberOfPartitions * numberOfPartitions;
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,NumberOfTriangles,The following statement contains a magic number: return 6 * 2 * numberOfPartitions * numberOfPartitions;
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,NumberOfVertices,The following statement contains a magic number: int numberOfVertices = 8;
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,NumberOfVertices,The following statement contains a magic number: numberOfVertices += 12 * numberOfPartitionsMinusOne;
Magic Number,OpenGlobe.Core,CubeMapEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\CubeMapEllipsoidTessellator.cs,NumberOfVertices,The following statement contains a magic number: numberOfVertices += 6 * numberOfPartitionsMinusOne * numberOfPartitionsMinusOne;
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The following statement contains a magic number: numberOfSlicePartitions < 3
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The following statement contains a magic number: numberOfStackPartitions < 2
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * NumberOfTriangles(numberOfSlicePartitions' numberOfStackPartitions));
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,Compute,The following statement contains a magic number: i < numberOfStackPartitions - 2
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,NumberOfTriangles,The following statement contains a magic number: int numberOfTriangles = 2 * numberOfSlicePartitions;
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,NumberOfTriangles,The following statement contains a magic number: numberOfTriangles += 2 * ((numberOfStackPartitions - 2) * numberOfSlicePartitions);
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,NumberOfTriangles,The following statement contains a magic number: numberOfTriangles += 2 * ((numberOfStackPartitions - 2) * numberOfSlicePartitions);
Magic Number,OpenGlobe.Core,GeographicGridEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\GeographicGridEllipsoidTessellator.cs,NumberOfVertices,The following statement contains a magic number: return 2 + ((numberOfStackPartitions - 1) * numberOfSlicePartitions);
Magic Number,OpenGlobe.Core,RectangleTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\RectangleTessellator.cs,Compute,The following statement contains a magic number: int numberOfIndices = (numberOfPartitionsX * numberOfPartitionsY) * 6;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * SubdivisionUtility.NumberOfTriangles(numberOfSubdivisions));
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: const double negativeOneThird = -1.0 / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Vector3D n1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Vector3D n1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Vector3D n1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 1' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 3' 1)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Subdivide,The following statement contains a magic number: Vector3D n01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Subdivide,The following statement contains a magic number: Vector3D n12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Subdivide,The following statement contains a magic number: Vector3D n20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Subdivide,The following statement contains a magic number: int i01 = positions.Count - 3;
Magic Number,OpenGlobe.Core,SubdivisionEllipsoidTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionEllipsoidTessellator.cs,Subdivide,The following statement contains a magic number: int i12 = positions.Count - 2;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * SubdivisionUtility.NumberOfTriangles(numberOfSubdivisions));
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: const double negativeOneThird = -1.0 / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Vector3D p1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Vector3D p1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Vector3D p1 = new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 1' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(0' 3' 1)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Compute,The following statement contains a magic number: Subdivide(subdivisionMesh' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Subdivide,The following statement contains a magic number: Vector3D p01 = ((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize();
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Subdivide,The following statement contains a magic number: Vector3D p12 = ((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize();
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Subdivide,The following statement contains a magic number: Vector3D p20 = ((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize();
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Subdivide,The following statement contains a magic number: int i01 = positions.Count - 3;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellator,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellator.cs,Subdivide,The following statement contains a magic number: int i12 = positions.Count - 2;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: IndicesUnsignedInt indices = new IndicesUnsignedInt(3 * SubdivisionUtility.NumberOfTriangles(numberOfSubdivisions));
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: double negativeRootTwoOverThree = -Math.Sqrt(2.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: const double negativeOneThird = -1.0 / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: double rootSixOverThree = Math.Sqrt(6.0) / 3.0;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: positions.Add(new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird));
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: positions.Add(new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird));
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: positions.Add(new Vector3D(0' (2.0 * Math.Sqrt(2.0)) / 3.0' negativeOneThird));
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(0' 1' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(0' 2' 3)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(0' 3' 1)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Compute,The following statement contains a magic number: Subdivide(positions' indices' new TriangleIndicesUnsignedInt(1' 3' 2)' numberOfSubdivisions);
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Subdivide,The following statement contains a magic number: positions.Add(((positions[triangle.I0] + positions[triangle.I1]) * 0.5).Normalize());
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Subdivide,The following statement contains a magic number: positions.Add(((positions[triangle.I1] + positions[triangle.I2]) * 0.5).Normalize());
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Subdivide,The following statement contains a magic number: positions.Add(((positions[triangle.I2] + positions[triangle.I0]) * 0.5).Normalize());
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Subdivide,The following statement contains a magic number: int i01 = positions.Count - 3;
Magic Number,OpenGlobe.Core,SubdivisionSphereTessellatorSimple,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionSphereTessellatorSimple.cs,Subdivide,The following statement contains a magic number: int i12 = positions.Count - 2;
Magic Number,OpenGlobe.Core,SubdivisionUtility,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,NumberOfTriangles,The following statement contains a magic number: numberOfTriangles += Convert.ToInt32(Math.Pow(4' i));
Magic Number,OpenGlobe.Core,SubdivisionUtility,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,NumberOfTriangles,The following statement contains a magic number: numberOfTriangles *= 4;
Magic Number,OpenGlobe.Core,SubdivisionUtility,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,NumberOfVertices,The following statement contains a magic number: numberOfVertices += Convert.ToInt32(Math.Pow(4' i));
Magic Number,OpenGlobe.Core,SubdivisionUtility,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,NumberOfVertices,The following statement contains a magic number: numberOfVertices = 4 + (12 * numberOfVertices);
Magic Number,OpenGlobe.Core,SubdivisionUtility,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,NumberOfVertices,The following statement contains a magic number: numberOfVertices = 4 + (12 * numberOfVertices);
Magic Number,OpenGlobe.Core,SubdivisionUtility,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,ComputeTextureCoordinate,The following statement contains a magic number: return new Vector2H((Math.Atan2(position.Y' position.X) / Trig.TwoPi) + 0.5'                                  (Math.Asin(position.Z) / Math.PI) + 0.5);
Magic Number,OpenGlobe.Core,SubdivisionUtility,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Tessellation\SubdivisionUtility.cs,ComputeTextureCoordinate,The following statement contains a magic number: return new Vector2H((Math.Atan2(position.Y' position.X) / Trig.TwoPi) + 0.5'                                  (Math.Asin(position.Z) / Math.PI) + 0.5);
Magic Number,OpenGlobe.Core,Vector2B,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector2B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 2) + Convert.ToInt32(_y);
Magic Number,OpenGlobe.Core,Vector3B,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector3B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 4) + (Convert.ToInt32(_y) * 2) + Convert.ToInt32(_z);
Magic Number,OpenGlobe.Core,Vector3B,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector3B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 4) + (Convert.ToInt32(_y) * 2) + Convert.ToInt32(_z);
Magic Number,OpenGlobe.Core,Vector4B,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector4B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 8) + (Convert.ToInt32(_y) * 4) + (Convert.ToInt32(_z) * 2) + Convert.ToInt32(_w);
Magic Number,OpenGlobe.Core,Vector4B,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector4B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 8) + (Convert.ToInt32(_y) * 4) + (Convert.ToInt32(_z) * 2) + Convert.ToInt32(_w);
Magic Number,OpenGlobe.Core,Vector4B,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\Source\Core\Vectors\Vector4B.cs,GetHashCode,The following statement contains a magic number: return (Convert.ToInt32(_x) * 8) + (Convert.ToInt32(_y) * 4) + (Convert.ToInt32(_z) * 2) + Convert.ToInt32(_w);
