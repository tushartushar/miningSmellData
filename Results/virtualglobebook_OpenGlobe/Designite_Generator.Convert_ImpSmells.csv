Implementation smell,Namespace,Class,File,Method,Description
Long Method,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The method has 241 lines of code.
Complex Method,Mono.Options,Option,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,ParsePrototype,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,Option,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,AddSeparators,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,WriteOptionPrototype,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,GetDescription,Cyclomatic complexity of the method is 12
Long Parameter List,Mono.Options,OptionSet,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,GetOptionParts,The method has 5 parameters. Parameters: argument' flag' name' sep' value
Long Statement,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The length of the statement  "            var function_string = ""; // Used to concatenate functions that are split in different lines. (e.g. "void\nclFoo(int /* a */'\nint b);") " is 136.
Long Statement,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The length of the statement  "                //var words = line.Replace("/*"' "").Replace("*/"' "").Split(" ()".ToCharArray()' StringSplitOptions.RemoveEmptyEntries); " is 121.
Long Statement,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The length of the statement  "                // '[parameter type] [parameter name]'' '[parameter type] [pointer] [parameter name]'' 'const [parameter type][pointer] [parameter name]' " is 137.
Long Statement,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The length of the statement  "                var get_param = new Regex(@"(\w+\s\(\*\w+\)\s*\(.*\)\s*(/\*.*?\*/|\w+)? | (const\s)?(\w+\s*)+\**\s*(/\*.*?\*/|\w+(\[.*?\])?))'?"' RegexOptions.IgnorePatternWhitespace); " is 168.
Long Statement,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The length of the statement  "                            let is_function_pointer = item.Contains("(*") // This only occurs in function pointers' e.g. void (*pfn_notify)() or void (*user_func)() " is 136.
Long Statement,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The length of the statement  "                                Name = (has_array_size ? array_size.Replace(param_name' "") : param_name).Replace("*"' "")' // Pointers are placed into the parameter Type' not Name " is 148.
Long Statement,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The length of the statement  "                                    (tokens.Contains("unsigned") && !param_type.StartsWith("byte") ? "u" : "") +    // Make sure we don't ignore the unsigned part of unsigned parameters (e.g. unsigned int -> uint) " is 177.
Long Statement,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The length of the statement  "                                    param_type.Replace("*"' "") + String.Join(""' pointers' 0' indirection_level)'  // Normalize pointer indirection level (place as many asterisks as in indirection_level variable) " is 177.
Long Statement,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The length of the statement  "                                     !(funcname.EndsWith("Info") || funcname.EndsWith("IDs") || funcname.EndsWith("ImageFormats"))) ? // OpenCL contains Get*[Info|IDs|ImageFormats] methods with 'in' pointer parameters " is 180.
Complex Conditional,Mono.Options,Option,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,Option,The conditional expression  "Array.IndexOf (names' "<>") >= 0 &&   					((names.Length == 1 && this.type != OptionValueType.None) ||  					 (names.Length > 1 && this.MaxValueCount > 1))"  is complex.
Complex Conditional,Mono.Options,OptionSet,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,ParseBool,The conditional expression  "n.Length >= 1 && (n [n.Length-1] == '+' || n [n.Length-1] == '-') &&  					Contains ((rn = n.Substring (0' n.Length-1)))"  is complex.
Magic Number,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The following statement contains a magic number: Func<string' List<XElement>' List<XElement>> enum_token = (line' acc) =>              {                  if (EnumToken.IsMatch(line))                  {                      if (acc.Count == 0 || acc.Last().Name.LocalName != "enum")                          acc.Add(new XElement("enum"' new XAttribute("name"' "Unknown")));                        var tokens = split(line);                      // Some constants are defined bitshifts' e.g. (1 << 2). If a constant contains parentheses                      // we assume it is a bitshift. Otherwise' we assume it is single value' separated by space                      // (e.g. 0xdeadbeef).                      if (line.Contains("("))                          tokens[2] = "(" + line.Split('(')[1];                        // Check whether this is an include guard (e.g. #define __OPENCL_CL_H)                      if (tokens[1].StartsWith("__"))                          return acc;                        // Check whether this is a known header define like WIN32_LEAN_AND_MEAN                      switch (tokens[1])                      {                          case "WIN32_LEAN_AND_MEAN":                          case "APIENTRY":                          case "GLAPI":                              return acc;                      }                        acc[acc.Count - 1].Add(new XElement("token"'                          new XAttribute("name"' tokens[1].Substring(Prefix.Length + 1))'   // remove prefix                          new XAttribute("value"' tokens[2])));                  }                  return acc;              };
Magic Number,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The following statement contains a magic number: Func<string' List<XElement>' List<XElement>> enum_token = (line' acc) =>              {                  if (EnumToken.IsMatch(line))                  {                      if (acc.Count == 0 || acc.Last().Name.LocalName != "enum")                          acc.Add(new XElement("enum"' new XAttribute("name"' "Unknown")));                        var tokens = split(line);                      // Some constants are defined bitshifts' e.g. (1 << 2). If a constant contains parentheses                      // we assume it is a bitshift. Otherwise' we assume it is single value' separated by space                      // (e.g. 0xdeadbeef).                      if (line.Contains("("))                          tokens[2] = "(" + line.Split('(')[1];                        // Check whether this is an include guard (e.g. #define __OPENCL_CL_H)                      if (tokens[1].StartsWith("__"))                          return acc;                        // Check whether this is a known header define like WIN32_LEAN_AND_MEAN                      switch (tokens[1])                      {                          case "WIN32_LEAN_AND_MEAN":                          case "APIENTRY":                          case "GLAPI":                              return acc;                      }                        acc[acc.Count - 1].Add(new XElement("token"'                          new XAttribute("name"' tokens[1].Substring(Prefix.Length + 1))'   // remove prefix                          new XAttribute("value"' tokens[2])));                  }                  return acc;              };
Magic Number,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The following statement contains a magic number: Func<string' List<XElement>' List<XElement>> function = (line' acc) =>              {                  if (!line.EndsWith(";"))                  {                      function_string += line + " ";                      return acc;                  }                    line = function_string + line;                  function_string = "";                    Func<string' string> GetExtension = name =>                  {                      var match = extensions.Match(name);                      return match != null && String.IsNullOrEmpty(match.Value) ? "Core" : match.Value;                  };                    var words = line.Split(splitters' StringSplitOptions.RemoveEmptyEntries);                  //var words = line.Replace("/*"' "").Replace("*/"' "").Split(" ()".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                  // ES does not start methods with 'extern'' while CL does.                  // Remove the 'extern' keyword to create a single code-path.                  if (words[0] == "extern")                      words = words.Skip(1).ToArray();                    string rettype = null;                  string funcname = null;                  GetFunctionNameAndType(words' out funcname' out rettype);                    var paramaters_string = Regex.Match(line' @"\(.*\)").Captures[0].Value.TrimStart('(').TrimEnd(')');                    // This regex matches function parameters.                  // The first part matches function pointers in the following format:                  // '[return type] (*[function pointer name])([parameter list]) [parameter name]                  // where [parameter name] may or may not be in comments.                  // The second part (after the '|') matches parameters of the following formats:                  // '[parameter type] [parameter name]'' '[parameter type] [pointer] [parameter name]'' 'const [parameter type][pointer] [parameter name]'                  // where [parameter name] may be inside comments (/* ... */) and [pointer] is ''' '*'' '**'' etc.                  var get_param = new Regex(@"(\w+\s\(\*\w+\)\s*\(.*\)\s*(/\*.*?\*/|\w+)? | (const\s)?(\w+\s*)+\**\s*(/\*.*?\*/|\w+(\[.*?\])?))'?"' RegexOptions.IgnorePatternWhitespace);                    var parameters =                      (from item in get_param.Matches(paramaters_string).OfType<Match>()                      select item.Captures[0].Value.TrimEnd(''')).ToList();                    var fun =                      new                      {                          Name = funcname'                          Return = rettype'                          Version = Version'                          Extension = GetExtension(funcname)'                          Profile = String.Empty'                          Parameters =                              from item in get_param.Matches(paramaters_string).OfType<Match>().Select(m => m.Captures[0].Value.TrimEnd('''))                                  //paramaters_string.Split("'".ToCharArray()' StringSplitOptions.RemoveEmptyEntries)                              let tokens = item.Trim().Split(' ')                              let is_function_pointer = item.Contains("(*") // This only occurs in function pointers' e.g. void (*pfn_notify)() or void (*user_func)()                              let param_name =                                  is_function_pointer ? tokens[1].TrimStart('('' '*').Split(')')[0] :                                  (tokens.Last().Trim() != "*/" ? tokens.Last() : tokens[tokens.Length - 2]).Trim()                              let param_type =                                  is_function_pointer ? "IntPtr" :                                  (from t in tokens where t.Trim() != "const" && t.Trim() != "unsigned" select t).First().Trim()                              let has_array_size = array_size.IsMatch(param_name)                              let indirection_level =                                  is_function_pointer ? 0 :                                  (from c in param_name where c == '*' select c).Count() +                                  (from c in param_type where c == '*' select c).Count() +                                  (from t in tokens where t == "***" select t).Count() * 3 +                                  (from t in tokens where t == "**" select t).Count() * 2 +                                  (from t in tokens where t == "*" select t).Count() +                                  (has_array_size ? 1 : 0)                              let pointers = new string[] { "*"' "*"' "*"' "*" } // for adding indirection levels (pointers) to param_type                              where tokens.Length > 1                              select new                              {                                  Name = (has_array_size ? array_size.Replace(param_name' "") : param_name).Replace("*"' "")' // Pointers are placed into the parameter Type' not Name                                  Type =                                      is_function_pointer ? param_type :                                      (tokens.Contains("unsigned") && !param_type.StartsWith("byte") ? "u" : "") +    // Make sure we don't ignore the unsigned part of unsigned parameters (e.g. unsigned int -> uint)                                      param_type.Replace("*"' "") + String.Join(""' pointers' 0' indirection_level)'  // Normalize pointer indirection level (place as many asterisks as in indirection_level variable)                                  Count = has_array_size ? Int32.Parse(array_size.Match(param_name).Value.Trim('['' ']')) : 0'                                  Flow =                                      param_name.EndsWith("ret") ||                                      ((funcname.StartsWith("Get") || funcname.StartsWith("Gen")) &&                                       indirection_level > 0 &&                                       !(funcname.EndsWith("Info") || funcname.EndsWith("IDs") || funcname.EndsWith("ImageFormats"))) ? // OpenCL contains Get*[Info|IDs|ImageFormats] methods with 'in' pointer parameters                                      "out" : "in"                              }                      };                    XElement func = new XElement("function"' new XAttribute("name"' fun.Name));                  func.Add(new XAttribute("extension"' fun.Extension));                  func.Add(new XAttribute("profile"' fun.Profile));                  func.Add(new XAttribute("category"' fun.Version));                  func.Add(new XAttribute("version"' fun.Version));                    func.Add(new XElement("returns"' new XAttribute("type"' fun.Return)));                  foreach (var p in fun.Parameters)                  {                      var param = new XElement("param"' new XAttribute("type"' p.Type)' new XAttribute("name"' p.Name));                      if (p.Count > 0)                          param.Add(new XAttribute("count"' p.Count));                      param.Add(new XAttribute("flow"' p.Flow));                      func.Add(param);                  }                    acc.Add(func);                  return acc;              };
Magic Number,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The following statement contains a magic number: Func<string' List<XElement>' List<XElement>> function = (line' acc) =>              {                  if (!line.EndsWith(";"))                  {                      function_string += line + " ";                      return acc;                  }                    line = function_string + line;                  function_string = "";                    Func<string' string> GetExtension = name =>                  {                      var match = extensions.Match(name);                      return match != null && String.IsNullOrEmpty(match.Value) ? "Core" : match.Value;                  };                    var words = line.Split(splitters' StringSplitOptions.RemoveEmptyEntries);                  //var words = line.Replace("/*"' "").Replace("*/"' "").Split(" ()".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                  // ES does not start methods with 'extern'' while CL does.                  // Remove the 'extern' keyword to create a single code-path.                  if (words[0] == "extern")                      words = words.Skip(1).ToArray();                    string rettype = null;                  string funcname = null;                  GetFunctionNameAndType(words' out funcname' out rettype);                    var paramaters_string = Regex.Match(line' @"\(.*\)").Captures[0].Value.TrimStart('(').TrimEnd(')');                    // This regex matches function parameters.                  // The first part matches function pointers in the following format:                  // '[return type] (*[function pointer name])([parameter list]) [parameter name]                  // where [parameter name] may or may not be in comments.                  // The second part (after the '|') matches parameters of the following formats:                  // '[parameter type] [parameter name]'' '[parameter type] [pointer] [parameter name]'' 'const [parameter type][pointer] [parameter name]'                  // where [parameter name] may be inside comments (/* ... */) and [pointer] is ''' '*'' '**'' etc.                  var get_param = new Regex(@"(\w+\s\(\*\w+\)\s*\(.*\)\s*(/\*.*?\*/|\w+)? | (const\s)?(\w+\s*)+\**\s*(/\*.*?\*/|\w+(\[.*?\])?))'?"' RegexOptions.IgnorePatternWhitespace);                    var parameters =                      (from item in get_param.Matches(paramaters_string).OfType<Match>()                      select item.Captures[0].Value.TrimEnd(''')).ToList();                    var fun =                      new                      {                          Name = funcname'                          Return = rettype'                          Version = Version'                          Extension = GetExtension(funcname)'                          Profile = String.Empty'                          Parameters =                              from item in get_param.Matches(paramaters_string).OfType<Match>().Select(m => m.Captures[0].Value.TrimEnd('''))                                  //paramaters_string.Split("'".ToCharArray()' StringSplitOptions.RemoveEmptyEntries)                              let tokens = item.Trim().Split(' ')                              let is_function_pointer = item.Contains("(*") // This only occurs in function pointers' e.g. void (*pfn_notify)() or void (*user_func)()                              let param_name =                                  is_function_pointer ? tokens[1].TrimStart('('' '*').Split(')')[0] :                                  (tokens.Last().Trim() != "*/" ? tokens.Last() : tokens[tokens.Length - 2]).Trim()                              let param_type =                                  is_function_pointer ? "IntPtr" :                                  (from t in tokens where t.Trim() != "const" && t.Trim() != "unsigned" select t).First().Trim()                              let has_array_size = array_size.IsMatch(param_name)                              let indirection_level =                                  is_function_pointer ? 0 :                                  (from c in param_name where c == '*' select c).Count() +                                  (from c in param_type where c == '*' select c).Count() +                                  (from t in tokens where t == "***" select t).Count() * 3 +                                  (from t in tokens where t == "**" select t).Count() * 2 +                                  (from t in tokens where t == "*" select t).Count() +                                  (has_array_size ? 1 : 0)                              let pointers = new string[] { "*"' "*"' "*"' "*" } // for adding indirection levels (pointers) to param_type                              where tokens.Length > 1                              select new                              {                                  Name = (has_array_size ? array_size.Replace(param_name' "") : param_name).Replace("*"' "")' // Pointers are placed into the parameter Type' not Name                                  Type =                                      is_function_pointer ? param_type :                                      (tokens.Contains("unsigned") && !param_type.StartsWith("byte") ? "u" : "") +    // Make sure we don't ignore the unsigned part of unsigned parameters (e.g. unsigned int -> uint)                                      param_type.Replace("*"' "") + String.Join(""' pointers' 0' indirection_level)'  // Normalize pointer indirection level (place as many asterisks as in indirection_level variable)                                  Count = has_array_size ? Int32.Parse(array_size.Match(param_name).Value.Trim('['' ']')) : 0'                                  Flow =                                      param_name.EndsWith("ret") ||                                      ((funcname.StartsWith("Get") || funcname.StartsWith("Gen")) &&                                       indirection_level > 0 &&                                       !(funcname.EndsWith("Info") || funcname.EndsWith("IDs") || funcname.EndsWith("ImageFormats"))) ? // OpenCL contains Get*[Info|IDs|ImageFormats] methods with 'in' pointer parameters                                      "out" : "in"                              }                      };                    XElement func = new XElement("function"' new XAttribute("name"' fun.Name));                  func.Add(new XAttribute("extension"' fun.Extension));                  func.Add(new XAttribute("profile"' fun.Profile));                  func.Add(new XAttribute("category"' fun.Version));                  func.Add(new XAttribute("version"' fun.Version));                    func.Add(new XElement("returns"' new XAttribute("type"' fun.Return)));                  foreach (var p in fun.Parameters)                  {                      var param = new XElement("param"' new XAttribute("type"' p.Type)' new XAttribute("name"' p.Name));                      if (p.Count > 0)                          param.Add(new XAttribute("count"' p.Count));                      param.Add(new XAttribute("flow"' p.Flow));                      func.Add(param);                  }                    acc.Add(func);                  return acc;              };
Magic Number,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The following statement contains a magic number: Func<string' List<XElement>' List<XElement>> function = (line' acc) =>              {                  if (!line.EndsWith(";"))                  {                      function_string += line + " ";                      return acc;                  }                    line = function_string + line;                  function_string = "";                    Func<string' string> GetExtension = name =>                  {                      var match = extensions.Match(name);                      return match != null && String.IsNullOrEmpty(match.Value) ? "Core" : match.Value;                  };                    var words = line.Split(splitters' StringSplitOptions.RemoveEmptyEntries);                  //var words = line.Replace("/*"' "").Replace("*/"' "").Split(" ()".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                  // ES does not start methods with 'extern'' while CL does.                  // Remove the 'extern' keyword to create a single code-path.                  if (words[0] == "extern")                      words = words.Skip(1).ToArray();                    string rettype = null;                  string funcname = null;                  GetFunctionNameAndType(words' out funcname' out rettype);                    var paramaters_string = Regex.Match(line' @"\(.*\)").Captures[0].Value.TrimStart('(').TrimEnd(')');                    // This regex matches function parameters.                  // The first part matches function pointers in the following format:                  // '[return type] (*[function pointer name])([parameter list]) [parameter name]                  // where [parameter name] may or may not be in comments.                  // The second part (after the '|') matches parameters of the following formats:                  // '[parameter type] [parameter name]'' '[parameter type] [pointer] [parameter name]'' 'const [parameter type][pointer] [parameter name]'                  // where [parameter name] may be inside comments (/* ... */) and [pointer] is ''' '*'' '**'' etc.                  var get_param = new Regex(@"(\w+\s\(\*\w+\)\s*\(.*\)\s*(/\*.*?\*/|\w+)? | (const\s)?(\w+\s*)+\**\s*(/\*.*?\*/|\w+(\[.*?\])?))'?"' RegexOptions.IgnorePatternWhitespace);                    var parameters =                      (from item in get_param.Matches(paramaters_string).OfType<Match>()                      select item.Captures[0].Value.TrimEnd(''')).ToList();                    var fun =                      new                      {                          Name = funcname'                          Return = rettype'                          Version = Version'                          Extension = GetExtension(funcname)'                          Profile = String.Empty'                          Parameters =                              from item in get_param.Matches(paramaters_string).OfType<Match>().Select(m => m.Captures[0].Value.TrimEnd('''))                                  //paramaters_string.Split("'".ToCharArray()' StringSplitOptions.RemoveEmptyEntries)                              let tokens = item.Trim().Split(' ')                              let is_function_pointer = item.Contains("(*") // This only occurs in function pointers' e.g. void (*pfn_notify)() or void (*user_func)()                              let param_name =                                  is_function_pointer ? tokens[1].TrimStart('('' '*').Split(')')[0] :                                  (tokens.Last().Trim() != "*/" ? tokens.Last() : tokens[tokens.Length - 2]).Trim()                              let param_type =                                  is_function_pointer ? "IntPtr" :                                  (from t in tokens where t.Trim() != "const" && t.Trim() != "unsigned" select t).First().Trim()                              let has_array_size = array_size.IsMatch(param_name)                              let indirection_level =                                  is_function_pointer ? 0 :                                  (from c in param_name where c == '*' select c).Count() +                                  (from c in param_type where c == '*' select c).Count() +                                  (from t in tokens where t == "***" select t).Count() * 3 +                                  (from t in tokens where t == "**" select t).Count() * 2 +                                  (from t in tokens where t == "*" select t).Count() +                                  (has_array_size ? 1 : 0)                              let pointers = new string[] { "*"' "*"' "*"' "*" } // for adding indirection levels (pointers) to param_type                              where tokens.Length > 1                              select new                              {                                  Name = (has_array_size ? array_size.Replace(param_name' "") : param_name).Replace("*"' "")' // Pointers are placed into the parameter Type' not Name                                  Type =                                      is_function_pointer ? param_type :                                      (tokens.Contains("unsigned") && !param_type.StartsWith("byte") ? "u" : "") +    // Make sure we don't ignore the unsigned part of unsigned parameters (e.g. unsigned int -> uint)                                      param_type.Replace("*"' "") + String.Join(""' pointers' 0' indirection_level)'  // Normalize pointer indirection level (place as many asterisks as in indirection_level variable)                                  Count = has_array_size ? Int32.Parse(array_size.Match(param_name).Value.Trim('['' ']')) : 0'                                  Flow =                                      param_name.EndsWith("ret") ||                                      ((funcname.StartsWith("Get") || funcname.StartsWith("Gen")) &&                                       indirection_level > 0 &&                                       !(funcname.EndsWith("Info") || funcname.EndsWith("IDs") || funcname.EndsWith("ImageFormats"))) ? // OpenCL contains Get*[Info|IDs|ImageFormats] methods with 'in' pointer parameters                                      "out" : "in"                              }                      };                    XElement func = new XElement("function"' new XAttribute("name"' fun.Name));                  func.Add(new XAttribute("extension"' fun.Extension));                  func.Add(new XAttribute("profile"' fun.Profile));                  func.Add(new XAttribute("category"' fun.Version));                  func.Add(new XAttribute("version"' fun.Version));                    func.Add(new XElement("returns"' new XAttribute("type"' fun.Return)));                  foreach (var p in fun.Parameters)                  {                      var param = new XElement("param"' new XAttribute("type"' p.Type)' new XAttribute("name"' p.Name));                      if (p.Count > 0)                          param.Add(new XAttribute("count"' p.Count));                      param.Add(new XAttribute("flow"' p.Flow));                      func.Add(param);                  }                    acc.Add(func);                  return acc;              };
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,Add,The following statement contains a magic number: Option p = new ActionOption (prototype' description' 2'   					delegate (OptionValueCollection v) {action (v [0]' v [1]);});
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: string prefix = new string (' '' OptionWidth+2);
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,GetLines,The following statement contains a magic number: int length = 80 - OptionWidth - 1;
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,GetLines,The following statement contains a magic number: length = 80 - OptionWidth - 2 - 1;
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,GetLines,The following statement contains a magic number: length = 80 - OptionWidth - 2 - 1;
Missing Default,CHeaderToXML,ESCLParser,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\ESCLParser.cs,Parse,The following switch statement is missing a default case: switch (tokens[1])                      {                          case "WIN32_LEAN_AND_MEAN":                          case "APIENTRY":                          case "GLAPI":                              return acc;                      }
Missing Default,Mono.Options,OptionSet,D:\research\architectureSmells\repos\virtualglobebook_OpenGlobe\ThirdParty\OpenTK.1.0\Source\Converter\Options.cs,Parse,The following switch statement is missing a default case: switch (p.OptionValueType) {  					case OptionValueType.None:  						c.OptionValues.Add (n);  						c.Option.Invoke (c);  						break;  					case OptionValueType.Optional:  					case OptionValueType.Required:   						ParseValue (v' c);  						break;  				}
