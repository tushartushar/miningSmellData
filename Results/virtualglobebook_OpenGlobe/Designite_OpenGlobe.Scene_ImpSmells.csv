Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The method has 106 lines of code.
Complex Method,OpenGlobe.Scene,RasterLevel,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\RasterLevel.cs,GetTilesInExtent,Cyclomatic complexity of the method is 11
Complex Method,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,Cyclomatic complexity of the method is 8
Long Parameter List,OpenGlobe.Scene,RasterLevel,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\RasterLevel.cs,RasterLevel,The method has 7 parameters. Parameters: source' level' extent' longitudePosts' latitudePosts' longitudePostsPerTile' latitudePostsPerTile
Long Parameter List,OpenGlobe.Scene,RasterTileRegion,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\RasterTileRegion.cs,RasterTileRegion,The method has 5 parameters. Parameters: tile' west' south' east' north
Long Parameter List,OpenGlobe.Scene,TerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TerrainTile.cs,TerrainTile,The method has 5 parameters. Parameters: extent' resolution' heights' minimumHeight' maximumHeight
Long Parameter List,OpenGlobe.Scene,ClipmapUpdate,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdate.cs,ClipmapUpdate,The method has 5 parameters. Parameters: level' west' south' east' north
Long Parameter List,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,RequestTileResidency,The method has 5 parameters. Parameters: context' level' details' rasterLevel' nextExtent
Long Parameter List,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,Update,The method has 5 parameters. Parameters: context' update' level' details' rasterLevel
Long Parameter List,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,RenderTileToLevelTexture,The method has 5 parameters. Parameters: context' level' details' region' tileTexture
Long Parameter List,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The method has 5 parameters. Parameters: context' terrainSource' imagery' ellipsoid' clipmapPosts
Long Parameter List,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The method has 7 parameters. Parameters: levelIndex' level' coarserLevel' fillRing' center' context' sceneState
Long Parameter List,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,DrawBlock,The method has 9 parameters. Parameters: block' level' coarserLevel' overallWest' overallSouth' blockWest' blockSouth' context' sceneState
Long Parameter List,OpenGlobe.Scene,BillboardCollection,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\BillboardCollection\BillboardCollection.cs,CopyBillboardsFromSystemMemory,The method has 7 parameters. Parameters: positions' textureCoordinates' colors' origins' pixelOffsets' bufferOffset' length
Long Identifier,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,,The length of the parameter _computeNormalsOneOverHeightMapSize is 35.
Long Identifier,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,,The length of the parameter _terrainToImageryResolutionRatio is 32.
Long Identifier,OpenGlobe.Scene,EsriRestImagery,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\EsriRestImagery.cs,,The length of the parameter LevelZeroDeltaLongitudeDegrees is 30.
Long Identifier,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,,The length of the parameter LevelZeroDeltaLongitudeDegrees is 30.
Long Statement,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,InitializeRequestThreads,The length of the statement  "            RasterTileRegion[] regions = rasterLevelZero.GetTilesInExtent(0' 0' rasterLevelZero.LongitudePosts - 1' rasterLevelZero.LatitudePosts - 1); " is 139.
Long Statement,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,RequestTileResidency,The length of the statement  "            RasterTileRegion[] tileRegions = rasterLevel.GetTilesInExtent(nextExtent.West' nextExtent.South' nextExtent.East' nextExtent.North); " is 132.
Long Statement,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,Update,The length of the statement  "                RasterTileRegion[] tileRegions = rasterLevel.GetTilesInExtent(nonWrappingUpdate.West' nonWrappingUpdate.South' nonWrappingUpdate.East' nonWrappingUpdate.North); " is 160.
Long Statement,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,UpsampleTileData,The length of the statement  "            double sourceWest = (coarserOriginInTextures.X + ((region.Tile.West + region.West) / 2.0 - coarserNextExtent.West)) % coarseClipmapSize; " is 136.
Long Statement,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,UpsampleTileData,The length of the statement  "            double sourceSouth = (coarserOriginInTextures.Y + ((region.Tile.South + region.South) / 2.0 - coarserNextExtent.South)) % coarseClipmapSize; " is 140.
Long Statement,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,UpsampleTileData,The length of the statement  "            _upsampleOneOverTextureSize.Value = new Vector2F(1.0f / coarserLevelTexture.Description.Width' 1.0f / coarserLevelTexture.Description.Height); " is 142.
Long Statement,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,UpdateNormals,The length of the statement  "            _computeNormalsOneOverHeightMapSize.Value = new Vector2F(1.0f / update.Level.HeightTexture.Description.Width' 1.0f / update.Level.HeightTexture.Description.Height); " is 164.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,Render,The length of the statement  "            _levelZeroWorldScaleFactor.Value = new Vector2F((float)_clipmapLevels[0].Terrain.PostDeltaLongitude' (float)_clipmapLevels[0].Terrain.PostDeltaLatitude); " is 153.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            _levelOffsetFromWorldOrigin.Value = new Vector2F((float)((double)level.CurrentExtent.West - level.Terrain.LongitudeToIndex(0.0))' " is 129.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            _viewPosInClippedLevel.Value = new Vector2F((float)(level.Terrain.LongitudeToIndex(Trig.ToDegrees(_clipmapCenter.Longitude)) - level.CurrentExtent.West)' " is 153.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            _terrainToImageryResolutionRatio.Value = new Vector2F((float)(level.Terrain.PostDeltaLongitude / level.Imagery.PostDeltaLongitude)' " is 131.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            DrawBlock(_fillPatch' level' coarserLevel' west' south' east - _fillPatchSegments' south + _fillPatchSegments' context' sceneState); " is 132.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            DrawBlock(_fillPatch' level' coarserLevel' west' south' east - _fillPatchSegments' north - 2 * _fillPatchSegments' context' sceneState); " is 136.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' north - _fillPatchSegments' context' sceneState); " is 132.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            DrawBlock(_fillPatch' level' coarserLevel' west' south' east - 2 * _fillPatchSegments' north - _fillPatchSegments' context' sceneState); " is 136.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            DrawBlock(_fillPatch' level' coarserLevel' west' south' east - _fillPatchSegments' north - _fillPatchSegments' context' sceneState); " is 132.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west' south + 2 * _fillPatchSegments' context' sceneState); " is 126.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' east - _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState); " is 147.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south' context' sceneState); " is 124.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "            DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' north - _fillPatchSegments' context' sceneState); " is 145.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState); " is 132.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState); " is 133.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState); " is 133.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState); " is 134.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState); " is 147.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState); " is 148.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState); " is 145.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState); " is 146.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState); " is 142.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState); " is 124.
Long Statement,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The length of the statement  "                DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState); " is 137.
Long Statement,OpenGlobe.Scene,DayNightGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\DayNight\DayNightGlobe.cs,Clean,The length of the statement  "                _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw); " is 123.
Long Statement,OpenGlobe.Scene,DayNightGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\DayNight\DayNightGlobe.cs,Clean,The length of the statement  "                ((Uniform<Vector3F>)_drawState.ShaderProgram.Uniforms["u_globeOneOverRadiiSquared"]).Value = _shape.OneOverRadiiSquared.ToVector3F(); " is 133.
Long Statement,OpenGlobe.Scene,LatitudeLongitudeGridGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\LatitudeLongitudeGrid\LatitudeLongitudeGridGlobe.cs,Clean,The length of the statement  "                Mesh mesh = GeographicGridEllipsoidTessellator.Compute(_shape' 64' 32' GeographicGridEllipsoidVertexAttributes.Position); " is 121.
Long Statement,OpenGlobe.Scene,LatitudeLongitudeGridGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\LatitudeLongitudeGrid\LatitudeLongitudeGridGlobe.cs,Clean,The length of the statement  "                _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw); " is 123.
Long Statement,OpenGlobe.Scene,RayCastedGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\RayCasted\RayCastedGlobe.cs,Clean,The length of the statement  "                ((Uniform<Vector3F>)_drawState.ShaderProgram.Uniforms["u_globeOneOverRadiiSquared"]).Value = _shape.OneOverRadiiSquared.ToVector3F(); " is 133.
Long Statement,OpenGlobe.Scene,RayCastedGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\RayCasted\RayCastedGlobe.cs,Clean,The length of the statement  "                ((Uniform<Vector3F>)_drawStateSolid.ShaderProgram.Uniforms["u_globeOneOverRadiiSquared"]).Value = _shape.OneOverRadiiSquared.ToVector3F(); " is 138.
Long Statement,OpenGlobe.Scene,TessellatedGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\Tessellated\TessellatedGlobe.cs,Clean,The length of the statement  "                _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw); " is 123.
Long Statement,OpenGlobe.Scene,BillboardCollection,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\BillboardCollection\BillboardCollection.cs,CreateVertexArray,The length of the statement  "            _textureCoordinatesBuffer = Device.CreateVertexBuffer(BufferHint.StaticDraw' _billboards.Count * SizeInBytes<Vector4H>.Value); " is 126.
Long Statement,OpenGlobe.Scene,Polyline,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\Polyline.cs,Set,The length of the statement  "            _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw); " is 123.
Long Statement,OpenGlobe.Scene,OutlinedPolylineGeometryShader,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineGeometryShader.cs,Set,The length of the statement  "                throw new ArgumentException("mesh.Attributes should contain attributes named \"position\"' \"color\"' and \"outlineColor\"."' "mesh"); " is 134.
Long Statement,OpenGlobe.Scene,OutlinedPolylineGeometryShader,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineGeometryShader.cs,Set,The length of the statement  "            _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw); " is 123.
Long Statement,OpenGlobe.Scene,OutlinedPolylineTexture,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineTexture.cs,Set,The length of the statement  "                throw new ArgumentException("mesh.Attributes should contain attributes named \"position\"' \"color\"' and \"outlineColor\"."' "mesh"); " is 134.
Long Statement,OpenGlobe.Scene,RayCastedTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\RayCastedTerrainTile.cs,Update,The length of the statement  "                _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw); " is 123.
Long Statement,OpenGlobe.Scene,TriangleMeshTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TriangleMeshTerrainTile.cs,CreateDepthAndSilhouetteData,The length of the statement  "                _depthTexture = Device.CreateTexture2D(new Texture2DDescription(context.Viewport.Width' context.Viewport.Height' TextureFormat.Depth24)); " is 137.
Long Statement,OpenGlobe.Scene,TriangleMeshTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TriangleMeshTerrainTile.cs,CreateDepthAndSilhouetteData,The length of the statement  "                _silhouetteTexture = Device.CreateTexture2D(new Texture2DDescription(context.Viewport.Width' context.Viewport.Height' TextureFormat.Red8)); " is 139.
Long Statement,OpenGlobe.Scene,TriangleMeshTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TriangleMeshTerrainTile.cs,CreateDepthAndSilhouetteData,The length of the statement  "                _colorTexture = Device.CreateTexture2D(new Texture2DDescription(context.Viewport.Width' context.Viewport.Height' TextureFormat.RedGreenBlue8)); " is 143.
Long Statement,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,PostsToTexture,The length of the statement  "            using (WritePixelBuffer wpb = Device.CreateWritePixelBuffer(PixelBufferHint.Stream' TileWidth * TileHeight * sizeof(float))) " is 124.
Complex Conditional,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The conditional expression  "ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals"  is complex.
Virtual Method Call from Constructor,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,ClipmapUpdater,The constructor "ClipmapUpdater" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,ClipmapUpdater,The constructor "ClipmapUpdater" calls a virtual method "CreateFramebuffer".
Virtual Method Call from Constructor,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The constructor "GlobeClipmapTerrain" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The constructor "GlobeClipmapTerrain" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The constructor "GlobeClipmapTerrain" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The constructor "GlobeClipmapTerrain" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The constructor "GlobeClipmapTerrain" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The constructor "GlobeClipmapTerrain" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The constructor "GlobeClipmapTerrain" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The constructor "Plane" calls a virtual method "CopyFromSystemMemory".
Virtual Method Call from Constructor,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The constructor "Plane" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,Wireframe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Wireframe\Wireframe.cs,Wireframe,The constructor "Wireframe" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,RayCastedTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\RayCastedTerrainTile.cs,RayCastedTerrainTile,The constructor "RayCastedTerrainTile" calls a virtual method "CopyFromSystemMemory".
Virtual Method Call from Constructor,OpenGlobe.Scene,RayCastedTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\RayCastedTerrainTile.cs,RayCastedTerrainTile,The constructor "RayCastedTerrainTile" calls a virtual method "CopyFromBuffer".
Virtual Method Call from Constructor,OpenGlobe.Scene,TriangleMeshTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TriangleMeshTerrainTile.cs,TriangleMeshTerrainTile,The constructor "TriangleMeshTerrainTile" calls a virtual method "CreateVertexArray".
Virtual Method Call from Constructor,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,VertexDisplacementMapTerrainTile,The constructor "VertexDisplacementMapTerrainTile" calls a virtual method "CopyFromSystemMemory".
Virtual Method Call from Constructor,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,VertexDisplacementMapTerrainTile,The constructor "VertexDisplacementMapTerrainTile" calls a virtual method "CopyFromBuffer".
Virtual Method Call from Constructor,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,VertexDisplacementMapTerrainTile,The constructor "VertexDisplacementMapTerrainTile" calls a virtual method "CreateVertexArray".
Empty Catch Block,OpenGlobe.Scene,PolygonShapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\PolygonShapefile.cs,PolygonShapefile,The method has an empty catch block.
Magic Number,OpenGlobe.Scene,CameraLookAtPoint,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Cameras\CameraLookAtPoint.cs,CameraLookAtPoint,The following statement contains a magic number: _zoomFactor = 5.0;
Magic Number,OpenGlobe.Scene,CameraLookAtPoint,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Cameras\CameraLookAtPoint.cs,CameraLookAtPoint,The following statement contains a magic number: _minimumZoomRate = ellipsoid.MaximumRadius / 100.0;
Magic Number,OpenGlobe.Scene,CameraLookAtPoint,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Cameras\CameraLookAtPoint.cs,CameraLookAtPoint,The following statement contains a magic number: _minimumRotateRate = 1.0 / 5000.0;
Magic Number,OpenGlobe.Scene,CameraLookAtPoint,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Cameras\CameraLookAtPoint.cs,CameraLookAtPoint,The following statement contains a magic number: _range = ellipsoid.MaximumRadius * 2.0;
Magic Number,OpenGlobe.Scene,ShapefileAppearance,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\ShapefileAppearance.cs,ShapefileAppearance,The following statement contains a magic number: PolylineWidth = 3.0;
Magic Number,OpenGlobe.Scene,ShapefileAppearance,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\ShapefileAppearance.cs,ShapefileAppearance,The following statement contains a magic number: PolylineOutlineWidth = 2.0;
Magic Number,OpenGlobe.Scene,TerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TerrainTile.cs,FromBitmap,The following statement contains a magic number: for (int j = bitmap.Height - 1; j >= 0; --j)              {                  for (int i = 0; i < bitmap.Width; ++i)                  {                      float height = (float)(bitmap.GetPixel(i' j).R / 255.0);                      heights[k++] = height;                      minHeight = Math.Min(height' minHeight);                      maxHeight = Math.Max(height' maxHeight);                  }              }
Magic Number,OpenGlobe.Scene,TerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TerrainTile.cs,FromBitmap,The following statement contains a magic number: return new TerrainTile(                  new RectangleD(new Vector2D(0.5' 0.5)' new Vector2D((double)bitmap.Width - 0.5' (double)bitmap.Height - 0.5))'                  new Vector2I(bitmap.Width' bitmap.Height)'                  heights' minHeight' maxHeight);
Magic Number,OpenGlobe.Scene,TerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TerrainTile.cs,FromBitmap,The following statement contains a magic number: return new TerrainTile(                  new RectangleD(new Vector2D(0.5' 0.5)' new Vector2D((double)bitmap.Width - 0.5' (double)bitmap.Height - 0.5))'                  new Vector2I(bitmap.Width' bitmap.Height)'                  heights' minHeight' maxHeight);
Magic Number,OpenGlobe.Scene,TerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TerrainTile.cs,FromBitmap,The following statement contains a magic number: return new TerrainTile(                  new RectangleD(new Vector2D(0.5' 0.5)' new Vector2D((double)bitmap.Width - 0.5' (double)bitmap.Height - 0.5))'                  new Vector2I(bitmap.Width' bitmap.Height)'                  heights' minHeight' maxHeight);
Magic Number,OpenGlobe.Scene,TerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TerrainTile.cs,FromBitmap,The following statement contains a magic number: return new TerrainTile(                  new RectangleD(new Vector2D(0.5' 0.5)' new Vector2D((double)bitmap.Width - 0.5' (double)bitmap.Height - 0.5))'                  new Vector2I(bitmap.Width' bitmap.Height)'                  heights' minHeight' maxHeight);
Magic Number,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,SplitUpdateToAvoidWrapping,The following statement contains a magic number: if (east < west && north < south)              {                  // Horizontal AND vertical wrap                  ClipmapUpdate bottomLeftUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      extent.West + (clipmapSizeX - origin.X - 1)'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate bottomRightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      update.South'                      update.East'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate topLeftUpdate = new ClipmapUpdate(                      level'                      update.West'                      extent.South + clipmapSizeY - origin.Y'                      extent.West + (clipmapSizeX - origin.X - 1)'                      update.North);                    ClipmapUpdate topRightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      extent.South + clipmapSizeY - origin.Y'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[4];                  result[0] = bottomLeftUpdate;                  result[1] = bottomRightUpdate;                  result[2] = topLeftUpdate;                  result[3] = topRightUpdate;                  return result;              }              else if (east < west)              {                  // Horizontal wrap                  ClipmapUpdate leftUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      extent.West + (clipmapSizeX - origin.X - 1)'                      update.North);                    ClipmapUpdate rightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      update.South'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[2];                  result[0] = leftUpdate;                  result[1] = rightUpdate;                  return result;              }              else if (north < south)              {                  // Vertical wrap                  ClipmapUpdate bottomUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      update.East'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate topUpdate = new ClipmapUpdate(                      level'                      update.West'                      extent.South + clipmapSizeY - origin.Y'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[2];                  result[0] = bottomUpdate;                  result[1] = topUpdate;                  return result;              }              else              {                  // No wrap                  ClipmapUpdate[] result = new ClipmapUpdate[1];                  result[0] = update;                  return result;              }
Magic Number,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,SplitUpdateToAvoidWrapping,The following statement contains a magic number: if (east < west && north < south)              {                  // Horizontal AND vertical wrap                  ClipmapUpdate bottomLeftUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      extent.West + (clipmapSizeX - origin.X - 1)'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate bottomRightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      update.South'                      update.East'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate topLeftUpdate = new ClipmapUpdate(                      level'                      update.West'                      extent.South + clipmapSizeY - origin.Y'                      extent.West + (clipmapSizeX - origin.X - 1)'                      update.North);                    ClipmapUpdate topRightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      extent.South + clipmapSizeY - origin.Y'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[4];                  result[0] = bottomLeftUpdate;                  result[1] = bottomRightUpdate;                  result[2] = topLeftUpdate;                  result[3] = topRightUpdate;                  return result;              }              else if (east < west)              {                  // Horizontal wrap                  ClipmapUpdate leftUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      extent.West + (clipmapSizeX - origin.X - 1)'                      update.North);                    ClipmapUpdate rightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      update.South'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[2];                  result[0] = leftUpdate;                  result[1] = rightUpdate;                  return result;              }              else if (north < south)              {                  // Vertical wrap                  ClipmapUpdate bottomUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      update.East'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate topUpdate = new ClipmapUpdate(                      level'                      update.West'                      extent.South + clipmapSizeY - origin.Y'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[2];                  result[0] = bottomUpdate;                  result[1] = topUpdate;                  return result;              }              else              {                  // No wrap                  ClipmapUpdate[] result = new ClipmapUpdate[1];                  result[0] = update;                  return result;              }
Magic Number,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,SplitUpdateToAvoidWrapping,The following statement contains a magic number: if (east < west && north < south)              {                  // Horizontal AND vertical wrap                  ClipmapUpdate bottomLeftUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      extent.West + (clipmapSizeX - origin.X - 1)'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate bottomRightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      update.South'                      update.East'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate topLeftUpdate = new ClipmapUpdate(                      level'                      update.West'                      extent.South + clipmapSizeY - origin.Y'                      extent.West + (clipmapSizeX - origin.X - 1)'                      update.North);                    ClipmapUpdate topRightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      extent.South + clipmapSizeY - origin.Y'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[4];                  result[0] = bottomLeftUpdate;                  result[1] = bottomRightUpdate;                  result[2] = topLeftUpdate;                  result[3] = topRightUpdate;                  return result;              }              else if (east < west)              {                  // Horizontal wrap                  ClipmapUpdate leftUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      extent.West + (clipmapSizeX - origin.X - 1)'                      update.North);                    ClipmapUpdate rightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      update.South'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[2];                  result[0] = leftUpdate;                  result[1] = rightUpdate;                  return result;              }              else if (north < south)              {                  // Vertical wrap                  ClipmapUpdate bottomUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      update.East'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate topUpdate = new ClipmapUpdate(                      level'                      update.West'                      extent.South + clipmapSizeY - origin.Y'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[2];                  result[0] = bottomUpdate;                  result[1] = topUpdate;                  return result;              }              else              {                  // No wrap                  ClipmapUpdate[] result = new ClipmapUpdate[1];                  result[0] = update;                  return result;              }
Magic Number,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,SplitUpdateToAvoidWrapping,The following statement contains a magic number: if (east < west && north < south)              {                  // Horizontal AND vertical wrap                  ClipmapUpdate bottomLeftUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      extent.West + (clipmapSizeX - origin.X - 1)'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate bottomRightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      update.South'                      update.East'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate topLeftUpdate = new ClipmapUpdate(                      level'                      update.West'                      extent.South + clipmapSizeY - origin.Y'                      extent.West + (clipmapSizeX - origin.X - 1)'                      update.North);                    ClipmapUpdate topRightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      extent.South + clipmapSizeY - origin.Y'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[4];                  result[0] = bottomLeftUpdate;                  result[1] = bottomRightUpdate;                  result[2] = topLeftUpdate;                  result[3] = topRightUpdate;                  return result;              }              else if (east < west)              {                  // Horizontal wrap                  ClipmapUpdate leftUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      extent.West + (clipmapSizeX - origin.X - 1)'                      update.North);                    ClipmapUpdate rightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      update.South'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[2];                  result[0] = leftUpdate;                  result[1] = rightUpdate;                  return result;              }              else if (north < south)              {                  // Vertical wrap                  ClipmapUpdate bottomUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      update.East'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate topUpdate = new ClipmapUpdate(                      level'                      update.West'                      extent.South + clipmapSizeY - origin.Y'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[2];                  result[0] = bottomUpdate;                  result[1] = topUpdate;                  return result;              }              else              {                  // No wrap                  ClipmapUpdate[] result = new ClipmapUpdate[1];                  result[0] = update;                  return result;              }
Magic Number,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,SplitUpdateToAvoidWrapping,The following statement contains a magic number: if (east < west && north < south)              {                  // Horizontal AND vertical wrap                  ClipmapUpdate bottomLeftUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      extent.West + (clipmapSizeX - origin.X - 1)'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate bottomRightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      update.South'                      update.East'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate topLeftUpdate = new ClipmapUpdate(                      level'                      update.West'                      extent.South + clipmapSizeY - origin.Y'                      extent.West + (clipmapSizeX - origin.X - 1)'                      update.North);                    ClipmapUpdate topRightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      extent.South + clipmapSizeY - origin.Y'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[4];                  result[0] = bottomLeftUpdate;                  result[1] = bottomRightUpdate;                  result[2] = topLeftUpdate;                  result[3] = topRightUpdate;                  return result;              }              else if (east < west)              {                  // Horizontal wrap                  ClipmapUpdate leftUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      extent.West + (clipmapSizeX - origin.X - 1)'                      update.North);                    ClipmapUpdate rightUpdate = new ClipmapUpdate(                      level'                      extent.West + clipmapSizeX - origin.X'                      update.South'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[2];                  result[0] = leftUpdate;                  result[1] = rightUpdate;                  return result;              }              else if (north < south)              {                  // Vertical wrap                  ClipmapUpdate bottomUpdate = new ClipmapUpdate(                      level'                      update.West'                      update.South'                      update.East'                      extent.South + (clipmapSizeY - origin.Y - 1));                    ClipmapUpdate topUpdate = new ClipmapUpdate(                      level'                      update.West'                      extent.South + clipmapSizeY - origin.Y'                      update.East'                      update.North);                    ClipmapUpdate[] result = new ClipmapUpdate[2];                  result[0] = bottomUpdate;                  result[1] = topUpdate;                  return result;              }              else              {                  // No wrap                  ClipmapUpdate[] result = new ClipmapUpdate[1];                  result[0] = update;                  return result;              }
Magic Number,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,UpsampleTileData,The following statement contains a magic number: double sourceWest = (coarserOriginInTextures.X + ((region.Tile.West + region.West) / 2.0 - coarserNextExtent.West)) % coarseClipmapSize;
Magic Number,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,UpsampleTileData,The following statement contains a magic number: double sourceSouth = (coarserOriginInTextures.Y + ((region.Tile.South + region.South) / 2.0 - coarserNextExtent.South)) % coarseClipmapSize;
Magic Number,OpenGlobe.Scene,ClipmapUpdater,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\ClipmapUpdater.cs,RequestTileLoad,The following statement contains a magic number: lock (details.RequestList)              {                  if (exists)                  {                      // Remove the existing request from the queue so we can re-insert it                      // in its new location.                      if (requestNode.List == null)                      {                          // Request was in the queue at one point' but it's not anymore.                          // That means it's been loaded'  so we don't need to do anything.                          return;                      }                      details.RequestList.Remove(requestNode);                  }                    if (details.RequestInsertionPoint == null || details.RequestInsertionPoint.List == null)                  {                      details.RequestList.AddLast(requestNode);                  }                  else                  {                      details.RequestList.AddBefore(details.RequestInsertionPoint' requestNode);                  }                  details.RequestInsertionPoint = requestNode;                    // If the request list has too many entries' delete from the beginning                  const int MaxRequests = 500;                  while (details.RequestList.Count > MaxRequests)                  {                      LinkedListNode<TileLoadRequest> nodeToRemove = details.RequestList.First;                      details.RequestList.RemoveFirst();                      details.LoadingTiles.Remove(nodeToRemove.Value.Tile.Identifier);                  }                    Monitor.Pulse(details.RequestList);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: _fillPatchPosts = (clipmapPosts + 1) / 4;
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh ringFixupHorizontalMesh = RectangleTessellator.Compute(                  new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(_fillPatchSegments' 2.0))'                  _fillPatchSegments' 2);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh ringFixupHorizontalMesh = RectangleTessellator.Compute(                  new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(_fillPatchSegments' 2.0))'                  _fillPatchSegments' 2);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh ringFixupVerticalMesh = RectangleTessellator.Compute(                  new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(2.0' _fillPatchSegments))'                  2' _fillPatchSegments);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh ringFixupVerticalMesh = RectangleTessellator.Compute(                  new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(2.0' _fillPatchSegments))'                  2' _fillPatchSegments);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh offsetStripHorizontalMesh = RectangleTessellator.Compute(                  new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(2 * _fillPatchPosts' 1.0))'                  2 * _fillPatchPosts' 1);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh offsetStripHorizontalMesh = RectangleTessellator.Compute(                  new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(2 * _fillPatchPosts' 1.0))'                  2 * _fillPatchPosts' 1);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh offsetStripVerticalMesh = RectangleTessellator.Compute(                  new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(1.0' 2 * _fillPatchPosts - 1))'                  1' 2 * _fillPatchPosts - 1);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh offsetStripVerticalMesh = RectangleTessellator.Compute(                  new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(1.0' 2 * _fillPatchPosts - 1))'                  1' 2 * _fillPatchPosts - 1);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh centerMesh = RectangleTessellator.Compute(new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(2.0' 2.0))' 2' 2);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh centerMesh = RectangleTessellator.Compute(new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(2.0' 2.0))' 2' 2);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh centerMesh = RectangleTessellator.Compute(new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(2.0' 2.0))' 2' 2);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: Mesh centerMesh = RectangleTessellator.Compute(new RectangleD(new Vector2D(0.0' 0.0)' new Vector2D(2.0' 2.0))' 2' 2);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: float oneOverBlendedRegionSize = (float)(10.0 / _clipmapPosts);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: float unblendedRegionSize = (float)(_clipmapSegments / 2 - _clipmapPosts / 10.0 - 1);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,GlobeClipmapTerrain,The following statement contains a magic number: float unblendedRegionSize = (float)(_clipmapSegments / 2 - _clipmapPosts / 10.0 - 1);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: int west = (int)(longitudeIndex - _clipmapPosts / 2);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: if ((west % 2) != 0)              {                  ++west;              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: int south = (int)(latitudeIndex - _clipmapPosts / 2);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: if ((south % 2) != 0)              {                  ++south;              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: int imageryWest = (int)(imageryLongitudeIndex - level.ImageryWidth / 2);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: int imagerySouth = (int)(imageryLatitudeIndex - level.ImageryHeight / 2);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: for (int i = _clipmapLevels.Length - 2; i >= 0; --i)              {                  level = _clipmapLevels[i];                  ClipmapLevel finerLevel = _clipmapLevels[i + 1];                    // Terrain                  level.NextExtent.West = finerLevel.NextExtent.West / 2 - _fillPatchSegments;                  level.OffsetStripOnEast = (level.NextExtent.West % 2) == 0;                  if (!level.OffsetStripOnEast)                  {                      --level.NextExtent.West;                  }                  level.NextExtent.East = level.NextExtent.West + _clipmapSegments;                    level.NextExtent.South = finerLevel.NextExtent.South / 2 - _fillPatchSegments;                  level.OffsetStripOnNorth = (level.NextExtent.South % 2) == 0;                  if (!level.OffsetStripOnNorth)                  {                      --level.NextExtent.South;                  }                  level.NextExtent.North = level.NextExtent.South + _clipmapSegments;                    // Imagery                  imageryWest = (int)level.Imagery.LongitudeToIndex(level.Terrain.IndexToLongitude(level.NextExtent.West));                  imagerySouth = (int)level.Imagery.LatitudeToIndex(level.Terrain.IndexToLatitude(level.NextExtent.South));                    level.NextImageryExtent.West = imageryWest;                  level.NextImageryExtent.East = imageryWest + level.ImageryWidth - 1;                  level.NextImageryExtent.South = imagerySouth;                  level.NextImageryExtent.North = imagerySouth + level.ImageryHeight - 1;                    UpdateOriginInTextures(level);                  UpdateImageryOriginInTextures(level);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: for (int i = _clipmapLevels.Length - 2; i >= 0; --i)              {                  level = _clipmapLevels[i];                  ClipmapLevel finerLevel = _clipmapLevels[i + 1];                    // Terrain                  level.NextExtent.West = finerLevel.NextExtent.West / 2 - _fillPatchSegments;                  level.OffsetStripOnEast = (level.NextExtent.West % 2) == 0;                  if (!level.OffsetStripOnEast)                  {                      --level.NextExtent.West;                  }                  level.NextExtent.East = level.NextExtent.West + _clipmapSegments;                    level.NextExtent.South = finerLevel.NextExtent.South / 2 - _fillPatchSegments;                  level.OffsetStripOnNorth = (level.NextExtent.South % 2) == 0;                  if (!level.OffsetStripOnNorth)                  {                      --level.NextExtent.South;                  }                  level.NextExtent.North = level.NextExtent.South + _clipmapSegments;                    // Imagery                  imageryWest = (int)level.Imagery.LongitudeToIndex(level.Terrain.IndexToLongitude(level.NextExtent.West));                  imagerySouth = (int)level.Imagery.LatitudeToIndex(level.Terrain.IndexToLatitude(level.NextExtent.South));                    level.NextImageryExtent.West = imageryWest;                  level.NextImageryExtent.East = imageryWest + level.ImageryWidth - 1;                  level.NextImageryExtent.South = imagerySouth;                  level.NextImageryExtent.North = imagerySouth + level.ImageryHeight - 1;                    UpdateOriginInTextures(level);                  UpdateImageryOriginInTextures(level);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: for (int i = _clipmapLevels.Length - 2; i >= 0; --i)              {                  level = _clipmapLevels[i];                  ClipmapLevel finerLevel = _clipmapLevels[i + 1];                    // Terrain                  level.NextExtent.West = finerLevel.NextExtent.West / 2 - _fillPatchSegments;                  level.OffsetStripOnEast = (level.NextExtent.West % 2) == 0;                  if (!level.OffsetStripOnEast)                  {                      --level.NextExtent.West;                  }                  level.NextExtent.East = level.NextExtent.West + _clipmapSegments;                    level.NextExtent.South = finerLevel.NextExtent.South / 2 - _fillPatchSegments;                  level.OffsetStripOnNorth = (level.NextExtent.South % 2) == 0;                  if (!level.OffsetStripOnNorth)                  {                      --level.NextExtent.South;                  }                  level.NextExtent.North = level.NextExtent.South + _clipmapSegments;                    // Imagery                  imageryWest = (int)level.Imagery.LongitudeToIndex(level.Terrain.IndexToLongitude(level.NextExtent.West));                  imagerySouth = (int)level.Imagery.LatitudeToIndex(level.Terrain.IndexToLatitude(level.NextExtent.South));                    level.NextImageryExtent.West = imageryWest;                  level.NextImageryExtent.East = imageryWest + level.ImageryWidth - 1;                  level.NextImageryExtent.South = imagerySouth;                  level.NextImageryExtent.North = imagerySouth + level.ImageryHeight - 1;                    UpdateOriginInTextures(level);                  UpdateImageryOriginInTextures(level);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: for (int i = _clipmapLevels.Length - 2; i >= 0; --i)              {                  level = _clipmapLevels[i];                  ClipmapLevel finerLevel = _clipmapLevels[i + 1];                    // Terrain                  level.NextExtent.West = finerLevel.NextExtent.West / 2 - _fillPatchSegments;                  level.OffsetStripOnEast = (level.NextExtent.West % 2) == 0;                  if (!level.OffsetStripOnEast)                  {                      --level.NextExtent.West;                  }                  level.NextExtent.East = level.NextExtent.West + _clipmapSegments;                    level.NextExtent.South = finerLevel.NextExtent.South / 2 - _fillPatchSegments;                  level.OffsetStripOnNorth = (level.NextExtent.South % 2) == 0;                  if (!level.OffsetStripOnNorth)                  {                      --level.NextExtent.South;                  }                  level.NextExtent.North = level.NextExtent.South + _clipmapSegments;                    // Imagery                  imageryWest = (int)level.Imagery.LongitudeToIndex(level.Terrain.IndexToLongitude(level.NextExtent.West));                  imagerySouth = (int)level.Imagery.LatitudeToIndex(level.Terrain.IndexToLatitude(level.NextExtent.South));                    level.NextImageryExtent.West = imageryWest;                  level.NextImageryExtent.East = imageryWest + level.ImageryWidth - 1;                  level.NextImageryExtent.South = imagerySouth;                  level.NextImageryExtent.North = imagerySouth + level.ImageryHeight - 1;                    UpdateOriginInTextures(level);                  UpdateImageryOriginInTextures(level);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,PreRender,The following statement contains a magic number: for (int i = _clipmapLevels.Length - 2; i >= 0; --i)              {                  level = _clipmapLevels[i];                  ClipmapLevel finerLevel = _clipmapLevels[i + 1];                    // Terrain                  level.NextExtent.West = finerLevel.NextExtent.West / 2 - _fillPatchSegments;                  level.OffsetStripOnEast = (level.NextExtent.West % 2) == 0;                  if (!level.OffsetStripOnEast)                  {                      --level.NextExtent.West;                  }                  level.NextExtent.East = level.NextExtent.West + _clipmapSegments;                    level.NextExtent.South = finerLevel.NextExtent.South / 2 - _fillPatchSegments;                  level.OffsetStripOnNorth = (level.NextExtent.South % 2) == 0;                  if (!level.OffsetStripOnNorth)                  {                      --level.NextExtent.South;                  }                  level.NextExtent.North = level.NextExtent.South + _clipmapSegments;                    // Imagery                  imageryWest = (int)level.Imagery.LongitudeToIndex(level.Terrain.IndexToLongitude(level.NextExtent.West));                  imagerySouth = (int)level.Imagery.LatitudeToIndex(level.Terrain.IndexToLatitude(level.NextExtent.South));                    level.NextImageryExtent.West = imageryWest;                  level.NextImageryExtent.East = imageryWest + level.ImageryWidth - 1;                  level.NextImageryExtent.South = imagerySouth;                  level.NextImageryExtent.North = imagerySouth + level.ImageryHeight - 1;                    UpdateOriginInTextures(level);                  UpdateImageryOriginInTextures(level);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: context.TextureUnits[2].Texture = level.NormalTexture;
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearRepeat;
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: context.TextureUnits[3].Texture = coarserLevel.NormalTexture;
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: context.TextureUnits[4].Texture = level.ImageryTexture;
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: float levelScaleFactor = (float)Math.Pow(2.0' -levelIndex);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: _fineLevelOriginInCoarse.Value = coarserLevel.OriginInTextures.ToVector2F() +                                               new Vector2F(west / 2 - coarserWest + 0.5f'                                                            south / 2 - coarserSouth + 0.5f);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: _fineLevelOriginInCoarse.Value = coarserLevel.OriginInTextures.ToVector2F() +                                               new Vector2F(west / 2 - coarserWest + 0.5f'                                                            south / 2 - coarserSouth + 0.5f);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: DrawBlock(_fillPatch' level' coarserLevel' west' south' east - 2 * _fillPatchSegments' south' context' sceneState);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: DrawBlock(_fillPatch' level' coarserLevel' west' south' west' north - 2 * _fillPatchSegments' context' sceneState);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: DrawBlock(_fillPatch' level' coarserLevel' west' south' east - _fillPatchSegments' north - 2 * _fillPatchSegments' context' sceneState);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: DrawBlock(_fillPatch' level' coarserLevel' west' south' east - 2 * _fillPatchSegments' north - _fillPatchSegments' context' sceneState);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west' south + 2 * _fillPatchSegments' context' sceneState);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' east - _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south' context' sceneState);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' north - _fillPatchSegments' context' sceneState);
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,RenderLevel,The following statement contains a magic number: if (fillRing)              {                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                  DrawBlock(_fillPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);                  DrawBlock(_horizontalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchPosts' south + 2 * _fillPatchSegments' context' sceneState);                    DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + _fillPatchSegments' context' sceneState);                  DrawBlock(_verticalFixupPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchPosts' context' sceneState);                    DrawBlock(_centerPatch' level' coarserLevel' west' south' west + 2 * _fillPatchSegments' south + 2 * _fillPatchSegments' context' sceneState);              }              else              {                  int offset = level.OffsetStripOnNorth                                  ? north - _fillPatchPosts                                  : south + _fillPatchSegments;                  DrawBlock(_horizontalOffsetPatch' level' coarserLevel' west' south' west + _fillPatchSegments' offset' context' sceneState);                    int southOffset = level.OffsetStripOnNorth ? 0 : 1;                  offset = level.OffsetStripOnEast                                  ? east - _fillPatchPosts                                  : west + _fillPatchSegments;                  DrawBlock(_verticalOffsetPatch' level' coarserLevel' west' south' offset' south + _fillPatchSegments + southOffset' context' sceneState);              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,CreateDegenerateTriangleMesh,The following statement contains a magic number: int numberOfPositions = _clipmapSegments * 4;
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,CreateDegenerateTriangleMesh,The following statement contains a magic number: int numberOfIndices = (numberOfPositions - 2) * 3;
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,CreateDegenerateTriangleMesh,The following statement contains a magic number: int numberOfIndices = (numberOfPositions - 2) * 3;
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,CreateDegenerateTriangleMesh,The following statement contains a magic number: for (int i = 0; i < numberOfPositions - 2; ++i)              {                  indices.AddTriangle(new TriangleIndicesUnsignedShort((ushort)i' (ushort)(i + 1)' (ushort)(i + 2)));              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,CreateDegenerateTriangleMesh,The following statement contains a magic number: for (int i = 0; i < numberOfPositions - 2; ++i)              {                  indices.AddTriangle(new TriangleIndicesUnsignedShort((ushort)i' (ushort)(i + 1)' (ushort)(i + 2)));              }
Magic Number,OpenGlobe.Scene,GlobeClipmapTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\GlobeClipmapTerrain.cs,CreateColors,The following statement contains a magic number: Vector3F[] colors = new Vector3F[20];
Magic Number,OpenGlobe.Scene,EsriRestImagery,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\EsriRestImagery.cs,EsriRestImagery,The following statement contains a magic number: for (int i = 0; i < _levels.Length; ++i)              {                  int longitudePosts = (int)Math.Round(360.0 / deltaLongitude) * TileLongitudePosts + 1;                  int latitudePosts = (int)Math.Round(180.0 / deltaLatitude) * TileLatitudePosts + 1;                  _levels[i] = new RasterLevel(this' i' _extent' longitudePosts' latitudePosts' TileLongitudePosts' TileLatitudePosts);                  deltaLongitude /= 2.0;                  deltaLatitude /= 2.0;              }
Magic Number,OpenGlobe.Scene,EsriRestImagery,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\EsriRestImagery.cs,EsriRestImagery,The following statement contains a magic number: for (int i = 0; i < _levels.Length; ++i)              {                  int longitudePosts = (int)Math.Round(360.0 / deltaLongitude) * TileLongitudePosts + 1;                  int latitudePosts = (int)Math.Round(180.0 / deltaLatitude) * TileLatitudePosts + 1;                  _levels[i] = new RasterLevel(this' i' _extent' longitudePosts' latitudePosts' TileLongitudePosts' TileLatitudePosts);                  deltaLongitude /= 2.0;                  deltaLatitude /= 2.0;              }
Magic Number,OpenGlobe.Scene,EsriRestImagery,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\EsriRestImagery.cs,EsriRestImagery,The following statement contains a magic number: for (int i = 0; i < _levels.Length; ++i)              {                  int longitudePosts = (int)Math.Round(360.0 / deltaLongitude) * TileLongitudePosts + 1;                  int latitudePosts = (int)Math.Round(180.0 / deltaLatitude) * TileLatitudePosts + 1;                  _levels[i] = new RasterLevel(this' i' _extent' longitudePosts' latitudePosts' TileLongitudePosts' TileLatitudePosts);                  deltaLongitude /= 2.0;                  deltaLatitude /= 2.0;              }
Magic Number,OpenGlobe.Scene,EsriRestImagery,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\EsriRestImagery.cs,EsriRestImagery,The following statement contains a magic number: for (int i = 0; i < _levels.Length; ++i)              {                  int longitudePosts = (int)Math.Round(360.0 / deltaLongitude) * TileLongitudePosts + 1;                  int latitudePosts = (int)Math.Round(180.0 / deltaLatitude) * TileLatitudePosts + 1;                  _levels[i] = new RasterLevel(this' i' _extent' longitudePosts' latitudePosts' TileLongitudePosts' TileLatitudePosts);                  deltaLongitude /= 2.0;                  deltaLatitude /= 2.0;              }
Magic Number,OpenGlobe.Scene,EsriRestImagery,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\EsriRestImagery.cs,LoadTileTexture,The following statement contains a magic number: if (!File.Exists(cacheFilename))              {                  // Esri tiles are numbered from the northwest instead of from the southwest.                    StringBuilder query = new StringBuilder(_baseUri.AbsoluteUri);                  query.Append(level);                  query.Append('/');                  query.Append((1 << level) - latitudeIndex - 1);                  query.Append('/');                  query.Append(longitudeIndex);                    string queryString = query.ToString();                  ++_tilesLoaded;                  Console.WriteLine("(" + _tilesLoaded + ") Downloading " + queryString);                    WebRequest request = WebRequest.Create(queryString);                  using (WebResponse response = request.GetResponse())                  using (Stream stream = response.GetResponseStream())                  using (FileStream file = new FileStream(cacheFilename' FileMode.Create' FileAccess.Write))                  {                      const int bufferSize = 4096;                      byte[] buffer = new byte[bufferSize];                        int bytesRead = stream.Read(buffer' 0' bufferSize);                      while (bytesRead > 0)                      {                          file.Write(buffer' 0' bytesRead);                          bytesRead = stream.Read(buffer' 0' bufferSize);                      }                  }              }
Magic Number,OpenGlobe.Scene,DayNightGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\DayNight\DayNightGlobe.cs,DayNightGlobe,The following statement contains a magic number: ((Uniform<float>)sp.Uniforms["u_blendDurationScale"]).Value = 1 / (2 * blendDurationScale);
Magic Number,OpenGlobe.Scene,DayNightGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\DayNight\DayNightGlobe.cs,Clean,The following statement contains a magic number: if (_dirty)              {                  if (_drawState.VertexArray != null)                  {                      _drawState.VertexArray.Dispose();                      _drawState.VertexArray = null;                  }                    Mesh mesh = BoxTessellator.Compute(2 * _shape.Radii);                  _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw);                  _primitiveType = mesh.PrimitiveType;                    _drawState.RenderState.FacetCulling.Face = CullFace.Front;                  _drawState.RenderState.FacetCulling.FrontFaceWindingOrder = mesh.FrontFaceWindingOrder;                    ((Uniform<Vector3F>)_drawState.ShaderProgram.Uniforms["u_globeOneOverRadiiSquared"]).Value = _shape.OneOverRadiiSquared.ToVector3F();                    if (_wireframe != null)                  {                      _wireframe.Dispose();                  }                  _wireframe = new Wireframe(context' mesh);                  _wireframe.FacetCullingFace = CullFace.Front;                  _wireframe.Width = 3;                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,DayNightGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\DayNight\DayNightGlobe.cs,Clean,The following statement contains a magic number: if (_dirty)              {                  if (_drawState.VertexArray != null)                  {                      _drawState.VertexArray.Dispose();                      _drawState.VertexArray = null;                  }                    Mesh mesh = BoxTessellator.Compute(2 * _shape.Radii);                  _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw);                  _primitiveType = mesh.PrimitiveType;                    _drawState.RenderState.FacetCulling.Face = CullFace.Front;                  _drawState.RenderState.FacetCulling.FrontFaceWindingOrder = mesh.FrontFaceWindingOrder;                    ((Uniform<Vector3F>)_drawState.ShaderProgram.Uniforms["u_globeOneOverRadiiSquared"]).Value = _shape.OneOverRadiiSquared.ToVector3F();                    if (_wireframe != null)                  {                      _wireframe.Dispose();                  }                  _wireframe = new Wireframe(context' mesh);                  _wireframe.FacetCullingFace = CullFace.Front;                  _wireframe.Width = 3;                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,DayNightViewportQuad,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\DayNight\DayNightViewportQuad.cs,Render,The following statement contains a magic number: context.TextureUnits[2].Texture = BlendTexture;
Magic Number,OpenGlobe.Scene,DayNightViewportQuad,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\DayNight\DayNightViewportQuad.cs,Render,The following statement contains a magic number: context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;
Magic Number,OpenGlobe.Scene,LatitudeLongitudeGridGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\LatitudeLongitudeGrid\LatitudeLongitudeGridGlobe.cs,Clean,The following statement contains a magic number: if (_dirty)              {                  if (_drawState.VertexArray != null)                  {                      _drawState.VertexArray.Dispose();                      _drawState.VertexArray = null;                  }                    Mesh mesh = GeographicGridEllipsoidTessellator.Compute(_shape' 64' 32' GeographicGridEllipsoidVertexAttributes.Position);                  _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw);                  _primitiveType = mesh.PrimitiveType;                    _drawState.RenderState.FacetCulling.FrontFaceWindingOrder = mesh.FrontFaceWindingOrder;                    _globeOneOverRadiiSquared.Value = _shape.OneOverRadiiSquared.ToVector3F();                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,LatitudeLongitudeGridGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\LatitudeLongitudeGrid\LatitudeLongitudeGridGlobe.cs,Clean,The following statement contains a magic number: if (_dirty)              {                  if (_drawState.VertexArray != null)                  {                      _drawState.VertexArray.Dispose();                      _drawState.VertexArray = null;                  }                    Mesh mesh = GeographicGridEllipsoidTessellator.Compute(_shape' 64' 32' GeographicGridEllipsoidVertexAttributes.Position);                  _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw);                  _primitiveType = mesh.PrimitiveType;                    _drawState.RenderState.FacetCulling.FrontFaceWindingOrder = mesh.FrontFaceWindingOrder;                    _globeOneOverRadiiSquared.Value = _shape.OneOverRadiiSquared.ToVector3F();                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,RayCastedGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\RayCasted\RayCastedGlobe.cs,Clean,The following statement contains a magic number: if (_dirty)              {                  if (_va != null)                  {                      _va.Dispose();                      _va = null;                      _drawState.VertexArray = null;                      _drawStateSolid.VertexArray = null;                  }                    Mesh mesh = BoxTessellator.Compute(2 * _shape.Radii);                  _va = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw);                  _drawState.VertexArray = _va;                  _drawStateSolid.VertexArray = _va;                  _primitiveType = mesh.PrimitiveType;                    _renderState.FacetCulling.FrontFaceWindingOrder = mesh.FrontFaceWindingOrder;                    ((Uniform<Vector3F>)_drawState.ShaderProgram.Uniforms["u_globeOneOverRadiiSquared"]).Value = _shape.OneOverRadiiSquared.ToVector3F();                  ((Uniform<Vector3F>)_drawStateSolid.ShaderProgram.Uniforms["u_globeOneOverRadiiSquared"]).Value = _shape.OneOverRadiiSquared.ToVector3F();                    if (_wireframe != null)                  {                      _wireframe.Dispose();                      _wireframe = null;                  }                  _wireframe = new Wireframe(context' mesh);                  _wireframe.FacetCullingFace = CullFace.Front;                  _wireframe.Width = 3;                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,RayCastedGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\RayCasted\RayCastedGlobe.cs,Clean,The following statement contains a magic number: if (_dirty)              {                  if (_va != null)                  {                      _va.Dispose();                      _va = null;                      _drawState.VertexArray = null;                      _drawStateSolid.VertexArray = null;                  }                    Mesh mesh = BoxTessellator.Compute(2 * _shape.Radii);                  _va = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw);                  _drawState.VertexArray = _va;                  _drawStateSolid.VertexArray = _va;                  _primitiveType = mesh.PrimitiveType;                    _renderState.FacetCulling.FrontFaceWindingOrder = mesh.FrontFaceWindingOrder;                    ((Uniform<Vector3F>)_drawState.ShaderProgram.Uniforms["u_globeOneOverRadiiSquared"]).Value = _shape.OneOverRadiiSquared.ToVector3F();                  ((Uniform<Vector3F>)_drawStateSolid.ShaderProgram.Uniforms["u_globeOneOverRadiiSquared"]).Value = _shape.OneOverRadiiSquared.ToVector3F();                    if (_wireframe != null)                  {                      _wireframe.Dispose();                      _wireframe = null;                  }                  _wireframe = new Wireframe(context' mesh);                  _wireframe.FacetCullingFace = CullFace.Front;                  _wireframe.Width = 3;                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,TessellatedGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\Tessellated\TessellatedGlobe.cs,TessellatedGlobe,The following statement contains a magic number: NumberOfSlicePartitions = 32;
Magic Number,OpenGlobe.Scene,TessellatedGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\Tessellated\TessellatedGlobe.cs,TessellatedGlobe,The following statement contains a magic number: NumberOfStackPartitions = 16;
Magic Number,OpenGlobe.Scene,TessellatedGlobe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Globes\Tessellated\TessellatedGlobe.cs,Clean,The following statement contains a magic number: if (_dirty)              {                  if (_drawState.VertexArray != null)                  {                      _drawState.VertexArray.Dispose();                      _drawState.VertexArray = null;                  }                    Mesh mesh = GeographicGridEllipsoidTessellator.Compute(Shape'                      _numberOfSlicePartitions' _numberOfStackPartitions' GeographicGridEllipsoidVertexAttributes.Position);                  _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw);                  _primitiveType = mesh.PrimitiveType;                  _numberOfTriangles = (((IndicesUnsignedInt)mesh.Indices).Values.Count / 3);                    _drawState.RenderState.FacetCulling.FrontFaceWindingOrder = mesh.FrontFaceWindingOrder;                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,Axes,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Axes.cs,Update,The following statement contains a magic number: if (_dirtyLength)              {                  VertexAttributeDoubleVector3 positionAttribute = new VertexAttributeDoubleVector3("position"' 6);                  positionAttribute.Values.Add(new Vector3D(0' 0' 0));                  positionAttribute.Values.Add(new Vector3D(_length' 0' 0));                  positionAttribute.Values.Add(new Vector3D(0' 0' 0));                  positionAttribute.Values.Add(new Vector3D(0' _length' 0));                  positionAttribute.Values.Add(new Vector3D(0' 0' 0));                  positionAttribute.Values.Add(new Vector3D(0' 0' _length));                    VertexAttributeRGBA colorAttribute = new VertexAttributeRGBA("color"' 6);                  colorAttribute.AddColor(Color.Red);                  colorAttribute.AddColor(Color.Red);                  colorAttribute.AddColor(Color.Green);                  colorAttribute.AddColor(Color.Green);                  colorAttribute.AddColor(Color.Blue);                  colorAttribute.AddColor(Color.Blue);                    Mesh mesh = new Mesh();                  mesh.PrimitiveType = PrimitiveType.Lines;                  mesh.Attributes.Add(positionAttribute);                  mesh.Attributes.Add(colorAttribute);                    _polyline.Set(context' mesh);                    _dirtyLength = false;              }
Magic Number,OpenGlobe.Scene,Axes,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Axes.cs,Update,The following statement contains a magic number: if (_dirtyLength)              {                  VertexAttributeDoubleVector3 positionAttribute = new VertexAttributeDoubleVector3("position"' 6);                  positionAttribute.Values.Add(new Vector3D(0' 0' 0));                  positionAttribute.Values.Add(new Vector3D(_length' 0' 0));                  positionAttribute.Values.Add(new Vector3D(0' 0' 0));                  positionAttribute.Values.Add(new Vector3D(0' _length' 0));                  positionAttribute.Values.Add(new Vector3D(0' 0' 0));                  positionAttribute.Values.Add(new Vector3D(0' 0' _length));                    VertexAttributeRGBA colorAttribute = new VertexAttributeRGBA("color"' 6);                  colorAttribute.AddColor(Color.Red);                  colorAttribute.AddColor(Color.Red);                  colorAttribute.AddColor(Color.Green);                  colorAttribute.AddColor(Color.Green);                  colorAttribute.AddColor(Color.Blue);                  colorAttribute.AddColor(Color.Blue);                    Mesh mesh = new Mesh();                  mesh.PrimitiveType = PrimitiveType.Lines;                  mesh.Attributes.Add(positionAttribute);                  mesh.Attributes.Add(colorAttribute);                    _polyline.Set(context' mesh);                    _dirtyLength = false;              }
Magic Number,OpenGlobe.Scene,BillboardCollection,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\BillboardCollection\BillboardCollection.cs,CreateVertexArray,The following statement contains a magic number: VertexBufferAttribute positionAttribute = new VertexBufferAttribute(                  _positionBuffer' ComponentDatatype.Float' 3);
Magic Number,OpenGlobe.Scene,BillboardCollection,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\BillboardCollection\BillboardCollection.cs,CreateVertexArray,The following statement contains a magic number: VertexBufferAttribute colorAttribute = new VertexBufferAttribute(                  _colorBuffer' ComponentDatatype.UnsignedByte' 4' true' 0' 0);
Magic Number,OpenGlobe.Scene,BillboardCollection,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\BillboardCollection\BillboardCollection.cs,CreateVertexArray,The following statement contains a magic number: VertexBufferAttribute pixelOffsetAttribute = new VertexBufferAttribute(                  _pixelOffsetBuffer' ComponentDatatype.HalfFloat' 2);
Magic Number,OpenGlobe.Scene,BillboardCollection,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\BillboardCollection\BillboardCollection.cs,CreateVertexArray,The following statement contains a magic number: VertexBufferAttribute textureCoordinatesAttribute = new VertexBufferAttribute(                  _textureCoordinatesBuffer' ComponentDatatype.HalfFloat' 4);
Magic Number,OpenGlobe.Scene,BillboardCollection,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\BillboardCollection\BillboardCollection.cs,BillboardOrigin,The following statement contains a magic number: return (byte)((byte)b.HorizontalOrigin | ((byte)b.VerticalOrigin << 2));
Magic Number,OpenGlobe.Scene,HeadsUpDisplay,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\HeadsUpDisplay\HeadsUpDisplay.cs,CreateVertexArray,The following statement contains a magic number: VertexBufferAttribute positionAttribute = new VertexBufferAttribute(                  _positionBuffer' ComponentDatatype.Float' 2);
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The following statement contains a magic number: _positionBuffer = Device.CreateVertexBuffer(BufferHint.StaticDraw' 2 * 4 * SizeInBytes<Vector3F>.Value);
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The following statement contains a magic number: _positionBuffer = Device.CreateVertexBuffer(BufferHint.StaticDraw' 2 * 4 * SizeInBytes<Vector3F>.Value);
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The following statement contains a magic number: ushort[] indices = new ushort[]               {                   0' 1' 2' 3'                             // Line loop                  0' 1' 2' 0' 2' 3                        // Triangles              };
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The following statement contains a magic number: ushort[] indices = new ushort[]               {                   0' 1' 2' 3'                             // Line loop                  0' 1' 2' 0' 2' 3                        // Triangles              };
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The following statement contains a magic number: ushort[] indices = new ushort[]               {                   0' 1' 2' 3'                             // Line loop                  0' 1' 2' 0' 2' 3                        // Triangles              };
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The following statement contains a magic number: ushort[] indices = new ushort[]               {                   0' 1' 2' 3'                             // Line loop                  0' 1' 2' 0' 2' 3                        // Triangles              };
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The following statement contains a magic number: ushort[] indices = new ushort[]               {                   0' 1' 2' 3'                             // Line loop                  0' 1' 2' 0' 2' 3                        // Triangles              };
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The following statement contains a magic number: int stride = 2 * SizeInBytes<Vector3F>.Value;
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The following statement contains a magic number: _va.Attributes[VertexLocations.PositionHigh] =                  new VertexBufferAttribute(_positionBuffer' ComponentDatatype.Float' 3' false' 0' stride);
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Plane,The following statement contains a magic number: _va.Attributes[VertexLocations.PositionLow] =                  new VertexBufferAttribute(_positionBuffer' ComponentDatatype.Float' 3' false' SizeInBytes<Vector3F>.Value' stride);
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Update,The following statement contains a magic number: if (_dirty)              {                  EmulatedVector3D p0 = new EmulatedVector3D(_origin - _xAxis - _yAxis);                  EmulatedVector3D p1 = new EmulatedVector3D(_origin + _xAxis - _yAxis);                  EmulatedVector3D p2 = new EmulatedVector3D(_origin + _xAxis + _yAxis);                  EmulatedVector3D p3 = new EmulatedVector3D(_origin - _xAxis + _yAxis);                    Vector3F[] positions = new Vector3F[8];                  positions[0] = p0.High;                  positions[1] = p0.Low;                  positions[2] = p1.High;                  positions[3] = p1.Low;                  positions[4] = p2.High;                  positions[5] = p2.Low;                  positions[6] = p3.High;                  positions[7] = p3.Low;                    _positionBuffer.CopyFromSystemMemory(positions);                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Update,The following statement contains a magic number: if (_dirty)              {                  EmulatedVector3D p0 = new EmulatedVector3D(_origin - _xAxis - _yAxis);                  EmulatedVector3D p1 = new EmulatedVector3D(_origin + _xAxis - _yAxis);                  EmulatedVector3D p2 = new EmulatedVector3D(_origin + _xAxis + _yAxis);                  EmulatedVector3D p3 = new EmulatedVector3D(_origin - _xAxis + _yAxis);                    Vector3F[] positions = new Vector3F[8];                  positions[0] = p0.High;                  positions[1] = p0.Low;                  positions[2] = p1.High;                  positions[3] = p1.Low;                  positions[4] = p2.High;                  positions[5] = p2.Low;                  positions[6] = p3.High;                  positions[7] = p3.Low;                    _positionBuffer.CopyFromSystemMemory(positions);                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Update,The following statement contains a magic number: if (_dirty)              {                  EmulatedVector3D p0 = new EmulatedVector3D(_origin - _xAxis - _yAxis);                  EmulatedVector3D p1 = new EmulatedVector3D(_origin + _xAxis - _yAxis);                  EmulatedVector3D p2 = new EmulatedVector3D(_origin + _xAxis + _yAxis);                  EmulatedVector3D p3 = new EmulatedVector3D(_origin - _xAxis + _yAxis);                    Vector3F[] positions = new Vector3F[8];                  positions[0] = p0.High;                  positions[1] = p0.Low;                  positions[2] = p1.High;                  positions[3] = p1.Low;                  positions[4] = p2.High;                  positions[5] = p2.Low;                  positions[6] = p3.High;                  positions[7] = p3.Low;                    _positionBuffer.CopyFromSystemMemory(positions);                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Update,The following statement contains a magic number: if (_dirty)              {                  EmulatedVector3D p0 = new EmulatedVector3D(_origin - _xAxis - _yAxis);                  EmulatedVector3D p1 = new EmulatedVector3D(_origin + _xAxis - _yAxis);                  EmulatedVector3D p2 = new EmulatedVector3D(_origin + _xAxis + _yAxis);                  EmulatedVector3D p3 = new EmulatedVector3D(_origin - _xAxis + _yAxis);                    Vector3F[] positions = new Vector3F[8];                  positions[0] = p0.High;                  positions[1] = p0.Low;                  positions[2] = p1.High;                  positions[3] = p1.Low;                  positions[4] = p2.High;                  positions[5] = p2.Low;                  positions[6] = p3.High;                  positions[7] = p3.Low;                    _positionBuffer.CopyFromSystemMemory(positions);                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Update,The following statement contains a magic number: if (_dirty)              {                  EmulatedVector3D p0 = new EmulatedVector3D(_origin - _xAxis - _yAxis);                  EmulatedVector3D p1 = new EmulatedVector3D(_origin + _xAxis - _yAxis);                  EmulatedVector3D p2 = new EmulatedVector3D(_origin + _xAxis + _yAxis);                  EmulatedVector3D p3 = new EmulatedVector3D(_origin - _xAxis + _yAxis);                    Vector3F[] positions = new Vector3F[8];                  positions[0] = p0.High;                  positions[1] = p0.Low;                  positions[2] = p1.High;                  positions[3] = p1.Low;                  positions[4] = p2.High;                  positions[5] = p2.Low;                  positions[6] = p3.High;                  positions[7] = p3.Low;                    _positionBuffer.CopyFromSystemMemory(positions);                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Update,The following statement contains a magic number: if (_dirty)              {                  EmulatedVector3D p0 = new EmulatedVector3D(_origin - _xAxis - _yAxis);                  EmulatedVector3D p1 = new EmulatedVector3D(_origin + _xAxis - _yAxis);                  EmulatedVector3D p2 = new EmulatedVector3D(_origin + _xAxis + _yAxis);                  EmulatedVector3D p3 = new EmulatedVector3D(_origin - _xAxis + _yAxis);                    Vector3F[] positions = new Vector3F[8];                  positions[0] = p0.High;                  positions[1] = p0.Low;                  positions[2] = p1.High;                  positions[3] = p1.Low;                  positions[4] = p2.High;                  positions[5] = p2.Low;                  positions[6] = p3.High;                  positions[7] = p3.Low;                    _positionBuffer.CopyFromSystemMemory(positions);                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Update,The following statement contains a magic number: if (_dirty)              {                  EmulatedVector3D p0 = new EmulatedVector3D(_origin - _xAxis - _yAxis);                  EmulatedVector3D p1 = new EmulatedVector3D(_origin + _xAxis - _yAxis);                  EmulatedVector3D p2 = new EmulatedVector3D(_origin + _xAxis + _yAxis);                  EmulatedVector3D p3 = new EmulatedVector3D(_origin - _xAxis + _yAxis);                    Vector3F[] positions = new Vector3F[8];                  positions[0] = p0.High;                  positions[1] = p0.Low;                  positions[2] = p1.High;                  positions[3] = p1.Low;                  positions[4] = p2.High;                  positions[5] = p2.Low;                  positions[6] = p3.High;                  positions[7] = p3.Low;                    _positionBuffer.CopyFromSystemMemory(positions);                    _dirty = false;              }
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Render,The following statement contains a magic number: if (Show)              {                  Update();                    if (ShowOutline)                  {                      //                      // Pass 1:  Outline                      //                      _lineFillDistance.Value = (float)(OutlineWidth * 0.5 * sceneState.HighResolutionSnapScale);                      context.Draw(PrimitiveType.LineLoop' 0' 4' _drawStateLine' sceneState);                  }                    if (ShowFill)                  {                      //                      // Pass 2:  Fill                      //                      context.Draw(PrimitiveType.Triangles' 4' 6' _drawStateFill' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Render,The following statement contains a magic number: if (Show)              {                  Update();                    if (ShowOutline)                  {                      //                      // Pass 1:  Outline                      //                      _lineFillDistance.Value = (float)(OutlineWidth * 0.5 * sceneState.HighResolutionSnapScale);                      context.Draw(PrimitiveType.LineLoop' 0' 4' _drawStateLine' sceneState);                  }                    if (ShowFill)                  {                      //                      // Pass 2:  Fill                      //                      context.Draw(PrimitiveType.Triangles' 4' 6' _drawStateFill' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Render,The following statement contains a magic number: if (Show)              {                  Update();                    if (ShowOutline)                  {                      //                      // Pass 1:  Outline                      //                      _lineFillDistance.Value = (float)(OutlineWidth * 0.5 * sceneState.HighResolutionSnapScale);                      context.Draw(PrimitiveType.LineLoop' 0' 4' _drawStateLine' sceneState);                  }                    if (ShowFill)                  {                      //                      // Pass 2:  Fill                      //                      context.Draw(PrimitiveType.Triangles' 4' 6' _drawStateFill' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,Plane,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Plane\Plane.cs,Render,The following statement contains a magic number: if (Show)              {                  Update();                    if (ShowOutline)                  {                      //                      // Pass 1:  Outline                      //                      _lineFillDistance.Value = (float)(OutlineWidth * 0.5 * sceneState.HighResolutionSnapScale);                      context.Draw(PrimitiveType.LineLoop' 0' 4' _drawStateLine' sceneState);                  }                    if (ShowFill)                  {                      //                      // Pass 2:  Fill                      //                      context.Draw(PrimitiveType.Triangles' 4' 6' _drawStateFill' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,Polygon,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polygon\Polygon.cs,Polygon,The following statement contains a magic number: VertexAttributeDoubleVector3 positionsAttribute = new VertexAttributeDoubleVector3(                  "position"' (result.Indices.Values.Count / 3) + 2);
Magic Number,OpenGlobe.Scene,Polygon,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polygon\Polygon.cs,Polygon,The following statement contains a magic number: VertexAttributeDoubleVector3 positionsAttribute = new VertexAttributeDoubleVector3(                  "position"' (result.Indices.Values.Count / 3) + 2);
Magic Number,OpenGlobe.Scene,PolylineOnTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\PolylineOnTerrain\PolylineOnTerrain.cs,Set,The following statement contains a magic number: int numberOfLineSegments = (positions.Count / 2) - 1;
Magic Number,OpenGlobe.Scene,PolylineOnTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\PolylineOnTerrain\PolylineOnTerrain.cs,Set,The following statement contains a magic number: int numberOfVertices = 2 + numberOfLineSegments + numberOfLineSegments;
Magic Number,OpenGlobe.Scene,PolylineOnTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\PolylineOnTerrain\PolylineOnTerrain.cs,Set,The following statement contains a magic number: int numIndices = 4 * numberOfLineSegments;
Magic Number,OpenGlobe.Scene,PolylineOnTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\PolylineOnTerrain\PolylineOnTerrain.cs,Set,The following statement contains a magic number: for (int i = 0; i < numIndices; i += 4' baseIndex += 2)              {                  indices[i] = (ushort)baseIndex;                  indices[i + 1] = (ushort)(baseIndex - 1);                  indices[i + 2] = (ushort)(baseIndex + 1);                  indices[i + 3] = (ushort)(baseIndex + 2);              }
Magic Number,OpenGlobe.Scene,PolylineOnTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\PolylineOnTerrain\PolylineOnTerrain.cs,Set,The following statement contains a magic number: for (int i = 0; i < numIndices; i += 4' baseIndex += 2)              {                  indices[i] = (ushort)baseIndex;                  indices[i + 1] = (ushort)(baseIndex - 1);                  indices[i + 2] = (ushort)(baseIndex + 1);                  indices[i + 3] = (ushort)(baseIndex + 2);              }
Magic Number,OpenGlobe.Scene,PolylineOnTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\PolylineOnTerrain\PolylineOnTerrain.cs,Set,The following statement contains a magic number: for (int i = 0; i < numIndices; i += 4' baseIndex += 2)              {                  indices[i] = (ushort)baseIndex;                  indices[i + 1] = (ushort)(baseIndex - 1);                  indices[i + 2] = (ushort)(baseIndex + 1);                  indices[i + 3] = (ushort)(baseIndex + 2);              }
Magic Number,OpenGlobe.Scene,PolylineOnTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\PolylineOnTerrain\PolylineOnTerrain.cs,Set,The following statement contains a magic number: for (int i = 0; i < numIndices; i += 4' baseIndex += 2)              {                  indices[i] = (ushort)baseIndex;                  indices[i + 1] = (ushort)(baseIndex - 1);                  indices[i + 2] = (ushort)(baseIndex + 1);                  indices[i + 3] = (ushort)(baseIndex + 2);              }
Magic Number,OpenGlobe.Scene,PolylineOnTerrain,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\PolylineOnTerrain\PolylineOnTerrain.cs,Set,The following statement contains a magic number: for (int i = 0; i < numIndices; i += 4' baseIndex += 2)              {                  indices[i] = (ushort)baseIndex;                  indices[i + 1] = (ushort)(baseIndex - 1);                  indices[i + 2] = (ushort)(baseIndex + 1);                  indices[i + 3] = (ushort)(baseIndex + 2);              }
Magic Number,OpenGlobe.Scene,Polyline,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\Polyline.cs,Render,The following statement contains a magic number: if (Show)              {                  if (_drawState.ShaderProgram != null)                  {                      _fillDistance.Value = (float)(Width * 0.5 * sceneState.HighResolutionSnapScale);                        context.Draw(_primitiveType' _drawState' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,OutlinedPolylineGeometryShader,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineGeometryShader.cs,Render,The following statement contains a magic number: if (_drawState.ShaderProgram != null)              {                  double fillDistance = Width * 0.5 * sceneState.HighResolutionSnapScale;                  _fillDistance.Value = (float)(fillDistance);                  _outlineDistance.Value = (float)(fillDistance + (OutlineWidth * sceneState.HighResolutionSnapScale));                    context.Draw(_primitiveType' _drawState' sceneState);              }
Magic Number,OpenGlobe.Scene,OutlinedPolylineTexture,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineTexture.cs,OutlinedPolylineTexture,The following statement contains a magic number: Width = 3;
Magic Number,OpenGlobe.Scene,OutlinedPolylineTexture,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineTexture.cs,OutlinedPolylineTexture,The following statement contains a magic number: OutlineWidth = 2;
Magic Number,OpenGlobe.Scene,OutlinedPolylineTexture,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineTexture.cs,Update,The following statement contains a magic number: int textureWidth = width + outlineWidth + outlineWidth + 2;
Magic Number,OpenGlobe.Scene,OutlinedPolylineTexture,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineTexture.cs,Update,The following statement contains a magic number: if ((_texture == null) || (_texture.Description.Width != textureWidth))              {                  int textureResolution = textureWidth * 2;                    float[] texels = new float[textureResolution];                    int k = 3;                  for (int i = 1; i < textureWidth - 1; ++i)                  {                      texels[k] = 1;                  // Alpha (stored in Green channel)                      k += 2;                  }                    int j = (outlineWidth + 1) * 2;                  for (int i = 0; i < width; ++i)                  {                      texels[j] = 1;                  // Fill/Outline (stored in Red channel)                      j += 2;                  }                    WritePixelBuffer pixelBuffer = Device.CreateWritePixelBuffer(PixelBufferHint.Stream'                      sizeof(float) * textureResolution);                  pixelBuffer.CopyFromSystemMemory(texels);                    if (_texture != null)                  {                      _texture.Dispose();                      _texture = null;                  }                    // TODO:  Why does only Float or HalfFloat work here?                  _texture = Device.CreateTexture2D(new Texture2DDescription(textureWidth' 1' TextureFormat.RedGreen8));                  _texture.CopyFromBuffer(pixelBuffer' ImageFormat.RedGreen' ImageDatatype.Float);              }
Magic Number,OpenGlobe.Scene,OutlinedPolylineTexture,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineTexture.cs,Update,The following statement contains a magic number: if ((_texture == null) || (_texture.Description.Width != textureWidth))              {                  int textureResolution = textureWidth * 2;                    float[] texels = new float[textureResolution];                    int k = 3;                  for (int i = 1; i < textureWidth - 1; ++i)                  {                      texels[k] = 1;                  // Alpha (stored in Green channel)                      k += 2;                  }                    int j = (outlineWidth + 1) * 2;                  for (int i = 0; i < width; ++i)                  {                      texels[j] = 1;                  // Fill/Outline (stored in Red channel)                      j += 2;                  }                    WritePixelBuffer pixelBuffer = Device.CreateWritePixelBuffer(PixelBufferHint.Stream'                      sizeof(float) * textureResolution);                  pixelBuffer.CopyFromSystemMemory(texels);                    if (_texture != null)                  {                      _texture.Dispose();                      _texture = null;                  }                    // TODO:  Why does only Float or HalfFloat work here?                  _texture = Device.CreateTexture2D(new Texture2DDescription(textureWidth' 1' TextureFormat.RedGreen8));                  _texture.CopyFromBuffer(pixelBuffer' ImageFormat.RedGreen' ImageDatatype.Float);              }
Magic Number,OpenGlobe.Scene,OutlinedPolylineTexture,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineTexture.cs,Update,The following statement contains a magic number: if ((_texture == null) || (_texture.Description.Width != textureWidth))              {                  int textureResolution = textureWidth * 2;                    float[] texels = new float[textureResolution];                    int k = 3;                  for (int i = 1; i < textureWidth - 1; ++i)                  {                      texels[k] = 1;                  // Alpha (stored in Green channel)                      k += 2;                  }                    int j = (outlineWidth + 1) * 2;                  for (int i = 0; i < width; ++i)                  {                      texels[j] = 1;                  // Fill/Outline (stored in Red channel)                      j += 2;                  }                    WritePixelBuffer pixelBuffer = Device.CreateWritePixelBuffer(PixelBufferHint.Stream'                      sizeof(float) * textureResolution);                  pixelBuffer.CopyFromSystemMemory(texels);                    if (_texture != null)                  {                      _texture.Dispose();                      _texture = null;                  }                    // TODO:  Why does only Float or HalfFloat work here?                  _texture = Device.CreateTexture2D(new Texture2DDescription(textureWidth' 1' TextureFormat.RedGreen8));                  _texture.CopyFromBuffer(pixelBuffer' ImageFormat.RedGreen' ImageDatatype.Float);              }
Magic Number,OpenGlobe.Scene,OutlinedPolylineTexture,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineTexture.cs,Update,The following statement contains a magic number: if ((_texture == null) || (_texture.Description.Width != textureWidth))              {                  int textureResolution = textureWidth * 2;                    float[] texels = new float[textureResolution];                    int k = 3;                  for (int i = 1; i < textureWidth - 1; ++i)                  {                      texels[k] = 1;                  // Alpha (stored in Green channel)                      k += 2;                  }                    int j = (outlineWidth + 1) * 2;                  for (int i = 0; i < width; ++i)                  {                      texels[j] = 1;                  // Fill/Outline (stored in Red channel)                      j += 2;                  }                    WritePixelBuffer pixelBuffer = Device.CreateWritePixelBuffer(PixelBufferHint.Stream'                      sizeof(float) * textureResolution);                  pixelBuffer.CopyFromSystemMemory(texels);                    if (_texture != null)                  {                      _texture.Dispose();                      _texture = null;                  }                    // TODO:  Why does only Float or HalfFloat work here?                  _texture = Device.CreateTexture2D(new Texture2DDescription(textureWidth' 1' TextureFormat.RedGreen8));                  _texture.CopyFromBuffer(pixelBuffer' ImageFormat.RedGreen' ImageDatatype.Float);              }
Magic Number,OpenGlobe.Scene,OutlinedPolylineTexture,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineTexture.cs,Update,The following statement contains a magic number: if ((_texture == null) || (_texture.Description.Width != textureWidth))              {                  int textureResolution = textureWidth * 2;                    float[] texels = new float[textureResolution];                    int k = 3;                  for (int i = 1; i < textureWidth - 1; ++i)                  {                      texels[k] = 1;                  // Alpha (stored in Green channel)                      k += 2;                  }                    int j = (outlineWidth + 1) * 2;                  for (int i = 0; i < width; ++i)                  {                      texels[j] = 1;                  // Fill/Outline (stored in Red channel)                      j += 2;                  }                    WritePixelBuffer pixelBuffer = Device.CreateWritePixelBuffer(PixelBufferHint.Stream'                      sizeof(float) * textureResolution);                  pixelBuffer.CopyFromSystemMemory(texels);                    if (_texture != null)                  {                      _texture.Dispose();                      _texture = null;                  }                    // TODO:  Why does only Float or HalfFloat work here?                  _texture = Device.CreateTexture2D(new Texture2DDescription(textureWidth' 1' TextureFormat.RedGreen8));                  _texture.CopyFromBuffer(pixelBuffer' ImageFormat.RedGreen' ImageDatatype.Float);              }
Magic Number,OpenGlobe.Scene,OutlinedPolylineTexture,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Polyline\OutlinedPolylineTexture.cs,Render,The following statement contains a magic number: if (_drawState.ShaderProgram != null)              {                  Update(context' sceneState);                    _distance.Value = (float)(((Width * 0.5) + OutlineWidth + 1) * sceneState.HighResolutionSnapScale);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.LinearClamp;                  context.Draw(_primitiveType' _drawState' sceneState);              }
Magic Number,OpenGlobe.Scene,ViewportQuadGeometry,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\ViewportQuad\ViewportQuadGeometry.cs,ViewportQuadGeometry,The following statement contains a magic number: _positionBuffer = Device.CreateVertexBuffer(BufferHint.StaticDraw' 4 * SizeInBytes<Vector2F>.Value);
Magic Number,OpenGlobe.Scene,ViewportQuadGeometry,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\ViewportQuad\ViewportQuadGeometry.cs,ViewportQuadGeometry,The following statement contains a magic number: _textureCoordinatesBuffer = Device.CreateVertexBuffer(BufferHint.StaticDraw' 4 * SizeInBytes<Vector2H>.Value);
Magic Number,OpenGlobe.Scene,ViewportQuadGeometry,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\ViewportQuad\ViewportQuadGeometry.cs,Update,The following statement contains a magic number: if (_va == null)              {                  VertexBufferAttribute positionAttribute = new VertexBufferAttribute(                      _positionBuffer' ComponentDatatype.Float' 2);                  VertexBufferAttribute textureCoordinatesAttribute = new VertexBufferAttribute(                      _textureCoordinatesBuffer' ComponentDatatype.HalfFloat' 2);                    _va = context.CreateVertexArray();                  _va.Attributes[sp.VertexAttributes["position"].Location] = positionAttribute;                  _va.Attributes[sp.VertexAttributes["textureCoordinates"].Location] = textureCoordinatesAttribute;              }
Magic Number,OpenGlobe.Scene,ViewportQuadGeometry,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\ViewportQuad\ViewportQuadGeometry.cs,Update,The following statement contains a magic number: if (_va == null)              {                  VertexBufferAttribute positionAttribute = new VertexBufferAttribute(                      _positionBuffer' ComponentDatatype.Float' 2);                  VertexBufferAttribute textureCoordinatesAttribute = new VertexBufferAttribute(                      _textureCoordinatesBuffer' ComponentDatatype.HalfFloat' 2);                    _va = context.CreateVertexArray();                  _va.Attributes[sp.VertexAttributes["position"].Location] = positionAttribute;                  _va.Attributes[sp.VertexAttributes["textureCoordinates"].Location] = textureCoordinatesAttribute;              }
Magic Number,OpenGlobe.Scene,Wireframe,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Renderables\Wireframe\Wireframe.cs,Render,The following statement contains a magic number: _lineWidth.Value = (float)(0.5 * Width * sceneState.HighResolutionSnapScale);
Magic Number,OpenGlobe.Scene,PolygonShapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\PolygonShapefile.cs,PolygonShapefile,The following statement contains a magic number: Random r = new Random(3);
Magic Number,OpenGlobe.Scene,PolygonShapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\PolygonShapefile.cs,PolygonShapefile,The following statement contains a magic number: foreach (Shape shape in shapefile)              {                  if (shape.ShapeType != ShapeType.Polygon)                  {                      throw new NotSupportedException("The type of an individual shape does not match the Shapefile type.");                  }                    PolygonShape polygonShape = (PolygonShape)shape;                    for (int j = 0; j < polygonShape.Count; ++j)                  {                      Color color = Color.FromArgb(127' r.Next(256)' r.Next(256)' r.Next(256));                        positions.Clear();                        ShapePart part = polygonShape[j];                        for (int i = 0; i < part.Count; ++i)                      {                          Vector2D point = part[i];                            positions.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                            //                          // For polyline                          //                          positionAttribute.Values.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                          colorAttribute.AddColor(color);                          outlineColorAttribute.AddColor(Color.Black);                            if (i != 0)                          {                              indices.Values.Add((uint)positionAttribute.Values.Count - 2);                              indices.Values.Add((uint)positionAttribute.Values.Count - 1);                          }                      }                        try                      {                          Polygon p = new Polygon(context' globeShape' positions);                          p.Color = color;                          _polygons.Add(p);                      }                      catch (ArgumentOutOfRangeException) // Not enough positions after cleaning                      {                      }                  }              }
Magic Number,OpenGlobe.Scene,PolygonShapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\PolygonShapefile.cs,PolygonShapefile,The following statement contains a magic number: foreach (Shape shape in shapefile)              {                  if (shape.ShapeType != ShapeType.Polygon)                  {                      throw new NotSupportedException("The type of an individual shape does not match the Shapefile type.");                  }                    PolygonShape polygonShape = (PolygonShape)shape;                    for (int j = 0; j < polygonShape.Count; ++j)                  {                      Color color = Color.FromArgb(127' r.Next(256)' r.Next(256)' r.Next(256));                        positions.Clear();                        ShapePart part = polygonShape[j];                        for (int i = 0; i < part.Count; ++i)                      {                          Vector2D point = part[i];                            positions.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                            //                          // For polyline                          //                          positionAttribute.Values.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                          colorAttribute.AddColor(color);                          outlineColorAttribute.AddColor(Color.Black);                            if (i != 0)                          {                              indices.Values.Add((uint)positionAttribute.Values.Count - 2);                              indices.Values.Add((uint)positionAttribute.Values.Count - 1);                          }                      }                        try                      {                          Polygon p = new Polygon(context' globeShape' positions);                          p.Color = color;                          _polygons.Add(p);                      }                      catch (ArgumentOutOfRangeException) // Not enough positions after cleaning                      {                      }                  }              }
Magic Number,OpenGlobe.Scene,PolygonShapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\PolygonShapefile.cs,PolygonShapefile,The following statement contains a magic number: foreach (Shape shape in shapefile)              {                  if (shape.ShapeType != ShapeType.Polygon)                  {                      throw new NotSupportedException("The type of an individual shape does not match the Shapefile type.");                  }                    PolygonShape polygonShape = (PolygonShape)shape;                    for (int j = 0; j < polygonShape.Count; ++j)                  {                      Color color = Color.FromArgb(127' r.Next(256)' r.Next(256)' r.Next(256));                        positions.Clear();                        ShapePart part = polygonShape[j];                        for (int i = 0; i < part.Count; ++i)                      {                          Vector2D point = part[i];                            positions.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                            //                          // For polyline                          //                          positionAttribute.Values.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                          colorAttribute.AddColor(color);                          outlineColorAttribute.AddColor(Color.Black);                            if (i != 0)                          {                              indices.Values.Add((uint)positionAttribute.Values.Count - 2);                              indices.Values.Add((uint)positionAttribute.Values.Count - 1);                          }                      }                        try                      {                          Polygon p = new Polygon(context' globeShape' positions);                          p.Color = color;                          _polygons.Add(p);                      }                      catch (ArgumentOutOfRangeException) // Not enough positions after cleaning                      {                      }                  }              }
Magic Number,OpenGlobe.Scene,PolygonShapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\PolygonShapefile.cs,PolygonShapefile,The following statement contains a magic number: foreach (Shape shape in shapefile)              {                  if (shape.ShapeType != ShapeType.Polygon)                  {                      throw new NotSupportedException("The type of an individual shape does not match the Shapefile type.");                  }                    PolygonShape polygonShape = (PolygonShape)shape;                    for (int j = 0; j < polygonShape.Count; ++j)                  {                      Color color = Color.FromArgb(127' r.Next(256)' r.Next(256)' r.Next(256));                        positions.Clear();                        ShapePart part = polygonShape[j];                        for (int i = 0; i < part.Count; ++i)                      {                          Vector2D point = part[i];                            positions.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                            //                          // For polyline                          //                          positionAttribute.Values.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                          colorAttribute.AddColor(color);                          outlineColorAttribute.AddColor(Color.Black);                            if (i != 0)                          {                              indices.Values.Add((uint)positionAttribute.Values.Count - 2);                              indices.Values.Add((uint)positionAttribute.Values.Count - 1);                          }                      }                        try                      {                          Polygon p = new Polygon(context' globeShape' positions);                          p.Color = color;                          _polygons.Add(p);                      }                      catch (ArgumentOutOfRangeException) // Not enough positions after cleaning                      {                      }                  }              }
Magic Number,OpenGlobe.Scene,PolygonShapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\PolygonShapefile.cs,PolygonShapefile,The following statement contains a magic number: foreach (Shape shape in shapefile)              {                  if (shape.ShapeType != ShapeType.Polygon)                  {                      throw new NotSupportedException("The type of an individual shape does not match the Shapefile type.");                  }                    PolygonShape polygonShape = (PolygonShape)shape;                    for (int j = 0; j < polygonShape.Count; ++j)                  {                      Color color = Color.FromArgb(127' r.Next(256)' r.Next(256)' r.Next(256));                        positions.Clear();                        ShapePart part = polygonShape[j];                        for (int i = 0; i < part.Count; ++i)                      {                          Vector2D point = part[i];                            positions.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                            //                          // For polyline                          //                          positionAttribute.Values.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                          colorAttribute.AddColor(color);                          outlineColorAttribute.AddColor(Color.Black);                            if (i != 0)                          {                              indices.Values.Add((uint)positionAttribute.Values.Count - 2);                              indices.Values.Add((uint)positionAttribute.Values.Count - 1);                          }                      }                        try                      {                          Polygon p = new Polygon(context' globeShape' positions);                          p.Color = color;                          _polygons.Add(p);                      }                      catch (ArgumentOutOfRangeException) // Not enough positions after cleaning                      {                      }                  }              }
Magic Number,OpenGlobe.Scene,PolylineShapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\PolylineShapefile.cs,PolylineShapefile,The following statement contains a magic number: foreach (Shape shape in shapefile)              {                  if (shape.ShapeType != ShapeType.Polyline)                  {                      throw new NotSupportedException("The type of an individual shape does not match the Shapefile type.");                  }                    PolylineShape polylineShape = (PolylineShape)shape;                    for (int j = 0; j < polylineShape.Count; ++j)                  {                      ShapePart part = polylineShape[j];                        for (int i = 0; i < part.Count; ++i)                      {                          Vector2D point = part[i];                            positionAttribute.Values.Add(globeShape.ToVector3D(Trig.ToRadians(new Geodetic3D(point.X' point.Y))));                          colorAttribute.AddColor(appearance.PolylineColor);                          outlineColorAttribute.AddColor(appearance.PolylineOutlineColor);                            if (i != 0)                          {                              indices.Values.Add((uint)positionAttribute.Values.Count - 2);                              indices.Values.Add((uint)positionAttribute.Values.Count - 1);                          }                      }                  }              }
Magic Number,OpenGlobe.Scene,PolylineShapefile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Shapefiles\PolylineShapefile.cs,PolylineCapacities,The following statement contains a magic number: foreach (Shape shape in shapefile)              {                  if (shape.ShapeType != ShapeType.Polyline)                  {                      throw new NotSupportedException("The type of an individual shape does not match the Shapefile type.");                  }                    PolylineShape polylineShape = (PolylineShape)shape;                    for (int j = 0; j < polylineShape.Count; ++j)                  {                      ShapePart part = polylineShape[j];                        numberOfPositions += part.Count;                      numberOfIndices += (part.Count - 1) * 2;                  }              }
Magic Number,OpenGlobe.Scene,RayCastedTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\RayCastedTerrainTile.cs,Update,The following statement contains a magic number: if (_dirtyVA)              {                  Vector3D radii = new Vector3D(_tileResolution.X' _tileResolution.Y'                      (_tileMaximumHeight - _tileMinimumHeight) * _heightExaggeration.Value);                  Vector3D halfRadii = 0.5 * radii;                    Mesh mesh = BoxTessellator.Compute(radii);                    //                  // TEXEL_SPACE_TODO:  Translate box so it is not centered at                   // the origin - world space and texel space will match up.                  //                  IList<Vector3D> positions = ((VertexAttributeDoubleVector3)mesh.Attributes["position"]).Values;                  for (int i = 0; i < positions.Count; ++i)                  {                      positions[i] = positions[i] + halfRadii;                  }                    if (_drawState.VertexArray != null)                  {                      _drawState.VertexArray.Dispose();                      _drawState.VertexArray = null;                  }                  _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw);                  _primitiveType = mesh.PrimitiveType;                  _drawState.RenderState.FacetCulling.FrontFaceWindingOrder = mesh.FrontFaceWindingOrder;                    if (_wireframe != null)                  {                      _wireframe.Dispose();                  }                  _wireframe = new Wireframe(context' mesh);                  _wireframe.FacetCullingFace = CullFace.Front;                  _wireframe.Width = 3;                    _dirtyVA = false;              }
Magic Number,OpenGlobe.Scene,RayCastedTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\RayCastedTerrainTile.cs,Update,The following statement contains a magic number: if (_dirtyVA)              {                  Vector3D radii = new Vector3D(_tileResolution.X' _tileResolution.Y'                      (_tileMaximumHeight - _tileMinimumHeight) * _heightExaggeration.Value);                  Vector3D halfRadii = 0.5 * radii;                    Mesh mesh = BoxTessellator.Compute(radii);                    //                  // TEXEL_SPACE_TODO:  Translate box so it is not centered at                   // the origin - world space and texel space will match up.                  //                  IList<Vector3D> positions = ((VertexAttributeDoubleVector3)mesh.Attributes["position"]).Values;                  for (int i = 0; i < positions.Count; ++i)                  {                      positions[i] = positions[i] + halfRadii;                  }                    if (_drawState.VertexArray != null)                  {                      _drawState.VertexArray.Dispose();                      _drawState.VertexArray = null;                  }                  _drawState.VertexArray = context.CreateVertexArray(mesh' _drawState.ShaderProgram.VertexAttributes' BufferHint.StaticDraw);                  _primitiveType = mesh.PrimitiveType;                  _drawState.RenderState.FacetCulling.FrontFaceWindingOrder = mesh.FrontFaceWindingOrder;                    if (_wireframe != null)                  {                      _wireframe.Dispose();                  }                  _wireframe = new Wireframe(context' mesh);                  _wireframe.FacetCullingFace = CullFace.Front;                  _wireframe.Width = 3;                    _dirtyVA = false;              }
Magic Number,OpenGlobe.Scene,TriangleMeshTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\TriangleMeshTerrainTile.cs,TriangleMeshTerrainTile,The following statement contains a magic number: int numberOfIndices = (numberOfPartitionsX * numberOfPartitionsY) * 6;
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,VertexDisplacementMapTerrainTile,The following statement contains a magic number: ((Uniform<Vector2F>)spTerrain.Uniforms["u_positionToRepeatTextureCoordinate"]).Value = new Vector2F(                  (float)(4.0 / (double)tile.Resolution.X)'                  (float)(4.0 / (double)tile.Resolution.Y));
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,VertexDisplacementMapTerrainTile,The following statement contains a magic number: ((Uniform<Vector2F>)spTerrain.Uniforms["u_positionToRepeatTextureCoordinate"]).Value = new Vector2F(                  (float)(4.0 / (double)tile.Resolution.X)'                  (float)(4.0 / (double)tile.Resolution.Y));
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,VertexDisplacementMapTerrainTile,The following statement contains a magic number: Mesh mesh = RectangleTessellator.Compute(new RectangleD(new Vector2D(0.5' 0.5)'                  new Vector2D((double)tile.Resolution.X - 0.5' (double)tile.Resolution.Y - 0.5))'                  tile.Resolution.X - 1' tile.Resolution.Y - 1);
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,VertexDisplacementMapTerrainTile,The following statement contains a magic number: Mesh mesh = RectangleTessellator.Compute(new RectangleD(new Vector2D(0.5' 0.5)'                  new Vector2D((double)tile.Resolution.X - 0.5' (double)tile.Resolution.Y - 0.5))'                  tile.Resolution.X - 1' tile.Resolution.Y - 1);
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,VertexDisplacementMapTerrainTile,The following statement contains a magic number: Mesh mesh = RectangleTessellator.Compute(new RectangleD(new Vector2D(0.5' 0.5)'                  new Vector2D((double)tile.Resolution.X - 0.5' (double)tile.Resolution.Y - 0.5))'                  tile.Resolution.X - 1' tile.Resolution.Y - 1);
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,VertexDisplacementMapTerrainTile,The following statement contains a magic number: Mesh mesh = RectangleTessellator.Compute(new RectangleD(new Vector2D(0.5' 0.5)'                  new Vector2D((double)tile.Resolution.X - 0.5' (double)tile.Resolution.Y - 0.5))'                  tile.Resolution.X - 1' tile.Resolution.Y - 1);
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Update,The following statement contains a magic number: _lineWidthWireframe.Value = (float)(0.5 * 3.0 * sceneState.HighResolutionSnapScale);
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Update,The following statement contains a magic number: _lineWidthWireframe.Value = (float)(0.5 * 3.0 * sceneState.HighResolutionSnapScale);
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Update,The following statement contains a magic number: _fillDistanceNormals.Value = (float)(0.5 * 3.0 * sceneState.HighResolutionSnapScale);
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Update,The following statement contains a magic number: _fillDistanceNormals.Value = (float)(0.5 * 3.0 * sceneState.HighResolutionSnapScale);
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,VertexDisplacementMapTerrainTile,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\VertexDisplacementMapTerrainTile.cs,Render,The following statement contains a magic number: if (ShowTerrain || ShowSilhouette || ShowWireframe || ShowNormals)              {                  Update(sceneState);                    context.TextureUnits[0].Texture = _texture;                  context.TextureUnits[0].TextureSampler = Device.TextureSamplers.NearestClamp;                    context.TextureUnits[6].Texture = ColorMapTexture;                  context.TextureUnits[6].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[1].Texture = ColorRampHeightTexture;                  context.TextureUnits[1].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[7].Texture = ColorRampSlopeTexture;                  context.TextureUnits[7].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[2].Texture = BlendRampTexture;                  context.TextureUnits[2].TextureSampler = Device.TextureSamplers.LinearClamp;                    context.TextureUnits[3].Texture = GrassTexture;                  context.TextureUnits[3].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[4].Texture = StoneTexture;                  context.TextureUnits[4].TextureSampler = Device.TextureSamplers.LinearRepeat;                    context.TextureUnits[5].Texture = BlendMaskTexture;                  context.TextureUnits[5].TextureSampler = Device.TextureSamplers.LinearClamp;                    if (ShowTerrain || ShowSilhouette)                  {                      context.Draw(_primitiveType' _drawStateTerrain' sceneState);                  }                    if (ShowWireframe)                  {                      context.Draw(_primitiveType' _drawStateWireframe' sceneState);                  }                    if (ShowNormals && (_normalsAlgorithm != TerrainNormalsAlgorithm.None))                  {                      context.Draw(PrimitiveType.Points' _drawStateNormals' sceneState);                  }              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,WorldWindTerrainSource,The following statement contains a magic number: for (int i = 0; i < _levels.Length; ++i)              {                  int longitudePosts = (int)Math.Round(360.0 / deltaLongitude) * TileLongitudePosts + 1;                  int latitudePosts = (int)Math.Round(180.0 / deltaLatitude) * TileLatitudePosts + 1;                  _levels[i] = new RasterLevel(this' i' _extent' longitudePosts' latitudePosts' TileLongitudePosts' TileLatitudePosts);                  deltaLongitude /= 2.0;                  deltaLatitude /= 2.0;              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,WorldWindTerrainSource,The following statement contains a magic number: for (int i = 0; i < _levels.Length; ++i)              {                  int longitudePosts = (int)Math.Round(360.0 / deltaLongitude) * TileLongitudePosts + 1;                  int latitudePosts = (int)Math.Round(180.0 / deltaLatitude) * TileLatitudePosts + 1;                  _levels[i] = new RasterLevel(this' i' _extent' longitudePosts' latitudePosts' TileLongitudePosts' TileLatitudePosts);                  deltaLongitude /= 2.0;                  deltaLatitude /= 2.0;              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,WorldWindTerrainSource,The following statement contains a magic number: for (int i = 0; i < _levels.Length; ++i)              {                  int longitudePosts = (int)Math.Round(360.0 / deltaLongitude) * TileLongitudePosts + 1;                  int latitudePosts = (int)Math.Round(180.0 / deltaLatitude) * TileLatitudePosts + 1;                  _levels[i] = new RasterLevel(this' i' _extent' longitudePosts' latitudePosts' TileLongitudePosts' TileLatitudePosts);                  deltaLongitude /= 2.0;                  deltaLatitude /= 2.0;              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,WorldWindTerrainSource,The following statement contains a magic number: for (int i = 0; i < _levels.Length; ++i)              {                  int longitudePosts = (int)Math.Round(360.0 / deltaLongitude) * TileLongitudePosts + 1;                  int latitudePosts = (int)Math.Round(180.0 / deltaLatitude) * TileLatitudePosts + 1;                  _levels[i] = new RasterLevel(this' i' _extent' longitudePosts' latitudePosts' TileLongitudePosts' TileLatitudePosts);                  deltaLongitude /= 2.0;                  deltaLatitude /= 2.0;              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,LoadTileTexture,The following statement contains a magic number: if (data == null || data.Length != heightsToRead * sizeof(short))              {                  double divisor = Math.Pow(2.0' identifier.Level);                  double longitudeResolution = LevelZeroDeltaLongitudeDegrees / divisor;                  double latitudeResolution = LevelZeroDeltaLatitudeDegrees / divisor;                    double west = -180.0 + longitudeResolution * identifier.X;                  double east = -180.0 + longitudeResolution * (identifier.X + 1);                  double south = -90.0 + latitudeResolution * identifier.Y;                  double north = -90.0 + latitudeResolution * (identifier.Y + 1);                    StringBuilder query = new StringBuilder(_baseUri.AbsoluteUri);                  query.Append("&bbox=");                  query.Append(west.ToString("0.###########"));                  query.Append(''');                  query.Append(south.ToString("0.###########"));                  query.Append(''');                  query.Append(east.ToString("0.###########"));                  query.Append(''');                  query.Append(north.ToString("0.###########"));                  query.Append('&');                    string queryString = query.ToString();                  ++_tilesLoaded;                  Console.WriteLine("(" + _tilesLoaded + ") Downloading " + queryString);                    int bytesToRead = heightsToRead * 2;                    WebRequest request = WebRequest.Create(queryString);                    data = new byte[bytesToRead];                    using (WebResponse response = request.GetResponse())                  using (Stream stream = response.GetResponseStream())                  using (FileStream file = new FileStream(cacheFilename' FileMode.Create' FileAccess.Write))                  {                      int bytesRead = 0;                      while (bytesRead < bytesToRead)                      {                          int bytesReadThisTime = stream.Read(data' bytesRead' bytesToRead - bytesRead);                          if (bytesReadThisTime == 0)                              throw new IOException("Unexpected end of file.");                          file.Write(data' bytesRead' bytesReadThisTime);                          bytesRead += bytesReadThisTime;                      }                  }              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,LoadTileTexture,The following statement contains a magic number: if (data == null || data.Length != heightsToRead * sizeof(short))              {                  double divisor = Math.Pow(2.0' identifier.Level);                  double longitudeResolution = LevelZeroDeltaLongitudeDegrees / divisor;                  double latitudeResolution = LevelZeroDeltaLatitudeDegrees / divisor;                    double west = -180.0 + longitudeResolution * identifier.X;                  double east = -180.0 + longitudeResolution * (identifier.X + 1);                  double south = -90.0 + latitudeResolution * identifier.Y;                  double north = -90.0 + latitudeResolution * (identifier.Y + 1);                    StringBuilder query = new StringBuilder(_baseUri.AbsoluteUri);                  query.Append("&bbox=");                  query.Append(west.ToString("0.###########"));                  query.Append(''');                  query.Append(south.ToString("0.###########"));                  query.Append(''');                  query.Append(east.ToString("0.###########"));                  query.Append(''');                  query.Append(north.ToString("0.###########"));                  query.Append('&');                    string queryString = query.ToString();                  ++_tilesLoaded;                  Console.WriteLine("(" + _tilesLoaded + ") Downloading " + queryString);                    int bytesToRead = heightsToRead * 2;                    WebRequest request = WebRequest.Create(queryString);                    data = new byte[bytesToRead];                    using (WebResponse response = request.GetResponse())                  using (Stream stream = response.GetResponseStream())                  using (FileStream file = new FileStream(cacheFilename' FileMode.Create' FileAccess.Write))                  {                      int bytesRead = 0;                      while (bytesRead < bytesToRead)                      {                          int bytesReadThisTime = stream.Read(data' bytesRead' bytesToRead - bytesRead);                          if (bytesReadThisTime == 0)                              throw new IOException("Unexpected end of file.");                          file.Write(data' bytesRead' bytesReadThisTime);                          bytesRead += bytesReadThisTime;                      }                  }              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,LoadTileTexture,The following statement contains a magic number: if (data == null || data.Length != heightsToRead * sizeof(short))              {                  double divisor = Math.Pow(2.0' identifier.Level);                  double longitudeResolution = LevelZeroDeltaLongitudeDegrees / divisor;                  double latitudeResolution = LevelZeroDeltaLatitudeDegrees / divisor;                    double west = -180.0 + longitudeResolution * identifier.X;                  double east = -180.0 + longitudeResolution * (identifier.X + 1);                  double south = -90.0 + latitudeResolution * identifier.Y;                  double north = -90.0 + latitudeResolution * (identifier.Y + 1);                    StringBuilder query = new StringBuilder(_baseUri.AbsoluteUri);                  query.Append("&bbox=");                  query.Append(west.ToString("0.###########"));                  query.Append(''');                  query.Append(south.ToString("0.###########"));                  query.Append(''');                  query.Append(east.ToString("0.###########"));                  query.Append(''');                  query.Append(north.ToString("0.###########"));                  query.Append('&');                    string queryString = query.ToString();                  ++_tilesLoaded;                  Console.WriteLine("(" + _tilesLoaded + ") Downloading " + queryString);                    int bytesToRead = heightsToRead * 2;                    WebRequest request = WebRequest.Create(queryString);                    data = new byte[bytesToRead];                    using (WebResponse response = request.GetResponse())                  using (Stream stream = response.GetResponseStream())                  using (FileStream file = new FileStream(cacheFilename' FileMode.Create' FileAccess.Write))                  {                      int bytesRead = 0;                      while (bytesRead < bytesToRead)                      {                          int bytesReadThisTime = stream.Read(data' bytesRead' bytesToRead - bytesRead);                          if (bytesReadThisTime == 0)                              throw new IOException("Unexpected end of file.");                          file.Write(data' bytesRead' bytesReadThisTime);                          bytesRead += bytesReadThisTime;                      }                  }              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,LoadTileTexture,The following statement contains a magic number: if (data == null || data.Length != heightsToRead * sizeof(short))              {                  double divisor = Math.Pow(2.0' identifier.Level);                  double longitudeResolution = LevelZeroDeltaLongitudeDegrees / divisor;                  double latitudeResolution = LevelZeroDeltaLatitudeDegrees / divisor;                    double west = -180.0 + longitudeResolution * identifier.X;                  double east = -180.0 + longitudeResolution * (identifier.X + 1);                  double south = -90.0 + latitudeResolution * identifier.Y;                  double north = -90.0 + latitudeResolution * (identifier.Y + 1);                    StringBuilder query = new StringBuilder(_baseUri.AbsoluteUri);                  query.Append("&bbox=");                  query.Append(west.ToString("0.###########"));                  query.Append(''');                  query.Append(south.ToString("0.###########"));                  query.Append(''');                  query.Append(east.ToString("0.###########"));                  query.Append(''');                  query.Append(north.ToString("0.###########"));                  query.Append('&');                    string queryString = query.ToString();                  ++_tilesLoaded;                  Console.WriteLine("(" + _tilesLoaded + ") Downloading " + queryString);                    int bytesToRead = heightsToRead * 2;                    WebRequest request = WebRequest.Create(queryString);                    data = new byte[bytesToRead];                    using (WebResponse response = request.GetResponse())                  using (Stream stream = response.GetResponseStream())                  using (FileStream file = new FileStream(cacheFilename' FileMode.Create' FileAccess.Write))                  {                      int bytesRead = 0;                      while (bytesRead < bytesToRead)                      {                          int bytesReadThisTime = stream.Read(data' bytesRead' bytesToRead - bytesRead);                          if (bytesReadThisTime == 0)                              throw new IOException("Unexpected end of file.");                          file.Write(data' bytesRead' bytesReadThisTime);                          bytesRead += bytesReadThisTime;                      }                  }              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,LoadTileTexture,The following statement contains a magic number: if (data == null || data.Length != heightsToRead * sizeof(short))              {                  double divisor = Math.Pow(2.0' identifier.Level);                  double longitudeResolution = LevelZeroDeltaLongitudeDegrees / divisor;                  double latitudeResolution = LevelZeroDeltaLatitudeDegrees / divisor;                    double west = -180.0 + longitudeResolution * identifier.X;                  double east = -180.0 + longitudeResolution * (identifier.X + 1);                  double south = -90.0 + latitudeResolution * identifier.Y;                  double north = -90.0 + latitudeResolution * (identifier.Y + 1);                    StringBuilder query = new StringBuilder(_baseUri.AbsoluteUri);                  query.Append("&bbox=");                  query.Append(west.ToString("0.###########"));                  query.Append(''');                  query.Append(south.ToString("0.###########"));                  query.Append(''');                  query.Append(east.ToString("0.###########"));                  query.Append(''');                  query.Append(north.ToString("0.###########"));                  query.Append('&');                    string queryString = query.ToString();                  ++_tilesLoaded;                  Console.WriteLine("(" + _tilesLoaded + ") Downloading " + queryString);                    int bytesToRead = heightsToRead * 2;                    WebRequest request = WebRequest.Create(queryString);                    data = new byte[bytesToRead];                    using (WebResponse response = request.GetResponse())                  using (Stream stream = response.GetResponseStream())                  using (FileStream file = new FileStream(cacheFilename' FileMode.Create' FileAccess.Write))                  {                      int bytesRead = 0;                      while (bytesRead < bytesToRead)                      {                          int bytesReadThisTime = stream.Read(data' bytesRead' bytesToRead - bytesRead);                          if (bytesReadThisTime == 0)                              throw new IOException("Unexpected end of file.");                          file.Write(data' bytesRead' bytesReadThisTime);                          bytesRead += bytesReadThisTime;                      }                  }              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,LoadTileTexture,The following statement contains a magic number: if (data == null || data.Length != heightsToRead * sizeof(short))              {                  double divisor = Math.Pow(2.0' identifier.Level);                  double longitudeResolution = LevelZeroDeltaLongitudeDegrees / divisor;                  double latitudeResolution = LevelZeroDeltaLatitudeDegrees / divisor;                    double west = -180.0 + longitudeResolution * identifier.X;                  double east = -180.0 + longitudeResolution * (identifier.X + 1);                  double south = -90.0 + latitudeResolution * identifier.Y;                  double north = -90.0 + latitudeResolution * (identifier.Y + 1);                    StringBuilder query = new StringBuilder(_baseUri.AbsoluteUri);                  query.Append("&bbox=");                  query.Append(west.ToString("0.###########"));                  query.Append(''');                  query.Append(south.ToString("0.###########"));                  query.Append(''');                  query.Append(east.ToString("0.###########"));                  query.Append(''');                  query.Append(north.ToString("0.###########"));                  query.Append('&');                    string queryString = query.ToString();                  ++_tilesLoaded;                  Console.WriteLine("(" + _tilesLoaded + ") Downloading " + queryString);                    int bytesToRead = heightsToRead * 2;                    WebRequest request = WebRequest.Create(queryString);                    data = new byte[bytesToRead];                    using (WebResponse response = request.GetResponse())                  using (Stream stream = response.GetResponseStream())                  using (FileStream file = new FileStream(cacheFilename' FileMode.Create' FileAccess.Write))                  {                      int bytesRead = 0;                      while (bytesRead < bytesToRead)                      {                          int bytesReadThisTime = stream.Read(data' bytesRead' bytesToRead - bytesRead);                          if (bytesReadThisTime == 0)                              throw new IOException("Unexpected end of file.");                          file.Write(data' bytesRead' bytesReadThisTime);                          bytesRead += bytesReadThisTime;                      }                  }              }
Magic Number,OpenGlobe.Scene,WorldWindTerrainSource,C:\repos\virtualglobebook_OpenGlobe\Source\Scene\Terrain\WorldWindTerrainSource.cs,LoadTileTexture,The following statement contains a magic number: for (int row = TileHeight - 1; row >= 0; --row)              {                  int rowIndex = row * TileWidth;                  for (int col = 0; col < TileWidth; ++col)                  {                      result[index++] = BitConverter.ToInt16(data' 2 * (rowIndex + col));                  }              }
