Implementation smell,Namespace,Class,File,Method,Description
Long Method,SIL.FieldWorks.LexText.Controls,ConfigureHomographDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\ConfigureHomographDlg.cs,InitializeComponent,The method has 130 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,OccurrenceDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\OccurrenceDlg.cs,InitializeComponent,The method has 105 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,GetSelectionInfo,The method has 119 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,SfmToTextsAndWordsMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\SfmToTextsAndWordsMappingBaseDlg.cs,InitializeComponent,The method has 110 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,InitializeComponent,The method has 136 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteCustomFields,The method has 105 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessRangeElement,The method has 188 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateCustomField,The method has 126 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexEntryRefs,The method has 159 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,DetermineLexEntryTypes,The method has 106 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureDefinition,The method has 125 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessStTextField,The method has 119 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateMSA,The method has 140 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SenseGramInfoConflicts,The method has 120 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LiftImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftImportDlg.cs,ImportLIFT,The method has 100 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LiftImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftImportDlg.cs,InitializeComponent,The method has 159 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The method has 142 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,InitializeComponent,The method has 212 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The method has 102 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,ProcessPhase4Log,The method has 154 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnModifyContentMapping_Click,The method has 158 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The method has 664 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ProcessPhase1Errors,The method has 115 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ProcessErrorLogCautions,The method has 124 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImportWizardCharMarkerDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardCharMarkerDlg.cs,InitializeComponent,The method has 172 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,MarkerPresenter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,MergeData,The method has 162 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImportWizardLanguage,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardLanguage.cs,InitializeComponent,The method has 124 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,Init,The method has 143 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,InitializeComponent,The method has 210 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,FillLexicalRefTypesCombo,The method has 110 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexOptionsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexOptionsDlg.cs,m_btnOK_Click,The method has 113 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LexOptionsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexOptionsDlg.cs,InitializeComponent,The method has 197 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LinkAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkAllomorphDlg.cs,InitializeComponent,The method has 101 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LinkEntryOrSenseDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkEntryOrSenseDlg.cs,InitializeComponent,The method has 130 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LinkMSADlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkMSADlg.cs,InitializeComponent,The method has 117 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,LinkVariantToEntryOrSense,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,InitializeComponent,The method has 119 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,MasterCategoryListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,InitializeComponent,The method has 122 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls,MasterListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterListDlg.cs,InitializeComponent,The method has 120 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,AnthroFieldMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\AnthroFieldMappingDlg.cs,SetSubControl,The method has 103 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,AnthroFieldMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\AnthroFieldMappingDlg.cs,InitializeComponent,The method has 117 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,ImportCharMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ImportCharMappingDlg.cs,InitializeComponent,The method has 170 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,ListRefFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ListRefFieldOptions.cs,InitializeComponent,The method has 239 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SaveSettings,The method has 124 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,WriteMarkerContents,The method has 118 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ReadMarkerSetting,The method has 103 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ImportStdFmtFile,The method has 152 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetDefaultForListRef,The method has 100 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The method has 149 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetListReference,The method has 100 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,StoreCustomListRefItem,The method has 155 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,InitializeComponent,The method has 702 lines of code.
Long Method,SIL.FieldWorks.LexText.Controls.DataNotebook,TextFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\TextFieldOptions.cs,InitializeComponent,The method has 125 lines of code.
Complex Method,SIL.FieldWorks.LexText.Controls,AddAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddAllomorphDlg.cs,HandleMatchingSelectionChanged,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,GetSelectionInfo,Cyclomatic complexity of the method is 15
Complex Method,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,PopulateValuesCombo,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,InsertionControl,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertionControl.cs,UpdateOptionsDisplay,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,EntryGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\EntryGoDlg.cs,GetFields,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteLiftEntry,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteCustomStText,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteLexReference,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteLexSense,Cyclomatic complexity of the method is 19
Complex Method,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteMoStemMsa,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteMoDerivAffMsa,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteAllForms,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,ConvertTsStringToLiftXml,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetCustomListsAndReferencedLists,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,LoadLiftRanges,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,InitializePossibilityMaps,Cyclomatic complexity of the method is 22
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeInAllomorphForms,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeInMultiString,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeInMultiUnicode,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MultiUnicodeStringMatches,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,TsStringAsHtml,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,StoreResidueFromVariant,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateCustomField,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CheckForCompatibleTypes,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,AddEticCategoryInfo,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessSlotDefinition,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessInflectionClassDefinition,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CollectLexEntryRefMembers,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexEntryRefs,Cyclomatic complexity of the method is 19
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,DetermineLexEntryTypes,Cyclomatic complexity of the method is 15
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CollapseCollectionRelationPairs,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,TreeRelationAlreadyExists,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,DeleteOrphans,Cyclomatic complexity of the method is 19
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,InitializeStemNameMap,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,LoadCategoryNode,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FillInExtensibleElementsFromRawXml,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureDefinition,Cyclomatic complexity of the method is 21
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureStrucType,Cyclomatic complexity of the method is 15
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureValue,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindRelevantClosedFeature,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FillIdAbbrSymFeatValMap,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessStemName,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeIntoExistingEntry,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SenseHasConflictingData,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ParseMultipleParagraphs,Cyclomatic complexity of the method is 17
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergePronunciationMedia,Cyclomatic complexity of the method is 15
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindMatchingPronunciation,Cyclomatic complexity of the method is 14
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,EntryEtymologiesConflict,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeIntoExistingSense,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeSenseExamples,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SenseExamplesConflict,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeExampleTranslations,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateMSA,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,StoreMsaExceptionFeatures,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessMsaInflectionClassInfo,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MsaMatchesInflClass,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessMsaSlotInformation,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MsaSlotInfoMatches,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MsaExceptionFeatsMatch,Cyclomatic complexity of the method is 18
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MsaInflFeatureMatches,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ParseFeatureString,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ParseFeatureString,Cyclomatic complexity of the method is 16
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatStrucData,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SplitFeatureString,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SenseGramInfoConflicts,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeSenseIllustrations,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindPicture,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.LexText.Controls,FeatureStructureTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\FeatureStructureTreeView.cs,AddNode,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,LiftImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftImportDlg.cs,ImportLIFT,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,GetFile,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,DisplayBeginMarkers,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnCancelButton,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ProcessErrorLogErrors,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ProcessErrorLogCautions,Cyclomatic complexity of the method is 18
Complex Method,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ProcessErrorLogSfmInfo,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,MarkerPresenter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,MergeData,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,Init,Cyclomatic complexity of the method is 24
Complex Method,SIL.FieldWorks.LexText.Controls,LexOptionsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexOptionsDlg.cs,m_btnOK_Click,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.LexText.Controls,MsaCreatorDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaCreatorDlg.cs,SetDlgInfo,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls,PopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,m_treeCombo_AfterSelect,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.XWorks.MorphologyEditor,PhonologicalFeaturePopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeaturePopupTreeManager.cs,MakeMenuItems,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,AnthroFieldMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\AnthroFieldMappingDlg.cs,m_btnAddCustom_Click,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,GetFile,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,IsValidMapFile,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,InitializeKeyMarkers,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,FixSettingsForThisDatabase,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SplitIntoParagraphs,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,MakeTsString,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,TryParseGenDate,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ProcessStoredLinkData,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetListReference,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ApplyBeforeAndBetween,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,StoreParticipant,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,CreateNewPossibility,Cyclomatic complexity of the method is 8
Long Parameter List,SIL.FieldWorks.LexText.Controls,AddAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddAllomorphDlg.cs,SetDlgInfo,The method has 6 parameters. Parameters: cache' wp' mediator' propertyTable' tssform' hvoType
Long Parameter List,SIL.FieldWorks.LexText.Controls,ConfigureHomographDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\ConfigureHomographDlg.cs,SetupDialog,The method has 5 parameters. Parameters: hc' cache' stylesheet' app' helpTopicProvider
Long Parameter List,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,Init,The method has 7 parameters. Parameters: mediator' propertyTable' hvo' patternControl' vc' rootFrag' sda
Long Parameter List,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,GetSelectionInfo,The method has 6 parameters. Parameters: sel' limit' vwSel' curHvo' curIch' curTag
Long Parameter List,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,SelectAt,The method has 5 parameters. Parameters: ctxt' index' initial' editable' install
Long Parameter List,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,SetDlgInfo,The method has 5 parameters. Parameters: cache' mediator' propertyTable' rule' ctxt
Long Parameter List,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,SetDlgInfo,The method has 5 parameters. Parameters: cache' mediator' propertyTable' cobj' owningFlid
Long Parameter List,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,SetDlgInfo,The method has 8 parameters. Parameters: cache' mediator' propertyTable' hvoOwner' owningFlid' fs' rule' ctxt
Long Parameter List,SIL.FieldWorks.LexText.Controls,SfmToTextsAndWordsMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\SfmToTextsAndWordsMappingBaseDlg.cs,SetupDlg,The method has 5 parameters. Parameters: helpTopicProvider' app' cache' mappingToModify' destinationsToDisplay
Long Parameter List,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The method has 5 parameters. Parameters: cache' wp' mediator' propertyTable' ws
Long Parameter List,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The method has 5 parameters. Parameters: cache' wp' mediator' propertyTable' form
Long Parameter List,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The method has 6 parameters. Parameters: cache' wp' mediator' propertyTable' form' ws
Long Parameter List,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The method has 5 parameters. Parameters: cache' wp' mediator' propertyTable' tssform
Long Parameter List,SIL.FieldWorks.LexText.Controls,InsertRecordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertRecordDlg.cs,SetDlgInfo,The method has 5 parameters. Parameters: cache' mediator' propertyTable' owner' tssTitle
Long Parameter List,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,ExportFile,The method has 5 parameters. Parameters: w' internalPath' actualPath' liftFolderName' expectRootFolder
Long Parameter List,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteAllForms,The method has 5 parameters. Parameters: w' wrappingElementName' attrs' elementName' multi
Long Parameter List,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteAllFormsWithMarkers,The method has 5 parameters. Parameters: w' wrappingElementName' attrs' elementName' alt
Long Parameter List,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteAllForms,The method has 5 parameters. Parameters: w' wrappingElementName' attrs' elementName' multi
Long Parameter List,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteString,The method has 5 parameters. Parameters: w' wrappingElementName' attrs' elementName' tssForm
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateLexRefType,The method has 9 parameters. Parameters: relationTypeName' guid' parent' desc' label' abbrev' revName' revAbbrev' refType
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreatePossibility,The method has 6 parameters. Parameters: traitValue' ws' createMethod' dict' rgnewPoss' listToUpdate
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,UpdatePossibilityWithTraitValue,The method has 5 parameters. Parameters: ws' poss' traitValue' dict' rgnewPoss
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,GetRangeElementDetails,The method has 6 parameters. Parameters: xnElem' guidAttr' parent' description' label' abbrev
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessRangeElement,The method has 8 parameters. Parameters: range' id' guidAttr' parent' description' label' abbrev' rawXml
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexRefType,The method has 7 parameters. Parameters: id' guidAttr' parent' desc' label' abbrev' rawXml
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeInAllomorphForms,The method has 5 parameters. Parameters: forms' tsm' clsidForm' guidEntry' flid
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MultiUnicodeStringsConflict,The method has 5 parameters. Parameters: tsm' lmt' fStripMarkers' guidEntry' flid
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MultiUnicodeStringMatches,The method has 5 parameters. Parameters: tsm' lmt' fStripMarkers' guidEntry' flid
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessAnthroItem,The method has 6 parameters. Parameters: id' guidAttr' parent' description' label' abbrev
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessSemanticDomain,The method has 6 parameters. Parameters: id' guidAttr' parent' description' label' abbrev
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessPossibility,The method has 10 parameters. Parameters: id' guidAttr' parent' description' label' abbrev' dict' rgNew' list' isCustom
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessPossibilityPublications,The method has 10 parameters. Parameters: id' guidAttr' parent' description' label' abbrev' dict' rgNew' list' isCustom
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLocation,The method has 6 parameters. Parameters: id' guidAttr' parent' description' label' abbrev
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessPerson,The method has 9 parameters. Parameters: id' guidAttr' parent' description' label' abbrev' dict' rgNew' list
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SetNewPossibilityAttributes,The method has 5 parameters. Parameters: id' description' label' abbrev' poss
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessPartOfSpeech,The method has 6 parameters. Parameters: id' guidAttr' parent' description' label' abbrev
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessMorphType,The method has 6 parameters. Parameters: id' guidAttr' parent' description' label' abbrev
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindExistingPossibility,The method has 6 parameters. Parameters: id' guidAttr' label' abbrev' dict' list
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessSlotDefinition,The method has 7 parameters. Parameters: range' id' guidAttr' parent' description' label' abbrev
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessInflectionClassDefinition,The method has 7 parameters. Parameters: range' id' guidAttr' sParent' description' label' abbrev
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MatchLexEntryRef,The method has 7 parameters. Parameters: ler' refType' complexEntryTypes' variantEntryTypes' summary' componentLexemes' primaryLexemes
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeInField,The method has 6 parameters. Parameters: extensible' tagAttribute' dateCreated' dateModified' contents' traits
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeInReversal,The method has 5 parameters. Parameters: sense' parent' contents' type' rawXml
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeInEtymology,The method has 6 parameters. Parameters: entry' source' type' form' gloss' rawXml
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureDefinition,The method has 8 parameters. Parameters: id' guidAttr' parent' description' label' abbrev' rawXml' featSystem
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureStrucType,The method has 8 parameters. Parameters: id' guidAttr' parent' description' label' abbrev' rawXml' featSystem
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureValue,The method has 8 parameters. Parameters: range' id' guidAttr' parent' description' label' abbrev' rawXml
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,StoreSymFeatValInClosedFeature,The method has 8 parameters. Parameters: id' description' label' abbrev' sCatalogId' fShowInGloss' featClosed' featId
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessStemName,The method has 8 parameters. Parameters: range' id' guidAttr' parent' description' label' abbrev' rawXml
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessNestedSpans,The method has 5 parameters. Parameters: text' span' wsSpan' styleSpan' tisb
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CreateMoForm,The method has 6 parameters. Parameters: traits' tssForm' mmt' realForm' guidEntry' flid
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FinishMoForm,The method has 7 parameters. Parameters: mf' forms' tssForm' mmt' realForm' guidEntry' flid
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindMatchingMoForm,The method has 5 parameters. Parameters: le' dictHvoVariant' lv' guidEntry' flid
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateStemMSA,The method has 8 parameters. Parameters: le' pos' dictPosSlots' dictPosInflClasses' rgpossProdRestrict' sInflectionFeature' rgsResidue' msaSense
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateUnclassifiedAffixMSA,The method has 6 parameters. Parameters: le' pos' dictPosSlots' dictPosInflClasses' rgsResidue' msaSense
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateDerivStepAffixMSA,The method has 6 parameters. Parameters: le' pos' dictPosSlots' dictPosInflClasses' rgsResidue' msaSense
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateDerivAffixMSA,The method has 13 parameters. Parameters: le' pos' sFromPOS' dictPosSlots' dictPosInflClasses' dictPosFromInflClasses' rgpossProdRestrict' rgpossFromProdRestrict' sInflectionFeature' sFromInflFeature' sFromStemName' rgsResidue' msaSense
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateInflAffixMSA,The method has 8 parameters. Parameters: le' pos' dictPosSlots' dictPosInflClasses' rgpossProdRestrict' sFeatureString' rgsResidue' msaSense
Long Parameter List,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessUnknownField,The method has 6 parameters. Parameters: co' obj' field' sClass' sOldPrefix' clid
Long Parameter List,SIL.FieldWorks.LexText.Controls,PendingErrorReport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerSupportCodeAndClasses.cs,PendingErrorReport,The method has 5 parameters. Parameters: guid' flid' ws' cache' merger
Long Parameter List,SIL.FieldWorks.LexText.Controls,InvalidData,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerSupportCodeAndClasses.cs,InvalidData,The method has 7 parameters. Parameters: sMsg' guid' flid' val' ws' cache' merger
Long Parameter List,SIL.FieldWorks.LexText.Controls,PendingFeatureValue,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerSupportCodeAndClasses.cs,PendingFeatureValue,The method has 8 parameters. Parameters: featId' id' description' label' abbrev' catalogId' fShowInGloss' guidLift
Long Parameter List,SIL.FieldWorks.LexText.Controls,RecordGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\RecordGoDlg.cs,SetDlgInfo,The method has 5 parameters. Parameters: cache' wp' mediator' propertyTable' form
Long Parameter List,SIL.FieldWorks.LexText.Controls,FeatureTreeNode,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\FeatureStructureTreeView.cs,FeatureTreeNode,The method has 5 parameters. Parameters: sName' i' iSel' iHvo' eKind
Long Parameter List,SIL.FieldWorks.LexText.Controls,InflectionClassPopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InflectionClassPopupTreeManager.cs,InflectionClassPopupTreeManager,The method has 7 parameters. Parameters: treeCombo' cache' mediator' propertyTable' useAbbr' parent' wsDisplay
Long Parameter List,SIL.FieldWorks.LexText.Controls,InflectionClassPopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InflectionClassPopupTreeManager.cs,GatherPartsOfSpeech,The method has 8 parameters. Parameters: cache' rootHvo' rootFlid' subFlid' itemFlid' flidName' wsName' collector
Long Parameter List,SIL.FieldWorks.LexText.Controls,InflectionFeaturePopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InflectionFeaturePopupTreeManager.cs,InflectionFeaturePopupTreeManager,The method has 7 parameters. Parameters: treeCombo' cache' useAbbr' mediator' propertyTable' parent' wsDisplay
Long Parameter List,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The method has 7 parameters. Parameters: cache' morphType' msaType' slot' mediator' propertyTable' filter
Long Parameter List,SIL.FieldWorks.LexText.Controls,MarkerPresenter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,MarkerPresenter,The method has 7 parameters. Parameters: rootDir' uiLangInfo' topAnalysisWS' mapfile' datafile' fwFile' numColumns
Long Parameter List,SIL.FieldWorks.LexText.Controls,ContentMapping,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,ContentMapping,The method has 10 parameters. Parameters: marker' desc' className' fwDest' ws' langDescriptor' count' order' fdesc' isCustom
Long Parameter List,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,Init,The method has 5 parameters. Parameters: currentMarker' uiLangsHT' cache' helpTopicProvider' app
Long Parameter List,SIL.FieldWorks.LexText.Controls,Sfm2FlexTextBase<TMapping>,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\Sfm2FlexTextWords.cs,MakeRepeatableItem,The method has 5 parameters. Parameters: mapping' data' itemType' parentMarker' itemsInThisParent
Long Parameter List,SIL.FieldWorks.LexText.Controls,LinkVariantToEntryOrSense,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,SetDlgInfo,The method has 5 parameters. Parameters: cache' wp' mediator' propertyTable' ws
Long Parameter List,SIL.FieldWorks.LexText.Controls,MasterCategoryListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,SetDlginfo,The method has 5 parameters. Parameters: posList' mediator' propertyTable' launchedFromInsertMenu' subItemOwner
Long Parameter List,SIL.FieldWorks.LexText.Controls,MasterCategory,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,GetBestWritingSystemForNamedNode,The method has 5 parameters. Parameters: node' sNodeName' sDefaultWS' cache' sNodeContent
Long Parameter List,SIL.FieldWorks.LexText.Controls,MasterCategory,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,DeterminePOSLocationInfo,The method has 6 parameters. Parameters: cache' subItemOwner' parent' posList' newOwningFlid' insertLocation
Long Parameter List,SIL.FieldWorks.LexText.Controls,MasterListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterListDlg.cs,SetDlginfo,The method has 6 parameters. Parameters: featSys' mediator' propertyTable' launchedFromInsertMenu' sWindowKey' sXmlFile
Long Parameter List,SIL.FieldWorks.LexText.Controls,MsaCreatorDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaCreatorDlg.cs,SetDlgInfo,The method has 9 parameters. Parameters: cache' persistProvider' mediator' propertyTable' entry' sandboxMsa' hvoOriginalMsa' useForEdit' titleForEdit
Long Parameter List,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,Initialize,The method has 5 parameters. Parameters: cache' mediator' propertyTable' ctrlAssistant' parentForm
Long Parameter List,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,Initialize,The method has 5 parameters. Parameters: cache' mediator' propertyTable' parentForm' sandboxMSA
Long Parameter List,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,SetDlgInfo,The method has 5 parameters. Parameters: cache' mediator' propertyTable' fs' owningFlid
Long Parameter List,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,SetDlgInfo,The method has 5 parameters. Parameters: cache' mediator' propertyTable' cobj' owningFlid
Long Parameter List,SIL.FieldWorks.LexText.Controls,MSAPopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAPopupTreeManager.cs,MSAPopupTreeManager,The method has 8 parameters. Parameters: treeCombo' cache' list' ws' useAbbr' mediator' propertyTable' parent
Long Parameter List,SIL.FieldWorks.LexText.Controls,MSAPopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAPopupTreeManager.cs,MSAPopupTreeManager,The method has 8 parameters. Parameters: popupTree' cache' list' ws' useAbbr' mediator' propertyTable' parent
Long Parameter List,SIL.FieldWorks.LexText.Controls,MasterCategoryListChooserLauncher,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAPopupTreeManager.cs,MasterCategoryListChooserLauncher,The method has 6 parameters. Parameters: popupMgrParent' mediator' propertyTable' possibilityList' fieldName' sense
Long Parameter List,SIL.FieldWorks.LexText.Controls,PopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,PopupTreeManager,The method has 8 parameters. Parameters: treeCombo' cache' mediator' propertyTable' list' ws' useAbbr' parent
Long Parameter List,SIL.FieldWorks.LexText.Controls,PopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,PopupTreeManager,The method has 8 parameters. Parameters: popupTree' cache' mediator' propertyTable' list' ws' useAbbr' parent
Long Parameter List,SIL.FieldWorks.LexText.Controls,PopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,Init,The method has 7 parameters. Parameters: cache' mediator' propertyTable' list' ws' useAbbr' parent
Long Parameter List,SIL.FieldWorks.LexText.Controls,PopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,AddNodes,The method has 5 parameters. Parameters: nodes' hvoOwner' flid' hvoTarget' tagName
Long Parameter List,SIL.FieldWorks.LexText.Controls,PopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,AddNodes,The method has 6 parameters. Parameters: nodes' hvoOwner' flid' flidSub' hvoTarget' tagName
Long Parameter List,SIL.FieldWorks.LexText.Controls,PossibilityListPopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,PossibilityListPopupTreeManager,The method has 8 parameters. Parameters: treeCombo' cache' mediator' propertyTable' list' ws' useAbbr' parent
Long Parameter List,SIL.FieldWorks.LexText.Controls,POSPopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\POSPopupTreeManager.cs,POSPopupTreeManager,The method has 8 parameters. Parameters: treeCombo' cache' list' ws' useAbbr' mediator' propertyTable' parent
Long Parameter List,SIL.FieldWorks.LexText.Controls,POSPopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\POSPopupTreeManager.cs,POSPopupTreeManager,The method has 8 parameters. Parameters: popupTree' cache' list' ws' useAbbr' mediator' propertyTable' parent
Long Parameter List,SIL.FieldWorks.XWorks.MorphologyEditor,PhonologicalFeaturePopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeaturePopupTreeManager.cs,PhonologicalFeaturePopupTreeManager,The method has 8 parameters. Parameters: treeCombo' cache' useAbbr' mediator' propertyTable' parent' wsDisplay' closedFeature
Long Parameter List,SIL.FieldWorks.LexText.Controls.DataNotebook,AnthroFieldMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\AnthroFieldMappingDlg.cs,Initialize,The method has 9 parameters. Parameters: cache' helpTopicProvider' app' rsf' sfmFile' mapFlidName' stylesheet' mediator' propertyTable
Long Parameter List,SIL.FieldWorks.LexText.Controls.DataNotebook,ImportCharMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ImportCharMappingDlg.cs,Initialize,The method has 5 parameters. Parameters: cache' helpTopicProvider' app' stylesheet' charMapping
Long Parameter List,SIL.FieldWorks.LexText.Controls.DataNotebook,ListRefFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ListRefFieldOptions.cs,Initialize,The method has 5 parameters. Parameters: cache' helpTopicProvider' app' rsfm' cpt
Long Parameter List,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,CreateNewPossibility,The method has 5 parameters. Parameters: rgsHier' factory' possList' map' rgNew
Long Parameter List,SIL.FieldWorks.LexText.Controls.DataNotebook,TextFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\TextFieldOptions.cs,Initialize,The method has 5 parameters. Parameters: cache' helpTopicProvider' app' stylesheet' rsfm
Long Identifier,SIL.FieldWorks.LexText.Controls,ConfigureHomographDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\ConfigureHomographDlg.cs,,The length of the parameter m_chkShowHomographNumInReversal is 31.
Long Identifier,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,PositionValuesCombo,The length of the parameter iValueLocationHorizontalOffset is 30.
Long Identifier,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetCmPossibilityListsObjectReferences,The length of the parameter cmPossibilityListsReferencedByFields is 36.
Long Identifier,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,AddPossListRefdByField,The length of the parameter cmPossibilityListsReferencedByFields is 36.
Long Identifier,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,MapCmPossibilityListGuidsToLiftRangeNames,The length of the parameter cmPossibilityListsReferencedByFields is 36.
Long Identifier,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,,The length of the parameter m_CmPossListsReferencedOrCustom is 31.
Long Identifier,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,,The length of the parameter m_rangeNamesToPossibilityListGuids is 34.
Long Identifier,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,,The length of the parameter m_CustomFieldNamesToPossibilityListGuids is 40.
Long Identifier,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,,The length of the parameter m_rgPendingCollectionRelations is 30.
Long Identifier,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,,The length of the parameter m_mapComplexFeatMissingTypeAbbr is 31.
Long Identifier,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,,The length of the parameter m_mapClosedFeatMissingValueAbbrs is 32.
Long Identifier,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,,The length of the parameter m_mapFeatStrucTypeMissingFeatureAbbrs is 37.
Long Identifier,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,,The length of the parameter lblMappingLanguagesInstructions is 31.
Long Identifier,SIL.FieldWorks.LexText.Controls,LinkVariantToEntryOrSense,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,,The length of the parameter m_fGetVariantEntryTypeFromTreeCombo is 35.
Long Identifier,SIL.FieldWorks.LexText.Controls,LinkVariantToEntryOrSense,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,,The length of the parameter m_fNewlyCreatedVariantEntryRef is 30.
Long Identifier,SIL.FieldWorks.LexText.Controls,FeatureSystemInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,PopulateTreeFromFeatureSystem,The length of the parameter topLevelComplexFeatureDefinitions is 33.
Long Identifier,SIL.FieldWorks.LexText.Controls,FeatureSystemInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,PopulateTreeFromFeatureSystem,The length of the parameter topLevelClosedFeatureDefinitions is 32.
Long Identifier,SIL.FieldWorks.LexText.Controls,FeatureSystemInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,PopulateTreeFromFeatureSystem,The length of the parameter typeUsedByComplexFormForThisClosedFeature is 41.
Long Identifier,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,,The length of the parameter lblMappingLanguagesInstructions is 31.
Long Statement,SIL.FieldWorks.LexText.Controls,AddAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddAllomorphDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AddAllomorphDlg)); " is 135.
Long Statement,SIL.FieldWorks.LexText.Controls,AddAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddAllomorphDlg.cs,InitializeComponent,The length of the statement  "			this.m_helpProvider.SetHelpNavigator(this' ((System.Windows.Forms.HelpNavigator)(resources.GetObject("$this.HelpNavigator")))); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,AddNewSenseDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddNewSenseDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AddNewSenseDlg)); " is 134.
Long Statement,SIL.FieldWorks.LexText.Controls,ConfigureHomographDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\ConfigureHomographDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ConfigureHomographDlg)); " is 141.
Long Statement,SIL.FieldWorks.LexText.Controls,ConfigureHomographDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\ConfigureHomographDlg.cs,InitializeComponent,The length of the statement  "			this.m_linkConfigHomographNumber.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.m_linkConfigHomographNumber_LinkClicked); " is 152.
Long Statement,SIL.FieldWorks.LexText.Controls,ConfigureHomographDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\ConfigureHomographDlg.cs,InitializeComponent,The length of the statement  "			this.m_linkConfigSenseRefNumber.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.m_linkConfigSenseRefNumber_LinkClicked); " is 150.
Long Statement,SIL.FieldWorks.LexText.Controls,OccurrenceDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\OccurrenceDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(OccurrenceDlg)); " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,PatternVcBase,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternVcBase.cs,AddExtraLines,The length of the statement  "				vwenv.set_IntProperty((int) FwTextPropType.ktptEditable' (int) FwTextPropVar.ktpvEnum' (int) TptEditable.ktptNotEditable); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,GetSelectionInfo,The length of the statement  "			sel.Selection.TextSelInfo(limit == SelectionHelper.SelLimitType.End' out curTss' out curIch' out prev' out curHvo' out curTag' out ws); " is 135.
Long Statement,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,GetSelectionInfo,The length of the statement  "			bool initial = limit == SelectionHelper.SelLimitType.Anchor ? !sel.Selection.EndBeforeAnchor : sel.Selection.EndBeforeAnchor; " is 125.
Long Statement,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,UpdateFeatureConstraints,The length of the statement  "					IPhFeatureConstraint removedConstr = RemoveFeatureConstraint(m_ctxt.PlusConstrRS' feat) ?? RemoveFeatureConstraint(m_ctxt.MinusConstrRS' feat); " is 143.
Long Statement,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,SetDlgInfo,The length of the statement  "			SetDlgInfo(cache' mediator' propertyTable' ctxt.FeatureStructureRA.Hvo' PhNCFeaturesTags.kflidFeatures' fs' rule' ctxt); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,SetHelpTopic,The length of the statement  "			m_helpProvider.SetHelpKeyword(this' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider").GetHelpString(helpTopic)); " is 128.
Long Statement,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,BuildInitialBrowseView,The length of the statement  "			m_bvList = new BrowseViewer(toolNode' m_cache.LangProject.Hvo' PhonologicalFeaturePublisher.ListFlid' m_cache' m_mediator' m_propertyTable' null' m_sda); " is 153.
Long Statement,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(PhonologicalFeatureChooserDlg)); " is 149.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertionControl,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertionControl.cs,UpdateOptionsDisplay,The length of the statement  "					var linkLabel = new LinkLabel {AutoSize = true' Font = new Font(MiscUtils.StandardSansSerif' 10)' TabStop = true' VisitedLinkColor = Color.Blue}; " is 145.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertionControl,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertionControl.cs,UpdateOptionsDisplay,The length of the statement  "					m_msgLabel = new GrowLabel {Font = new Font(MiscUtils.StandardSansSerif' 10)' Text = text' Width = m_insertPanel.ClientSize.Width}; " is 131.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertionControl,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertionControl.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(InsertionControl)); " is 136.
Long Statement,SIL.FieldWorks.LexText.Controls,SfmToTextsAndWordsMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\SfmToTextsAndWordsMappingBaseDlg.cs,SetupDlg,The length of the statement  "			addWritingSystemButton.Initialize(m_cache' helpTopicProvider' app' cache.ServiceLocator.WritingSystems.AllWritingSystems); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,SfmToTextsAndWordsMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\SfmToTextsAndWordsMappingBaseDlg.cs,LoadDestinations,The length of the statement  "			items.Insert(0' new DestinationItem() { Name = GetDestinationName(InterlinDestination.Ignored)' Dest = InterlinDestination.Ignored }); " is 134.
Long Statement,SIL.FieldWorks.LexText.Controls,SfmToTextsAndWordsMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\SfmToTextsAndWordsMappingBaseDlg.cs,m_okButton_Click,The length of the statement  "			m_mapping.WritingSystem = dest == InterlinDestination.Ignored ? null : ((CoreWritingSystemDefinition) m_writingSystemCombo.SelectedItem).Id; " is 140.
Long Statement,SIL.FieldWorks.LexText.Controls,SfmToTextsAndWordsMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\SfmToTextsAndWordsMappingBaseDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(SfmToTextsAndWordsMappingDlg)); " is 148.
Long Statement,SIL.FieldWorks.LexText.Controls,EntryGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\EntryGoDlg.cs,InitializeMatchingObjects,The length of the statement  "			SearchEngine searchEngine = SearchEngine.Get(m_mediator' m_propertyTable' "EntryGoSearchEngine"' () => new EntryGoSearchEngine(cache)); " is 135.
Long Statement,SIL.FieldWorks.LexText.Controls,EntryGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\EntryGoDlg.cs,InitializeMatchingObjects,The length of the statement  "			m_matchingObjectsBrowser.Initialize(cache' FontHeightAdjuster.StyleSheetFromPropertyTable(m_propertyTable)' m_mediator' m_propertyTable' configNode' " is 148.
Long Statement,SIL.FieldWorks.LexText.Controls,EntryGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\EntryGoDlg.cs,GetFields,The length of the statement  "				if (m_matchingObjectsBrowser.IsVisibleColumn("EntryHeadword") || m_matchingObjectsBrowser.IsVisibleColumn("CitationForm")) " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,EntryGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\EntryGoDlg.cs,GetFields,The length of the statement  "				if (m_matchingObjectsBrowser.IsVisibleColumn("EntryHeadword") || m_matchingObjectsBrowser.IsVisibleColumn("LexemeForm")) " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The length of the statement  "			List<int> vernList = cache.ServiceLocator.WritingSystems.CurrentVernacularWritingSystems.Select(wsObj => wsObj.Handle).ToList(); " is 128.
Long Statement,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The length of the statement  "				List<int> analList = cache.ServiceLocator.WritingSystems.CurrentAnalysisWritingSystems.Select(wsObj => wsObj.Handle).ToList(); " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(BaseGoDlg)); " is 129.
Long Statement,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,InitializeComponent,The length of the statement  "			this.m_matchingObjectsBrowser.SelectionChanged += new FwSelectionChangedEventHandler(this.m_matchingObjects_SelectionChanged); " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,InitializeComponent,The length of the statement  "			this.m_matchingObjectsBrowser.SelectionMade += new FwSelectionChangedEventHandler(this.m_matchingObjectsBrowser_SelectionMade); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertRecordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertRecordDlg.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + " ******************"); " is 140.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertRecordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertRecordDlg.cs,OnClosing,The length of the statement  "					UndoableUnitOfWorkHelper.Do(LexTextControls.ksUndoCreateRecord' LexTextControls.ksRedoCreateRecord' m_cache.ActionHandlerAccessor' () => " is 136.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertRecordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertRecordDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(InsertRecordDlg)); " is 135.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteLexEntryRef,The length of the statement  "			if (ler.ComplexEntryTypesRS.Count == 1 && ler.ComplexEntryTypesRS[0].Name.get_String(m_cache.WritingSystemFactory.GetWsFromStr("en")).Text == "BaseForm") " is 153.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteLexSense,The length of the statement  "				w.WriteLine("<trait name =\"{0}\" value=\"{1}\"/>"' RangeNames.sSemanticDomainListOA' MakeSafeAndNormalizedAttribute(val)); " is 123.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,ExportFile,The length of the statement  "				var pathWithoutExt = Path.Combine(Path.GetDirectoryName(safeWritePath)' Path.GetFileNameWithoutExtension(safeWritePath)); " is 121.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteMoStemMsa,The length of the statement  "				w.WriteLine("<trait name=\"{0}\" value=\"{1}\"/>"' RangeNames.sMSAinflectionFeature' MakeSafeAndNormalizedAttribute(msa.MsFeaturesOA.LiftName)); " is 144.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteMoInflAffMsa,The length of the statement  "				w.WriteLine("<trait name=\"{0}\" value=\"{1}\"/>"' RangeNames.sMSAinflectionFeature' MakeSafeAndNormalizedAttribute(msa.InflFeatsOA.LiftName)); " is 143.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteInternalRangeInformation,The length of the statement  "			w.WriteLine("<!-- The following ranges are produced by FieldWorks Language Explorer' and are not part of the LIFT standard. -->"); " is 130.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteInternalRangeInformation,The length of the statement  "			w.WriteLine("<!-- The parts of speech are duplicated in another range because derivational affixes require a \"From\" PartOfSpeech as well as a \"To\" PartOfSpeech. -->"); " is 171.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteInternalFieldInformation,The length of the statement  "			w.WriteLine("<form lang=\"en\"><text>This records the syllable pattern for a LexPronunciation in FieldWorks.</text></form>"); " is 125.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteInternalFieldInformation,The length of the statement  "			w.WriteLine("<form lang=\"en\"><text>This records the tone information for a LexPronunciation in FieldWorks.</text></form>"); " is 125.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteInternalFieldInformation,The length of the statement  "			w.WriteLine("<form lang=\"en\"><text>This records residue left over from importing a standard format file into FieldWorks (or LinguaLinks).</text></form>"); " is 156.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteInternalFieldInformation,The length of the statement  "			w.WriteLine("<form lang=\"en\"><text>This field is used to store a literal meaning of the entry.  Typically' this field is necessary only for a compound or an idiom where the meaning of the whole is different from the sum of its parts.</text></form>"); " is 252.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteInternalFieldInformation,The length of the statement  "			w.WriteLine("<form lang=\"en\"><text>A summary definition (located at the entry level in the Entry pane) is a general definition summarizing all the senses of a primary entry. It has no theoretical value; its use is solely pragmatic.</text></form>"); " is 250.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteInternalFieldInformation,The length of the statement  "			w.WriteLine("<form lang=\"en\"><text>This field stores the scientific name pertinent to the current sense.</text></form>"); " is 123.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetCustomFieldDefinition,The length of the statement  "				Debug.Assert(!String.IsNullOrEmpty(wsInternalName)' "There is an invalid magic writing system value being exported. It should be between -1 and -6. "); " is 151.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetProperty,The length of the statement  "				throw new ConfigurationException("There is no public property named '" + property + "' in " + type + ". Remember' properties often end in a two-character suffix such as OA'OS'RA' or RS."); " is 188.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetProperty,The length of the statement  "				throw new ApplicationException(String.Format("There was an error while trying to get the property {0}. One thing that has caused this in the past has been a database which was not migrated properly."' property)' error); " is 219.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteAnyOtherRangesReferencedByFields,The length of the statement  "				w.WriteLine("<!-- This is a custom list or other list which is not output by default but if referenced in the data of a field.  -->"); " is 134.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteEtymologyRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>The word is borrowed from another language</text></form></description>"); " is 123.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteEtymologyRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>The proto form of the word in another language</text></form></description>"); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteGrammaticalInfoRange,The length of the statement  "			w.WriteLine("<!-- These are all the parts of speech in the FLEx db' used or unused.  These are used as the basic grammatical-info values. -->"); " is 144.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteNoteTypeRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>This note is an arbitrary comment not for publication</text></form></description>"); " is 134.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteNoteTypeRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>Gives discourse information about a sense.</text></form></description>"); " is 123.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteNoteTypeRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>This note gives encyclopedic information.</text></form></description>"); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteNoteTypeRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>General notes that do not fall in another clear category</text></form></description>"); " is 137.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteNoteTypeRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>Gives grammatical information about a word.</text></form></description>"); " is 124.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteNoteTypeRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>Gives phonological information about a word.</text></form></description>"); " is 125.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteNoteTypeRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>Gives information on the restriction of usage of a word.</text></form></description>"); " is 137.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteNoteTypeRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>Gives sociolinguistic information about a sense.</text></form></description>"); " is 129.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteNoteTypeRange,The length of the statement  "			w.WriteLine("<description><form lang=\"en\"><text>Gives semantic information about a sense.</text></form></description>"); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteSemanticDomainRange,The length of the statement  "			if (m_cache.LangProject.SemanticDomainListOA == null || m_cache.LangProject.SemanticDomainListOA.PossibilitiesOS.Count == 0) " is 124.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteExceptionFeatureRange,The length of the statement  "			WritePossibilityListAsRange(w' RangeNames.sProdRestrictOA' m_cache.LangProject.MorphologicalDataOA.ProdRestrictOA' null); " is 121.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteFromPartsOfSpeechRange,The length of the statement  "			w.WriteLine("<!-- The parts of speech are duplicated in another range because derivational affixes require a \"From\" PartOfSpeech as well as a \"To\" PartOfSpeech. -->"); " is 171.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateLexRefType,The length of the statement  "					// If we make a new LRT with a different guid' anything that references it in the file will point at the wrong object (of the wrong type). " is 138.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateLexRefType,The length of the statement  "					throw new ApplicationException(string.Format("input file expects object {0} to be a LexRefType' but it is a {1}"' guid' match.GetType().Name)); " is 143.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ListCombinedCollections,The length of the statement  "			writer.WriteLine("<th width=\"17%\">{0}</th>"' LexTextControls.ksAddedItem); //column header for items added in combining two collections during lift merge " is 155.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessCustomListRangeElement,The length of the statement  "			ProcessPossibility(id' guidAttr' parent' MakeSafeLiftMultiText(description)' MakeSafeLiftMultiText(label)' MakeSafeLiftMultiText(abbrev)' " is 137.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessRangeElement,The length of the statement  "					ProcessPerson(id' guidAttr' parent' newDesc' newLabel' newAbbrev' m_dictPerson' m_rgnewPerson' m_cache.LangProject.PeopleOA); " is 125.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexRefType,The length of the statement  "			// If the guid and parent are both null this is probably a 'default' lexical-relation' we won't bother trying to create it " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,NoteMigration,The length of the statement  "					m_writingsytemChangeMap[RemoveMultipleX(info.LanguageTagBeforeMigration.ToLowerInvariant())] = info.LanguageTagAfterMigration; " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeStringsFromLiftContents,The length of the statement  "					else if (liftString.Text.Normalize() != ourString.Text.Normalize()) // ignore the very unlikely case of more subtle differences we can't report " is 143.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeStringsFromLiftContents,The length of the statement  "						// Fairly typically this is called more than once on the same object...not quite sure why. Simplest thing is not to make " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,AppendXmlDateAttributes,The length of the statement  "				bldr.AppendFormat(" dateCreated=\"{0}\""' ConvertToSafeFieldXmlContent(created.ToUniversalTime().ToString(LiftDateTimeFormat))); " is 128.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,AppendXmlDateAttributes,The length of the statement  "				bldr.AppendFormat(" dateModified=\"{0}\""' ConvertToSafeFieldXmlContent(modified.ToUniversalTime().ToString(LiftDateTimeFormat))); " is 130.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateCustomField,The length of the statement  "						// Fieldworks knows about a field with this label' but the file doesn't. Assume the project's definition of it is valid. " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessPendingRelations,The length of the statement  "			// Collection of the lexical references from before the import. Items remaining here may be removed for MergeStyle.MsKeepOnlyNew " is 128.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessPendingRelations,The length of the statement  "				GatherUnwantedObjects(originalLexEntryRefs' originalLexRefs); //at this point any LexRefs which haven't been matched are dead. " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,StorePendingLexEntryRefs,The length of the statement  "					bldr.Append("The LIFT file you are importing has entries with 'Component' or 'Variant' references to lexical entries that "); " is 125.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,StorePendingLexEntryRefs,The length of the statement  "					bldr.Append("This is probably a result of doing a Filtered Lexicon LIFT export. Instead' a Full Lexicon LIFT export should been done "); " is 136.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexEntryRefs,The length of the statement  "					//in the lexEntry might be referencing another lexEntry that was not part of the export. In this case Target will be null. " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexEntryRefs,The length of the statement  "					//If there is a partial LIFT export "Filtered Lexicon LIFT 0.13 XML" we can encounter a LexEntryRef that has a null target. " is 123.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexEntryRefs,The length of the statement  "					//However' for a partial export where'un-' 'believe' and '-ing' are not included in the export' the reference	s to these found in " is 129.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexEntryRefs,The length of the statement  "					//We should however warn the user that this data is not being imported and that they should do a FULL export to ensure this data " is 128.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexEntryRefs,The length of the statement  "			if (complexEntryTypes.Count == 0 && variantEntryTypes.Count == 0 && rgRefs[0].RelationType == "BaseForm" && componentLexemes.Count == 1 " is 135.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexEntryRefs,The length of the statement  "						bldr.AppendFormat("CmLiftEntry.LexicalForm is:    {0}"' XmlUtils.DecodeXml(rgRefs[0].LexemeForm.FirstValue.Value.Text)); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,AdjustCollectionContents,The length of the statement  "									 lexEntryRef.VariantEntryTypesRS.Count == 0 ? LexTextControls.ksComplexFormType : LexTextControls.ksVariantType' lexEntryRef.Owner); " is 131.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,AdjustCollectionContents,The length of the statement  "				if(!complexEntryTypes.ContainsCollection(referenceCollection) && !referenceCollection.ContainsCollection(complexEntryTypes)) " is 124.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,StoreLexReference,The length of the statement  "					StoreAsymmetricPairRelations(refsAsYetUnmatched' lrt' rgRelation' ObjectIsFirstInRelation(rgRelation[0].RelationType' lrt)); " is 124.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindLexRefType,The length of the statement  "				//This section is for older lift files where the type information wasn't written out well enough' new files will work better' but this is better than nothing " is 157.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,StorePendingCollectionRelations,The length of the statement  "			progress.Message = string.Format(LexTextControls.ksSettingCollectionRelationLinks' m_rgPendingCollectionRelations.Count); " is 121.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,TreeRelationAlreadyExists,The length of the statement  "							relationsBeforeAdditions.Remove(pendingObj); // The pending relation wasn't for this LexRef' so don't store pendingObj for removal " is 130.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,TreeRelationAlreadyExists,The length of the statement  "						// Skipping the removal of an unusedObject when the Hvo matches the CmObject that owns the relations prevents removing the head " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CreateNewLexRefType,The length of the statement  "													 m_cache.ServiceLocator.GetAllInstances<ILexRefType>().FirstOrDefault(x => x.Guid.ToString().ToLowerInvariant() == cleanOwner)); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CreateLiftFieldFromXml,The length of the statement  "				throw new LiftFormatException(String.Format("Field with same type ({0}) as sibling not allowed. Context:{1}"' fieldType' node.ParentNode.OuterXml)); " is 148.
Long Statement,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeLexemeForm,The length of the statement  "					string form = Icu.Normalize(XmlUtils.DecodeXml(entry.LexicalForm.FirstValue.Value.Text)' Icu.UNormalizationMode.UNORM_NFD); " is 123.
Long Statement,SIL.FieldWorks.LexText.Controls,RecordGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\RecordGoDlg.cs,InitializeMatchingObjects,The length of the statement  "			SearchEngine searchEngine = SearchEngine.Get(m_mediator' m_propertyTable' "RecordGoSearchEngine"' () => new RecordGoSearchEngine(cache)); " is 137.
Long Statement,SIL.FieldWorks.LexText.Controls,RecordGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\RecordGoDlg.cs,InitializeMatchingObjects,The length of the statement  "			m_matchingObjectsBrowser.Initialize(cache' FontHeightAdjuster.StyleSheetFromPropertyTable(m_propertyTable)' m_mediator' m_propertyTable' configNode' " is 148.
Long Statement,SIL.FieldWorks.LexText.Controls,RecordGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\RecordGoDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(RecordGoDlg)); " is 131.
Long Statement,SIL.FieldWorks.LexText.Controls,RecordGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\RecordGoDlg.cs,InitializeComponent,The length of the statement  "			this.m_helpProvider.SetHelpNavigator(this' ((System.Windows.Forms.HelpNavigator)(resources.GetObject("$this.HelpNavigator")))); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,FeatureStructureTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\FeatureStructureTreeView.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FeatureStructureTreeView)); " is 144.
Long Statement,SIL.FieldWorks.LexText.Controls,FeatureStructureTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\FeatureStructureTreeView.cs,InitializeComponent,The length of the statement  "			this.imageList1.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("imageList1.ImageStream"))); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftImportDlg.cs,ImportLIFT,The length of the statement  "						Path.ChangeExtension(Path.GetFileName(sFilename)' "." + Validator.LiftVersion + FwFileExtensions.ksLexiconInterchangeFormat)); " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,LiftImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftImportDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LiftImportDlg)); " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The length of the statement  "				SearchEngine searchEngine = SearchEngine.Get(m_mediator' m_propertyTable' "InsertEntrySearchEngine"' () => new InsertEntrySearchEngine(cache)); " is 143.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The length of the statement  "				var rgComplexTypes = new List<ICmPossibility>(m_cache.LangProject.LexDbOA.ComplexEntryTypesOA.ReallyReallyAllPossibilities.ToArray()); " is 134.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The length of the statement  "				foreach (IMoMorphType mType in m_cache.LanguageProject.LexDbOA.MorphTypesOA.ReallyReallyAllPossibilities.Cast<IMoMorphType>()) " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The length of the statement  "				m_searchAnimation.Top = m_matchingEntriesGroupBox.Top + (m_matchingEntriesGroupBox.Height / 2) - (m_searchAnimation.Height / 2); " is 128.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The length of the statement  "				m_searchAnimation.Left = m_matchingEntriesGroupBox.Left + (m_matchingEntriesGroupBox.Width / 2) - (m_searchAnimation.Width / 2); " is 128.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The length of the statement  "			SetDlgInfo(cache' cache.ServiceLocator.GetInstance<IMoMorphTypeRepository>().GetObject(MoMorphTypeTags.kguidMorphStem)); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,BuildSearchFieldArray,The length of the statement  "			if(m_matchingObjectsBrowser.IsVisibleColumn("EntryHeadword") || m_matchingObjectsBrowser.IsVisibleColumn("CitationForm")) " is 121.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,BuildSearchFieldArray,The length of the statement  "			if (m_matchingObjectsBrowser.IsVisibleColumn("EntryHeadword") || m_matchingObjectsBrowser.IsVisibleColumn("LexemeForm")) " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(InsertEntryDlg)); " is 134.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,InitializeComponent,The length of the statement  "			this.m_imageList.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("m_imageList.ImageStream"))); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,InitializeComponent,The length of the statement  "			this.m_matchingObjectsBrowser.SelectionChanged += new FwSelectionChangedEventHandler(this.m_matchingObjectsBrowser_SelectionChanged); " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,InitializeComponent,The length of the statement  "			this.m_matchingObjectsBrowser.SelectionMade += new FwSelectionChangedEventHandler(this.m_matchingObjectsBrowser_SelectionMade); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,InitializeComponent,The length of the statement  "			this.m_lnkAssistant.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.lnkAssistant_LinkClicked); " is 124.
Long Statement,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,lnkAssistant_LinkClicked,The length of the statement  "					dlg = new MGAHtmlHelpDialog(m_cache' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' m_tbLexicalForm.Text); " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,Init,The length of the statement  "			m_CustomFields = ReadCustomFieldsFromDB(out customFieldsChanged);	// compare with map file before showing the UI and before the Import " is 134.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,GetCustomFieldHelp,The length of the statement  "			else if (fd.Type == CellarPropertyType.GenDate || fd.Type == CellarPropertyType.Numeric || fd.Type == CellarPropertyType.Integer) " is 129.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnAddMappingLanguage_Click,The length of the statement  "			using (var dlg = new LexImportWizardLanguage(m_cache' langDescs' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' m_app)) " is 139.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnModifyContentMapping_Click,The length of the statement  "			// make sure the display is made correct by compairing to the memory list (could have deleted custom fields that were ref'd) " is 124.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,listViewContentMapping_ColumnClick,The length of the statement  "			listViewContentMapping.ListViewItemSorter = new MarkerPresenter.ListViewItemComparer(e.Column' // ListViewItemComparer(e.Column' " is 128.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,SaveNewMapFile,The length of the statement  "			System.Collections.Generic.List<Sfm2Xml.FieldHierarchyInfo> sfmInfo = new System.Collections.Generic.List<Sfm2Xml.FieldHierarchyInfo>(); " is 136.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,SaveNewMapFile,The length of the statement  "			System.Collections.Generic.List<Sfm2Xml.ClsInFieldMarker> ifMarker = new System.Collections.Generic.List<Sfm2Xml.ClsInFieldMarker>(); " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,SaveNewMapFile,The length of the statement  "			Sfm2Xml.STATICS.NewMapFileBuilder(uiLangsNew' m_LexFields' m_CustomFields' sfmInfo' ifMarker' m_SaveAsFileName.Text' options); " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,UpdateIfInputFileContentsChanged,The length of the statement  "					m_lastDateTime = System.IO.File.GetLastWriteTime(m_processedInputFile);	// used to keep track of the last write date on the data file " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,EnableNextButton,The length of the statement  "						m_lastDateTime = System.IO.File.GetLastWriteTime(m_processedInputFile);	// used to keep track of the last write date on the data file " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LexImportWizard)); " is 135.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The length of the statement  "			this.listViewMappingLanguages.ColumnClick += new System.Windows.Forms.ColumnClickEventHandler(this.listViewMappingLanguages_ColumnClick); " is 137.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The length of the statement  "			this.listViewMappingLanguages.SelectedIndexChanged += new System.EventHandler(this.listViewMappingLanguages_SelectedIndexChanged); " is 130.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The length of the statement  "			this.listViewContentMapping.ColumnClick += new System.Windows.Forms.ColumnClickEventHandler(this.listViewContentMapping_ColumnClick); " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The length of the statement  "			this.listViewContentMapping.SelectedIndexChanged += new System.EventHandler(this.listViewContentMapping_SelectedIndexChanged); " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The length of the statement  "			this.listViewCharMappings.SelectedIndexChanged += new System.EventHandler(this.listViewCharMappings_SelectedIndexChanged); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The length of the statement  "			this.tvBeginMarkers.BeforeCollapse += new System.Windows.Forms.TreeViewCancelEventHandler(this.tvBeginMarkers_BeforeCollapse); " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The length of the statement  "			this.imageList1.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("imageList1.ImageStream"))); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnAddCharMapping_Click,The length of the statement  "			using (var dlg = new LexImportWizardCharMarkerDlg(m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' m_app' m_stylesheet)) " is 138.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnModifyCharMapping_Click,The length of the statement  "			using (var dlg = new LexImportWizardCharMarkerDlg(m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' m_app' m_stylesheet)) " is 138.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizardCharMarkerDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardCharMarkerDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LexImportWizardCharMarkerDlg)); " is 148.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizardCharMarkerDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardCharMarkerDlg.cs,ValidateBeginMarkerText,The length of the statement  "			isValidBeginMarker = !(marker.Length == 0 || m_existingBeginMarkers.ContainsKey(marker) || m_existingEndMarkers.ContainsKey(marker)); " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,MarkerPresenter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,UpdateLexFieldsWithCustomFields,The length of the statement  "			string sImportFields = sRootDir + String.Format("Language Explorer{0}Import{0}ImportFields.xml"' Path.DirectorySeparatorChar); " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,MarkerPresenter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,MergeData,The length of the statement  "						Sfm2Xml.ILexImportCustomField licf = m_LexFields.GetCustomField(startMapFieldData as Sfm2Xml.ClsCustomFieldDescription); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,MarkerPresenter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,MergeData,The length of the statement  "					ContentMapping uiData = new ContentMapping(marker' desc' className' dest' ws' langDesc' count' order' startMapFieldData' isCustom); " is 131.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizardLanguage,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardLanguage.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LexImportWizardLanguage)); " is 143.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,Init,The length of the statement  "			if (currentMarker.Exclude)// currentMarker.IsLangIgnore || // currentMarker.DestinationField == MarkerPresenter.ContentMapping.Ignore() || " is 138.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LexImportWizardMarker)); " is 141.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,InitializeComponent,The length of the statement  "			this.tvDestination.BeforeSelect += new System.Windows.Forms.TreeViewCancelEventHandler(this.tvDestination_BeforeSelect); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,InitBottomPanel,The length of the statement  "			string sXsltFile = Path.Combine(FwDirectoryFinder.CodeDirectory' @"Language Explorer/Import/ImportFieldsHelpToHtml.xsl"); " is 121.
Long Statement,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,btnOK_Click,The length of the statement  "					MessageBox.Show("You must select a '"+labelText+"' item or enter a new one to continue."' "Missing information"' MessageBoxButtons.OK' MessageBoxIcon.Stop); " is 156.
Long Statement,SIL.FieldWorks.LexText.Controls,LexOptionsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexOptionsDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LexOptionsDlg)); " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,LexReferenceDetailsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexReferenceDetailsDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LexReferenceDetailsDlg)); " is 142.
Long Statement,SIL.FieldWorks.LexText.Controls,Sfm2FlexTextWordsFrag,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\Sfm2FlexTextWords.cs,WriteToDocElement,The length of the statement  "					// (For AdaptIt Knowledge Base sfm) it is okay to add more than one "gls" with same writing system to word parent element " is 121.
Long Statement,SIL.FieldWorks.LexText.Controls,LinkAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkAllomorphDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LinkAllomorphDlg)); " is 136.
Long Statement,SIL.FieldWorks.LexText.Controls,LinkAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkAllomorphDlg.cs,InitializeComponent,The length of the statement  "			this.m_helpProvider.SetHelpNavigator(this' ((System.Windows.Forms.HelpNavigator)(resources.GetObject("$this.HelpNavigator")))); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,LinkEntryOrSenseDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkEntryOrSenseDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LinkEntryOrSenseDlg)); " is 139.
Long Statement,SIL.FieldWorks.LexText.Controls,LinkEntryOrSenseDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkEntryOrSenseDlg.cs,InitializeComponent,The length of the statement  "			this.m_helpProvider.SetHelpNavigator(this' ((System.Windows.Forms.HelpNavigator)(resources.GetObject("$this.HelpNavigator")))); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,LinkMSADlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkMSADlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LinkMSADlg)); " is 130.
Long Statement,SIL.FieldWorks.LexText.Controls,LinkMSADlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkMSADlg.cs,InitializeComponent,The length of the statement  "			this.m_helpProvider.SetHelpNavigator(this' ((System.Windows.Forms.HelpNavigator)(resources.GetObject("$this.HelpNavigator")))); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,LinkVariantToEntryOrSense,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,m_btnInsert_Click,The length of the statement  "			UndoableUnitOfWorkHelper.Do(LexTextControls.ksUndoCreateVarEntry' LexTextControls.ksRedoCreateVarEntry' m_startingEntry' () => " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,LinkVariantToEntryOrSense,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LinkVariantToEntryOrSense)); " is 145.
Long Statement,SIL.FieldWorks.LexText.Controls,LinkVariantToEntryOrSense,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,InitializeComponent,The length of the statement  "			this.m_helpProvider.SetHelpNavigator(this' ((System.Windows.Forms.HelpNavigator)(resources.GetObject("$this.HelpNavigator")))); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterCategoryListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterCategoryListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MasterCategoryListDlg)); " is 141.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterCategoryListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,InitializeComponent,The length of the statement  "			this.m_tvMasterList.BeforeCheck += new System.Windows.Forms.TreeViewCancelEventHandler(this.m_tvMasterList_BeforeCheck); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterCategoryListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,InitializeComponent,The length of the statement  "			this.m_imageList.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("m_imageList.ImageStream"))); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterCategoryListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,InitializeComponent,The length of the statement  "			this.m_imageListPictures.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("m_imageListPictures.ImageStream"))); " is 138.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterCategory,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,Create,The length of the statement  "					<def ws="en">An adjective is a part of speech whose members modify nouns. An adjective specifies the attributes of a noun referent. Note: this is one case among many. Adjectives are a class of modifiers.</def> " is 209.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterListDlg.cs,SetDlginfo,The length of the statement  "			string sXmlFile = Path.Combine(FwDirectoryFinder.CodeDirectory' String.Format("Language Explorer{0}MGA{0}GlossLists{0}EticGlossList.xml"' Path.DirectorySeparatorChar)); " is 168.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterListDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MasterListDlg)); " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterListDlg.cs,InitializeComponent,The length of the statement  "			this.m_tvMasterList.BeforeCheck += new System.Windows.Forms.TreeViewCancelEventHandler(this.m_tvMasterList_BeforeCheck); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterListDlg.cs,InitializeComponent,The length of the statement  "			this.m_imageList.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("m_imageList.ImageStream"))); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterListDlg.cs,InitializeComponent,The length of the statement  "			this.m_imageListPictures.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("m_imageListPictures.ImageStream"))); " is 138.
Long Statement,SIL.FieldWorks.LexText.Controls,MasterPhonologicalFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterPhonologicalFeatureListDlg.cs,linkLabel1_LinkClicked,The length of the statement  "			UndoableUnitOfWorkHelper.Do(LexTextControls.ksUndoInsertPhonologicalFeature' LexTextControls.ksRedoInsertPhonologicalFeature' " is 125.
Long Statement,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,InitializeMatchingObjects,The length of the statement  "			var searchEngine = (MergeEntrySearchEngine)SearchEngine.Get(m_mediator' m_propertyTable' "MergeEntrySearchEngine"' () => new MergeEntrySearchEngine(cache)); " is 156.
Long Statement,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,InitializeMatchingObjects,The length of the statement  "			m_matchingObjectsBrowser.Initialize(cache' FontHeightAdjuster.StyleSheetFromPropertyTable(m_propertyTable)' m_mediator' m_propertyTable' configNode' " is 148.
Long Statement,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MergeEntryDlg)); " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,InitializeComponent,The length of the statement  "			this.m_helpProvider.SetHelpNavigator(this' ((System.Windows.Forms.HelpNavigator)(resources.GetObject("$this.HelpNavigator")))); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,MsaCreatorDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaCreatorDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MsaCreatorDlg)); " is 133.
Long Statement,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MSAGroupBox)); " is 131.
Long Statement,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,HandleComboSlotChange,The length of the statement  "			m_selectedSlot = (selItem == null) ? null : m_cache.ServiceLocator.GetInstance<IMoInflAffixSlotRepository>().GetObject(selItem.Hvo); " is 132.
Long Statement,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MsaInflectionFeatureListDlg)); " is 147.
Long Statement,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,InitializeComponent,The length of the statement  "			this.m_imageList.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("m_imageList.ImageStream"))); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,InitializeComponent,The length of the statement  "			this.m_imageListPictures.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("m_imageListPictures.ImageStream"))); " is 138.
Long Statement,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,BuildFeatureStructure,The length of the statement  "						fs.TypeRA = m_cache.LanguageProject.MsFeatureSystemOA.TypesOC.SingleOrDefault(type => type.FeaturesRS.Contains(complexFeat)); " is 125.
Long Statement,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,BuildFeatureStructure,The length of the statement  "						fs.TypeRA = m_cache.LanguageProject.MsFeatureSystemOA.TypesOC.FirstOrDefault(type => type.FeaturesRS.Contains(closedFeat)); " is 123.
Long Statement,SIL.FieldWorks.LexText.Controls,MSAPopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAPopupTreeManager.cs,MakeMenuItems,The length of the statement  "					popupTree.Nodes.Add(new HvoTreeNode(TsStringUtils.MakeString(m_sSpecifyGramFunc' Cache.WritingSystemFactory.UserWs)' kCreate)); " is 127.
Long Statement,SIL.FieldWorks.LexText.Controls,MSAPopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAPopupTreeManager.cs,MakeMenuItems,The length of the statement  "						popupTree.Nodes.Add(new HvoTreeNode(TsStringUtils.MakeString(m_sModifyGramFunc' Cache.WritingSystemFactory.UserWs)' kModify)); " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls,MSAPopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAPopupTreeManager.cs,MakeMenuItems,The length of the statement  "					popupTree.Nodes.Add(new HvoTreeNode(TsStringUtils.MakeString(m_sSpecifyDifferent' Cache.WritingSystemFactory.UserWs)' kCreate)); " is 128.
Long Statement,SIL.FieldWorks.LexText.Controls,PopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls,PopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,AddMoreItem,The length of the statement  "			popupTree.Nodes.Add(new HvoTreeNode(TsStringUtils.MakeString(LexTextControls.ksMore_' Cache.WritingSystemFactory.UserWs)' kMore)); " is 130.
Long Statement,SIL.FieldWorks.LexText.Controls,PopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,AddNotSureItem,The length of the statement  "			HvoTreeNode empty = new HvoTreeNode(TsStringUtils.MakeString(LexTextControls.ks_NotSure_' Cache.WritingSystemFactory.UserWs)' kEmpty); " is 134.
Long Statement,SIL.FieldWorks.XWorks.MorphologyEditor,PhonologicalFeaturePopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeaturePopupTreeManager.cs,m_treeCombo_AfterSelect,The length of the statement  "						Cache.DomainDataByFlid.BeginUndoTask(LexTextControls.ksUndoInsertPhonologicalFeature' LexTextControls.ksRedoInsertPhonologicalFeature); " is 135.
Long Statement,SIL.FieldWorks.XWorks.MorphologyEditor,PhonologicalFeaturePopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeaturePopupTreeManager.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,AnthroFieldMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\AnthroFieldMappingDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AnthroFieldMappingDlg)); " is 141.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,DiscardOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\DiscardOptions.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(DiscardOptions)); " is 134.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,ImportCharMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ImportCharMappingDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ImportCharMappingDlg)); " is 140.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,ImportDateFormatDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ImportDateFormatDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ImportDateFormatDlg)); " is 139.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,ImportEncCvtrDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ImportEncCvtrDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ImportEncCvtrDlg)); " is 136.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,ImportMatchReplaceDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ImportMatchReplaceDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ImportMatchReplaceDlg)); " is 141.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,ListRefFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ListRefFieldOptions.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ListRefFieldOptions)); " is 139.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,ListRefFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ListRefFieldOptions.cs,InitializeComponent,The length of the statement  "			this.m_btnAddWritingSystem.WritingSystemAdded += new System.EventHandler(this.m_btnAddWritingSystem_WritingSystemAdded); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,StringFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\StringFieldOptions.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(StringFieldOptions)); " is 138.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,StringFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\StringFieldOptions.cs,InitializeComponent,The length of the statement  "			this.m_btnAddWritingSystem.WritingSystemAdded += new System.EventHandler(this.m_btnAddWritingSystem_WritingSystemAdded); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,WriteHtmlJavaScript,The length of the statement  "			//var isNetscape = typeof window != 'undefined' && typeof window.netscape != 'undefined' && typeof window.netscape.security != 'undefined' && typeof window.opera != 'object'; " is 174.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,WriteHtmlJavaScript,The length of the statement  "			//                var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile); " is 128.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,WriteHtmlJavaScript,The length of the statement  "			//                var process = Components.classes["@mozilla.org/process/util;1"].createInstance(Components.interfaces.nsIProcess); " is 131.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(NotebookImportWiz)); " is 137.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,InitializeComponent,The length of the statement  "			this.m_lvContentMapping.SelectedIndexChanged += new System.EventHandler(this.listViewContentMapping_SelectedIndexChanged); " is 122.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,InitializeComponent,The length of the statement  "			this.m_btnAddWritingSystem.WritingSystemAdded += new System.EventHandler(this.m_btnAddWritingSystem_WritingSystemAdded); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,InitializeComponent,The length of the statement  "			this.m_lvMappingLanguages.SelectedIndexChanged += new System.EventHandler(this.listViewMappingLanguages_SelectedIndexChanged); " is 126.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,TextFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\TextFieldOptions.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(TextFieldOptions)); " is 136.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,TextFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\TextFieldOptions.cs,InitializeComponent,The length of the statement  "			this.m_btnAddWritingSystem.WritingSystemAdded += new System.EventHandler(this.m_btnAddWritingSystem_WritingSystemAdded); " is 120.
Long Statement,SIL.FieldWorks.LexText.Controls.DataNotebook,DateFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\DateFieldOptions.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(DateFieldOptions)); " is 136.
Complex Conditional,SIL.FieldWorks.LexText.Controls,AddAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddAllomorphDlg.cs,HandleMatchingSelectionChanged,The conditional expression  "mtOrig != null && mf.MorphTypeRA != null &&  						(m_hvoType == mf.MorphTypeRA.Hvo ||  						 mtOrig.IsAmbiguousWith(mf.MorphTypeRA))"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,AdjustSelection,The conditional expression  "wholeHvo != curHvo || wholeEndHvo != curEndHvo || wholeIch != curIch || wholeEndIch != curEndIch  					|| wholeTag != curTag || wholeEndTag != curEndTag"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,GetSelectionInfo,The conditional expression  "(curHvo == initialHvo && curIch == initialIch && curTag == initialTag)  				|| (curIch == 0 && curTag == PatternVcBase.ktagLeftBoundary)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,GetSelectionInfo,The conditional expression  "(curHvo == finalHvo && curIch == finalIch && curTag == finalTag)  					|| (curIch == curTss.Length && curTag == PatternVcBase.ktagRightBoundary)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,RangeNames,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,RangeNameIsCustomList,The conditional expression  "range.EndsWith("-slot") || range.EndsWith("-Slots") ||  						range.EndsWith("-infl-class") || range.EndsWith("-InflClasses") ||  						range.EndsWith("-feature-value") || range.EndsWith("-stem-name")"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CreateRelationResidue,The conditional expression  "rel.Usage != null || rel.Fields.Count > 0 || rel.Traits.Count > 0 ||  				rel.Annotations.Count > 0"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,StoreResidueFromVariant,The conditional expression  "!String.IsNullOrEmpty(var.RawXml) &&  					String.IsNullOrEmpty(var.Ref) &&  					var.Pronunciations.Count == 0 &&  					var.Relations.Count == 0"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CollectLexEntryRefMembers,The conditional expression  "pend.ObjectHvo != hvo || pend.EntryType != sEntryType ||  					pend.MinorEntryCondition != sMinorEntryCondition ||  					pend.DateCreated != dateCreated || pend.DateModified != dateModified"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessLexEntryRefs,The conditional expression  "complexEntryTypes.Count == 0 && variantEntryTypes.Count == 0 && rgRefs[0].RelationType == "BaseForm" && componentLexemes.Count == 1  				&& primaryLexemes.Count == 0"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,DetermineLexEntryTypes,The conditional expression  "sub != null &&  									(sub.Name.AnalysisDefaultWritingSystem.Text == sOldCondition ||  									 sub.Abbreviation.AnalysisDefaultWritingSystem.Text == sOldCondition ||  									 sub.ReverseAbbr.AnalysisDefaultWritingSystem.Text == sOldCondition)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,PairRelationAlreadyExists,The conditional expression  "(hvoA == hvo1 && hvoB == hvo2) || (hvoA == hvo2 && hvoB == hvo1)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CollectRelationMembers,The conditional expression  "pend.ObjectHvo != hvo || pend.RelationType != sType ||  					pend.DateCreated != dateCreated || pend.DateModified != dateModified ||  					pend.Residue != sResidue"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,DeleteOrphans,The conditional expression  "mb.Form.StringCount == 0 && mb.MorphRA == null && mb.MsaRA == null && mb.SenseRA == null"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FillInExtensibleElementsFromRawXml,The conditional expression  "rawXml.IndexOf("<trait") > 0 ||  				rawXml.IndexOf("<field") > 0 ||  				rawXml.IndexOf("<annotation") > 0 ||  				(obj is CmLiftRelation && rawXml.IndexOf("order=") > 0)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessEntryMorphType,The conditional expression  "le.LexemeFormOA.MorphTypeRA != mmt &&  				(m_fCreatingNewEntry || m_msImport != MergeStyle.MsKeepOld || le.LexemeFormOA.MorphTypeRA == null)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessPronunciationFieldsAndTraits,The conditional expression  "pron.LocationRA != loc && (m_fCreatingNewEntry || m_msImport != MergeStyle.MsKeepOld ||  							pron.LocationRA == null)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessEtymologyFieldsAndTraits,The conditional expression  "!ety.LanguageRS.Any(l => l == lang) &&  							(m_fCreatingNewEntry || m_msImport != MergeStyle.MsKeepOld || !ety.LanguageRS.Any())"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindExampleSentence,The conditional expression  "(expl.Content == null || expl.Content.IsEmpty) &&  					(les.Example == null || les.Example.BestVernacularAnalysisAlternative.Equals(les.Example.NotFoundTss))"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MergeExampleTranslations,The conditional expression  "type != null &&  					ct.TypeRA != type &&  					(m_fCreatingNewSense || m_msImport != MergeStyle.MsKeepOld)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindExampleTranslation,The conditional expression  "(tran.Content == null || tran.Content.IsEmpty) &&  					(ct.Translation == null || ct.Translation.BestAnalysisVernacularAlternative.Equals(ct.Translation.NotFoundTss))"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateStemMSA,The conditional expression  "msaStem != null &&  					msaStem.PartOfSpeechRA == pos &&  					MsaSlotInfoMatches(dictPosSlots' msaStem) &&  					MsaInflClassInfoMatches(dictPosInflClasses' null' msaStem) &&  					MsaExceptionFeatsMatch(rgpossProdRestrict' null' msaStem) &&  					MsaInflFeatureMatches(sInflectionFeature' null' msaStem)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateUnclassifiedAffixMSA,The conditional expression  "msaAffix != null &&  					msaAffix.PartOfSpeechRA == pos &&  					MsaSlotInfoMatches(dictPosSlots' msaAffix) &&  					MsaInflClassInfoMatches(dictPosInflClasses' null' msaAffix)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateDerivStepAffixMSA,The conditional expression  "msaAffix != null &&  					msaAffix.PartOfSpeechRA == pos &&  					MsaSlotInfoMatches(dictPosSlots' msaAffix) &&  					MsaInflClassInfoMatches(dictPosInflClasses' null' msaAffix)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateDerivAffixMSA,The conditional expression  "msaAffix != null &&  					msaAffix.ToPartOfSpeechRA == pos &&  					msaAffix.FromPartOfSpeechRA == posFrom &&  					MsaSlotInfoMatches(dictPosSlots' msaAffix) &&  					MsaInflClassInfoMatches(dictPosInflClasses' dictPosFromInflClasses' msaAffix) &&  					MsaExceptionFeatsMatch(rgpossProdRestrict' rgpossFromProdRestrict' msaAffix) &&  					MsaInflFeatureMatches(sInflectionFeature' sFromInflFeature' msaAffix) &&  					MsaStemNameMatches(sFromStemName' msaAffix)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateInflAffixMSA,The conditional expression  "msaAffix != null &&  					msaAffix.PartOfSpeechRA == pos &&  					MsaSlotInfoMatches(dictPosSlots' msaAffix) &&  					MsaInflClassInfoMatches(dictPosInflClasses' null' msaAffix) &&  					MsaExceptionFeatsMatch(rgpossProdRestrict' null'  msaAffix) &&  					MsaInflFeatureMatches(sFeatureString' null' msaAffix)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessSenseTraits,The conditional expression  "ls.SenseTypeRA != poss && (m_fCreatingNewSense || m_msImport != MergeStyle.MsKeepOld || ls.SenseTypeRA == null)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessSenseTraits,The conditional expression  "ls.StatusRA != poss && (m_fCreatingNewSense || m_msImport != MergeStyle.MsKeepOld || ls.StatusRA == null)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindEmptyStemMsa,The conditional expression  "msaStem != null &&  					msaStem.PartOfSpeechRA == null &&  					msaStem.FromPartsOfSpeechRC.Count == 0 &&  					msaStem.InflectionClassRA == null &&  					msaStem.ProdRestrictRC.Count == 0 &&  					msaStem.StratumRA == null &&  					msaStem.MsFeaturesOA == null"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,PendingErrorReport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerSupportCodeAndClasses.cs,Equals,The conditional expression  "that != null && m_flid == that.m_flid && m_guid == that.m_guid &&  					m_ws == that.m_ws"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,HandleDBFileNameChanges,The conditional expression  "(m_SettingsFileName.Text != "" && settings != m_SettingsFileName.Text) ||  						(m_SaveAsFileName.Text != "" && saveAs != m_SaveAsFileName.Text)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,DisplayBeginMarkers,The conditional expression  "field.Exclude ||  						field.IsLangIgnore || // field.DestinationField == MarkerPresenter.ContentMapping.Ignore() ||  						field.DestinationField == MarkerPresenter.ContentMapping.Unknown() ||  						field.LanguageDescriptor == MarkerPresenter.ContentMapping.Unknown()"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,EnableNextButton,The conditional expression  "m_isPhaseInputFile || (m_DatabaseFileName.Text.Length > 0 &&  						System.IO.File.Exists(m_DatabaseFileName.Text) &&  						m_SaveAsFileName.Text != m_sMDFImportMap)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls.DataNotebook,ImportCharMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\ImportCharMappingDlg.cs,m_btnStyles_Click,The conditional expression  "dlg.ShowDialog(this) == DialogResult.OK &&  					((dlg.ChangeType & StyleChangeType.DefChanged) > 0 ||  					(dlg.ChangeType & StyleChangeType.Added) > 0 ||  					(dlg.ChangeType & StyleChangeType.RenOrDel) > 0)"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,OnResize,The conditional expression  "m_btnQuickFinish != null && m_btnBack != null && m_btnCancel != null &&  				m_OriginalCancelButtonLeft != 0"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ReadPossibilityMarker,The conditional expression  "cpt == CellarPropertyType.ReferenceCollection ||  							cpt == CellarPropertyType.ReferenceSequence ||  							cpt == CellarPropertyType.OwningCollection ||  							cpt == CellarPropertyType.OwningSequence"  is complex.
Complex Conditional,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ApplyBeforeAndBetween,The conditional expression  "sT.Length > 0 && rsf.m_tlo.m_fHaveBetween &&  					rsf.m_tlo.m_rgsMarkStart != null && rsf.m_tlo.m_rgsMarkEnd != null"  is complex.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,SelectLeftBoundary,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,SelectRightBoundary,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ReadFormNodes,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,DeleteObjects,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CreateLiftMultiTextFromXml,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ConvertStringToGuid,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CopyFileToLinkedFiles,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,LiftImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftImportDlg.cs,ImportLIFT,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,LiftImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftImportDlg.cs,GetLiftProducer,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,CheckIfInputFileHasChanged,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,IFMReader,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,IFMS,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,LangConverter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,Languages,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,LexOptionsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexOptionsDlg.cs,m_btnOK_Click,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls,LexOptionsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexOptionsDlg.cs,m_btnOK_Click,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,GetFile,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SaveSettings,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,LoadSettingsFile,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ReadMarkerSetting,The method has an empty catch block.
Magic Number,SIL.FieldWorks.LexText.Controls,AddAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddAllomorphDlg.cs,SetDlgInfo,The following statement contains a magic number: m_btnOK.Width += 30;
Magic Number,SIL.FieldWorks.LexText.Controls,AddAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddAllomorphDlg.cs,SetDlgInfo,The following statement contains a magic number: m_btnOK.Left += 90;
Magic Number,SIL.FieldWorks.LexText.Controls,AddAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddAllomorphDlg.cs,SetDlgInfo,The following statement contains a magic number: m_btnClose.Width += 30;
Magic Number,SIL.FieldWorks.LexText.Controls,AddNewSenseDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddNewSenseDlg.cs,SetDlgInfo,The following statement contains a magic number: m_fwtbCitationForm.Font = new Font(defVernWs.DefaultFontName' 10);
Magic Number,SIL.FieldWorks.LexText.Controls,AddNewSenseDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddNewSenseDlg.cs,SetDlgInfo,The following statement contains a magic number: m_fwtbGloss.Font = new Font(defAnalWs.DefaultFontName' 10);
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnPaint,The following statement contains a magic number: using (var p = new Pen(SystemColors.ControlText' 1))  			{  				int x = Width - 14; // 7 wide at top' and 7 in from right boundry  				int y = Height / 2 - 2; // up 2 past the mid point  				// 4 lines: len 7' len 5' len 3 and len 1  				e.Graphics.DrawLine(p' x' y' x + 7' y);  				e.Graphics.DrawLine(p' x + 1' y + 1' x + 1 + 5' y + 1);  				e.Graphics.DrawLine(p' x + 2' y + 2' x + 2 + 3' y + 2);  				e.Graphics.DrawLine(p' x + 3' y + 3' x + 3 + 1' y + 3);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnClick,The following statement contains a magic number: var xmlWsV = new MenuItem[xmlWs.Count + 2];
Magic Number,SIL.FieldWorks.LexText.Controls,AddWritingSystemButton,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\AddWritingSystemButton.cs,OnClick,The following statement contains a magic number: var xmlWsA = new MenuItem[xmlWs.Count + 2];
Magic Number,SIL.FieldWorks.LexText.Controls,PatternView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternView.cs,MakeRoot,The following statement contains a magic number: m_rootb.MaxParasToScan = 10;
Magic Number,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,PositionValuesCombo,The following statement contains a magic number: m_valuesCombo.Location = new Point(valueLocation.Left + m_listPanel.Left + 2 - iValueLocationHorizontalOffset'  											   valueLocation.Top + m_listPanel.Top - 3);
Magic Number,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,PositionValuesCombo,The following statement contains a magic number: m_valuesCombo.Location = new Point(valueLocation.Left + m_listPanel.Left + 2 - iValueLocationHorizontalOffset'  											   valueLocation.Top + m_listPanel.Top - 3);
Magic Number,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,PositionValuesCombo,The following statement contains a magic number: m_valuesCombo.Size = new Size(valueLocation.Width + 1' valueLocation.Height + 4);
Magic Number,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,PopulateValuesCombo,The following statement contains a magic number: if (comboSelectedIndex < 0)  			{  				comboSelectedIndex = feat.ValuesOC.Count + (ShowFeatureConstraintValues ? 2 : 0);  				Debug.Assert(comboSelectedIndex == index);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,PhonologicalFeatureChooserDlg_Closing,The following statement contains a magic number: if (DialogResult == DialogResult.OK)  			{  				using (new WaitCursor(this))  				{  					UndoableUnitOfWorkHelper.DoUsingNewOrCurrentUOW(LexTextControls.ksUndoSelectionOfPhonologicalFeatures'  						LexTextControls.ksRedoSelectionOfPhonologicalFeatures' m_cache.ActionHandlerAccessor' () =>  					{  						if (m_fs == null)  						{  							// Didn't have one to begin with. See whether we want to create one.  							if (m_hvoOwner != 0 && CheckFeatureStructure())  							{  								// The last argument is meaningless since we expect this property to be owning  								// or collection.  								var hvoFs = m_cache.DomainDataByFlid.MakeNewObject(FsFeatStrucTags.kClassId' m_hvoOwner' m_owningFlid' -2);  								m_fs = m_cache.ServiceLocator.GetInstance<IFsFeatStrucRepository>().GetObject(hvoFs);  								UpdateFeatureStructure();  							}  						}  						else  						{  							// clean out any extant features in the feature structure  							m_fs.FeatureSpecsOC.Clear();  							UpdateFeatureStructure();  						}  					});  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,PhonologicalFeatureChooserDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeatureChooserDlg.cs,m_bnHelp_Click,The following statement contains a magic number: if (m_propertyTable.GetStringProperty("currentContentControl"' null).Substring(0' 7) == "natural")  				m_helpTopic = "khtpChoose-Phonemes";
Magic Number,SIL.FieldWorks.LexText.Controls,InsertionControl,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertionControl.cs,UpdateOptionsDisplay,The following statement contains a magic number: foreach (Tuple<object' Func<object' bool>' Func<IEnumerable<object>>> opt in m_options)  			{  				if (opt.Item2 == null || opt.Item2(opt.Item1))  				{  					var linkLabel = new LinkLabel {AutoSize = true' Font = new Font(MiscUtils.StandardSansSerif' 10)' TabStop = true' VisitedLinkColor = Color.Blue};  					linkLabel.LinkClicked += link_LinkClicked;  					if (opt.Item3 != null)  					{  						object[] options = opt.Item3().ToArray();  						var sb = new StringBuilder();  						for (int i = 0; i < options.Length; i++)  						{  							sb.Append(options[i]);  							if (i < options.Length - 1)  								sb.Append(" ");  						}  						linkLabel.Text = sb.ToString();    						linkLabel.Links.Clear();  						int start = 0;  						foreach (int option in options)  						{  							int len = Convert.ToString(option).Length;  							LinkLabel.Link link = linkLabel.Links.Add(start' len' opt.Item1);  							// use the tag property to store the index for this link  							link.Tag = option;  							start += len + 1;  						}  					}  					else  					{  						linkLabel.Text = opt.Item1.ToString();  						linkLabel.Links[0].LinkData = opt.Item1;  					}    					m_insertPanel.Controls.Add(linkLabel);  					displayingOpts = true;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,InsertionControl,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertionControl.cs,UpdateOptionsDisplay,The following statement contains a magic number: if (!displayingOpts && m_noOptsMsg != null)  			{  				string text = m_noOptsMsg();  				if (text != null)  				{  					m_msgLabel = new GrowLabel {Font = new Font(MiscUtils.StandardSansSerif' 10)' Text = text' Width = m_insertPanel.ClientSize.Width};  					m_insertPanel.Controls.Add(m_msgLabel);  				}  			}  			else  			{  				m_msgLabel = null;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,GrowLabel,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertionControl.cs,ResizeLabel,The following statement contains a magic number: try  				{  					m_growing = true;  					var sz = new Size(Width' Int32.MaxValue);  					sz = TextRenderer.MeasureText(Text' Font' sz' TextFormatFlags.WordBreak);  					// The mono implementation chops off the bottom line of the display (FWNX-752).  					if (MiscUtils.IsMono)  						Height = sz.Height + 7;  					else  						Height = sz.Height;  				}  				finally  				{  					m_growing = false;  				}
Magic Number,SIL.FieldWorks.LexText.Controls,SfmToTextsAndWordsMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\SfmToTextsAndWordsMappingBaseDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_destinationsListBox.MinimumSize = new System.Drawing.Size(251' 160);
Magic Number,SIL.FieldWorks.LexText.Controls,SfmToTextsAndWordsMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\SfmToTextsAndWordsMappingBaseDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_destinationsListBox.MinimumSize = new System.Drawing.Size(251' 160);
Magic Number,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,BaseGoDlg,The following statement contains a magic number: m_searchAnimation.Top = m_matchingObjectsBrowser.Top - m_searchAnimation.Height - 5;
Magic Number,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,BaseGoDlg,The following statement contains a magic number: m_searchAnimation.Left = m_matchingObjectsBrowser.Right - m_searchAnimation.Width - 10;
Magic Number,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The following statement contains a magic number: if (m_propertyTable != null)  			{  				// Reset window location.  				// Get location to the stored values' if any.  				if (m_propertyTable.PropertyExists(PersistenceLabel + "DlgLocation")  					&& m_propertyTable.PropertyExists(PersistenceLabel + "DlgSize"))  				{  					var locWnd = m_propertyTable.GetValue<Point>(PersistenceLabel + "DlgLocation");  					var szWnd = m_propertyTable.GetValue<Size>(PersistenceLabel + "DlgSize");  					var rect = new Rectangle(locWnd' szWnd);    					//grow it if it's too small.  This will happen when we add new controls to the dialog box.  					if (rect.Width < m_btnHelp.Left + m_btnHelp.Width + 30)  						rect.Width = m_btnHelp.Left + m_btnHelp.Width + 30;    					if (rect.Height < m_btnHelp.Top + m_btnHelp.Height + 50)  						rect.Height = m_btnHelp.Top + m_btnHelp.Height + 50;    					ScreenHelper.EnsureVisibleRect(ref rect);  					DesktopBounds = rect;  					StartPosition = FormStartPosition.Manual;  				}    				m_helpTopicProvider = m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider");  				if (m_helpTopicProvider != null)  				{  					m_helpProvider.HelpNamespace = m_helpTopicProvider.HelpFile;  					SetHelpButtonEnabled();  				}    			}
Magic Number,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The following statement contains a magic number: if (m_propertyTable != null)  			{  				// Reset window location.  				// Get location to the stored values' if any.  				if (m_propertyTable.PropertyExists(PersistenceLabel + "DlgLocation")  					&& m_propertyTable.PropertyExists(PersistenceLabel + "DlgSize"))  				{  					var locWnd = m_propertyTable.GetValue<Point>(PersistenceLabel + "DlgLocation");  					var szWnd = m_propertyTable.GetValue<Size>(PersistenceLabel + "DlgSize");  					var rect = new Rectangle(locWnd' szWnd);    					//grow it if it's too small.  This will happen when we add new controls to the dialog box.  					if (rect.Width < m_btnHelp.Left + m_btnHelp.Width + 30)  						rect.Width = m_btnHelp.Left + m_btnHelp.Width + 30;    					if (rect.Height < m_btnHelp.Top + m_btnHelp.Height + 50)  						rect.Height = m_btnHelp.Top + m_btnHelp.Height + 50;    					ScreenHelper.EnsureVisibleRect(ref rect);  					DesktopBounds = rect;  					StartPosition = FormStartPosition.Manual;  				}    				m_helpTopicProvider = m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider");  				if (m_helpTopicProvider != null)  				{  					m_helpProvider.HelpNamespace = m_helpTopicProvider.HelpFile;  					SetHelpButtonEnabled();  				}    			}
Magic Number,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The following statement contains a magic number: if (m_propertyTable != null)  			{  				// Reset window location.  				// Get location to the stored values' if any.  				if (m_propertyTable.PropertyExists(PersistenceLabel + "DlgLocation")  					&& m_propertyTable.PropertyExists(PersistenceLabel + "DlgSize"))  				{  					var locWnd = m_propertyTable.GetValue<Point>(PersistenceLabel + "DlgLocation");  					var szWnd = m_propertyTable.GetValue<Size>(PersistenceLabel + "DlgSize");  					var rect = new Rectangle(locWnd' szWnd);    					//grow it if it's too small.  This will happen when we add new controls to the dialog box.  					if (rect.Width < m_btnHelp.Left + m_btnHelp.Width + 30)  						rect.Width = m_btnHelp.Left + m_btnHelp.Width + 30;    					if (rect.Height < m_btnHelp.Top + m_btnHelp.Height + 50)  						rect.Height = m_btnHelp.Top + m_btnHelp.Height + 50;    					ScreenHelper.EnsureVisibleRect(ref rect);  					DesktopBounds = rect;  					StartPosition = FormStartPosition.Manual;  				}    				m_helpTopicProvider = m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider");  				if (m_helpTopicProvider != null)  				{  					m_helpProvider.HelpNamespace = m_helpTopicProvider.HelpFile;  					SetHelpButtonEnabled();  				}    			}
Magic Number,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The following statement contains a magic number: if (m_propertyTable != null)  			{  				// Reset window location.  				// Get location to the stored values' if any.  				if (m_propertyTable.PropertyExists(PersistenceLabel + "DlgLocation")  					&& m_propertyTable.PropertyExists(PersistenceLabel + "DlgSize"))  				{  					var locWnd = m_propertyTable.GetValue<Point>(PersistenceLabel + "DlgLocation");  					var szWnd = m_propertyTable.GetValue<Size>(PersistenceLabel + "DlgSize");  					var rect = new Rectangle(locWnd' szWnd);    					//grow it if it's too small.  This will happen when we add new controls to the dialog box.  					if (rect.Width < m_btnHelp.Left + m_btnHelp.Width + 30)  						rect.Width = m_btnHelp.Left + m_btnHelp.Width + 30;    					if (rect.Height < m_btnHelp.Top + m_btnHelp.Height + 50)  						rect.Height = m_btnHelp.Top + m_btnHelp.Height + 50;    					ScreenHelper.EnsureVisibleRect(ref rect);  					DesktopBounds = rect;  					StartPosition = FormStartPosition.Manual;  				}    				m_helpTopicProvider = m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider");  				if (m_helpTopicProvider != null)  				{  					m_helpProvider.HelpNamespace = m_helpTopicProvider.HelpFile;  					SetHelpButtonEnabled();  				}    			}
Magic Number,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetDlgInfo,The following statement contains a magic number: m_tbForm.Font = new Font(cache.ServiceLocator.WritingSystemManager.Get(ws).DefaultFontName' 10);
Magic Number,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,SetupBottomMsg,The following statement contains a magic number: m_fwTextBoxBottomMsg.Font = new Font(userWs.DefaultFontName' 10);
Magic Number,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,ShowControlsBasedOnPanel1Position,The following statement contains a magic number: int ypos = m_panel1.Bottom + 5;
Magic Number,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,ShowControlsBasedOnPanel1Position,The following statement contains a magic number: ypos = m_matchingObjectsBrowser.Top - m_objectsLabel.Size.Height - 5;
Magic Number,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetGenDateFromInt,The following statement contains a magic number: var prec = nVal % 10;
Magic Number,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetGenDateFromInt,The following statement contains a magic number: nVal /= 10;
Magic Number,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetGenDateFromInt,The following statement contains a magic number: var day = nVal % 100;
Magic Number,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetGenDateFromInt,The following statement contains a magic number: nVal /= 100;
Magic Number,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetGenDateFromInt,The following statement contains a magic number: var month = nVal % 100;
Magic Number,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetGenDateFromInt,The following statement contains a magic number: var year = nVal / 100;
Magic Number,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetProperty,The following statement contains a magic number: if (info == null && property.EndsWith(".Hvo"))  			{  				fWantHvo = true;  				var realprop = property.Substring(0' property.Length - 4);  				info = type.GetProperty(realprop' BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,DisplayNewListItems,The following statement contains a magic number: using (var writer = new StreamWriter(sHtmlFile' false' System.Text.Encoding.UTF8))  			{  				string sTitle = String.Format(LexTextControls.ksImportLogFor0' sLIFTFile);  				writer.WriteLine("<html>");  				writer.WriteLine("<head>");  				writer.WriteLine("<title>{0}</title>"' sTitle);  				writer.WriteLine("</head>");  				writer.WriteLine("<body>");  				writer.WriteLine("<h2>{0}</h2>"' sTitle);  				long deltaTicks = dtEnd.Ticks - m_dtStart.Ticks;	// number of 100-nanosecond intervals  				int deltaMsec = (int)((deltaTicks + 5000L) / 10000L);	// round off to milliseconds  				int deltaSec = deltaMsec / 1000;  				string sDeltaTime = String.Format(LexTextControls.ksImportingTookTime'  					System.IO.Path.GetFileName(sLIFTFile)' deltaSec' deltaMsec % 1000);  				writer.WriteLine("<p>{0}</p>"' sDeltaTime);  				string sEntryCounts = String.Format(LexTextControls.ksEntriesImportCounts'  					cEntriesRead' m_cEntriesAdded' m_cSensesAdded' m_cEntriesDeleted);  				writer.WriteLine("<p><h3>{0}</h3></p>"' sEntryCounts);  				ListNewPossibilities(writer' LexTextControls.ksPartsOfSpeechAdded' m_rgnewPos);  				ListNewPossibilities(writer' LexTextControls.ksMorphTypesAdded' m_rgnewMmt);  				ListNewLexEntryTypes(writer' LexTextControls.ksComplexFormTypesAdded' m_rgnewComplexFormType);  				ListNewLexEntryTypes(writer' LexTextControls.ksVariantTypesAdded' m_rgnewVariantType);  				ListNewPossibilities(writer' LexTextControls.ksSemanticDomainsAdded' m_rgnewSemDom);  				ListNewPossibilities(writer' LexTextControls.ksTranslationTypesAdded' m_rgnewTransType);  				ListNewPossibilities(writer' LexTextControls.ksConditionsAdded' m_rgnewCondition);  				ListNewPossibilities(writer' LexTextControls.ksAnthropologyCodesAdded' m_rgnewAnthroCode);  				ListNewPossibilities(writer' LexTextControls.ksDialectsAdded' m_rgnewDialects);  				ListNewPossibilities(writer' LexTextControls.ksDomainTypesAdded' m_rgnewDomainType);  				ListNewPossibilities(writer' LexTextControls.ksSenseTypesAdded' m_rgnewSenseType);  				ListNewPossibilities(writer' LexTextControls.ksPeopleAdded' m_rgnewPerson);  				ListNewPossibilities(writer' LexTextControls.ksStatusValuesAdded' m_rgnewStatus);  				ListNewPossibilities(writer' LexTextControls.ksUsageTypesAdded' m_rgnewUsageType);  				ListNewPossibilities(writer' LexTextControls.ksLocationsAdded' m_rgnewLocation);  				ListNewPossibilities(writer' LexTextControls.ksLanguagesAdded' m_rgnewLanguage);  				ListNewEnvironments(writer' LexTextControls.ksEnvironmentsAdded' m_rgnewEnvirons);  				ListNewPossibilities(writer' LexTextControls.ksLexicalReferenceTypesAdded' m_rgnewLexRefTypes);  				ListNewWritingSystems(writer' LexTextControls.ksWritingSystemsAdded' m_addedWss);  				ListNewInflectionClasses(writer' LexTextControls.ksInflectionClassesAdded' m_rgnewInflClasses);  				ListNewSlots(writer' LexTextControls.ksInflectionalAffixSlotsAdded' m_rgnewSlots);  				ListNewPossibilities(writer' LexTextControls.ksExceptionFeaturesAdded' m_rgnewExceptFeat);  				ListNewInflectionalFeatures(writer' LexTextControls.ksInflectionFeaturesAdded' m_rgnewFeatDefn);  				ListNewFeatureTypes(writer' LexTextControls.ksFeatureTypesAdded' m_rgnewFeatStrucType);  				ListNewStemNames(writer' LexTextControls.ksStemNamesAdded' m_rgnewStemName);  				ListNewPossibilities(writer' LexTextControls.ksPublicationTypesAdded' m_rgnewPublicationType);  				ListNewCustomFields(writer' LexTextControls.ksCustomFieldsAdded' m_rgnewCustomFields);  				ListConflictsFound(writer' LexTextControls.ksConflictsResultedInDup' m_rgcdConflicts);  				ListInvalidData(writer);  				ListInvalidRelations(writer);  				ListCombinedCollections(writer);  				ListInvalidMorphTypes(writer);  				ListErrorMessages(writer);  				writer.WriteLine("</body>");  				writer.WriteLine("</html>");  				writer.Close();  				return sHtmlFile;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,DisplayNewListItems,The following statement contains a magic number: using (var writer = new StreamWriter(sHtmlFile' false' System.Text.Encoding.UTF8))  			{  				string sTitle = String.Format(LexTextControls.ksImportLogFor0' sLIFTFile);  				writer.WriteLine("<html>");  				writer.WriteLine("<head>");  				writer.WriteLine("<title>{0}</title>"' sTitle);  				writer.WriteLine("</head>");  				writer.WriteLine("<body>");  				writer.WriteLine("<h2>{0}</h2>"' sTitle);  				long deltaTicks = dtEnd.Ticks - m_dtStart.Ticks;	// number of 100-nanosecond intervals  				int deltaMsec = (int)((deltaTicks + 5000L) / 10000L);	// round off to milliseconds  				int deltaSec = deltaMsec / 1000;  				string sDeltaTime = String.Format(LexTextControls.ksImportingTookTime'  					System.IO.Path.GetFileName(sLIFTFile)' deltaSec' deltaMsec % 1000);  				writer.WriteLine("<p>{0}</p>"' sDeltaTime);  				string sEntryCounts = String.Format(LexTextControls.ksEntriesImportCounts'  					cEntriesRead' m_cEntriesAdded' m_cSensesAdded' m_cEntriesDeleted);  				writer.WriteLine("<p><h3>{0}</h3></p>"' sEntryCounts);  				ListNewPossibilities(writer' LexTextControls.ksPartsOfSpeechAdded' m_rgnewPos);  				ListNewPossibilities(writer' LexTextControls.ksMorphTypesAdded' m_rgnewMmt);  				ListNewLexEntryTypes(writer' LexTextControls.ksComplexFormTypesAdded' m_rgnewComplexFormType);  				ListNewLexEntryTypes(writer' LexTextControls.ksVariantTypesAdded' m_rgnewVariantType);  				ListNewPossibilities(writer' LexTextControls.ksSemanticDomainsAdded' m_rgnewSemDom);  				ListNewPossibilities(writer' LexTextControls.ksTranslationTypesAdded' m_rgnewTransType);  				ListNewPossibilities(writer' LexTextControls.ksConditionsAdded' m_rgnewCondition);  				ListNewPossibilities(writer' LexTextControls.ksAnthropologyCodesAdded' m_rgnewAnthroCode);  				ListNewPossibilities(writer' LexTextControls.ksDialectsAdded' m_rgnewDialects);  				ListNewPossibilities(writer' LexTextControls.ksDomainTypesAdded' m_rgnewDomainType);  				ListNewPossibilities(writer' LexTextControls.ksSenseTypesAdded' m_rgnewSenseType);  				ListNewPossibilities(writer' LexTextControls.ksPeopleAdded' m_rgnewPerson);  				ListNewPossibilities(writer' LexTextControls.ksStatusValuesAdded' m_rgnewStatus);  				ListNewPossibilities(writer' LexTextControls.ksUsageTypesAdded' m_rgnewUsageType);  				ListNewPossibilities(writer' LexTextControls.ksLocationsAdded' m_rgnewLocation);  				ListNewPossibilities(writer' LexTextControls.ksLanguagesAdded' m_rgnewLanguage);  				ListNewEnvironments(writer' LexTextControls.ksEnvironmentsAdded' m_rgnewEnvirons);  				ListNewPossibilities(writer' LexTextControls.ksLexicalReferenceTypesAdded' m_rgnewLexRefTypes);  				ListNewWritingSystems(writer' LexTextControls.ksWritingSystemsAdded' m_addedWss);  				ListNewInflectionClasses(writer' LexTextControls.ksInflectionClassesAdded' m_rgnewInflClasses);  				ListNewSlots(writer' LexTextControls.ksInflectionalAffixSlotsAdded' m_rgnewSlots);  				ListNewPossibilities(writer' LexTextControls.ksExceptionFeaturesAdded' m_rgnewExceptFeat);  				ListNewInflectionalFeatures(writer' LexTextControls.ksInflectionFeaturesAdded' m_rgnewFeatDefn);  				ListNewFeatureTypes(writer' LexTextControls.ksFeatureTypesAdded' m_rgnewFeatStrucType);  				ListNewStemNames(writer' LexTextControls.ksStemNamesAdded' m_rgnewStemName);  				ListNewPossibilities(writer' LexTextControls.ksPublicationTypesAdded' m_rgnewPublicationType);  				ListNewCustomFields(writer' LexTextControls.ksCustomFieldsAdded' m_rgnewCustomFields);  				ListConflictsFound(writer' LexTextControls.ksConflictsResultedInDup' m_rgcdConflicts);  				ListInvalidData(writer);  				ListInvalidRelations(writer);  				ListCombinedCollections(writer);  				ListInvalidMorphTypes(writer);  				ListErrorMessages(writer);  				writer.WriteLine("</body>");  				writer.WriteLine("</html>");  				writer.Close();  				return sHtmlFile;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,GetOrCreateCustomList,The following statement contains a magic number: customPossibilityList.Depth = 127;
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ExtractLIFTResidue,The following statement contains a magic number: if (sImportResidue.Length < 13)  				return null;
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ExtractLIFTResidue,The following statement contains a magic number: if (idx >= 0)  			{  				string sLiftResidue = sImportResidue.Substring(idx);  				int idx2 = sLiftResidue.IndexOf("</lift-residue>");  				if (idx2 >= 0)  				{  					idx2 += 15;  					if (sLiftResidue.Length > idx2)  						sLiftResidue = sLiftResidue.Substring(0' idx2);  				}  				int cch = sLiftResidue.Length;  				cache.MainCacheAccessor.set_UnicodeProp(hvo' flidImportResidue' sImportResidue.Remove(idx' cch));  				cache.MainCacheAccessor.set_UnicodeProp(hvo' flidLiftResidue' sLiftResidue);  				return sLiftResidue;  			}  			else  			{  				return null;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CreateXmlForEtymology,The following statement contains a magic number: Debug.Assert(ety.Form.Count < 2);
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,GetCustomFieldPossListGuid,The following statement contains a magic number: foreach (string sDef in rgsDef)  			{  				if (sDef.StartsWith("range="))  				{  					possListName = sDef.Substring(6);  					if (m_rangeNamesToPossibilityListGuids.TryGetValue(possListName' out guidToReturn))  						return guidToReturn;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,GetCustomFieldType,The following statement contains a magic number: foreach (string sDef in rgsDef)  			{  				if (sDef.StartsWith("Type="))  				{  					var sValue = sDef.Substring(5);  					if (sValue.StartsWith("kcpt"))  						sValue = sValue.Substring(4);  					return (CellarPropertyType)Enum.Parse(typeof(CellarPropertyType)' sValue' true);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,GetCustomFieldType,The following statement contains a magic number: foreach (string sDef in rgsDef)  			{  				if (sDef.StartsWith("Type="))  				{  					var sValue = sDef.Substring(5);  					if (sValue.StartsWith("kcpt"))  						sValue = sValue.Substring(4);  					return (CellarPropertyType)Enum.Parse(typeof(CellarPropertyType)' sValue' true);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,GetCustomFieldWsSelector,The following statement contains a magic number: foreach (string sDef in rgsDef)  			{  				if (sDef.StartsWith("WsSelector="))  				{  					string sValue = sDef.Substring(11);  					// Do NOT use WritingSystemServices.GetMagicWsIdFromName...that's a different set of names (LT-12275)  					int ws = GetLiftExportMagicWsIdFromName(sValue);  					if (ws == 0)  						ws = GetWsFromStr(sValue);  					return ws;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,GetCustomFieldDstCls,The following statement contains a magic number: foreach (string sDef in rgsDef)  			{  				if (sDef.StartsWith("DstCls="))  				{  					sValue = sDef.Substring(7);  					return (int)m_cache.MetaDataCacheAccessor.GetClassId(sValue);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindGuidInString,The following statement contains a magic number: if (String.IsNullOrEmpty(sId) || sId.Length < 36)  				return null;
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,AsymmetricPairRelationAlreadyExists,The following statement contains a magic number: foreach(var lr in lrt.MembersOC)  			{  				if(lr.TargetsRS.Count != 2)  					continue; // SHOULD NEVER HAPPEN!!  				var hvoA = lr.TargetsRS[0].Hvo;  				var hvoB = lr.TargetsRS[1].Hvo;  				if(isFirst)  				{  					if(hvoA == hvo1 && hvoB == hvo2)  					{  						refsAsYetUnmatched.Remove(lr);  						return true;  					}  				}  				else  				{  					if(hvoA == hvo2 && hvoB == hvo1)  					{  						refsAsYetUnmatched.Remove(lr);  						return true;  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,PairRelationAlreadyExists,The following statement contains a magic number: foreach(var lr in lrt.MembersOC)  			{  				if(lr.TargetsRS.Count != 2)  					continue; // SHOULD NEVER HAPPEN!!  				var hvoA = lr.TargetsRS[0].Hvo;  				var hvoB = lr.TargetsRS[1].Hvo;  				if((hvoA == hvo1 && hvoB == hvo2) || (hvoA == hvo2 && hvoB == hvo1))  				{  					refsAsYetUnmatched.Remove(lr);  					return true;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessStTextField,The following statement contains a magic number: if (hvoText == 0)  			{  				hvoText = m_cache.DomainDataByFlid.MakeNewObject(StTextTags.kClassId' hvoOwner' flid' -2);  				fNew = true;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateMSA,The following statement contains a magic number: foreach (LiftTrait trait in traits)  			{  				if (trait.Name == "type")  				{  					sType = trait.Value;  				}  				else if (trait.Name == RangeNames.sPartsOfSpeechOAold1 || trait.Name == RangeNames.sPartsOfSpeechOAold2)  				{  					sFromPOS = trait.Value;  				}  				else if (trait.Name == RangeNames.sProdRestrictOA)  				{  					ICmPossibility poss = FindOrCreateExceptionFeature(trait.Value);  					rgpossProdRestrict.Add(poss);  				}  				else if (trait.Name == RangeNames.sProdRestrictOAfrom)  				{  					ICmPossibility poss = FindOrCreateExceptionFeature(trait.Value);  					rgpossFromProdRestrict.Add(poss);  				}  				else if (trait.Name == RangeNames.sMSAinflectionFeature)  				{  					sInflectionFeature = trait.Value;  				}  				else if (trait.Name == RangeNames.sMSAfromInflectionFeature)  				{  					sFromInflFeature = trait.Value;  				}  				else if (trait.Name == "from-stem-name")  				{  					sFromStemName = trait.Value;  				}  				else if (trait.Name.EndsWith("-slot") || trait.Name.EndsWith("-Slots"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-slot") ? 5 : 6);  					string sPos = trait.Name.Substring(0' len);  					List<string> rgsSlots;  					if (!dictPosSlots.TryGetValue(sPos' out rgsSlots))  					{  						rgsSlots = new List<string>();  						dictPosSlots.Add(sPos' rgsSlots);  					}  					rgsSlots.Add(trait.Value);  				}  				else if (trait.Name.EndsWith("-infl-class") || trait.Name.EndsWith("-InflectionClass"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-infl-class") ? 11 : 16);  					string sPos = trait.Name.Substring(0' len);  					if (sPos.StartsWith("from-"))  					{  						sPos = sPos.Substring(5);  						Debug.Assert(sPos.Length > 0);  						List<string> rgsInflClasses;  						if (!dictPosFromInflClasses.TryGetValue(sPos' out rgsInflClasses))  						{  							rgsInflClasses = new List<string>();  							dictPosFromInflClasses.Add(sPos' rgsInflClasses);  						}  						rgsInflClasses.Add(trait.Value);  					}  					else  					{  						List<string> rgsInflClasses;  						if (!dictPosInflClasses.TryGetValue(sPos' out rgsInflClasses))  						{  							rgsInflClasses = new List<string>();  							dictPosInflClasses.Add(sPos' rgsInflClasses);  						}  						rgsInflClasses.Add(trait.Value);  					}  				}  				else  				{  					rgsResidue.Add(CreateXmlForTrait(trait));  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateMSA,The following statement contains a magic number: foreach (LiftTrait trait in traits)  			{  				if (trait.Name == "type")  				{  					sType = trait.Value;  				}  				else if (trait.Name == RangeNames.sPartsOfSpeechOAold1 || trait.Name == RangeNames.sPartsOfSpeechOAold2)  				{  					sFromPOS = trait.Value;  				}  				else if (trait.Name == RangeNames.sProdRestrictOA)  				{  					ICmPossibility poss = FindOrCreateExceptionFeature(trait.Value);  					rgpossProdRestrict.Add(poss);  				}  				else if (trait.Name == RangeNames.sProdRestrictOAfrom)  				{  					ICmPossibility poss = FindOrCreateExceptionFeature(trait.Value);  					rgpossFromProdRestrict.Add(poss);  				}  				else if (trait.Name == RangeNames.sMSAinflectionFeature)  				{  					sInflectionFeature = trait.Value;  				}  				else if (trait.Name == RangeNames.sMSAfromInflectionFeature)  				{  					sFromInflFeature = trait.Value;  				}  				else if (trait.Name == "from-stem-name")  				{  					sFromStemName = trait.Value;  				}  				else if (trait.Name.EndsWith("-slot") || trait.Name.EndsWith("-Slots"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-slot") ? 5 : 6);  					string sPos = trait.Name.Substring(0' len);  					List<string> rgsSlots;  					if (!dictPosSlots.TryGetValue(sPos' out rgsSlots))  					{  						rgsSlots = new List<string>();  						dictPosSlots.Add(sPos' rgsSlots);  					}  					rgsSlots.Add(trait.Value);  				}  				else if (trait.Name.EndsWith("-infl-class") || trait.Name.EndsWith("-InflectionClass"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-infl-class") ? 11 : 16);  					string sPos = trait.Name.Substring(0' len);  					if (sPos.StartsWith("from-"))  					{  						sPos = sPos.Substring(5);  						Debug.Assert(sPos.Length > 0);  						List<string> rgsInflClasses;  						if (!dictPosFromInflClasses.TryGetValue(sPos' out rgsInflClasses))  						{  							rgsInflClasses = new List<string>();  							dictPosFromInflClasses.Add(sPos' rgsInflClasses);  						}  						rgsInflClasses.Add(trait.Value);  					}  					else  					{  						List<string> rgsInflClasses;  						if (!dictPosInflClasses.TryGetValue(sPos' out rgsInflClasses))  						{  							rgsInflClasses = new List<string>();  							dictPosInflClasses.Add(sPos' rgsInflClasses);  						}  						rgsInflClasses.Add(trait.Value);  					}  				}  				else  				{  					rgsResidue.Add(CreateXmlForTrait(trait));  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateMSA,The following statement contains a magic number: foreach (LiftTrait trait in traits)  			{  				if (trait.Name == "type")  				{  					sType = trait.Value;  				}  				else if (trait.Name == RangeNames.sPartsOfSpeechOAold1 || trait.Name == RangeNames.sPartsOfSpeechOAold2)  				{  					sFromPOS = trait.Value;  				}  				else if (trait.Name == RangeNames.sProdRestrictOA)  				{  					ICmPossibility poss = FindOrCreateExceptionFeature(trait.Value);  					rgpossProdRestrict.Add(poss);  				}  				else if (trait.Name == RangeNames.sProdRestrictOAfrom)  				{  					ICmPossibility poss = FindOrCreateExceptionFeature(trait.Value);  					rgpossFromProdRestrict.Add(poss);  				}  				else if (trait.Name == RangeNames.sMSAinflectionFeature)  				{  					sInflectionFeature = trait.Value;  				}  				else if (trait.Name == RangeNames.sMSAfromInflectionFeature)  				{  					sFromInflFeature = trait.Value;  				}  				else if (trait.Name == "from-stem-name")  				{  					sFromStemName = trait.Value;  				}  				else if (trait.Name.EndsWith("-slot") || trait.Name.EndsWith("-Slots"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-slot") ? 5 : 6);  					string sPos = trait.Name.Substring(0' len);  					List<string> rgsSlots;  					if (!dictPosSlots.TryGetValue(sPos' out rgsSlots))  					{  						rgsSlots = new List<string>();  						dictPosSlots.Add(sPos' rgsSlots);  					}  					rgsSlots.Add(trait.Value);  				}  				else if (trait.Name.EndsWith("-infl-class") || trait.Name.EndsWith("-InflectionClass"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-infl-class") ? 11 : 16);  					string sPos = trait.Name.Substring(0' len);  					if (sPos.StartsWith("from-"))  					{  						sPos = sPos.Substring(5);  						Debug.Assert(sPos.Length > 0);  						List<string> rgsInflClasses;  						if (!dictPosFromInflClasses.TryGetValue(sPos' out rgsInflClasses))  						{  							rgsInflClasses = new List<string>();  							dictPosFromInflClasses.Add(sPos' rgsInflClasses);  						}  						rgsInflClasses.Add(trait.Value);  					}  					else  					{  						List<string> rgsInflClasses;  						if (!dictPosInflClasses.TryGetValue(sPos' out rgsInflClasses))  						{  							rgsInflClasses = new List<string>();  							dictPosInflClasses.Add(sPos' rgsInflClasses);  						}  						rgsInflClasses.Add(trait.Value);  					}  				}  				else  				{  					rgsResidue.Add(CreateXmlForTrait(trait));  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateMSA,The following statement contains a magic number: foreach (LiftTrait trait in traits)  			{  				if (trait.Name == "type")  				{  					sType = trait.Value;  				}  				else if (trait.Name == RangeNames.sPartsOfSpeechOAold1 || trait.Name == RangeNames.sPartsOfSpeechOAold2)  				{  					sFromPOS = trait.Value;  				}  				else if (trait.Name == RangeNames.sProdRestrictOA)  				{  					ICmPossibility poss = FindOrCreateExceptionFeature(trait.Value);  					rgpossProdRestrict.Add(poss);  				}  				else if (trait.Name == RangeNames.sProdRestrictOAfrom)  				{  					ICmPossibility poss = FindOrCreateExceptionFeature(trait.Value);  					rgpossFromProdRestrict.Add(poss);  				}  				else if (trait.Name == RangeNames.sMSAinflectionFeature)  				{  					sInflectionFeature = trait.Value;  				}  				else if (trait.Name == RangeNames.sMSAfromInflectionFeature)  				{  					sFromInflFeature = trait.Value;  				}  				else if (trait.Name == "from-stem-name")  				{  					sFromStemName = trait.Value;  				}  				else if (trait.Name.EndsWith("-slot") || trait.Name.EndsWith("-Slots"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-slot") ? 5 : 6);  					string sPos = trait.Name.Substring(0' len);  					List<string> rgsSlots;  					if (!dictPosSlots.TryGetValue(sPos' out rgsSlots))  					{  						rgsSlots = new List<string>();  						dictPosSlots.Add(sPos' rgsSlots);  					}  					rgsSlots.Add(trait.Value);  				}  				else if (trait.Name.EndsWith("-infl-class") || trait.Name.EndsWith("-InflectionClass"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-infl-class") ? 11 : 16);  					string sPos = trait.Name.Substring(0' len);  					if (sPos.StartsWith("from-"))  					{  						sPos = sPos.Substring(5);  						Debug.Assert(sPos.Length > 0);  						List<string> rgsInflClasses;  						if (!dictPosFromInflClasses.TryGetValue(sPos' out rgsInflClasses))  						{  							rgsInflClasses = new List<string>();  							dictPosFromInflClasses.Add(sPos' rgsInflClasses);  						}  						rgsInflClasses.Add(trait.Value);  					}  					else  					{  						List<string> rgsInflClasses;  						if (!dictPosInflClasses.TryGetValue(sPos' out rgsInflClasses))  						{  							rgsInflClasses = new List<string>();  							dictPosInflClasses.Add(sPos' rgsInflClasses);  						}  						rgsInflClasses.Add(trait.Value);  					}  				}  				else  				{  					rgsResidue.Add(CreateXmlForTrait(trait));  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindOrCreateMSA,The following statement contains a magic number: foreach (LiftTrait trait in traits)  			{  				if (trait.Name == "type")  				{  					sType = trait.Value;  				}  				else if (trait.Name == RangeNames.sPartsOfSpeechOAold1 || trait.Name == RangeNames.sPartsOfSpeechOAold2)  				{  					sFromPOS = trait.Value;  				}  				else if (trait.Name == RangeNames.sProdRestrictOA)  				{  					ICmPossibility poss = FindOrCreateExceptionFeature(trait.Value);  					rgpossProdRestrict.Add(poss);  				}  				else if (trait.Name == RangeNames.sProdRestrictOAfrom)  				{  					ICmPossibility poss = FindOrCreateExceptionFeature(trait.Value);  					rgpossFromProdRestrict.Add(poss);  				}  				else if (trait.Name == RangeNames.sMSAinflectionFeature)  				{  					sInflectionFeature = trait.Value;  				}  				else if (trait.Name == RangeNames.sMSAfromInflectionFeature)  				{  					sFromInflFeature = trait.Value;  				}  				else if (trait.Name == "from-stem-name")  				{  					sFromStemName = trait.Value;  				}  				else if (trait.Name.EndsWith("-slot") || trait.Name.EndsWith("-Slots"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-slot") ? 5 : 6);  					string sPos = trait.Name.Substring(0' len);  					List<string> rgsSlots;  					if (!dictPosSlots.TryGetValue(sPos' out rgsSlots))  					{  						rgsSlots = new List<string>();  						dictPosSlots.Add(sPos' rgsSlots);  					}  					rgsSlots.Add(trait.Value);  				}  				else if (trait.Name.EndsWith("-infl-class") || trait.Name.EndsWith("-InflectionClass"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-infl-class") ? 11 : 16);  					string sPos = trait.Name.Substring(0' len);  					if (sPos.StartsWith("from-"))  					{  						sPos = sPos.Substring(5);  						Debug.Assert(sPos.Length > 0);  						List<string> rgsInflClasses;  						if (!dictPosFromInflClasses.TryGetValue(sPos' out rgsInflClasses))  						{  							rgsInflClasses = new List<string>();  							dictPosFromInflClasses.Add(sPos' rgsInflClasses);  						}  						rgsInflClasses.Add(trait.Value);  					}  					else  					{  						List<string> rgsInflClasses;  						if (!dictPosInflClasses.TryGetValue(sPos' out rgsInflClasses))  						{  							rgsInflClasses = new List<string>();  							dictPosInflClasses.Add(sPos' rgsInflClasses);  						}  						rgsInflClasses.Add(trait.Value);  					}  				}  				else  				{  					rgsResidue.Add(CreateXmlForTrait(trait));  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ParseFeatureString,The following statement contains a magic number: if (sFeatureString[0] == '[' && sFeatureString.EndsWith("]"))  			{  				// Remove the outermost bracketing  				List<string> rgsName = new List<string>();  				List<string> rgsValue = new List<string>();  				if (SplitFeatureString(sFeatureString.Substring(1' sFeatureString.Length - 2)' rgsName' rgsValue))  				{  					if (m_factFsFeatStruc == null)  						m_factFsFeatStruc = m_cache.ServiceLocator.GetInstance<IFsFeatStrucFactory>();  					IFsFeatStruc feat = m_factFsFeatStruc.Create();  					if (msaStem != null)  					{  						msaStem.MsFeaturesOA = feat;  					}  					else if (msaInfl != null)  					{  						msaInfl.InflFeatsOA = feat;  					}  					else if (msaDeriv != null)  					{  						if (fFrom)  							msaDeriv.FromMsFeaturesOA = feat;  						else if (msaDeriv != null)  							msaDeriv.ToMsFeaturesOA = feat;  					}  					else  					{  						return false;  					}  					if (!String.IsNullOrEmpty(sType))  					{  						IFsFeatStrucType type = null;  						if (m_mapIdFeatStrucType.TryGetValue(sType' out type))  							feat.TypeRA = type;  						else  							return false;  					}  					return ProcessFeatStrucData(rgsName' rgsValue' feat);  				}  				else  				{  					return false;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ParseFeatureString,The following statement contains a magic number: if (sFeatureString[0] == '[' && sFeatureString.EndsWith("]"))  			{  				// Remove the outermost bracketing  				List<string> rgsName = new List<string>();  				List<string> rgsValue = new List<string>();  				if (SplitFeatureString(sFeatureString.Substring(1' sFeatureString.Length - 2)' rgsName' rgsValue))  				{  					if (m_factFsFeatStruc == null)  						m_factFsFeatStruc = m_cache.ServiceLocator.GetInstance<IFsFeatStrucFactory>();  					IFsFeatStruc ffs = null;  					ffs = m_factFsFeatStruc.Create();  					stem.RegionsOC.Add(ffs);  					if (type != null)  						ffs.TypeRA = type;  					if (ProcessFeatStrucData(rgsName' rgsValue' ffs))  					{  						int cffs = 0;  						string liftName = ffs.LiftName;  						foreach (IFsFeatStruc fs in stem.RegionsOC)  						{  							if (fs.LiftName == liftName)  								++cffs;  						}  						if (cffs > 1)  						{  							stem.RegionsOC.Remove(ffs);  							return null;  						}  						return ffs;  					}  					else  					{  						stem.RegionsOC.Remove(ffs);  						return null;  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatStrucData,The following statement contains a magic number: for (int i = 0; i < rgsName.Count; ++i)  			{  				string sName = rgsName[i];  				IFsFeatDefn featDefn = null;  				if (!m_mapIdFeatDefn.TryGetValue(sName' out featDefn))  				{  					// REVIEW: SHOULD WE TRY TO CREATE ONE?  					return false;  				}  				string sValue = rgsValue[i];  				if (sValue[0] == '[')  				{  					if (!sValue.EndsWith("]"))  						return false;  					if (m_factFsComplexValue == null)  						m_factFsComplexValue = m_cache.ServiceLocator.GetInstance<IFsComplexValueFactory>();  					List<string> rgsValName = new List<string>();  					List<string> rgsValValue = new List<string>();  					if (SplitFeatureString(sValue.Substring(1' sValue.Length - 2)' rgsValName' rgsValValue))  					{  						IFsComplexValue val = m_factFsComplexValue.Create();  						ownerFeatStruc.FeatureSpecsOC.Add(val);  						val.FeatureRA = featDefn;  						IFsFeatStruc featVal = m_factFsFeatStruc.Create();  						val.ValueOA = featVal;  						if (!ProcessFeatStrucData(rgsValName' rgsValValue' featVal))  							return false;  					}  					else  					{  						return false;  					}  				}  				else  				{  					if (m_factFsClosedValue == null)  						m_factFsClosedValue = m_cache.ServiceLocator.GetInstance<IFsClosedValueFactory>();  					IFsSymFeatVal featVal = null;  					string valueKey = String.Format("{0}:{1}"' sName' sValue);  					if (m_mapIdAbbrSymFeatVal.TryGetValue(valueKey' out featVal))  					{  						IFsClosedValue val = m_factFsClosedValue.Create();  						ownerFeatStruc.FeatureSpecsOC.Add(val);  						val.FeatureRA = featDefn;  						val.ValueRA = featVal;  					}  					else  					{  						return false;  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SenseGramInfoConflicts,The following statement contains a magic number: foreach (LiftTrait trait in gram.Traits)  			{  				if (trait.Name == "type")  				{  					sType = trait.Value;  				}  				else if (trait.Name == RangeNames.sPartsOfSpeechOAold1 || trait.Name == RangeNames.sPartsOfSpeechOAold2)  				{  					sFromPOS = trait.Value;  				}  				else if (trait.Name.EndsWith("-slot") || trait.Name.EndsWith("-Slots"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-slot") ? 5 : 6);  					string sTraitPos = trait.Name.Substring(0' len);  					List<string> rgsSlots;  					if (!dictPosSlots.TryGetValue(sTraitPos' out rgsSlots))  					{  						rgsSlots = new List<string>();  						dictPosSlots.Add(sTraitPos' rgsSlots);  					}  					rgsSlots.Add(trait.Value);  				}  				else if (trait.Name.EndsWith("-infl-class") || trait.Name.EndsWith("-InflectionClass"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-infl-class") ? 11 : 16);  					string sTraitPos = trait.Name.Substring(0' len);  					List<string> rgsInflClasses;  					if (!dictPosInflClasses.TryGetValue(sTraitPos' out rgsInflClasses))  					{  						rgsInflClasses = new List<string>();  						dictPosInflClasses.Add(sTraitPos' rgsInflClasses);  					}  					rgsInflClasses.Add(trait.Value);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SenseGramInfoConflicts,The following statement contains a magic number: foreach (LiftTrait trait in gram.Traits)  			{  				if (trait.Name == "type")  				{  					sType = trait.Value;  				}  				else if (trait.Name == RangeNames.sPartsOfSpeechOAold1 || trait.Name == RangeNames.sPartsOfSpeechOAold2)  				{  					sFromPOS = trait.Value;  				}  				else if (trait.Name.EndsWith("-slot") || trait.Name.EndsWith("-Slots"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-slot") ? 5 : 6);  					string sTraitPos = trait.Name.Substring(0' len);  					List<string> rgsSlots;  					if (!dictPosSlots.TryGetValue(sTraitPos' out rgsSlots))  					{  						rgsSlots = new List<string>();  						dictPosSlots.Add(sTraitPos' rgsSlots);  					}  					rgsSlots.Add(trait.Value);  				}  				else if (trait.Name.EndsWith("-infl-class") || trait.Name.EndsWith("-InflectionClass"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-infl-class") ? 11 : 16);  					string sTraitPos = trait.Name.Substring(0' len);  					List<string> rgsInflClasses;  					if (!dictPosInflClasses.TryGetValue(sTraitPos' out rgsInflClasses))  					{  						rgsInflClasses = new List<string>();  						dictPosInflClasses.Add(sTraitPos' rgsInflClasses);  					}  					rgsInflClasses.Add(trait.Value);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SenseGramInfoConflicts,The following statement contains a magic number: foreach (LiftTrait trait in gram.Traits)  			{  				if (trait.Name == "type")  				{  					sType = trait.Value;  				}  				else if (trait.Name == RangeNames.sPartsOfSpeechOAold1 || trait.Name == RangeNames.sPartsOfSpeechOAold2)  				{  					sFromPOS = trait.Value;  				}  				else if (trait.Name.EndsWith("-slot") || trait.Name.EndsWith("-Slots"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-slot") ? 5 : 6);  					string sTraitPos = trait.Name.Substring(0' len);  					List<string> rgsSlots;  					if (!dictPosSlots.TryGetValue(sTraitPos' out rgsSlots))  					{  						rgsSlots = new List<string>();  						dictPosSlots.Add(sTraitPos' rgsSlots);  					}  					rgsSlots.Add(trait.Value);  				}  				else if (trait.Name.EndsWith("-infl-class") || trait.Name.EndsWith("-InflectionClass"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-infl-class") ? 11 : 16);  					string sTraitPos = trait.Name.Substring(0' len);  					List<string> rgsInflClasses;  					if (!dictPosInflClasses.TryGetValue(sTraitPos' out rgsInflClasses))  					{  						rgsInflClasses = new List<string>();  						dictPosInflClasses.Add(sTraitPos' rgsInflClasses);  					}  					rgsInflClasses.Add(trait.Value);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SenseGramInfoConflicts,The following statement contains a magic number: foreach (LiftTrait trait in gram.Traits)  			{  				if (trait.Name == "type")  				{  					sType = trait.Value;  				}  				else if (trait.Name == RangeNames.sPartsOfSpeechOAold1 || trait.Name == RangeNames.sPartsOfSpeechOAold2)  				{  					sFromPOS = trait.Value;  				}  				else if (trait.Name.EndsWith("-slot") || trait.Name.EndsWith("-Slots"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-slot") ? 5 : 6);  					string sTraitPos = trait.Name.Substring(0' len);  					List<string> rgsSlots;  					if (!dictPosSlots.TryGetValue(sTraitPos' out rgsSlots))  					{  						rgsSlots = new List<string>();  						dictPosSlots.Add(sTraitPos' rgsSlots);  					}  					rgsSlots.Add(trait.Value);  				}  				else if (trait.Name.EndsWith("-infl-class") || trait.Name.EndsWith("-InflectionClass"))  				{  					int len = trait.Name.Length - (trait.Name.EndsWith("-infl-class") ? 11 : 16);  					string sTraitPos = trait.Name.Substring(0' len);  					List<string> rgsInflClasses;  					if (!dictPosInflClasses.TryGetValue(sTraitPos' out rgsInflClasses))  					{  						rgsInflClasses = new List<string>();  						dictPosInflClasses.Add(sTraitPos' rgsInflClasses);  					}  					rgsInflClasses.Add(trait.Value);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CopyPicture,The following statement contains a magic number: if (sFile.Length > 8)  			{  				var tpath = sFile.Substring(0' 9);  				if (tpath.ToLowerInvariant() == "pictures\\" || tpath.ToLowerInvariant() == "pictures/")  					ssFile = sFile.Substring(9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CopyPicture,The following statement contains a magic number: if (sFile.Length > 8)  			{  				var tpath = sFile.Substring(0' 9);  				if (tpath.ToLowerInvariant() == "pictures\\" || tpath.ToLowerInvariant() == "pictures/")  					ssFile = sFile.Substring(9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,CopyPicture,The following statement contains a magic number: if (sFile.Length > 8)  			{  				var tpath = sFile.Substring(0' 9);  				if (tpath.ToLowerInvariant() == "pictures\\" || tpath.ToLowerInvariant() == "pictures/")  					ssFile = sFile.Substring(9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindPicture,The following statement contains a magic number: if (sFile.Length > 9)  			{  				var tpath = sFile.Substring(0' 9).ToLowerInvariant();  				if (tpath == "pictures\\" || tpath == "pictures/")  					sFile = sFile.Substring(9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindPicture,The following statement contains a magic number: if (sFile.Length > 9)  			{  				var tpath = sFile.Substring(0' 9).ToLowerInvariant();  				if (tpath == "pictures\\" || tpath == "pictures/")  					sFile = sFile.Substring(9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindPicture,The following statement contains a magic number: if (sFile.Length > 9)  			{  				var tpath = sFile.Substring(0' 9).ToLowerInvariant();  				if (tpath == "pictures\\" || tpath == "pictures/")  					sFile = sFile.Substring(9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindPicture,The following statement contains a magic number: foreach (ICmPicture pict in rgpictures)  			{  				if (pict.PictureFileRA == null)  					continue;	// should NEVER happen!  				var fpath = pict.PictureFileRA.InternalPath;  				if (fpath == null)  					continue;  				if (fpath.Length > 9)  				{  					var tpath = fpath.Substring(0' 9).ToLowerInvariant();  					if (tpath == "pictures\\" || tpath == "pictures/")  						fpath = fpath.Substring(9);  				}  				if (sFile == fpath)  				{  					int cCurrent = MultiTsStringMatches(pict.Caption' lmtLabel);  					if (cCurrent >= cMatches)  					{  						pictMatching = pict;  						cMatches = cCurrent;  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindPicture,The following statement contains a magic number: foreach (ICmPicture pict in rgpictures)  			{  				if (pict.PictureFileRA == null)  					continue;	// should NEVER happen!  				var fpath = pict.PictureFileRA.InternalPath;  				if (fpath == null)  					continue;  				if (fpath.Length > 9)  				{  					var tpath = fpath.Substring(0' 9).ToLowerInvariant();  					if (tpath == "pictures\\" || tpath == "pictures/")  						fpath = fpath.Substring(9);  				}  				if (sFile == fpath)  				{  					int cCurrent = MultiTsStringMatches(pict.Caption' lmtLabel);  					if (cCurrent >= cMatches)  					{  						pictMatching = pict;  						cMatches = cCurrent;  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,FindPicture,The following statement contains a magic number: foreach (ICmPicture pict in rgpictures)  			{  				if (pict.PictureFileRA == null)  					continue;	// should NEVER happen!  				var fpath = pict.PictureFileRA.InternalPath;  				if (fpath == null)  					continue;  				if (fpath.Length > 9)  				{  					var tpath = fpath.Substring(0' 9).ToLowerInvariant();  					if (tpath == "pictures\\" || tpath == "pictures/")  						fpath = fpath.Substring(9);  				}  				if (sFile == fpath)  				{  					int cCurrent = MultiTsStringMatches(pict.Caption' lmtLabel);  					if (cCurrent >= cMatches)  					{  						pictMatching = pict;  						cMatches = cCurrent;  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FeatureStructureTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\FeatureStructureTreeView.cs,OnMouseUp,The following statement contains a magic number: if (mea.Button == MouseButtons.Left)  			{  				TreeView tv = (TreeView) obj;  				FeatureTreeNode tn = (FeatureTreeNode)tv.GetNodeAt(mea.X' mea.Y);  				if (tn != null)  				{  					Rectangle rec = tn.Bounds;  					rec.X += -18;       // include the image bitmap (16 pixels plus 2 pixels between the image and the text)  					rec.Width += 18;  					if (rec.Contains(mea.X' mea.Y))  					{  						HandleCheckBoxNodes(tv' tn);  						//int i = tn.ImageIndex;  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FeatureStructureTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\FeatureStructureTreeView.cs,OnMouseUp,The following statement contains a magic number: if (mea.Button == MouseButtons.Left)  			{  				TreeView tv = (TreeView) obj;  				FeatureTreeNode tn = (FeatureTreeNode)tv.GetNodeAt(mea.X' mea.Y);  				if (tn != null)  				{  					Rectangle rec = tn.Bounds;  					rec.X += -18;       // include the image bitmap (16 pixels plus 2 pixels between the image and the text)  					rec.Width += 18;  					if (rec.Contains(mea.X' mea.Y))  					{  						HandleCheckBoxNodes(tv' tn);  						//int i = tn.ImageIndex;  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,FeatureStructureTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\FeatureStructureTreeView.cs,InitializeComponent,The following statement contains a magic number: this.imageList1.Images.SetKeyName(2' "");
Magic Number,SIL.FieldWorks.LexText.Controls,FeatureStructureTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\FeatureStructureTreeView.cs,InitializeComponent,The following statement contains a magic number: this.imageList1.Images.SetKeyName(3' "");
Magic Number,SIL.FieldWorks.LexText.Controls,LiftImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftImportDlg.cs,DoImport,The following statement contains a magic number: using (new WaitCursor(this))  			{  				using (var progressDlg = new ProgressDialogWithTask(this))  				{  					progressDlg.Minimum = 0;  					progressDlg.Maximum = 100;  					progressDlg.AllowCancel = true;  					progressDlg.Restartable = true;  					progressDlg.Title = String.Format(LexTextControls.ksImportingFrom0' tbPath.Text);  					try  					{  						m_cache.DomainDataByFlid.BeginNonUndoableTask();  						m_sLogFile = (string)progressDlg.RunTask(true' ImportLIFT' tbPath.Text);  					}  					finally  					{  						// This can indirectly try to access Views code in all the PropChanged  						// handling.  This is why the UOW handling has been moved from ImportLIFT  						// (which executes on a different thread).  See FWR-3057.  						m_cache.DomainDataByFlid.EndNonUndoableTask();  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,AdjustWidthForLinkLabelGroupBox,The following statement contains a magic number: int needWidth = m_lnkAssistant.Location.X + m_lnkAssistant.Width + 2;
Magic Number,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The following statement contains a magic number: try  			{  				IVwStylesheet stylesheet = FontHeightAdjuster.StyleSheetFromPropertyTable(m_propertyTable);  				var xnWindow = m_propertyTable.GetValue<XmlNode>("WindowConfiguration");  				XmlNode configNode = xnWindow.SelectSingleNode("controls/parameters/guicontrol[@id=\"matchingEntries\"]/parameters");    				SearchEngine searchEngine = SearchEngine.Get(m_mediator' m_propertyTable' "InsertEntrySearchEngine"' () => new InsertEntrySearchEngine(cache));    				m_matchingObjectsBrowser.Initialize(cache' stylesheet' m_mediator' m_propertyTable' configNode'  					searchEngine);    				m_cache = cache;    				m_fNewlyCreated = false;  				m_oldForm = "";    				// Set fonts for the two edit boxes.  				if (stylesheet != null)  				{  					m_tbLexicalForm.StyleSheet = stylesheet;  					m_tbGloss.StyleSheet = stylesheet;  				}    				// Set writing system factory and code for the two edit boxes.  				IWritingSystemContainer wsContainer = cache.ServiceLocator.WritingSystems;  				CoreWritingSystemDefinition defAnalWs = wsContainer.DefaultAnalysisWritingSystem;  				CoreWritingSystemDefinition defVernWs = wsContainer.DefaultVernacularWritingSystem;  				m_tbLexicalForm.WritingSystemFactory = cache.WritingSystemFactory;  				m_tbGloss.WritingSystemFactory = cache.WritingSystemFactory;    				m_tbLexicalForm.AdjustStringHeight = false;  				m_tbGloss.AdjustStringHeight = false;    				if (wsVern <= 0)  					wsVern = defVernWs.Handle;  				// initialize to empty TsStrings  				//we need to use the wsVern so that tbLexicalForm is sized correctly for the font size.  				//In Interlinear text the baseline can be in any of the vernacular writing systems' not just  				//the defaultVernacularWritingSystem.  				ITsString tssForm = TsStringUtils.EmptyString(wsVern);  				ITsString tssGloss = TsStringUtils.EmptyString(defAnalWs.Handle);    				using (m_updateTextMonitor.Enter())  				{  					m_tbLexicalForm.WritingSystemCode = wsVern;  					m_tbGloss.WritingSystemCode = defAnalWs.Handle;    					TssForm = tssForm;  					TssGloss = tssGloss;  				}    				// start building index  				m_matchingObjectsBrowser.SearchAsync(BuildSearchFieldArray(tssForm' tssGloss));    				((ISupportInitialize)(m_tbLexicalForm)).EndInit();  				((ISupportInitialize)(m_tbGloss)).EndInit();    				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsVerns' false).Count > 1)  				{  					msLexicalForm = ReplaceTextBoxWithMultiStringBox(m_tbLexicalForm' WritingSystemServices.kwsVerns' stylesheet);  					msLexicalForm.TextChanged += tbLexicalForm_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the lexical form  					AdjustTextBoxAndDialogHeight(m_tbLexicalForm);  				}    				// JohnT addition: if multiple analysis writing systems' replace tbGloss with msGloss  				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsAnals' false).Count > 1)  				{  					msGloss = ReplaceTextBoxWithMultiStringBox(m_tbGloss' WritingSystemServices.kwsAnals' stylesheet);  					m_lnkAssistant.Top = msGloss.Bottom - m_lnkAssistant.Height;  					msGloss.TextChanged += tbGloss_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the gloss  					AdjustTextBoxAndDialogHeight(m_tbGloss);  				}    				m_msaGroupBox.Initialize(cache' m_mediator' m_propertyTable' m_lnkAssistant' this);  				// See if we need to adjust the height of the MSA group box.  				int oldHeight = m_msaGroupBox.Height;  				int newHeight = Math.Max(m_msaGroupBox.PreferredHeight' oldHeight);  				GrowDialogAndAdjustControls(newHeight - oldHeight' m_msaGroupBox);  				m_msaGroupBox.AdjustInternalControlsAndGrow();    				Text = GetTitle();  				m_lnkAssistant.Enabled = false;  				// Set font for the combobox.  				m_cbMorphType.Font = new Font(defAnalWs.DefaultFontName' 12);    				// Populate morph type combo.  				// first Fill ComplexFormType combo' since cbMorphType controls  				// whether it gets enabled and which index is selected.  				m_cbComplexFormType.Font = new Font(defAnalWs.DefaultFontName' 12);  				var rgComplexTypes = new List<ICmPossibility>(m_cache.LangProject.LexDbOA.ComplexEntryTypesOA.ReallyReallyAllPossibilities.ToArray());  				rgComplexTypes.Sort();  				m_idxNotComplex = m_cbComplexFormType.Items.Count;  				m_cbComplexFormType.Items.Add(new DummyEntryType(LexTextControls.ksNotApplicable' false));  				for (int i = 0; i < rgComplexTypes.Count; ++i)  				{  					var type = (ILexEntryType)rgComplexTypes[i];  					m_cbComplexFormType.Items.Add(type);  				}  				m_cbComplexFormType.SelectedIndex = 0;  				m_cbComplexFormType.Visible = true;  				m_cbComplexFormType.Enabled = true;  				// Convert from Set to List' since the Set can't sort.    				var al = new List<IMoMorphType>();  				foreach (IMoMorphType mType in m_cache.LanguageProject.LexDbOA.MorphTypesOA.ReallyReallyAllPossibilities.Cast<IMoMorphType>())  				{  					switch (filter)  					{  						case MorphTypeFilterType.Prefix:  							if (mType.IsPrefixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Suffix:  							if (mType.IsSuffixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Any:  							al.Add(mType);  							break;  					}  				}  				al.Sort();  				for (int i = 0; i < al.Count; ++i)  				{  					m_cbMorphType.Items.Add(al[i]);  					if (al[i] == morphType)  						m_cbMorphType.SelectedIndex = i;  				}    				m_morphType = morphType; // Is this still needed?  				m_msaGroupBox.MorphTypePreference = m_morphType;  				// Now position the searching animation  				/*  					* This position put the animation over the Glossing Assistant button. LT-9146  				m_searchAnimation.Top = groupBox2.Top - m_searchAnimation.Height - 5;  				m_searchAnimation.Left = groupBox2.Right - m_searchAnimation.Width - 10;  					*/  				/* This position puts the animation over the top left corner' but will that  					* look okay with right-to-left?  				m_searchAnimation.Top = groupBox2.Top + 40;  				m_searchAnimation.Left = groupBox2.Left + 10;  					*/  				// This position puts the animation close to the middle of the list.  				m_searchAnimation.Top = m_matchingEntriesGroupBox.Top + (m_matchingEntriesGroupBox.Height / 2) - (m_searchAnimation.Height / 2);  				m_searchAnimation.Left = m_matchingEntriesGroupBox.Left + (m_matchingEntriesGroupBox.Width / 2) - (m_searchAnimation.Width / 2);  			}  			catch(Exception e)  			{  				MessageBox.Show(e.ToString());  				MessageBox.Show(e.StackTrace);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The following statement contains a magic number: try  			{  				IVwStylesheet stylesheet = FontHeightAdjuster.StyleSheetFromPropertyTable(m_propertyTable);  				var xnWindow = m_propertyTable.GetValue<XmlNode>("WindowConfiguration");  				XmlNode configNode = xnWindow.SelectSingleNode("controls/parameters/guicontrol[@id=\"matchingEntries\"]/parameters");    				SearchEngine searchEngine = SearchEngine.Get(m_mediator' m_propertyTable' "InsertEntrySearchEngine"' () => new InsertEntrySearchEngine(cache));    				m_matchingObjectsBrowser.Initialize(cache' stylesheet' m_mediator' m_propertyTable' configNode'  					searchEngine);    				m_cache = cache;    				m_fNewlyCreated = false;  				m_oldForm = "";    				// Set fonts for the two edit boxes.  				if (stylesheet != null)  				{  					m_tbLexicalForm.StyleSheet = stylesheet;  					m_tbGloss.StyleSheet = stylesheet;  				}    				// Set writing system factory and code for the two edit boxes.  				IWritingSystemContainer wsContainer = cache.ServiceLocator.WritingSystems;  				CoreWritingSystemDefinition defAnalWs = wsContainer.DefaultAnalysisWritingSystem;  				CoreWritingSystemDefinition defVernWs = wsContainer.DefaultVernacularWritingSystem;  				m_tbLexicalForm.WritingSystemFactory = cache.WritingSystemFactory;  				m_tbGloss.WritingSystemFactory = cache.WritingSystemFactory;    				m_tbLexicalForm.AdjustStringHeight = false;  				m_tbGloss.AdjustStringHeight = false;    				if (wsVern <= 0)  					wsVern = defVernWs.Handle;  				// initialize to empty TsStrings  				//we need to use the wsVern so that tbLexicalForm is sized correctly for the font size.  				//In Interlinear text the baseline can be in any of the vernacular writing systems' not just  				//the defaultVernacularWritingSystem.  				ITsString tssForm = TsStringUtils.EmptyString(wsVern);  				ITsString tssGloss = TsStringUtils.EmptyString(defAnalWs.Handle);    				using (m_updateTextMonitor.Enter())  				{  					m_tbLexicalForm.WritingSystemCode = wsVern;  					m_tbGloss.WritingSystemCode = defAnalWs.Handle;    					TssForm = tssForm;  					TssGloss = tssGloss;  				}    				// start building index  				m_matchingObjectsBrowser.SearchAsync(BuildSearchFieldArray(tssForm' tssGloss));    				((ISupportInitialize)(m_tbLexicalForm)).EndInit();  				((ISupportInitialize)(m_tbGloss)).EndInit();    				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsVerns' false).Count > 1)  				{  					msLexicalForm = ReplaceTextBoxWithMultiStringBox(m_tbLexicalForm' WritingSystemServices.kwsVerns' stylesheet);  					msLexicalForm.TextChanged += tbLexicalForm_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the lexical form  					AdjustTextBoxAndDialogHeight(m_tbLexicalForm);  				}    				// JohnT addition: if multiple analysis writing systems' replace tbGloss with msGloss  				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsAnals' false).Count > 1)  				{  					msGloss = ReplaceTextBoxWithMultiStringBox(m_tbGloss' WritingSystemServices.kwsAnals' stylesheet);  					m_lnkAssistant.Top = msGloss.Bottom - m_lnkAssistant.Height;  					msGloss.TextChanged += tbGloss_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the gloss  					AdjustTextBoxAndDialogHeight(m_tbGloss);  				}    				m_msaGroupBox.Initialize(cache' m_mediator' m_propertyTable' m_lnkAssistant' this);  				// See if we need to adjust the height of the MSA group box.  				int oldHeight = m_msaGroupBox.Height;  				int newHeight = Math.Max(m_msaGroupBox.PreferredHeight' oldHeight);  				GrowDialogAndAdjustControls(newHeight - oldHeight' m_msaGroupBox);  				m_msaGroupBox.AdjustInternalControlsAndGrow();    				Text = GetTitle();  				m_lnkAssistant.Enabled = false;  				// Set font for the combobox.  				m_cbMorphType.Font = new Font(defAnalWs.DefaultFontName' 12);    				// Populate morph type combo.  				// first Fill ComplexFormType combo' since cbMorphType controls  				// whether it gets enabled and which index is selected.  				m_cbComplexFormType.Font = new Font(defAnalWs.DefaultFontName' 12);  				var rgComplexTypes = new List<ICmPossibility>(m_cache.LangProject.LexDbOA.ComplexEntryTypesOA.ReallyReallyAllPossibilities.ToArray());  				rgComplexTypes.Sort();  				m_idxNotComplex = m_cbComplexFormType.Items.Count;  				m_cbComplexFormType.Items.Add(new DummyEntryType(LexTextControls.ksNotApplicable' false));  				for (int i = 0; i < rgComplexTypes.Count; ++i)  				{  					var type = (ILexEntryType)rgComplexTypes[i];  					m_cbComplexFormType.Items.Add(type);  				}  				m_cbComplexFormType.SelectedIndex = 0;  				m_cbComplexFormType.Visible = true;  				m_cbComplexFormType.Enabled = true;  				// Convert from Set to List' since the Set can't sort.    				var al = new List<IMoMorphType>();  				foreach (IMoMorphType mType in m_cache.LanguageProject.LexDbOA.MorphTypesOA.ReallyReallyAllPossibilities.Cast<IMoMorphType>())  				{  					switch (filter)  					{  						case MorphTypeFilterType.Prefix:  							if (mType.IsPrefixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Suffix:  							if (mType.IsSuffixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Any:  							al.Add(mType);  							break;  					}  				}  				al.Sort();  				for (int i = 0; i < al.Count; ++i)  				{  					m_cbMorphType.Items.Add(al[i]);  					if (al[i] == morphType)  						m_cbMorphType.SelectedIndex = i;  				}    				m_morphType = morphType; // Is this still needed?  				m_msaGroupBox.MorphTypePreference = m_morphType;  				// Now position the searching animation  				/*  					* This position put the animation over the Glossing Assistant button. LT-9146  				m_searchAnimation.Top = groupBox2.Top - m_searchAnimation.Height - 5;  				m_searchAnimation.Left = groupBox2.Right - m_searchAnimation.Width - 10;  					*/  				/* This position puts the animation over the top left corner' but will that  					* look okay with right-to-left?  				m_searchAnimation.Top = groupBox2.Top + 40;  				m_searchAnimation.Left = groupBox2.Left + 10;  					*/  				// This position puts the animation close to the middle of the list.  				m_searchAnimation.Top = m_matchingEntriesGroupBox.Top + (m_matchingEntriesGroupBox.Height / 2) - (m_searchAnimation.Height / 2);  				m_searchAnimation.Left = m_matchingEntriesGroupBox.Left + (m_matchingEntriesGroupBox.Width / 2) - (m_searchAnimation.Width / 2);  			}  			catch(Exception e)  			{  				MessageBox.Show(e.ToString());  				MessageBox.Show(e.StackTrace);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The following statement contains a magic number: try  			{  				IVwStylesheet stylesheet = FontHeightAdjuster.StyleSheetFromPropertyTable(m_propertyTable);  				var xnWindow = m_propertyTable.GetValue<XmlNode>("WindowConfiguration");  				XmlNode configNode = xnWindow.SelectSingleNode("controls/parameters/guicontrol[@id=\"matchingEntries\"]/parameters");    				SearchEngine searchEngine = SearchEngine.Get(m_mediator' m_propertyTable' "InsertEntrySearchEngine"' () => new InsertEntrySearchEngine(cache));    				m_matchingObjectsBrowser.Initialize(cache' stylesheet' m_mediator' m_propertyTable' configNode'  					searchEngine);    				m_cache = cache;    				m_fNewlyCreated = false;  				m_oldForm = "";    				// Set fonts for the two edit boxes.  				if (stylesheet != null)  				{  					m_tbLexicalForm.StyleSheet = stylesheet;  					m_tbGloss.StyleSheet = stylesheet;  				}    				// Set writing system factory and code for the two edit boxes.  				IWritingSystemContainer wsContainer = cache.ServiceLocator.WritingSystems;  				CoreWritingSystemDefinition defAnalWs = wsContainer.DefaultAnalysisWritingSystem;  				CoreWritingSystemDefinition defVernWs = wsContainer.DefaultVernacularWritingSystem;  				m_tbLexicalForm.WritingSystemFactory = cache.WritingSystemFactory;  				m_tbGloss.WritingSystemFactory = cache.WritingSystemFactory;    				m_tbLexicalForm.AdjustStringHeight = false;  				m_tbGloss.AdjustStringHeight = false;    				if (wsVern <= 0)  					wsVern = defVernWs.Handle;  				// initialize to empty TsStrings  				//we need to use the wsVern so that tbLexicalForm is sized correctly for the font size.  				//In Interlinear text the baseline can be in any of the vernacular writing systems' not just  				//the defaultVernacularWritingSystem.  				ITsString tssForm = TsStringUtils.EmptyString(wsVern);  				ITsString tssGloss = TsStringUtils.EmptyString(defAnalWs.Handle);    				using (m_updateTextMonitor.Enter())  				{  					m_tbLexicalForm.WritingSystemCode = wsVern;  					m_tbGloss.WritingSystemCode = defAnalWs.Handle;    					TssForm = tssForm;  					TssGloss = tssGloss;  				}    				// start building index  				m_matchingObjectsBrowser.SearchAsync(BuildSearchFieldArray(tssForm' tssGloss));    				((ISupportInitialize)(m_tbLexicalForm)).EndInit();  				((ISupportInitialize)(m_tbGloss)).EndInit();    				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsVerns' false).Count > 1)  				{  					msLexicalForm = ReplaceTextBoxWithMultiStringBox(m_tbLexicalForm' WritingSystemServices.kwsVerns' stylesheet);  					msLexicalForm.TextChanged += tbLexicalForm_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the lexical form  					AdjustTextBoxAndDialogHeight(m_tbLexicalForm);  				}    				// JohnT addition: if multiple analysis writing systems' replace tbGloss with msGloss  				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsAnals' false).Count > 1)  				{  					msGloss = ReplaceTextBoxWithMultiStringBox(m_tbGloss' WritingSystemServices.kwsAnals' stylesheet);  					m_lnkAssistant.Top = msGloss.Bottom - m_lnkAssistant.Height;  					msGloss.TextChanged += tbGloss_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the gloss  					AdjustTextBoxAndDialogHeight(m_tbGloss);  				}    				m_msaGroupBox.Initialize(cache' m_mediator' m_propertyTable' m_lnkAssistant' this);  				// See if we need to adjust the height of the MSA group box.  				int oldHeight = m_msaGroupBox.Height;  				int newHeight = Math.Max(m_msaGroupBox.PreferredHeight' oldHeight);  				GrowDialogAndAdjustControls(newHeight - oldHeight' m_msaGroupBox);  				m_msaGroupBox.AdjustInternalControlsAndGrow();    				Text = GetTitle();  				m_lnkAssistant.Enabled = false;  				// Set font for the combobox.  				m_cbMorphType.Font = new Font(defAnalWs.DefaultFontName' 12);    				// Populate morph type combo.  				// first Fill ComplexFormType combo' since cbMorphType controls  				// whether it gets enabled and which index is selected.  				m_cbComplexFormType.Font = new Font(defAnalWs.DefaultFontName' 12);  				var rgComplexTypes = new List<ICmPossibility>(m_cache.LangProject.LexDbOA.ComplexEntryTypesOA.ReallyReallyAllPossibilities.ToArray());  				rgComplexTypes.Sort();  				m_idxNotComplex = m_cbComplexFormType.Items.Count;  				m_cbComplexFormType.Items.Add(new DummyEntryType(LexTextControls.ksNotApplicable' false));  				for (int i = 0; i < rgComplexTypes.Count; ++i)  				{  					var type = (ILexEntryType)rgComplexTypes[i];  					m_cbComplexFormType.Items.Add(type);  				}  				m_cbComplexFormType.SelectedIndex = 0;  				m_cbComplexFormType.Visible = true;  				m_cbComplexFormType.Enabled = true;  				// Convert from Set to List' since the Set can't sort.    				var al = new List<IMoMorphType>();  				foreach (IMoMorphType mType in m_cache.LanguageProject.LexDbOA.MorphTypesOA.ReallyReallyAllPossibilities.Cast<IMoMorphType>())  				{  					switch (filter)  					{  						case MorphTypeFilterType.Prefix:  							if (mType.IsPrefixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Suffix:  							if (mType.IsSuffixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Any:  							al.Add(mType);  							break;  					}  				}  				al.Sort();  				for (int i = 0; i < al.Count; ++i)  				{  					m_cbMorphType.Items.Add(al[i]);  					if (al[i] == morphType)  						m_cbMorphType.SelectedIndex = i;  				}    				m_morphType = morphType; // Is this still needed?  				m_msaGroupBox.MorphTypePreference = m_morphType;  				// Now position the searching animation  				/*  					* This position put the animation over the Glossing Assistant button. LT-9146  				m_searchAnimation.Top = groupBox2.Top - m_searchAnimation.Height - 5;  				m_searchAnimation.Left = groupBox2.Right - m_searchAnimation.Width - 10;  					*/  				/* This position puts the animation over the top left corner' but will that  					* look okay with right-to-left?  				m_searchAnimation.Top = groupBox2.Top + 40;  				m_searchAnimation.Left = groupBox2.Left + 10;  					*/  				// This position puts the animation close to the middle of the list.  				m_searchAnimation.Top = m_matchingEntriesGroupBox.Top + (m_matchingEntriesGroupBox.Height / 2) - (m_searchAnimation.Height / 2);  				m_searchAnimation.Left = m_matchingEntriesGroupBox.Left + (m_matchingEntriesGroupBox.Width / 2) - (m_searchAnimation.Width / 2);  			}  			catch(Exception e)  			{  				MessageBox.Show(e.ToString());  				MessageBox.Show(e.StackTrace);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The following statement contains a magic number: try  			{  				IVwStylesheet stylesheet = FontHeightAdjuster.StyleSheetFromPropertyTable(m_propertyTable);  				var xnWindow = m_propertyTable.GetValue<XmlNode>("WindowConfiguration");  				XmlNode configNode = xnWindow.SelectSingleNode("controls/parameters/guicontrol[@id=\"matchingEntries\"]/parameters");    				SearchEngine searchEngine = SearchEngine.Get(m_mediator' m_propertyTable' "InsertEntrySearchEngine"' () => new InsertEntrySearchEngine(cache));    				m_matchingObjectsBrowser.Initialize(cache' stylesheet' m_mediator' m_propertyTable' configNode'  					searchEngine);    				m_cache = cache;    				m_fNewlyCreated = false;  				m_oldForm = "";    				// Set fonts for the two edit boxes.  				if (stylesheet != null)  				{  					m_tbLexicalForm.StyleSheet = stylesheet;  					m_tbGloss.StyleSheet = stylesheet;  				}    				// Set writing system factory and code for the two edit boxes.  				IWritingSystemContainer wsContainer = cache.ServiceLocator.WritingSystems;  				CoreWritingSystemDefinition defAnalWs = wsContainer.DefaultAnalysisWritingSystem;  				CoreWritingSystemDefinition defVernWs = wsContainer.DefaultVernacularWritingSystem;  				m_tbLexicalForm.WritingSystemFactory = cache.WritingSystemFactory;  				m_tbGloss.WritingSystemFactory = cache.WritingSystemFactory;    				m_tbLexicalForm.AdjustStringHeight = false;  				m_tbGloss.AdjustStringHeight = false;    				if (wsVern <= 0)  					wsVern = defVernWs.Handle;  				// initialize to empty TsStrings  				//we need to use the wsVern so that tbLexicalForm is sized correctly for the font size.  				//In Interlinear text the baseline can be in any of the vernacular writing systems' not just  				//the defaultVernacularWritingSystem.  				ITsString tssForm = TsStringUtils.EmptyString(wsVern);  				ITsString tssGloss = TsStringUtils.EmptyString(defAnalWs.Handle);    				using (m_updateTextMonitor.Enter())  				{  					m_tbLexicalForm.WritingSystemCode = wsVern;  					m_tbGloss.WritingSystemCode = defAnalWs.Handle;    					TssForm = tssForm;  					TssGloss = tssGloss;  				}    				// start building index  				m_matchingObjectsBrowser.SearchAsync(BuildSearchFieldArray(tssForm' tssGloss));    				((ISupportInitialize)(m_tbLexicalForm)).EndInit();  				((ISupportInitialize)(m_tbGloss)).EndInit();    				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsVerns' false).Count > 1)  				{  					msLexicalForm = ReplaceTextBoxWithMultiStringBox(m_tbLexicalForm' WritingSystemServices.kwsVerns' stylesheet);  					msLexicalForm.TextChanged += tbLexicalForm_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the lexical form  					AdjustTextBoxAndDialogHeight(m_tbLexicalForm);  				}    				// JohnT addition: if multiple analysis writing systems' replace tbGloss with msGloss  				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsAnals' false).Count > 1)  				{  					msGloss = ReplaceTextBoxWithMultiStringBox(m_tbGloss' WritingSystemServices.kwsAnals' stylesheet);  					m_lnkAssistant.Top = msGloss.Bottom - m_lnkAssistant.Height;  					msGloss.TextChanged += tbGloss_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the gloss  					AdjustTextBoxAndDialogHeight(m_tbGloss);  				}    				m_msaGroupBox.Initialize(cache' m_mediator' m_propertyTable' m_lnkAssistant' this);  				// See if we need to adjust the height of the MSA group box.  				int oldHeight = m_msaGroupBox.Height;  				int newHeight = Math.Max(m_msaGroupBox.PreferredHeight' oldHeight);  				GrowDialogAndAdjustControls(newHeight - oldHeight' m_msaGroupBox);  				m_msaGroupBox.AdjustInternalControlsAndGrow();    				Text = GetTitle();  				m_lnkAssistant.Enabled = false;  				// Set font for the combobox.  				m_cbMorphType.Font = new Font(defAnalWs.DefaultFontName' 12);    				// Populate morph type combo.  				// first Fill ComplexFormType combo' since cbMorphType controls  				// whether it gets enabled and which index is selected.  				m_cbComplexFormType.Font = new Font(defAnalWs.DefaultFontName' 12);  				var rgComplexTypes = new List<ICmPossibility>(m_cache.LangProject.LexDbOA.ComplexEntryTypesOA.ReallyReallyAllPossibilities.ToArray());  				rgComplexTypes.Sort();  				m_idxNotComplex = m_cbComplexFormType.Items.Count;  				m_cbComplexFormType.Items.Add(new DummyEntryType(LexTextControls.ksNotApplicable' false));  				for (int i = 0; i < rgComplexTypes.Count; ++i)  				{  					var type = (ILexEntryType)rgComplexTypes[i];  					m_cbComplexFormType.Items.Add(type);  				}  				m_cbComplexFormType.SelectedIndex = 0;  				m_cbComplexFormType.Visible = true;  				m_cbComplexFormType.Enabled = true;  				// Convert from Set to List' since the Set can't sort.    				var al = new List<IMoMorphType>();  				foreach (IMoMorphType mType in m_cache.LanguageProject.LexDbOA.MorphTypesOA.ReallyReallyAllPossibilities.Cast<IMoMorphType>())  				{  					switch (filter)  					{  						case MorphTypeFilterType.Prefix:  							if (mType.IsPrefixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Suffix:  							if (mType.IsSuffixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Any:  							al.Add(mType);  							break;  					}  				}  				al.Sort();  				for (int i = 0; i < al.Count; ++i)  				{  					m_cbMorphType.Items.Add(al[i]);  					if (al[i] == morphType)  						m_cbMorphType.SelectedIndex = i;  				}    				m_morphType = morphType; // Is this still needed?  				m_msaGroupBox.MorphTypePreference = m_morphType;  				// Now position the searching animation  				/*  					* This position put the animation over the Glossing Assistant button. LT-9146  				m_searchAnimation.Top = groupBox2.Top - m_searchAnimation.Height - 5;  				m_searchAnimation.Left = groupBox2.Right - m_searchAnimation.Width - 10;  					*/  				/* This position puts the animation over the top left corner' but will that  					* look okay with right-to-left?  				m_searchAnimation.Top = groupBox2.Top + 40;  				m_searchAnimation.Left = groupBox2.Left + 10;  					*/  				// This position puts the animation close to the middle of the list.  				m_searchAnimation.Top = m_matchingEntriesGroupBox.Top + (m_matchingEntriesGroupBox.Height / 2) - (m_searchAnimation.Height / 2);  				m_searchAnimation.Left = m_matchingEntriesGroupBox.Left + (m_matchingEntriesGroupBox.Width / 2) - (m_searchAnimation.Width / 2);  			}  			catch(Exception e)  			{  				MessageBox.Show(e.ToString());  				MessageBox.Show(e.StackTrace);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The following statement contains a magic number: try  			{  				IVwStylesheet stylesheet = FontHeightAdjuster.StyleSheetFromPropertyTable(m_propertyTable);  				var xnWindow = m_propertyTable.GetValue<XmlNode>("WindowConfiguration");  				XmlNode configNode = xnWindow.SelectSingleNode("controls/parameters/guicontrol[@id=\"matchingEntries\"]/parameters");    				SearchEngine searchEngine = SearchEngine.Get(m_mediator' m_propertyTable' "InsertEntrySearchEngine"' () => new InsertEntrySearchEngine(cache));    				m_matchingObjectsBrowser.Initialize(cache' stylesheet' m_mediator' m_propertyTable' configNode'  					searchEngine);    				m_cache = cache;    				m_fNewlyCreated = false;  				m_oldForm = "";    				// Set fonts for the two edit boxes.  				if (stylesheet != null)  				{  					m_tbLexicalForm.StyleSheet = stylesheet;  					m_tbGloss.StyleSheet = stylesheet;  				}    				// Set writing system factory and code for the two edit boxes.  				IWritingSystemContainer wsContainer = cache.ServiceLocator.WritingSystems;  				CoreWritingSystemDefinition defAnalWs = wsContainer.DefaultAnalysisWritingSystem;  				CoreWritingSystemDefinition defVernWs = wsContainer.DefaultVernacularWritingSystem;  				m_tbLexicalForm.WritingSystemFactory = cache.WritingSystemFactory;  				m_tbGloss.WritingSystemFactory = cache.WritingSystemFactory;    				m_tbLexicalForm.AdjustStringHeight = false;  				m_tbGloss.AdjustStringHeight = false;    				if (wsVern <= 0)  					wsVern = defVernWs.Handle;  				// initialize to empty TsStrings  				//we need to use the wsVern so that tbLexicalForm is sized correctly for the font size.  				//In Interlinear text the baseline can be in any of the vernacular writing systems' not just  				//the defaultVernacularWritingSystem.  				ITsString tssForm = TsStringUtils.EmptyString(wsVern);  				ITsString tssGloss = TsStringUtils.EmptyString(defAnalWs.Handle);    				using (m_updateTextMonitor.Enter())  				{  					m_tbLexicalForm.WritingSystemCode = wsVern;  					m_tbGloss.WritingSystemCode = defAnalWs.Handle;    					TssForm = tssForm;  					TssGloss = tssGloss;  				}    				// start building index  				m_matchingObjectsBrowser.SearchAsync(BuildSearchFieldArray(tssForm' tssGloss));    				((ISupportInitialize)(m_tbLexicalForm)).EndInit();  				((ISupportInitialize)(m_tbGloss)).EndInit();    				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsVerns' false).Count > 1)  				{  					msLexicalForm = ReplaceTextBoxWithMultiStringBox(m_tbLexicalForm' WritingSystemServices.kwsVerns' stylesheet);  					msLexicalForm.TextChanged += tbLexicalForm_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the lexical form  					AdjustTextBoxAndDialogHeight(m_tbLexicalForm);  				}    				// JohnT addition: if multiple analysis writing systems' replace tbGloss with msGloss  				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsAnals' false).Count > 1)  				{  					msGloss = ReplaceTextBoxWithMultiStringBox(m_tbGloss' WritingSystemServices.kwsAnals' stylesheet);  					m_lnkAssistant.Top = msGloss.Bottom - m_lnkAssistant.Height;  					msGloss.TextChanged += tbGloss_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the gloss  					AdjustTextBoxAndDialogHeight(m_tbGloss);  				}    				m_msaGroupBox.Initialize(cache' m_mediator' m_propertyTable' m_lnkAssistant' this);  				// See if we need to adjust the height of the MSA group box.  				int oldHeight = m_msaGroupBox.Height;  				int newHeight = Math.Max(m_msaGroupBox.PreferredHeight' oldHeight);  				GrowDialogAndAdjustControls(newHeight - oldHeight' m_msaGroupBox);  				m_msaGroupBox.AdjustInternalControlsAndGrow();    				Text = GetTitle();  				m_lnkAssistant.Enabled = false;  				// Set font for the combobox.  				m_cbMorphType.Font = new Font(defAnalWs.DefaultFontName' 12);    				// Populate morph type combo.  				// first Fill ComplexFormType combo' since cbMorphType controls  				// whether it gets enabled and which index is selected.  				m_cbComplexFormType.Font = new Font(defAnalWs.DefaultFontName' 12);  				var rgComplexTypes = new List<ICmPossibility>(m_cache.LangProject.LexDbOA.ComplexEntryTypesOA.ReallyReallyAllPossibilities.ToArray());  				rgComplexTypes.Sort();  				m_idxNotComplex = m_cbComplexFormType.Items.Count;  				m_cbComplexFormType.Items.Add(new DummyEntryType(LexTextControls.ksNotApplicable' false));  				for (int i = 0; i < rgComplexTypes.Count; ++i)  				{  					var type = (ILexEntryType)rgComplexTypes[i];  					m_cbComplexFormType.Items.Add(type);  				}  				m_cbComplexFormType.SelectedIndex = 0;  				m_cbComplexFormType.Visible = true;  				m_cbComplexFormType.Enabled = true;  				// Convert from Set to List' since the Set can't sort.    				var al = new List<IMoMorphType>();  				foreach (IMoMorphType mType in m_cache.LanguageProject.LexDbOA.MorphTypesOA.ReallyReallyAllPossibilities.Cast<IMoMorphType>())  				{  					switch (filter)  					{  						case MorphTypeFilterType.Prefix:  							if (mType.IsPrefixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Suffix:  							if (mType.IsSuffixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Any:  							al.Add(mType);  							break;  					}  				}  				al.Sort();  				for (int i = 0; i < al.Count; ++i)  				{  					m_cbMorphType.Items.Add(al[i]);  					if (al[i] == morphType)  						m_cbMorphType.SelectedIndex = i;  				}    				m_morphType = morphType; // Is this still needed?  				m_msaGroupBox.MorphTypePreference = m_morphType;  				// Now position the searching animation  				/*  					* This position put the animation over the Glossing Assistant button. LT-9146  				m_searchAnimation.Top = groupBox2.Top - m_searchAnimation.Height - 5;  				m_searchAnimation.Left = groupBox2.Right - m_searchAnimation.Width - 10;  					*/  				/* This position puts the animation over the top left corner' but will that  					* look okay with right-to-left?  				m_searchAnimation.Top = groupBox2.Top + 40;  				m_searchAnimation.Left = groupBox2.Left + 10;  					*/  				// This position puts the animation close to the middle of the list.  				m_searchAnimation.Top = m_matchingEntriesGroupBox.Top + (m_matchingEntriesGroupBox.Height / 2) - (m_searchAnimation.Height / 2);  				m_searchAnimation.Left = m_matchingEntriesGroupBox.Left + (m_matchingEntriesGroupBox.Width / 2) - (m_searchAnimation.Width / 2);  			}  			catch(Exception e)  			{  				MessageBox.Show(e.ToString());  				MessageBox.Show(e.StackTrace);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The following statement contains a magic number: try  			{  				IVwStylesheet stylesheet = FontHeightAdjuster.StyleSheetFromPropertyTable(m_propertyTable);  				var xnWindow = m_propertyTable.GetValue<XmlNode>("WindowConfiguration");  				XmlNode configNode = xnWindow.SelectSingleNode("controls/parameters/guicontrol[@id=\"matchingEntries\"]/parameters");    				SearchEngine searchEngine = SearchEngine.Get(m_mediator' m_propertyTable' "InsertEntrySearchEngine"' () => new InsertEntrySearchEngine(cache));    				m_matchingObjectsBrowser.Initialize(cache' stylesheet' m_mediator' m_propertyTable' configNode'  					searchEngine);    				m_cache = cache;    				m_fNewlyCreated = false;  				m_oldForm = "";    				// Set fonts for the two edit boxes.  				if (stylesheet != null)  				{  					m_tbLexicalForm.StyleSheet = stylesheet;  					m_tbGloss.StyleSheet = stylesheet;  				}    				// Set writing system factory and code for the two edit boxes.  				IWritingSystemContainer wsContainer = cache.ServiceLocator.WritingSystems;  				CoreWritingSystemDefinition defAnalWs = wsContainer.DefaultAnalysisWritingSystem;  				CoreWritingSystemDefinition defVernWs = wsContainer.DefaultVernacularWritingSystem;  				m_tbLexicalForm.WritingSystemFactory = cache.WritingSystemFactory;  				m_tbGloss.WritingSystemFactory = cache.WritingSystemFactory;    				m_tbLexicalForm.AdjustStringHeight = false;  				m_tbGloss.AdjustStringHeight = false;    				if (wsVern <= 0)  					wsVern = defVernWs.Handle;  				// initialize to empty TsStrings  				//we need to use the wsVern so that tbLexicalForm is sized correctly for the font size.  				//In Interlinear text the baseline can be in any of the vernacular writing systems' not just  				//the defaultVernacularWritingSystem.  				ITsString tssForm = TsStringUtils.EmptyString(wsVern);  				ITsString tssGloss = TsStringUtils.EmptyString(defAnalWs.Handle);    				using (m_updateTextMonitor.Enter())  				{  					m_tbLexicalForm.WritingSystemCode = wsVern;  					m_tbGloss.WritingSystemCode = defAnalWs.Handle;    					TssForm = tssForm;  					TssGloss = tssGloss;  				}    				// start building index  				m_matchingObjectsBrowser.SearchAsync(BuildSearchFieldArray(tssForm' tssGloss));    				((ISupportInitialize)(m_tbLexicalForm)).EndInit();  				((ISupportInitialize)(m_tbGloss)).EndInit();    				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsVerns' false).Count > 1)  				{  					msLexicalForm = ReplaceTextBoxWithMultiStringBox(m_tbLexicalForm' WritingSystemServices.kwsVerns' stylesheet);  					msLexicalForm.TextChanged += tbLexicalForm_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the lexical form  					AdjustTextBoxAndDialogHeight(m_tbLexicalForm);  				}    				// JohnT addition: if multiple analysis writing systems' replace tbGloss with msGloss  				if (WritingSystemServices.GetWritingSystemList(m_cache' WritingSystemServices.kwsAnals' false).Count > 1)  				{  					msGloss = ReplaceTextBoxWithMultiStringBox(m_tbGloss' WritingSystemServices.kwsAnals' stylesheet);  					m_lnkAssistant.Top = msGloss.Bottom - m_lnkAssistant.Height;  					msGloss.TextChanged += tbGloss_TextChanged;  				}  				else  				{  					// See if we need to adjust the height of the gloss  					AdjustTextBoxAndDialogHeight(m_tbGloss);  				}    				m_msaGroupBox.Initialize(cache' m_mediator' m_propertyTable' m_lnkAssistant' this);  				// See if we need to adjust the height of the MSA group box.  				int oldHeight = m_msaGroupBox.Height;  				int newHeight = Math.Max(m_msaGroupBox.PreferredHeight' oldHeight);  				GrowDialogAndAdjustControls(newHeight - oldHeight' m_msaGroupBox);  				m_msaGroupBox.AdjustInternalControlsAndGrow();    				Text = GetTitle();  				m_lnkAssistant.Enabled = false;  				// Set font for the combobox.  				m_cbMorphType.Font = new Font(defAnalWs.DefaultFontName' 12);    				// Populate morph type combo.  				// first Fill ComplexFormType combo' since cbMorphType controls  				// whether it gets enabled and which index is selected.  				m_cbComplexFormType.Font = new Font(defAnalWs.DefaultFontName' 12);  				var rgComplexTypes = new List<ICmPossibility>(m_cache.LangProject.LexDbOA.ComplexEntryTypesOA.ReallyReallyAllPossibilities.ToArray());  				rgComplexTypes.Sort();  				m_idxNotComplex = m_cbComplexFormType.Items.Count;  				m_cbComplexFormType.Items.Add(new DummyEntryType(LexTextControls.ksNotApplicable' false));  				for (int i = 0; i < rgComplexTypes.Count; ++i)  				{  					var type = (ILexEntryType)rgComplexTypes[i];  					m_cbComplexFormType.Items.Add(type);  				}  				m_cbComplexFormType.SelectedIndex = 0;  				m_cbComplexFormType.Visible = true;  				m_cbComplexFormType.Enabled = true;  				// Convert from Set to List' since the Set can't sort.    				var al = new List<IMoMorphType>();  				foreach (IMoMorphType mType in m_cache.LanguageProject.LexDbOA.MorphTypesOA.ReallyReallyAllPossibilities.Cast<IMoMorphType>())  				{  					switch (filter)  					{  						case MorphTypeFilterType.Prefix:  							if (mType.IsPrefixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Suffix:  							if (mType.IsSuffixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Any:  							al.Add(mType);  							break;  					}  				}  				al.Sort();  				for (int i = 0; i < al.Count; ++i)  				{  					m_cbMorphType.Items.Add(al[i]);  					if (al[i] == morphType)  						m_cbMorphType.SelectedIndex = i;  				}    				m_morphType = morphType; // Is this still needed?  				m_msaGroupBox.MorphTypePreference = m_morphType;  				// Now position the searching animation  				/*  					* This position put the animation over the Glossing Assistant button. LT-9146  				m_searchAnimation.Top = groupBox2.Top - m_searchAnimation.Height - 5;  				m_searchAnimation.Left = groupBox2.Right - m_searchAnimation.Width - 10;  					*/  				/* This position puts the animation over the top left corner' but will that  					* look okay with right-to-left?  				m_searchAnimation.Top = groupBox2.Top + 40;  				m_searchAnimation.Left = groupBox2.Left + 10;  					*/  				// This position puts the animation close to the middle of the list.  				m_searchAnimation.Top = m_matchingEntriesGroupBox.Top + (m_matchingEntriesGroupBox.Height / 2) - (m_searchAnimation.Height / 2);  				m_searchAnimation.Left = m_matchingEntriesGroupBox.Left + (m_matchingEntriesGroupBox.Width / 2) - (m_searchAnimation.Width / 2);  			}  			catch(Exception e)  			{  				MessageBox.Show(e.ToString());  				MessageBox.Show(e.StackTrace);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_toolTipSlotCombo.AutoPopDelay = 5000;
Magic Number,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_toolTipSlotCombo.InitialDelay = 250;
Magic Number,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_toolTipSlotCombo.ReshowDelay = 100;
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: Debug.Assert(parameters.Length == 9);
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: int startPhase = (int)parameters[2];
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: string databaseFileName = (string)parameters[3];
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: int cEntries = (int)parameters[4];
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: m_fDisplayImportReport = (bool)parameters[5];
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: m_sPhase1HtmlReport = (string)parameters[6];
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: m_sPhase1FileName = (string)parameters[7];
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: var fCreateMissingLinks = (bool) parameters[8];
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,Import,The following statement contains a magic number: try  			{  				// if starting with a phase file' rename the phase file with the input file  				switch (startPhase)  				{  					case 1:  						sPhase1Output = databaseFileName;  						break;  					case 2:  						sPhase2Output = databaseFileName;  						break;  					case 3:  						sPhase3Output = databaseFileName;  						break;  					case 4:  						m_sPhase4Output = databaseFileName;  						break;  					default:  						break; // no renaming needed  				}    				if (startPhase < 2)  				{  					dlg.Title = String.Format(LexTextControls.ksImportingXEntriesFromY'  						cEntries' processedInputFile);  					dlg.Message = String.Format(LexTextControls.ksPhase1ofX_Preview' lastStep);  					sErrorMsg = LexTextControls.ksTransformProblemPhase1_X;  					DoTransform(m_sBuildPhase2XSLT' sPhase1Output' m_sPhase2XSLT);  				}  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase2_X;  				dlg.Message = String.Format(LexTextControls.ksPhase2ofX' lastStep);  				if (startPhase < 2)  					DoTransform(m_sPhase2XSLT' sPhase1Output' sPhase2Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase3_X;  				dlg.Message = String.Format(LexTextControls.ksPhase3ofX' lastStep);  				if (startPhase < 3)  					DoTransform(m_sPhase3XSLT' sPhase2Output' sPhase3Output);  				dlg.Step(10);  				if (dlg.Canceled)  					return false;    				sErrorMsg = LexTextControls.ksTransformProblemPhase4_X;  				dlg.Message = String.Format(LexTextControls.ksPhase4ofX' lastStep);  				if (startPhase < 4)  					DoTransform(m_sPhase4XSLT' sPhase3Output' m_sPhase4Output);  				dlg.Step(20);  				if (dlg.Canceled)  					return false;    				if (runToCompletion)  				{  					sErrorMsg = LexTextControls.ksXmlParsingProblem5_X;  					dlg.Message = LexTextControls.ksPhase5of5_LoadingData;  					if (dlg.Canceled)  						return false;  					dlg.Step(1);  					// There's no way to cancel from here on out.  					dlg.AllowCancel = false;  					xid = new XmlImportData(m_cache' fCreateMissingLinks);  					fAttemptedXml = true;  					if (startPhase == 4 && processedInputFile.Length == 0)  						processedInputFile = m_sPhase4Output;  					xid.ImportData(m_sPhase4Output' dlg);  					sErrorMsg = LexTextControls.ksLogFileProblem5_X;  					ProcessLogFile(processedInputFile' startPhase' xid);  					return true;  				}  			}  			catch (Exception ex)  			{  				Debug.WriteLine("Error: " + ex.Message);    				ReportError(string.Format(sErrorMsg' ex.Message)' LexTextControls.ksUnhandledError);    				if (fAttemptedXml)  				{  					// We want to see the log file even (especially) if the Xml blows up.  					ProcessLogFile(processedInputFile' startPhase' xid);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImport,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImport.cs,ProcessPhase4Log,The following statement contains a magic number: try  			{  				string sHtmlFile = Path.Combine(m_sTempDir' "ImportLog.htm");  				using (StreamWriter sw = File.CreateText(sHtmlFile))  				{  					sw.WriteLine("<html>");  					sw.WriteLine("<head>");  					sw.WriteLine("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>");  					string sHeadInfo = String.Format(LexTextControls.ksImportLogForX' inputFileName);  					sw.WriteLine(String.Format("  <title>{0}</title>"' sHeadInfo));  					// add the script  					string script = GetHtmlJavaScript();  					sw.WriteLine(script);  					// done adding the java script for jumping to errors  					sw.WriteLine("</head>");  					sw.WriteLine("<body>");  					sw.WriteLine(String.Format("<h2>{0}</h2>"' sHeadInfo));  					sw.WriteLine(String.Format("<h3>{0}</h3>"' LexTextControls.ksMessagesFromPreview));  					sw.WriteLine(m_sPhase1HtmlReport);  					string sInput;  					// LT-1901 : make a first pass through the log file and put all "Warning:" errors together  					bool bWarningFound = false;	// none yet  					string sWarning_ = LexTextControls.ksWarning_;	// localized version of "Warning:"  					string sInfo_ = LexTextControls.ksInfo_;		// localized version of "Info:"  					while ((sInput = sr.ReadLine()) != null)  					{  						ich = sInput.IndexOf(sWarning_);  						if (ich == -1)  							ich = sInput.IndexOf("Warning:");	// in case warning message not localized...  						if (ich != -1)  						{  							if (!bWarningFound)	// first time put out the header  							{  								bWarningFound = true;  								sw.WriteLine(String.Format("<p><h3>{0}</h3>"'  									LexTextControls.ksMayBeBugInImport));  								sw.WriteLine("<ul>");  							}    							// Need to quote any occurrences of <' >' or & in the message text.  							sInput = sInput.Replace("&"' "&amp;");  							sInput = sInput.Replace("<"' "&lt;");  							sInput = sInput.Replace(">"' "&gt;");  							sw.WriteLine("<li>" + sInput);  						}  					}  					sr.Dispose();  					sr = File.OpenText(sLogFile);    					if (bWarningFound)  						sw.WriteLine("</ul>");    					sw.WriteLine(String.Format("<p><h3>{0}</h3>"'  						LexTextControls.ksMessagesFromLoading));  					string sTiming = null;  					sw.WriteLine("<ul>");    					string sPath = m_sPhase4Output.Replace("\\"' "\\\\");  					List<string> rgsCreated = xid.CreatedForMessages;  					List<Regex> rgxMsgs = new List<Regex>();  					foreach (string sMsg in rgsCreated)  					{  						string sRegex = "^" + sMsg + "$";  						sRegex = sRegex.Replace("{0}"' sPath);  						sRegex = sRegex.Replace("{1}"' "[0-9]+");  						sRegex = sRegex.Replace("{2}"' "[^\"]+");  						Regex xMsg = new Regex(sRegex);  						rgxMsgs.Add(xMsg);  					}    					string sElapsedTimeMsg = xid.ElapsedTimeMsg;  					ich = sElapsedTimeMsg.IndexOf("{0:F1}");  					Debug.Assert(ich >= 0);  					sElapsedTimeMsg = sElapsedTimeMsg.Substring(0' ich);  					// Print the Info: messages together' save everything else for a later loop.  					List<string> rgsNotInfo = new List<string>();  					while ((sInput = sr.ReadLine()) != null)  					{  						// warning msgs were already handled' so don't show them again  						ich = sInput.IndexOf(sWarning_);  						if (ich == -1)  							ich = sInput.IndexOf("Warning:");	// in case warning message not localized...  						if (ich != -1)  							continue;  						ich = sInput.IndexOf(m_sPhase4Output + ":");  						if (ich != -1)  						{  							int ichNumber = ich + m_sPhase4Output.Length + 1;  							ich = sInput.IndexOf(": "' ichNumber);  							if (ich != -1)  							{  								// Need to quote any occurrences of <' >' or & in the message text.  								string sOutput = sInput.Remove(0' ich + 2);  								sOutput = sOutput.Replace("&"' "&amp;");  								sOutput = sOutput.Replace("<"' "&lt;");  								sOutput = sOutput.Replace(">"' "&gt;");  								if (AnyMsgMatches(rgxMsgs' sInput))  								{  									string sNumber = sInput.Substring(ichNumber' ich - ichNumber);  									int hvo;  									if (Int32.TryParse(sNumber' out hvo))  									{  										// Convert text between ichBegin and ichEnd into a link to the Flex entry.  										string sLinkRef = LinkRef(hvo);  										if (sLinkRef != null)  										{  											int ichBegin = sOutput.IndexOf('"') + 1;  											int ichEnd = sOutput.IndexOf('"'' ichBegin);  											Debug.Assert(ichBegin > 0 && ichEnd > ichBegin);  											sOutput = sOutput.Insert(ichEnd' "</a>");  											sOutput = sOutput.Insert(ichBegin' String.Format("<a href=\"{0}\">"' sLinkRef));  										}  									}  								}  								sOutput = sOutput.Insert(0' "<li>");  								if (sOutput.IndexOf(sInfo_) >= 0 || sOutput.IndexOf("Info:") >= 0)  									sw.WriteLine(sOutput);  								else  									rgsNotInfo.Add(sOutput);  							}  						}  						else  						{  							ich = sInput.IndexOf(sElapsedTimeMsg);  							if (ich != -1)  								sTiming = sInput;  						}  					}  					sr.Close();  					for (int i = 0; i < rgsNotInfo.Count; ++i)  						sw.WriteLine(rgsNotInfo[i]);  					sw.WriteLine("</ul>");  					if (sTiming != null)  						sw.WriteLine("<p>" + sTiming);  					sw.WriteLine("</body>");  					sw.WriteLine("</html>");  					sw.Close();  				}  			}  			finally  			{  				sr.Dispose();  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ComputeDisplayWidth,The following statement contains a magic number: using (var g = this.CreateGraphics())  			{  				SizeF size = g.MeasureString(label' font' 1000);	// expected values are < 100  				int width = (int)Math.Ceiling(size.Width);  				return width + kdxpStepSquareWidth + 3 * kdxpStepListSpacing;	// add fudge factor for squares -- see WizardDialog.cs.  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ComputeDisplayWidth,The following statement contains a magic number: using (var g = this.CreateGraphics())  			{  				SizeF size = g.MeasureString(label' font' 1000);	// expected values are < 100  				int width = (int)Math.Ceiling(size.Width);  				return width + kdxpStepSquareWidth + 3 * kdxpStepListSpacing;	// add fudge factor for squares -- see WizardDialog.cs.  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,GetFile,The following statement contains a magic number: openFileDialog.FilterIndex = (fileType == OFType.Settings) ? 1 : (fileType == OFType.Database) ? 3 : 4;
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,GetFile,The following statement contains a magic number: openFileDialog.FilterIndex = (fileType == OFType.Settings) ? 1 : (fileType == OFType.Database) ? 3 : 4;
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ReadCustomFieldsFromDB,The following statement contains a magic number: foreach (FieldDescription fd in FieldDescription.FieldDescriptors(m_cache))  			{  				if (fd.IsCustomField && fd.Class > 4999 && fd.Class < 6000)  				{  					Sfm2Xml.LexImportCustomField lif = FieldDescriptionToLexImportField(fd);  					System.Xml.XmlDocument doc = new System.Xml.XmlDocument();    					string helpString = GetCustomFieldHelp(fd);  					doc.LoadXml(helpString);    					System.Xml.XmlNode root = doc.DocumentElement;  					lif.ReadNode(root);  					sb.Append(lif.CRC);	// for cumulative CRC (over the whole list)  					crcs.Add(lif.CRC);  					customFields.AddCustomField(fd.Class' lif);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ReadCustomFieldsFromDB,The following statement contains a magic number: foreach (FieldDescription fd in FieldDescription.FieldDescriptors(m_cache))  			{  				if (fd.IsCustomField && fd.Class > 4999 && fd.Class < 6000)  				{  					Sfm2Xml.LexImportCustomField lif = FieldDescriptionToLexImportField(fd);  					System.Xml.XmlDocument doc = new System.Xml.XmlDocument();    					string helpString = GetCustomFieldHelp(fd);  					doc.LoadXml(helpString);    					System.Xml.XmlNode root = doc.DocumentElement;  					lif.ReadNode(root);  					sb.Append(lif.CRC);	// for cumulative CRC (over the whole list)  					crcs.Add(lif.CRC);  					customFields.AddCustomField(fd.Class' lif);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnModifyMappingLanguage_Click,The following statement contains a magic number: foreach(ListViewItem lvItem in listViewMappingLanguages.Items)  			{  				langDescs.Add(lvItem.Text' null);  				if (lvItem.Selected && !selectedFound)  				{  //					selectedItem = lvItem;	// save for future modification  					desc = lvItem.Text;  					name = lvItem.SubItems[1].Text;  					map = lvItem.SubItems[2].Text;  					selectedFound = true;  					// only one selected at a time' but can't break as that  					// keeps the rest of the list from being added to the list of current  					// Language Descriptors which is used in the dlg for making sure that  					// there aren't duplicates.  Fix for LT-5745  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,SetListViewItemColor,The following statement contains a magic number: if (info.AutoImport)	// this is an autoimport field  			{  				item.UseItemStyleForSubItems = false;  				for (int i=0; i<5; i++)  				{  					item.SubItems[i].ForeColor = Color.Red;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,SetListViewItemColor,The following statement contains a magic number: if (info.Exclude)	// this is an excluded field  			{  				item.UseItemStyleForSubItems = false;  				item.SubItems[4].ForeColor = Color.Blue;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,SetListViewItemColor,The following statement contains a magic number: if (info.WritingSystem == Sfm2Xml.STATICS.Ignore)	// this is ignored due to lang  			{  				item.UseItemStyleForSubItems = false;  				item.SubItems[5].ForeColor = Color.Blue;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,SetListViewItemColor,The following statement contains a magic number: if (info.LanguageDescriptor == MarkerPresenter.ContentMapping.Unknown())  			{  				item.UseItemStyleForSubItems = false;  				item.SubItems[5].ForeColor = Color.Red;	// column 5 due to column 1 being hidden (zero width)  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,SaveNewMapFile,The following statement contains a magic number: System.Text.StringBuilder XMLText = new System.Text.StringBuilder(1024);
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnHelpButton,The following statement contains a magic number: switch(CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpImportSFMStep1";  					break;  				case 1:  					helpTopic = "khtpImportSFMStep2";  					break;  				case 2:  					helpTopic = "khtpImportSFMStep3";  					break;  				case 3:  					helpTopic = "khtpImportSFMStep4";  					break;  				case 4:  					helpTopic = "khtpImportSFMStep5";  					break;  				case 5:  					helpTopic = "khtpImportSFMStep6";  					break;  				case 6:  					helpTopic = "khtpImportSFMStep7";  					break;  				case 7:  					helpTopic = "khtpImportSFMStep8";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnHelpButton,The following statement contains a magic number: switch(CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpImportSFMStep1";  					break;  				case 1:  					helpTopic = "khtpImportSFMStep2";  					break;  				case 2:  					helpTopic = "khtpImportSFMStep3";  					break;  				case 3:  					helpTopic = "khtpImportSFMStep4";  					break;  				case 4:  					helpTopic = "khtpImportSFMStep5";  					break;  				case 5:  					helpTopic = "khtpImportSFMStep6";  					break;  				case 6:  					helpTopic = "khtpImportSFMStep7";  					break;  				case 7:  					helpTopic = "khtpImportSFMStep8";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnHelpButton,The following statement contains a magic number: switch(CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpImportSFMStep1";  					break;  				case 1:  					helpTopic = "khtpImportSFMStep2";  					break;  				case 2:  					helpTopic = "khtpImportSFMStep3";  					break;  				case 3:  					helpTopic = "khtpImportSFMStep4";  					break;  				case 4:  					helpTopic = "khtpImportSFMStep5";  					break;  				case 5:  					helpTopic = "khtpImportSFMStep6";  					break;  				case 6:  					helpTopic = "khtpImportSFMStep7";  					break;  				case 7:  					helpTopic = "khtpImportSFMStep8";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnHelpButton,The following statement contains a magic number: switch(CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpImportSFMStep1";  					break;  				case 1:  					helpTopic = "khtpImportSFMStep2";  					break;  				case 2:  					helpTopic = "khtpImportSFMStep3";  					break;  				case 3:  					helpTopic = "khtpImportSFMStep4";  					break;  				case 4:  					helpTopic = "khtpImportSFMStep5";  					break;  				case 5:  					helpTopic = "khtpImportSFMStep6";  					break;  				case 6:  					helpTopic = "khtpImportSFMStep7";  					break;  				case 7:  					helpTopic = "khtpImportSFMStep8";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnHelpButton,The following statement contains a magic number: switch(CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpImportSFMStep1";  					break;  				case 1:  					helpTopic = "khtpImportSFMStep2";  					break;  				case 2:  					helpTopic = "khtpImportSFMStep3";  					break;  				case 3:  					helpTopic = "khtpImportSFMStep4";  					break;  				case 4:  					helpTopic = "khtpImportSFMStep5";  					break;  				case 5:  					helpTopic = "khtpImportSFMStep6";  					break;  				case 6:  					helpTopic = "khtpImportSFMStep7";  					break;  				case 7:  					helpTopic = "khtpImportSFMStep8";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnHelpButton,The following statement contains a magic number: switch(CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpImportSFMStep1";  					break;  				case 1:  					helpTopic = "khtpImportSFMStep2";  					break;  				case 2:  					helpTopic = "khtpImportSFMStep3";  					break;  				case 3:  					helpTopic = "khtpImportSFMStep4";  					break;  				case 4:  					helpTopic = "khtpImportSFMStep5";  					break;  				case 5:  					helpTopic = "khtpImportSFMStep6";  					break;  				case 6:  					helpTopic = "khtpImportSFMStep7";  					break;  				case 7:  					helpTopic = "khtpImportSFMStep8";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnFinishButton,The following statement contains a magic number: int lastStep = 5;
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnFinishButton,The following statement contains a magic number: if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)  			{  				runToCompletion = false;  				lastStep = 4;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnFinishButton,The following statement contains a magic number: using (var dlg = new ProgressDialogWithTask(this))  			{  				dlg.AllowCancel = true;  				dlg.Maximum = 200;  				using (new WaitCursor(this' true))  				{  					int startPhase = GetDictionaryFileAsPhaseFileNumber();	// see if starting with phase file  					// XSLT files  					string sTransformDir = Path.Combine(FwDirectoryFinder.CodeDirectory'  						String.Format("Language Explorer{0}Import{0}"' Path.DirectorySeparatorChar));    					LexImport lexImport = new LexImport(m_cache' m_sTempDir' sTransformDir);  					lexImport.Error += OnImportError;  					bool fRet = (bool)dlg.RunTask(true' lexImport.Import'  						runToCompletion' lastStep' startPhase' m_DatabaseFileName.Text' m_cEntries'  						m_DisplayImportReport.Checked' m_sPhase1HtmlReport' LexImport.s_sPhase1FileName'  						m_chkCreateMissingLinks.Checked);    					if (fRet)  						DialogResult = DialogResult.OK;	// only 'OK' if not exception  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnCancelButton,The following statement contains a magic number: if (m_dirtySenseLastSave || (Control.ModifierKeys & Keys.Shift) == Keys.Shift)  			{  				// LT-7057: if no settings file' don't ask to save  				if (UsesInvalidFileNames(true))  					return;	// finsih with out prompting to save...    				// ask to save the settings  				DialogResult result = DialogResult.Yes;  				// if we're not importing a phaseX file' then ask  				if (GetDictionaryFileAsPhaseFileNumber() == 0)  					result = MessageBox.Show(this' LexTextControls.ksAskRememberImportSettings'  						LexTextControls.ksSaveSettings_'  						MessageBoxButtons.YesNoCancel' MessageBoxIcon.Question' MessageBoxDefaultButton.Button3);    				if (result == DialogResult.Yes)  				{  					// before saving we need to make sure all the data structures are populated  					while (CurrentStepNumber <= 6)  					{  						EnableNextButton();  						m_CurrentStepNumber++;  					}  					SaveSettings();  				}  				else if (result == DialogResult.Cancel)  				{  					// This is how do we stop the cancel process...  					this.DialogResult = DialogResult.None;  					m_fCanceling = false;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ValidToGoForward,The following statement contains a magic number: switch (CurrentStepNumber)  			{  			case 2:  				if (listViewMappingLanguages.Items.Count <= 0)  				{  					MessageBox.Show(LexTextControls.ksNeedALanguage'  						LexTextControls.ksIncompleteLangStep);  					rval = false;  				}  				break;  			case 6:  				rval = m_FeasabilityReportGenerated;  				break;  			default:  				break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ValidToGoForward,The following statement contains a magic number: switch (CurrentStepNumber)  			{  			case 2:  				if (listViewMappingLanguages.Items.Count <= 0)  				{  					MessageBox.Show(LexTextControls.ksNeedALanguage'  						LexTextControls.ksIncompleteLangStep);  					rval = false;  				}  				break;  			case 6:  				rval = m_FeasabilityReportGenerated;  				break;  			default:  				break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,EnableNextButton,The following statement contains a magic number: using (new WaitCursor(this))  			{  				switch (CurrentStepNumber)  				{  				case 1: // has to have a dictionary file to allow 'next'  					if (m_isPhaseInputFile || (m_DatabaseFileName.Text.Length > 0 &&  						System.IO.File.Exists(m_DatabaseFileName.Text) &&  						m_SaveAsFileName.Text != m_sMDFImportMap))		// not same as MDFImport.map file  					{  						rval = true;  					}  					break;    				case 2:	// preparing to display the languages info  					if (m_dirtyMapFile)  					{  						ReadLanguageInfoFromMapFile();  						m_processedMapFile = m_SettingsFileName.Text;  //						m_dirtyMapFile = false;  					}  					rval = true;    					// make sure there is a value for the 'Save as:' entry  					if (m_SaveAsFileName.Text.Length <= 0 && !m_isPhaseInputFile)  					{  						m_SaveAsFileName.Text = RemoveTheFileExtension(m_DatabaseFileName.Text) + "-import-settings.map";  					}  					break;    				case 3:  					// current technique for getting the custom fields in the DB  					bool customFieldsChanged = false;  					m_CustomFields = LexImportWizard.Wizard().ReadCustomFieldsFromDB(out customFieldsChanged);    					UpdateIfInputFileContentsChanged();  					if (m_dirtyInputFile || m_dirtyMapFile)  					{  						ReadMarkersFromDataFile();  						ReadIFMFromMapFile();	// do it now before setting the dirty map flag to false  						m_processedInputFile = m_DatabaseFileName.Text;  						m_lastDateTime = System.IO.File.GetLastWriteTime(m_processedInputFile);	// used to keep track of the last write date on the data file  						m_crcOfInputFile = m_crcObj.FileCRC(m_processedInputFile);		// the computed crc of the data file  						m_dirtyInputFile = false;  						m_dirtyMapFile = false;  						string topAnalysisWS = m_cache.LanguageWritingSystemFactoryAccessor.GetStrFromWs(m_cache.DefaultAnalWs);  						m_MappingMgr = new MarkerPresenter( /*m_cache'*/FwDirectoryFinder.CodeDirectory'  							LexImportWizard.Wizard().GetUILanguages()'  							topAnalysisWS'  							m_SettingsFileName.Text'  							m_DatabaseFileName.Text'  							m_sImportFields' 6);	// number of columns  						DisplayMarkerStep();  						m_FeasabilityReportGenerated = false;	// reset when intputs change  					}  					rval = true;  					break;    				case 4:  					UpdateIfInputFileContentsChanged();  					if (m_DirtyStep5 || true)  					{  						DisplayBeginMarkers();  						m_DirtyStep5 = false;  					}  					rval = Step5NextButtonEnabled();  					break;    				case 5:	// preparing to display the inline markers  //					if (true || m_hasShownIFMs)  					{  						//ReadIFMFromMapFile();  						DisplayInlineMarkers();  //						m_hasShownIFMs = true;  					}  					rval = true;  					break;    				case 6:  					rval = m_FeasabilityReportGenerated;  					break;    				default:  					rval = true;  					break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,EnableNextButton,The following statement contains a magic number: using (new WaitCursor(this))  			{  				switch (CurrentStepNumber)  				{  				case 1: // has to have a dictionary file to allow 'next'  					if (m_isPhaseInputFile || (m_DatabaseFileName.Text.Length > 0 &&  						System.IO.File.Exists(m_DatabaseFileName.Text) &&  						m_SaveAsFileName.Text != m_sMDFImportMap))		// not same as MDFImport.map file  					{  						rval = true;  					}  					break;    				case 2:	// preparing to display the languages info  					if (m_dirtyMapFile)  					{  						ReadLanguageInfoFromMapFile();  						m_processedMapFile = m_SettingsFileName.Text;  //						m_dirtyMapFile = false;  					}  					rval = true;    					// make sure there is a value for the 'Save as:' entry  					if (m_SaveAsFileName.Text.Length <= 0 && !m_isPhaseInputFile)  					{  						m_SaveAsFileName.Text = RemoveTheFileExtension(m_DatabaseFileName.Text) + "-import-settings.map";  					}  					break;    				case 3:  					// current technique for getting the custom fields in the DB  					bool customFieldsChanged = false;  					m_CustomFields = LexImportWizard.Wizard().ReadCustomFieldsFromDB(out customFieldsChanged);    					UpdateIfInputFileContentsChanged();  					if (m_dirtyInputFile || m_dirtyMapFile)  					{  						ReadMarkersFromDataFile();  						ReadIFMFromMapFile();	// do it now before setting the dirty map flag to false  						m_processedInputFile = m_DatabaseFileName.Text;  						m_lastDateTime = System.IO.File.GetLastWriteTime(m_processedInputFile);	// used to keep track of the last write date on the data file  						m_crcOfInputFile = m_crcObj.FileCRC(m_processedInputFile);		// the computed crc of the data file  						m_dirtyInputFile = false;  						m_dirtyMapFile = false;  						string topAnalysisWS = m_cache.LanguageWritingSystemFactoryAccessor.GetStrFromWs(m_cache.DefaultAnalWs);  						m_MappingMgr = new MarkerPresenter( /*m_cache'*/FwDirectoryFinder.CodeDirectory'  							LexImportWizard.Wizard().GetUILanguages()'  							topAnalysisWS'  							m_SettingsFileName.Text'  							m_DatabaseFileName.Text'  							m_sImportFields' 6);	// number of columns  						DisplayMarkerStep();  						m_FeasabilityReportGenerated = false;	// reset when intputs change  					}  					rval = true;  					break;    				case 4:  					UpdateIfInputFileContentsChanged();  					if (m_DirtyStep5 || true)  					{  						DisplayBeginMarkers();  						m_DirtyStep5 = false;  					}  					rval = Step5NextButtonEnabled();  					break;    				case 5:	// preparing to display the inline markers  //					if (true || m_hasShownIFMs)  					{  						//ReadIFMFromMapFile();  						DisplayInlineMarkers();  //						m_hasShownIFMs = true;  					}  					rval = true;  					break;    				case 6:  					rval = m_FeasabilityReportGenerated;  					break;    				default:  					rval = true;  					break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,EnableNextButton,The following statement contains a magic number: using (new WaitCursor(this))  			{  				switch (CurrentStepNumber)  				{  				case 1: // has to have a dictionary file to allow 'next'  					if (m_isPhaseInputFile || (m_DatabaseFileName.Text.Length > 0 &&  						System.IO.File.Exists(m_DatabaseFileName.Text) &&  						m_SaveAsFileName.Text != m_sMDFImportMap))		// not same as MDFImport.map file  					{  						rval = true;  					}  					break;    				case 2:	// preparing to display the languages info  					if (m_dirtyMapFile)  					{  						ReadLanguageInfoFromMapFile();  						m_processedMapFile = m_SettingsFileName.Text;  //						m_dirtyMapFile = false;  					}  					rval = true;    					// make sure there is a value for the 'Save as:' entry  					if (m_SaveAsFileName.Text.Length <= 0 && !m_isPhaseInputFile)  					{  						m_SaveAsFileName.Text = RemoveTheFileExtension(m_DatabaseFileName.Text) + "-import-settings.map";  					}  					break;    				case 3:  					// current technique for getting the custom fields in the DB  					bool customFieldsChanged = false;  					m_CustomFields = LexImportWizard.Wizard().ReadCustomFieldsFromDB(out customFieldsChanged);    					UpdateIfInputFileContentsChanged();  					if (m_dirtyInputFile || m_dirtyMapFile)  					{  						ReadMarkersFromDataFile();  						ReadIFMFromMapFile();	// do it now before setting the dirty map flag to false  						m_processedInputFile = m_DatabaseFileName.Text;  						m_lastDateTime = System.IO.File.GetLastWriteTime(m_processedInputFile);	// used to keep track of the last write date on the data file  						m_crcOfInputFile = m_crcObj.FileCRC(m_processedInputFile);		// the computed crc of the data file  						m_dirtyInputFile = false;  						m_dirtyMapFile = false;  						string topAnalysisWS = m_cache.LanguageWritingSystemFactoryAccessor.GetStrFromWs(m_cache.DefaultAnalWs);  						m_MappingMgr = new MarkerPresenter( /*m_cache'*/FwDirectoryFinder.CodeDirectory'  							LexImportWizard.Wizard().GetUILanguages()'  							topAnalysisWS'  							m_SettingsFileName.Text'  							m_DatabaseFileName.Text'  							m_sImportFields' 6);	// number of columns  						DisplayMarkerStep();  						m_FeasabilityReportGenerated = false;	// reset when intputs change  					}  					rval = true;  					break;    				case 4:  					UpdateIfInputFileContentsChanged();  					if (m_DirtyStep5 || true)  					{  						DisplayBeginMarkers();  						m_DirtyStep5 = false;  					}  					rval = Step5NextButtonEnabled();  					break;    				case 5:	// preparing to display the inline markers  //					if (true || m_hasShownIFMs)  					{  						//ReadIFMFromMapFile();  						DisplayInlineMarkers();  //						m_hasShownIFMs = true;  					}  					rval = true;  					break;    				case 6:  					rval = m_FeasabilityReportGenerated;  					break;    				default:  					rval = true;  					break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,EnableNextButton,The following statement contains a magic number: using (new WaitCursor(this))  			{  				switch (CurrentStepNumber)  				{  				case 1: // has to have a dictionary file to allow 'next'  					if (m_isPhaseInputFile || (m_DatabaseFileName.Text.Length > 0 &&  						System.IO.File.Exists(m_DatabaseFileName.Text) &&  						m_SaveAsFileName.Text != m_sMDFImportMap))		// not same as MDFImport.map file  					{  						rval = true;  					}  					break;    				case 2:	// preparing to display the languages info  					if (m_dirtyMapFile)  					{  						ReadLanguageInfoFromMapFile();  						m_processedMapFile = m_SettingsFileName.Text;  //						m_dirtyMapFile = false;  					}  					rval = true;    					// make sure there is a value for the 'Save as:' entry  					if (m_SaveAsFileName.Text.Length <= 0 && !m_isPhaseInputFile)  					{  						m_SaveAsFileName.Text = RemoveTheFileExtension(m_DatabaseFileName.Text) + "-import-settings.map";  					}  					break;    				case 3:  					// current technique for getting the custom fields in the DB  					bool customFieldsChanged = false;  					m_CustomFields = LexImportWizard.Wizard().ReadCustomFieldsFromDB(out customFieldsChanged);    					UpdateIfInputFileContentsChanged();  					if (m_dirtyInputFile || m_dirtyMapFile)  					{  						ReadMarkersFromDataFile();  						ReadIFMFromMapFile();	// do it now before setting the dirty map flag to false  						m_processedInputFile = m_DatabaseFileName.Text;  						m_lastDateTime = System.IO.File.GetLastWriteTime(m_processedInputFile);	// used to keep track of the last write date on the data file  						m_crcOfInputFile = m_crcObj.FileCRC(m_processedInputFile);		// the computed crc of the data file  						m_dirtyInputFile = false;  						m_dirtyMapFile = false;  						string topAnalysisWS = m_cache.LanguageWritingSystemFactoryAccessor.GetStrFromWs(m_cache.DefaultAnalWs);  						m_MappingMgr = new MarkerPresenter( /*m_cache'*/FwDirectoryFinder.CodeDirectory'  							LexImportWizard.Wizard().GetUILanguages()'  							topAnalysisWS'  							m_SettingsFileName.Text'  							m_DatabaseFileName.Text'  							m_sImportFields' 6);	// number of columns  						DisplayMarkerStep();  						m_FeasabilityReportGenerated = false;	// reset when intputs change  					}  					rval = true;  					break;    				case 4:  					UpdateIfInputFileContentsChanged();  					if (m_DirtyStep5 || true)  					{  						DisplayBeginMarkers();  						m_DirtyStep5 = false;  					}  					rval = Step5NextButtonEnabled();  					break;    				case 5:	// preparing to display the inline markers  //					if (true || m_hasShownIFMs)  					{  						//ReadIFMFromMapFile();  						DisplayInlineMarkers();  //						m_hasShownIFMs = true;  					}  					rval = true;  					break;    				case 6:  					rval = m_FeasabilityReportGenerated;  					break;    				default:  					rval = true;  					break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,EnableNextButton,The following statement contains a magic number: using (new WaitCursor(this))  			{  				switch (CurrentStepNumber)  				{  				case 1: // has to have a dictionary file to allow 'next'  					if (m_isPhaseInputFile || (m_DatabaseFileName.Text.Length > 0 &&  						System.IO.File.Exists(m_DatabaseFileName.Text) &&  						m_SaveAsFileName.Text != m_sMDFImportMap))		// not same as MDFImport.map file  					{  						rval = true;  					}  					break;    				case 2:	// preparing to display the languages info  					if (m_dirtyMapFile)  					{  						ReadLanguageInfoFromMapFile();  						m_processedMapFile = m_SettingsFileName.Text;  //						m_dirtyMapFile = false;  					}  					rval = true;    					// make sure there is a value for the 'Save as:' entry  					if (m_SaveAsFileName.Text.Length <= 0 && !m_isPhaseInputFile)  					{  						m_SaveAsFileName.Text = RemoveTheFileExtension(m_DatabaseFileName.Text) + "-import-settings.map";  					}  					break;    				case 3:  					// current technique for getting the custom fields in the DB  					bool customFieldsChanged = false;  					m_CustomFields = LexImportWizard.Wizard().ReadCustomFieldsFromDB(out customFieldsChanged);    					UpdateIfInputFileContentsChanged();  					if (m_dirtyInputFile || m_dirtyMapFile)  					{  						ReadMarkersFromDataFile();  						ReadIFMFromMapFile();	// do it now before setting the dirty map flag to false  						m_processedInputFile = m_DatabaseFileName.Text;  						m_lastDateTime = System.IO.File.GetLastWriteTime(m_processedInputFile);	// used to keep track of the last write date on the data file  						m_crcOfInputFile = m_crcObj.FileCRC(m_processedInputFile);		// the computed crc of the data file  						m_dirtyInputFile = false;  						m_dirtyMapFile = false;  						string topAnalysisWS = m_cache.LanguageWritingSystemFactoryAccessor.GetStrFromWs(m_cache.DefaultAnalWs);  						m_MappingMgr = new MarkerPresenter( /*m_cache'*/FwDirectoryFinder.CodeDirectory'  							LexImportWizard.Wizard().GetUILanguages()'  							topAnalysisWS'  							m_SettingsFileName.Text'  							m_DatabaseFileName.Text'  							m_sImportFields' 6);	// number of columns  						DisplayMarkerStep();  						m_FeasabilityReportGenerated = false;	// reset when intputs change  					}  					rval = true;  					break;    				case 4:  					UpdateIfInputFileContentsChanged();  					if (m_DirtyStep5 || true)  					{  						DisplayBeginMarkers();  						m_DirtyStep5 = false;  					}  					rval = Step5NextButtonEnabled();  					break;    				case 5:	// preparing to display the inline markers  //					if (true || m_hasShownIFMs)  					{  						//ReadIFMFromMapFile();  						DisplayInlineMarkers();  //						m_hasShownIFMs = true;  					}  					rval = true;  					break;    				case 6:  					rval = m_FeasabilityReportGenerated;  					break;    				default:  					rval = true;  					break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,EnableNextButton,The following statement contains a magic number: using (new WaitCursor(this))  			{  				switch (CurrentStepNumber)  				{  				case 1: // has to have a dictionary file to allow 'next'  					if (m_isPhaseInputFile || (m_DatabaseFileName.Text.Length > 0 &&  						System.IO.File.Exists(m_DatabaseFileName.Text) &&  						m_SaveAsFileName.Text != m_sMDFImportMap))		// not same as MDFImport.map file  					{  						rval = true;  					}  					break;    				case 2:	// preparing to display the languages info  					if (m_dirtyMapFile)  					{  						ReadLanguageInfoFromMapFile();  						m_processedMapFile = m_SettingsFileName.Text;  //						m_dirtyMapFile = false;  					}  					rval = true;    					// make sure there is a value for the 'Save as:' entry  					if (m_SaveAsFileName.Text.Length <= 0 && !m_isPhaseInputFile)  					{  						m_SaveAsFileName.Text = RemoveTheFileExtension(m_DatabaseFileName.Text) + "-import-settings.map";  					}  					break;    				case 3:  					// current technique for getting the custom fields in the DB  					bool customFieldsChanged = false;  					m_CustomFields = LexImportWizard.Wizard().ReadCustomFieldsFromDB(out customFieldsChanged);    					UpdateIfInputFileContentsChanged();  					if (m_dirtyInputFile || m_dirtyMapFile)  					{  						ReadMarkersFromDataFile();  						ReadIFMFromMapFile();	// do it now before setting the dirty map flag to false  						m_processedInputFile = m_DatabaseFileName.Text;  						m_lastDateTime = System.IO.File.GetLastWriteTime(m_processedInputFile);	// used to keep track of the last write date on the data file  						m_crcOfInputFile = m_crcObj.FileCRC(m_processedInputFile);		// the computed crc of the data file  						m_dirtyInputFile = false;  						m_dirtyMapFile = false;  						string topAnalysisWS = m_cache.LanguageWritingSystemFactoryAccessor.GetStrFromWs(m_cache.DefaultAnalWs);  						m_MappingMgr = new MarkerPresenter( /*m_cache'*/FwDirectoryFinder.CodeDirectory'  							LexImportWizard.Wizard().GetUILanguages()'  							topAnalysisWS'  							m_SettingsFileName.Text'  							m_DatabaseFileName.Text'  							m_sImportFields' 6);	// number of columns  						DisplayMarkerStep();  						m_FeasabilityReportGenerated = false;	// reset when intputs change  					}  					rval = true;  					break;    				case 4:  					UpdateIfInputFileContentsChanged();  					if (m_DirtyStep5 || true)  					{  						DisplayBeginMarkers();  						m_DirtyStep5 = false;  					}  					rval = Step5NextButtonEnabled();  					break;    				case 5:	// preparing to display the inline markers  //					if (true || m_hasShownIFMs)  					{  						//ReadIFMFromMapFile();  						DisplayInlineMarkers();  //						m_hasShownIFMs = true;  					}  					rval = true;  					break;    				case 6:  					rval = m_FeasabilityReportGenerated;  					break;    				default:  					rval = true;  					break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,GetDictionaryFileAsPhaseFileNumber,The following statement contains a magic number: if (fileName.EndsWith(LexImport.s_sPhase2FileName))  				return 2;
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,GetDictionaryFileAsPhaseFileNumber,The following statement contains a magic number: if (fileName.EndsWith(LexImport.s_sPhase3FileName))  				return 3;
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,GetDictionaryFileAsPhaseFileNumber,The following statement contains a magic number: if (fileName.EndsWith(LexImport.s_sPhase4FileName))  				return 4;
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnBackButton,The following statement contains a magic number: if (m_QuickFinish)  			{  				// go back to the page where we came from  				tabSteps.SelectedIndex = m_lastQuickFinishTab+1;  				m_CurrentStepNumber = m_lastQuickFinishTab;  				UpdateStepLabel();  				m_QuickFinish = false;	// going back' so turn off flag  			}  			else if (CurrentStepNumber == 6 && m_isPhaseInputFile)  			{  				// skip the pages in the middle that were skipped getting here  				tabSteps.SelectedIndex = 2;	// 0-7  				m_CurrentStepNumber = 1;	// 1-8  				UpdateStepLabel();  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnBackButton,The following statement contains a magic number: if (m_QuickFinish)  			{  				// go back to the page where we came from  				tabSteps.SelectedIndex = m_lastQuickFinishTab+1;  				m_CurrentStepNumber = m_lastQuickFinishTab;  				UpdateStepLabel();  				m_QuickFinish = false;	// going back' so turn off flag  			}  			else if (CurrentStepNumber == 6 && m_isPhaseInputFile)  			{  				// skip the pages in the middle that were skipped getting here  				tabSteps.SelectedIndex = 2;	// 0-7  				m_CurrentStepNumber = 1;	// 1-8  				UpdateStepLabel();  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnNextButton,The following statement contains a magic number: if (CurrentStepNumber == 2)  			{  				bool fStayHere = UsesInvalidFileNames(false);  				if (fStayHere)  				{  					// Don't go anywhere' stay right here.  					m_CurrentStepNumber = 1;	// 1-8  					tabSteps.SelectedIndex = 0;	// 0-7  					UpdateStepLabel();  				}  				if (GetDictionaryFileAsPhaseFileNumber() > 0)  				{  					// we need to skip to the final step now' also handle back processing from there  					m_CurrentStepNumber = 7;	// 1-8  					tabSteps.SelectedIndex = 6;	// 0-7  					UpdateStepLabel();  				}  				ReadOptionInfoFromMapFile();  			}  			else if (CurrentStepNumber == 4)  			{  				if (UpdateIfInputFileContentsChanged())  				{  					// don't go to the next page' stay here due to change  					NextButtonEnabled = true;	//  EnableNextButton();  					m_CurrentStepNumber = 3;    					return; // don't do the default processing  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnNextButton,The following statement contains a magic number: if (CurrentStepNumber == 2)  			{  				bool fStayHere = UsesInvalidFileNames(false);  				if (fStayHere)  				{  					// Don't go anywhere' stay right here.  					m_CurrentStepNumber = 1;	// 1-8  					tabSteps.SelectedIndex = 0;	// 0-7  					UpdateStepLabel();  				}  				if (GetDictionaryFileAsPhaseFileNumber() > 0)  				{  					// we need to skip to the final step now' also handle back processing from there  					m_CurrentStepNumber = 7;	// 1-8  					tabSteps.SelectedIndex = 6;	// 0-7  					UpdateStepLabel();  				}  				ReadOptionInfoFromMapFile();  			}  			else if (CurrentStepNumber == 4)  			{  				if (UpdateIfInputFileContentsChanged())  				{  					// don't go to the next page' stay here due to change  					NextButtonEnabled = true;	//  EnableNextButton();  					m_CurrentStepNumber = 3;    					return; // don't do the default processing  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnNextButton,The following statement contains a magic number: if (CurrentStepNumber == 2)  			{  				bool fStayHere = UsesInvalidFileNames(false);  				if (fStayHere)  				{  					// Don't go anywhere' stay right here.  					m_CurrentStepNumber = 1;	// 1-8  					tabSteps.SelectedIndex = 0;	// 0-7  					UpdateStepLabel();  				}  				if (GetDictionaryFileAsPhaseFileNumber() > 0)  				{  					// we need to skip to the final step now' also handle back processing from there  					m_CurrentStepNumber = 7;	// 1-8  					tabSteps.SelectedIndex = 6;	// 0-7  					UpdateStepLabel();  				}  				ReadOptionInfoFromMapFile();  			}  			else if (CurrentStepNumber == 4)  			{  				if (UpdateIfInputFileContentsChanged())  				{  					// don't go to the next page' stay here due to change  					NextButtonEnabled = true;	//  EnableNextButton();  					m_CurrentStepNumber = 3;    					return; // don't do the default processing  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnNextButton,The following statement contains a magic number: if (CurrentStepNumber == 2)  			{  				bool fStayHere = UsesInvalidFileNames(false);  				if (fStayHere)  				{  					// Don't go anywhere' stay right here.  					m_CurrentStepNumber = 1;	// 1-8  					tabSteps.SelectedIndex = 0;	// 0-7  					UpdateStepLabel();  				}  				if (GetDictionaryFileAsPhaseFileNumber() > 0)  				{  					// we need to skip to the final step now' also handle back processing from there  					m_CurrentStepNumber = 7;	// 1-8  					tabSteps.SelectedIndex = 6;	// 0-7  					UpdateStepLabel();  				}  				ReadOptionInfoFromMapFile();  			}  			else if (CurrentStepNumber == 4)  			{  				if (UpdateIfInputFileContentsChanged())  				{  					// don't go to the next page' stay here due to change  					NextButtonEnabled = true;	//  EnableNextButton();  					m_CurrentStepNumber = 3;    					return; // don't do the default processing  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnNextButton,The following statement contains a magic number: if (CurrentStepNumber == 2)  			{  				bool fStayHere = UsesInvalidFileNames(false);  				if (fStayHere)  				{  					// Don't go anywhere' stay right here.  					m_CurrentStepNumber = 1;	// 1-8  					tabSteps.SelectedIndex = 0;	// 0-7  					UpdateStepLabel();  				}  				if (GetDictionaryFileAsPhaseFileNumber() > 0)  				{  					// we need to skip to the final step now' also handle back processing from there  					m_CurrentStepNumber = 7;	// 1-8  					tabSteps.SelectedIndex = 6;	// 0-7  					UpdateStepLabel();  				}  				ReadOptionInfoFromMapFile();  			}  			else if (CurrentStepNumber == 4)  			{  				if (UpdateIfInputFileContentsChanged())  				{  					// don't go to the next page' stay here due to change  					NextButtonEnabled = true;	//  EnableNextButton();  					m_CurrentStepNumber = 3;    					return; // don't do the default processing  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The following statement contains a magic number: this.tvBeginMarkers.ItemHeight = 16;
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The following statement contains a magic number: this.imageList1.Images.SetKeyName(2' "CheckBox");
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,InitializeComponent,The following statement contains a magic number: this.StepPageCount = 8;
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,tvBeginMarkers_MouseUp,The following statement contains a magic number: if (mea.Button == MouseButtons.Left)  			{  				TreeView tv = (TreeView) obj;  				TreeNode tn = tv.GetNodeAt(mea.X' mea.Y);  				if (tn != null)  				{  					Rectangle rec = tn.Bounds;  					rec.X += -18;       // include the image bitmap (16 pixels plus 2 pixels between the image and the text)  					rec.Width += 18;  					if (rec.Contains(mea.X' mea.Y))  					{  						tvBeginMarkers_HandleCheckBoxNode(tn);  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,tvBeginMarkers_MouseUp,The following statement contains a magic number: if (mea.Button == MouseButtons.Left)  			{  				TreeView tv = (TreeView) obj;  				TreeNode tn = tv.GetNodeAt(mea.X' mea.Y);  				if (tn != null)  				{  					Rectangle rec = tn.Bounds;  					rec.X += -18;       // include the image bitmap (16 pixels plus 2 pixels between the image and the text)  					rec.Width += 18;  					if (rec.Contains(mea.X' mea.Y))  					{  						tvBeginMarkers_HandleCheckBoxNode(tn);  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ShowFinishLabel,The following statement contains a magic number: if (CurrentStepNumber == 7 && (Control.ModifierKeys & Keys.Shift) == Keys.Shift)  				lblFinishWOImport.Visible = true;  			else  				lblFinishWOImport.Visible = false;
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,AllowQuickFinishButton,The following statement contains a magic number: if (m_CurrentStepNumber > 5)  			{  				if (btnQuickFinish.Visible)  					btnQuickFinish.Visible = false;  				return false;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnQuickFinish_Click,The following statement contains a magic number: if (AllowQuickFinishButton())  			{  				m_lastQuickFinishTab = m_CurrentStepNumber;	// save for later    				// before jumping we need to make sure all the data structures are populated  				//  for (near) future use.  				while (CurrentStepNumber <= 6)  				{  					EnableNextButton();  					m_CurrentStepNumber++;  				}    				if (GetDictionaryFileAsPhaseFileNumber() > 0)  				{  					m_CurrentStepNumber = 7;	// 1-8  					tabSteps.SelectedIndex = 7;	// 0-7  				}  				else  				{  					m_CurrentStepNumber = 6;	// 1-8  					tabSteps.SelectedIndex = 6;	// 0-7  				}    				// we need to skip to the final step now' also handle back processing from there  				m_QuickFinish = true;  				UpdateStepLabel();      				// used in the finial steps of importing the data  				m_processedInputFile = m_DatabaseFileName.Text;  				m_processedMapFile = m_SettingsFileName.Text;  				btnQuickFinish.Visible = false;    				// added to take care of LT-2967  				NextButtonEnabled = EnableNextButton();  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnQuickFinish_Click,The following statement contains a magic number: if (AllowQuickFinishButton())  			{  				m_lastQuickFinishTab = m_CurrentStepNumber;	// save for later    				// before jumping we need to make sure all the data structures are populated  				//  for (near) future use.  				while (CurrentStepNumber <= 6)  				{  					EnableNextButton();  					m_CurrentStepNumber++;  				}    				if (GetDictionaryFileAsPhaseFileNumber() > 0)  				{  					m_CurrentStepNumber = 7;	// 1-8  					tabSteps.SelectedIndex = 7;	// 0-7  				}  				else  				{  					m_CurrentStepNumber = 6;	// 1-8  					tabSteps.SelectedIndex = 6;	// 0-7  				}    				// we need to skip to the final step now' also handle back processing from there  				m_QuickFinish = true;  				UpdateStepLabel();      				// used in the finial steps of importing the data  				m_processedInputFile = m_DatabaseFileName.Text;  				m_processedMapFile = m_SettingsFileName.Text;  				btnQuickFinish.Visible = false;    				// added to take care of LT-2967  				NextButtonEnabled = EnableNextButton();  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnQuickFinish_Click,The following statement contains a magic number: if (AllowQuickFinishButton())  			{  				m_lastQuickFinishTab = m_CurrentStepNumber;	// save for later    				// before jumping we need to make sure all the data structures are populated  				//  for (near) future use.  				while (CurrentStepNumber <= 6)  				{  					EnableNextButton();  					m_CurrentStepNumber++;  				}    				if (GetDictionaryFileAsPhaseFileNumber() > 0)  				{  					m_CurrentStepNumber = 7;	// 1-8  					tabSteps.SelectedIndex = 7;	// 0-7  				}  				else  				{  					m_CurrentStepNumber = 6;	// 1-8  					tabSteps.SelectedIndex = 6;	// 0-7  				}    				// we need to skip to the final step now' also handle back processing from there  				m_QuickFinish = true;  				UpdateStepLabel();      				// used in the finial steps of importing the data  				m_processedInputFile = m_DatabaseFileName.Text;  				m_processedMapFile = m_SettingsFileName.Text;  				btnQuickFinish.Visible = false;    				// added to take care of LT-2967  				NextButtonEnabled = EnableNextButton();  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnQuickFinish_Click,The following statement contains a magic number: if (AllowQuickFinishButton())  			{  				m_lastQuickFinishTab = m_CurrentStepNumber;	// save for later    				// before jumping we need to make sure all the data structures are populated  				//  for (near) future use.  				while (CurrentStepNumber <= 6)  				{  					EnableNextButton();  					m_CurrentStepNumber++;  				}    				if (GetDictionaryFileAsPhaseFileNumber() > 0)  				{  					m_CurrentStepNumber = 7;	// 1-8  					tabSteps.SelectedIndex = 7;	// 0-7  				}  				else  				{  					m_CurrentStepNumber = 6;	// 1-8  					tabSteps.SelectedIndex = 6;	// 0-7  				}    				// we need to skip to the final step now' also handle back processing from there  				m_QuickFinish = true;  				UpdateStepLabel();      				// used in the finial steps of importing the data  				m_processedInputFile = m_DatabaseFileName.Text;  				m_processedMapFile = m_SettingsFileName.Text;  				btnQuickFinish.Visible = false;    				// added to take care of LT-2967  				NextButtonEnabled = EnableNextButton();  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnQuickFinish_Click,The following statement contains a magic number: if (AllowQuickFinishButton())  			{  				m_lastQuickFinishTab = m_CurrentStepNumber;	// save for later    				// before jumping we need to make sure all the data structures are populated  				//  for (near) future use.  				while (CurrentStepNumber <= 6)  				{  					EnableNextButton();  					m_CurrentStepNumber++;  				}    				if (GetDictionaryFileAsPhaseFileNumber() > 0)  				{  					m_CurrentStepNumber = 7;	// 1-8  					tabSteps.SelectedIndex = 7;	// 0-7  				}  				else  				{  					m_CurrentStepNumber = 6;	// 1-8  					tabSteps.SelectedIndex = 6;	// 0-7  				}    				// we need to skip to the final step now' also handle back processing from there  				m_QuickFinish = true;  				UpdateStepLabel();      				// used in the finial steps of importing the data  				m_processedInputFile = m_DatabaseFileName.Text;  				m_processedMapFile = m_SettingsFileName.Text;  				btnQuickFinish.Visible = false;    				// added to take care of LT-2967  				NextButtonEnabled = EnableNextButton();  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnSizeChanged,The following statement contains a magic number: if (m_origWidth == 0 && listViewContentMapping != null)	// have size info  			{  				// capture the original size information of the dialog  				m_origWidth = Width;  				m_origHeight = Height;  			}  			else  			{  				if (m_origSet == false && Width != 0 && m_origWidth != 0)	// adjust sizes  				{  					int diffWidth = Width - m_origWidth;  					int diffHeight = Height - m_origHeight;    					// adjust the width and height of problematic controls at 120 dpi  					listViewContentMapping.Width += diffWidth;  					listViewContentMapping.Height += diffHeight;  					listViewMappingLanguages.Width += diffWidth;  					listViewMappingLanguages.Height += diffHeight;  					tvBeginMarkers.Width += diffWidth;  					tvBeginMarkers.Height += diffHeight;  					listViewCharMappings.Width += diffWidth;  					listViewCharMappings.Height += diffHeight;    					// move the buttons now in both x and y directions  					diffHeight += 3;	// still need a little more ...  LT-4918  					diffHeight += 7;	// ... and more now after style change ... LT-9941    					var buttonYCoord = Convert.ToInt32(listViewCharMappings.Height*1.03);    					if (btnAddMappingLanguage.Location.Y >= buttonYCoord)  					{//this is for 90dpi (100% Windows 7 display setting)  						MoveButton(btnAddMappingLanguage' diffWidth' diffHeight);  						MoveButton(btnModifyMappingLanguage' diffWidth' diffHeight);  						MoveButton(btnModifyContentMapping' diffWidth' diffHeight);  						MoveButton(btnAddCharMapping' diffWidth' diffHeight);  						MoveButton(btnModifyCharMapping' diffWidth' diffHeight);  						MoveButton(btnDeleteCharMapping' diffWidth' diffHeight);  						MoveButton(m_chkCreateMissingLinks' diffWidth' diffHeight);  					}  					else  					{//this is for 120 dpi (125% Windows 7 display settings)  						//LT-11558  						MoveButton2(btnAddMappingLanguage' diffWidth' buttonYCoord);  						MoveButton2(btnModifyMappingLanguage' diffWidth' buttonYCoord);  						MoveButton2(btnModifyContentMapping' diffWidth' buttonYCoord);  						MoveButton2(btnAddCharMapping' diffWidth' buttonYCoord);  						MoveButton2(btnModifyCharMapping' diffWidth' buttonYCoord);  						MoveButton2(btnDeleteCharMapping' diffWidth' buttonYCoord);  						MoveButton2(m_chkCreateMissingLinks' diffWidth' buttonYCoord);  					}    					// update the 'original' size for future OnSize msgs  					m_origWidth = Width;  					m_origHeight = Height;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnSizeChanged,The following statement contains a magic number: if (m_origWidth == 0 && listViewContentMapping != null)	// have size info  			{  				// capture the original size information of the dialog  				m_origWidth = Width;  				m_origHeight = Height;  			}  			else  			{  				if (m_origSet == false && Width != 0 && m_origWidth != 0)	// adjust sizes  				{  					int diffWidth = Width - m_origWidth;  					int diffHeight = Height - m_origHeight;    					// adjust the width and height of problematic controls at 120 dpi  					listViewContentMapping.Width += diffWidth;  					listViewContentMapping.Height += diffHeight;  					listViewMappingLanguages.Width += diffWidth;  					listViewMappingLanguages.Height += diffHeight;  					tvBeginMarkers.Width += diffWidth;  					tvBeginMarkers.Height += diffHeight;  					listViewCharMappings.Width += diffWidth;  					listViewCharMappings.Height += diffHeight;    					// move the buttons now in both x and y directions  					diffHeight += 3;	// still need a little more ...  LT-4918  					diffHeight += 7;	// ... and more now after style change ... LT-9941    					var buttonYCoord = Convert.ToInt32(listViewCharMappings.Height*1.03);    					if (btnAddMappingLanguage.Location.Y >= buttonYCoord)  					{//this is for 90dpi (100% Windows 7 display setting)  						MoveButton(btnAddMappingLanguage' diffWidth' diffHeight);  						MoveButton(btnModifyMappingLanguage' diffWidth' diffHeight);  						MoveButton(btnModifyContentMapping' diffWidth' diffHeight);  						MoveButton(btnAddCharMapping' diffWidth' diffHeight);  						MoveButton(btnModifyCharMapping' diffWidth' diffHeight);  						MoveButton(btnDeleteCharMapping' diffWidth' diffHeight);  						MoveButton(m_chkCreateMissingLinks' diffWidth' diffHeight);  					}  					else  					{//this is for 120 dpi (125% Windows 7 display settings)  						//LT-11558  						MoveButton2(btnAddMappingLanguage' diffWidth' buttonYCoord);  						MoveButton2(btnModifyMappingLanguage' diffWidth' buttonYCoord);  						MoveButton2(btnModifyContentMapping' diffWidth' buttonYCoord);  						MoveButton2(btnAddCharMapping' diffWidth' buttonYCoord);  						MoveButton2(btnModifyCharMapping' diffWidth' buttonYCoord);  						MoveButton2(btnDeleteCharMapping' diffWidth' buttonYCoord);  						MoveButton2(m_chkCreateMissingLinks' diffWidth' buttonYCoord);  					}    					// update the 'original' size for future OnSize msgs  					m_origWidth = Width;  					m_origHeight = Height;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnSizeChanged,The following statement contains a magic number: if (m_origWidth == 0 && listViewContentMapping != null)	// have size info  			{  				// capture the original size information of the dialog  				m_origWidth = Width;  				m_origHeight = Height;  			}  			else  			{  				if (m_origSet == false && Width != 0 && m_origWidth != 0)	// adjust sizes  				{  					int diffWidth = Width - m_origWidth;  					int diffHeight = Height - m_origHeight;    					// adjust the width and height of problematic controls at 120 dpi  					listViewContentMapping.Width += diffWidth;  					listViewContentMapping.Height += diffHeight;  					listViewMappingLanguages.Width += diffWidth;  					listViewMappingLanguages.Height += diffHeight;  					tvBeginMarkers.Width += diffWidth;  					tvBeginMarkers.Height += diffHeight;  					listViewCharMappings.Width += diffWidth;  					listViewCharMappings.Height += diffHeight;    					// move the buttons now in both x and y directions  					diffHeight += 3;	// still need a little more ...  LT-4918  					diffHeight += 7;	// ... and more now after style change ... LT-9941    					var buttonYCoord = Convert.ToInt32(listViewCharMappings.Height*1.03);    					if (btnAddMappingLanguage.Location.Y >= buttonYCoord)  					{//this is for 90dpi (100% Windows 7 display setting)  						MoveButton(btnAddMappingLanguage' diffWidth' diffHeight);  						MoveButton(btnModifyMappingLanguage' diffWidth' diffHeight);  						MoveButton(btnModifyContentMapping' diffWidth' diffHeight);  						MoveButton(btnAddCharMapping' diffWidth' diffHeight);  						MoveButton(btnModifyCharMapping' diffWidth' diffHeight);  						MoveButton(btnDeleteCharMapping' diffWidth' diffHeight);  						MoveButton(m_chkCreateMissingLinks' diffWidth' diffHeight);  					}  					else  					{//this is for 120 dpi (125% Windows 7 display settings)  						//LT-11558  						MoveButton2(btnAddMappingLanguage' diffWidth' buttonYCoord);  						MoveButton2(btnModifyMappingLanguage' diffWidth' buttonYCoord);  						MoveButton2(btnModifyContentMapping' diffWidth' buttonYCoord);  						MoveButton2(btnAddCharMapping' diffWidth' buttonYCoord);  						MoveButton2(btnModifyCharMapping' diffWidth' buttonYCoord);  						MoveButton2(btnDeleteCharMapping' diffWidth' buttonYCoord);  						MoveButton2(m_chkCreateMissingLinks' diffWidth' buttonYCoord);  					}    					// update the 'original' size for future OnSize msgs  					m_origWidth = Width;  					m_origHeight = Height;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,btnSaveMapFile_Click,The following statement contains a magic number: while (CurrentStepNumber <= 6)  			{  				EnableNextButton();  				m_CurrentStepNumber++;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,OnResize,The following statement contains a magic number: if (listViewMappingLanguages != null)  			{  				// make sure the controls that tend to 'float' when the resx is checked out -  				//  still have a good screen position and size  				listViewMappingLanguages.Width = tabSteps.Width - 40;  				listViewMappingLanguages.Height = lblSteps.Top - btnAddMappingLanguage.Height -  listViewMappingLanguages.Top - 20;    				listViewContentMapping.Width = tabSteps.Width - 40;  				// LT-10904 added checkbox  				listViewContentMapping.Height =  					tabSteps.Bottom - btnModifyContentMapping.Height - m_chkCreateMissingLinks.Height - listViewContentMapping.Top - 20;  				var nudge = 0;  				if (MiscUtils.IsUnix)  					nudge = 25;  				// LT-17974 Adjust layout on Linux/Mono so checkbox and modify button are not overlapping.  				listViewContentMapping.Height -= nudge;    				listViewCharMappings.Width = tabSteps.Width - 40;  				listViewCharMappings.Height = tabSteps.Bottom - btnModifyCharMapping.Height - listViewCharMappings.Top - 20;    				tvBeginMarkers.Width = tabSteps.Width - 40;  				tvBeginMarkers.Height = tabSteps.Bottom - tvBeginMarkers.Top - 20;    				int buttonSpace = btnDatabaseBrowse.Location.X - (m_DatabaseFileName.Location.X + m_DatabaseFileName.Width);  				FixControlWidth(lblDatabaseInstructions' tabSteps.Width -  9);  				FixControlLocation(btnDatabaseBrowse' tabSteps.Width - 9);  				FixControlWidth(m_DatabaseFileName' btnDatabaseBrowse.Left - buttonSpace);    				FixControlWidth(lblSettingsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSettingsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SettingsFileName' btnSettingsBrowse.Left - buttonSpace);    				FixControlWidth(lblSaveAsInstructions' tabSteps.Width - 9);  				FixControlLocation(btnSaveAsBrowse' tabSteps.Width - 9);  				FixControlWidth(m_SaveAsFileName' btnSaveAsBrowse.Left - buttonSpace);    				FixControlWidth(FeasabilityCheckInstructions' tabSteps.Width - 9);  			}
Magic Number,SIL.FieldWorks.LexText.Controls,ListViewItemComparer,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,Compare,The following statement contains a magic number: if (col == 1)	// source order case  				{  					if (ascendingOrder)  						return b.Order - a.Order;  					return a.Order - b.Order;  				}  				else if (col == 2)	// count case  				{  					if (ascendingOrder)  						return b.Count - a.Count;  					return a.Count - b.Count;  				}
Magic Number,SIL.FieldWorks.LexText.Controls,ListViewItemComparer,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,Compare,The following statement contains a magic number: switch (col)  				{  					case 0:  						aText = a.Marker;  						bText = b.Marker;  						break;  					case 3:  						aText = a.Description + "__" + a.Marker;  						bText = b.Description + "__" + b.Marker;  						break;  					case 4:  						aText = a.DestinationField + "__" + a.Marker;  						bText = b.DestinationField + "__" + b.Marker;  						break;  					case 5:  						aText = a.WritingSystem + "__" + a.Marker;  						bText = b.WritingSystem + "__" + b.Marker;  						break;  					default:  						break;  				}
Magic Number,SIL.FieldWorks.LexText.Controls,ListViewItemComparer,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,Compare,The following statement contains a magic number: switch (col)  				{  					case 0:  						aText = a.Marker;  						bText = b.Marker;  						break;  					case 3:  						aText = a.Description + "__" + a.Marker;  						bText = b.Description + "__" + b.Marker;  						break;  					case 4:  						aText = a.DestinationField + "__" + a.Marker;  						bText = b.DestinationField + "__" + b.Marker;  						break;  					case 5:  						aText = a.WritingSystem + "__" + a.Marker;  						bText = b.WritingSystem + "__" + b.Marker;  						break;  					default:  						break;  				}
Magic Number,SIL.FieldWorks.LexText.Controls,ListViewItemComparer,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardHelpers.cs,Compare,The following statement contains a magic number: switch (col)  				{  					case 0:  						aText = a.Marker;  						bText = b.Marker;  						break;  					case 3:  						aText = a.Description + "__" + a.Marker;  						bText = b.Description + "__" + b.Marker;  						break;  					case 4:  						aText = a.DestinationField + "__" + a.Marker;  						bText = b.DestinationField + "__" + b.Marker;  						break;  					case 5:  						aText = a.WritingSystem + "__" + a.Marker;  						bText = b.WritingSystem + "__" + b.Marker;  						break;  					default:  						break;  				}
Magic Number,SIL.FieldWorks.LexText.Controls,LexOptionsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexOptionsDlg.cs,LexOptionsDlg,The following statement contains a magic number: optionsTooltip = new ToolTip { AutoPopDelay = 6000' InitialDelay = 400' ReshowDelay = 500' IsBalloon = true };
Magic Number,SIL.FieldWorks.LexText.Controls,LexOptionsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexOptionsDlg.cs,LexOptionsDlg,The following statement contains a magic number: optionsTooltip = new ToolTip { AutoPopDelay = 6000' InitialDelay = 400' ReshowDelay = 500' IsBalloon = true };
Magic Number,SIL.FieldWorks.LexText.Controls,LexOptionsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexOptionsDlg.cs,LexOptionsDlg,The following statement contains a magic number: optionsTooltip = new ToolTip { AutoPopDelay = 6000' InitialDelay = 400' ReshowDelay = 500' IsBalloon = true };
Magic Number,SIL.FieldWorks.LexText.Controls,LexReferenceDetailsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexReferenceDetailsDlg.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(320' 300);
Magic Number,SIL.FieldWorks.LexText.Controls,LexReferenceDetailsDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexReferenceDetailsDlg.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(320' 300);
Magic Number,SIL.FieldWorks.LexText.Controls,LinkAllomorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkAllomorphDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_fwcbAllomorphs.DropDownWidth = 200;
Magic Number,SIL.FieldWorks.LexText.Controls,LinkMSADlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkMSADlg.cs,InitializeComponent,The following statement contains a magic number: this.m_fwcbFunctions.DropDownWidth = 123;
Magic Number,SIL.FieldWorks.LexText.Controls,LinkVariantToEntryOrSense,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,InitializeComponent,The following statement contains a magic number: this.tcVariantTypes.DropDownWidth = 120;
Magic Number,SIL.FieldWorks.LexText.Controls,InsertVariantDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,ApplySomeResources,The following statement contains a magic number: if (MiscUtils.IsUnix)  			{  				// Mono doesn't handle anchoring coming in through these resources for adjusting  				// initial locations and sizes' so let's set those manually.  See FWNX-546.  				var bounds = this.ClientSize;  				var deltaX = bounds.Width - (m_matchingObjectsBrowser.Location.X + m_matchingObjectsBrowser.Width + 12);  				FixButtonLocation(m_btnClose' bounds' deltaX);  				FixButtonLocation(m_btnOK' bounds' deltaX);  				FixButtonLocation(m_btnInsert' bounds' deltaX);  				FixButtonLocation(m_btnHelp' bounds' deltaX);  				if (deltaX > 0)  					m_matchingObjectsBrowser.Width = m_matchingObjectsBrowser.Width + deltaX;  				var desiredBottom = Math.Min(m_btnClose.Location.Y' m_btnOK.Location.Y);  				desiredBottom = Math.Min(desiredBottom' m_btnInsert.Location.Y);  				desiredBottom = Math.Min(desiredBottom' m_btnHelp.Location.Y);  				desiredBottom -= 30;  				var deltaY = desiredBottom - (m_matchingObjectsBrowser.Location.Y + m_matchingObjectsBrowser.Height);  				if (deltaY > 0)  					m_matchingObjectsBrowser.Height = m_matchingObjectsBrowser.Height + deltaY;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,InsertVariantDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,ApplySomeResources,The following statement contains a magic number: if (MiscUtils.IsUnix)  			{  				// Mono doesn't handle anchoring coming in through these resources for adjusting  				// initial locations and sizes' so let's set those manually.  See FWNX-546.  				var bounds = this.ClientSize;  				var deltaX = bounds.Width - (m_matchingObjectsBrowser.Location.X + m_matchingObjectsBrowser.Width + 12);  				FixButtonLocation(m_btnClose' bounds' deltaX);  				FixButtonLocation(m_btnOK' bounds' deltaX);  				FixButtonLocation(m_btnInsert' bounds' deltaX);  				FixButtonLocation(m_btnHelp' bounds' deltaX);  				if (deltaX > 0)  					m_matchingObjectsBrowser.Width = m_matchingObjectsBrowser.Width + deltaX;  				var desiredBottom = Math.Min(m_btnClose.Location.Y' m_btnOK.Location.Y);  				desiredBottom = Math.Min(desiredBottom' m_btnInsert.Location.Y);  				desiredBottom = Math.Min(desiredBottom' m_btnHelp.Location.Y);  				desiredBottom -= 30;  				var deltaY = desiredBottom - (m_matchingObjectsBrowser.Location.Y + m_matchingObjectsBrowser.Height);  				if (deltaY > 0)  					m_matchingObjectsBrowser.Height = m_matchingObjectsBrowser.Height + deltaY;  			}
Magic Number,SIL.FieldWorks.LexText.Controls,InsertVariantDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkVariantToEntryOrSense.cs,FixButtonLocation,The following statement contains a magic number: var desiredY = bounds.Height - (button.Height + 12);
Magic Number,SIL.FieldWorks.LexText.Controls,MasterCategoryListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterCategoryListDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_imageList.Images.SetKeyName(2' "");
Magic Number,SIL.FieldWorks.LexText.Controls,MasterListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MasterListDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_imageList.Images.SetKeyName(2' "");
Magic Number,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,SetDlgInfo,The following statement contains a magic number: pt.X = Width - m_btnHelp.Width - 20;
Magic Number,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,SetDlgInfo,The following statement contains a magic number: pt.X -= (m_btnClose.Width + 10);
Magic Number,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,SetDlgInfo,The following statement contains a magic number: pt.X -= (m_btnOK.Width + 10);
Magic Number,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,SetBottomMessage,The following statement contains a magic number: while (ich >= 0 && cch > 0)  			{  				tsb.ReplaceTsString(ich' ich + 3' tssFrom);  				tsb.SetIntPropValues(ich' ich + cch'  					(int)FwTextPropType.ktptBold'  					(int)FwTextPropVar.ktpvEnum'  					(int)FwTextToggleVal.kttvForceOn);  				sTmp = tsb.Text;  				ich = sTmp.IndexOf("{0}"' StringComparison.Ordinal);	// in case localization needs more than one.  			}
Magic Number,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,SetBottomMessage,The following statement contains a magic number: if (m_selObject != null)  			{  				// Replace every "{1}" with the headword we'll be merging into.  				ITsString tssTo = ((ILexEntry)m_selObject).HeadWord;  				ich = sTmp.IndexOf("{1}"' StringComparison.Ordinal);  				cch = tssTo.Length;  				while (ich >= 0 && cch > 0)  				{  					tsb.ReplaceTsString(ich' ich + 3' tssTo);  					tsb.SetIntPropValues(ich' ich + cch'  						(int)FwTextPropType.ktptBold'  						(int)FwTextPropVar.ktpvEnum'  						(int)FwTextToggleVal.kttvForceOn);  					sTmp = tsb.Text;  					ich = sTmp.IndexOf("{0}"' StringComparison.Ordinal);  				}  				// Replace every "{2}" with a newline character.  				ich = sTmp.IndexOf("{2}"' StringComparison.Ordinal);  				while (ich >= 0)  				{  					tsb.ReplaceTsString(ich' ich + 3' TsStringUtils.MakeString(StringUtils.kChHardLB.ToString()' userWs));  					sTmp = tsb.Text;  					ich = sTmp.IndexOf("{2}"' StringComparison.Ordinal);  				}  			}  			else  			{  				// Replace every "{1}" with a newline character.  				ich = sTmp.IndexOf("{1}"' StringComparison.Ordinal);  				while (ich >= 0)  				{  					tsb.ReplaceTsString(ich' ich + 3' TsStringUtils.MakeString(StringUtils.kChHardLB.ToString()' userWs));  					sTmp = tsb.Text;  					ich = sTmp.IndexOf("{1}"' StringComparison.Ordinal);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,SetBottomMessage,The following statement contains a magic number: if (m_selObject != null)  			{  				// Replace every "{1}" with the headword we'll be merging into.  				ITsString tssTo = ((ILexEntry)m_selObject).HeadWord;  				ich = sTmp.IndexOf("{1}"' StringComparison.Ordinal);  				cch = tssTo.Length;  				while (ich >= 0 && cch > 0)  				{  					tsb.ReplaceTsString(ich' ich + 3' tssTo);  					tsb.SetIntPropValues(ich' ich + cch'  						(int)FwTextPropType.ktptBold'  						(int)FwTextPropVar.ktpvEnum'  						(int)FwTextToggleVal.kttvForceOn);  					sTmp = tsb.Text;  					ich = sTmp.IndexOf("{0}"' StringComparison.Ordinal);  				}  				// Replace every "{2}" with a newline character.  				ich = sTmp.IndexOf("{2}"' StringComparison.Ordinal);  				while (ich >= 0)  				{  					tsb.ReplaceTsString(ich' ich + 3' TsStringUtils.MakeString(StringUtils.kChHardLB.ToString()' userWs));  					sTmp = tsb.Text;  					ich = sTmp.IndexOf("{2}"' StringComparison.Ordinal);  				}  			}  			else  			{  				// Replace every "{1}" with a newline character.  				ich = sTmp.IndexOf("{1}"' StringComparison.Ordinal);  				while (ich >= 0)  				{  					tsb.ReplaceTsString(ich' ich + 3' TsStringUtils.MakeString(StringUtils.kChHardLB.ToString()' userWs));  					sTmp = tsb.Text;  					ich = sTmp.IndexOf("{1}"' StringComparison.Ordinal);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,MergeEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MergeEntryDlg.cs,SetBottomMessage,The following statement contains a magic number: if (m_selObject != null)  			{  				// Replace every "{1}" with the headword we'll be merging into.  				ITsString tssTo = ((ILexEntry)m_selObject).HeadWord;  				ich = sTmp.IndexOf("{1}"' StringComparison.Ordinal);  				cch = tssTo.Length;  				while (ich >= 0 && cch > 0)  				{  					tsb.ReplaceTsString(ich' ich + 3' tssTo);  					tsb.SetIntPropValues(ich' ich + cch'  						(int)FwTextPropType.ktptBold'  						(int)FwTextPropVar.ktpvEnum'  						(int)FwTextToggleVal.kttvForceOn);  					sTmp = tsb.Text;  					ich = sTmp.IndexOf("{0}"' StringComparison.Ordinal);  				}  				// Replace every "{2}" with a newline character.  				ich = sTmp.IndexOf("{2}"' StringComparison.Ordinal);  				while (ich >= 0)  				{  					tsb.ReplaceTsString(ich' ich + 3' TsStringUtils.MakeString(StringUtils.kChHardLB.ToString()' userWs));  					sTmp = tsb.Text;  					ich = sTmp.IndexOf("{2}"' StringComparison.Ordinal);  				}  			}  			else  			{  				// Replace every "{1}" with a newline character.  				ich = sTmp.IndexOf("{1}"' StringComparison.Ordinal);  				while (ich >= 0)  				{  					tsb.ReplaceTsString(ich' ich + 3' TsStringUtils.MakeString(StringUtils.kChHardLB.ToString()' userWs));  					sTmp = tsb.Text;  					ich = sTmp.IndexOf("{1}"' StringComparison.Ordinal);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,Initialize,The following statement contains a magic number: m_fwcbSlots.Font = new Font(defAnalWsFont' 10);
Magic Number,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,Initialize,The following statement contains a magic number: m_tcMainPOS.Font = new Font(defAnalWsFont' 10);
Magic Number,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,Initialize,The following statement contains a magic number: m_tcSecondaryPOS.Font = new Font(defAnalWsFont' 10);
Magic Number,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,InitializeComponent,The following statement contains a magic number: this.m_fwcbAffixTypes.DropDownWidth = 140;
Magic Number,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,InitializeComponent,The following statement contains a magic number: this.m_tcMainPOS.DropDownWidth = 140;
Magic Number,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,InitializeComponent,The following statement contains a magic number: this.m_fwcbSlots.DropDownWidth = 140;
Magic Number,SIL.FieldWorks.LexText.Controls,MSAGroupBox,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MSAGroupBox.cs,InitializeComponent,The following statement contains a magic number: this.m_tcSecondaryPOS.DropDownWidth = 140;
Magic Number,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_imageList.Images.SetKeyName(2' "");
Magic Number,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,MsaInflectionFeatureListDlg_Closing,The following statement contains a magic number: if (DialogResult == DialogResult.OK)  			{  				// making and maybe then deleting the new item for the combo is not undoable  				NonUndoableUnitOfWorkHelper.Do(m_cache.ActionHandlerAccessor'  					() =>  						{  							if (m_fs == null)  							{  								// Didn't have one to begin with. See whether we want to create one.  								if (CheckFeatureStructure(m_tvMsaFeatureList.Nodes))  								{  									var repo = m_cache.ServiceLocator.GetInstance<IFsFeatStrucRepository>();  									// FsFeatStruc may be owned atomically or in a colllection. See which fake insertion index we need.  									int where = m_cache.MetaDataCacheAccessor.GetFieldType(m_owningFlid) == (int) CellarPropertyType.OwningAtomic ? -2: -1;  									int hvoNew = m_cache.DomainDataByFlid.MakeNewObject(FsFeatStrucTags.kClassId' m_hvoOwner'  										m_owningFlid' where);  									m_fs = repo.GetObject(hvoNew);  								}  								else  								{  									return; // leave it null.  								}  							}  							// clean out any extant features in the feature structure  							foreach (var spec in m_fs.FeatureSpecsOC)  								m_fs.FeatureSpecsOC.Remove(spec);  							UpdateFeatureStructure(m_tvMsaFeatureList.Nodes);  							// The (usually) newly created one may be a duplicate. If we find a duplicate  							// delete the one we just made (or were passed) and return the duplicate.  							int cpt = m_cache.MetaDataCacheAccessor.GetFieldType(m_owningFlid);  							if (m_hvoOwner != 0 && cpt != (int) CellarPropertyType.OwningAtomic)  							{  								int chvo = m_cache.DomainDataByFlid.get_VecSize(m_hvoOwner' m_owningFlid);  								for (int ihvo = 0; ihvo < chvo; ihvo++)  								{  									int hvo = m_cache.DomainDataByFlid.get_VecItem(m_hvoOwner' m_owningFlid' ihvo);  									if (hvo == m_fs.Hvo)  										continue;  									IFsFeatStruc fs = m_cache.ServiceLocator.GetInstance<IFsFeatStrucRepository>().GetObject(hvo);  									if (DomainObjectServices.AreEquivalent(fs' m_fs))  									{  										m_cache.DomainDataByFlid.DeleteObj(m_fs.Hvo);  										m_fs = fs;  										break;  									}  								}  							}  							// If the user emptied all the FeatureSpecs (i.e. chose "None of the above" in each area)'  							// then we need to delete the FsFeatStruc. (LT-13596)  							if (FS.FeatureSpecsOC.Count == 0)  							{  								if (m_fs.CanDelete)  									m_fs.Delete();  								m_fs = null;  							}  						});  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,AnthroFieldMappingDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\AnthroFieldMappingDlg.cs,m_btnAddCustom_Click,The following statement contains a magic number: if (mi != null)  			{  				var parameters = new object[2];  				parameters[0] = m_mediator;  				parameters[1] = m_propertyTable;  				mi.Invoke(typeFound'  					System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public |  					System.Reflection.BindingFlags.NonPublic' null' parameters' null);  				// Now' clean up our map of possible field targets and reload the field combo list.  				List<int> delFields = new List<int>();  				foreach (int key in m_mapFlidName.Keys)  				{  					if (!m_mdc.FieldExists(key))  						delFields.Add(key);  				}  				foreach (int flid in delFields)  					m_mapFlidName.Remove(flid);  				foreach (int flid in m_mdc.GetFields(RnGenericRecTags.kClassId' false' (int)CellarPropertyTypeFilter.All))  				{  					if (m_mapFlidName.ContainsKey(flid))  						continue;  					if (m_mdc.IsCustom(flid))  					{  						string name = m_mdc.GetFieldName(flid);  						m_mapFlidName.Add(flid' name);  					}  				}  				FillInFieldList();  			}  			else  			{  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,LinkFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\LinkFieldOptions.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(20' 20);
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,LinkFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\LinkFieldOptions.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(20' 20);
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,LinkFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\LinkFieldOptions.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(133' 13);
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,LinkFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\LinkFieldOptions.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(133' 13);
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,LinkFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\LinkFieldOptions.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 2;
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,LinkFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\LinkFieldOptions.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(338' 382);
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,LinkFieldOptions,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\LinkFieldOptions.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(338' 382);
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,OnHelpButton,The following statement contains a magic number: switch (CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpDataNotebookImportWizStep1";  					break;  				case 1:  					helpTopic = "khtpDataNotebookImportWizStep2";  					break;  				case 2:  					helpTopic = "khtpDataNotebookImportWizStep3";  					break;  				case 3:  					helpTopic = "khtpDataNotebookImportWizStep4";  					break;  				case 4:  					helpTopic = "khtpDataNotebookImportWizStep5";  					break;  				case 5:  					helpTopic = "khtpDataNotebookImportWizStep6";  					break;  				case 6:  					helpTopic = "khtpDataNotebookImportWizStep7";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,OnHelpButton,The following statement contains a magic number: switch (CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpDataNotebookImportWizStep1";  					break;  				case 1:  					helpTopic = "khtpDataNotebookImportWizStep2";  					break;  				case 2:  					helpTopic = "khtpDataNotebookImportWizStep3";  					break;  				case 3:  					helpTopic = "khtpDataNotebookImportWizStep4";  					break;  				case 4:  					helpTopic = "khtpDataNotebookImportWizStep5";  					break;  				case 5:  					helpTopic = "khtpDataNotebookImportWizStep6";  					break;  				case 6:  					helpTopic = "khtpDataNotebookImportWizStep7";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,OnHelpButton,The following statement contains a magic number: switch (CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpDataNotebookImportWizStep1";  					break;  				case 1:  					helpTopic = "khtpDataNotebookImportWizStep2";  					break;  				case 2:  					helpTopic = "khtpDataNotebookImportWizStep3";  					break;  				case 3:  					helpTopic = "khtpDataNotebookImportWizStep4";  					break;  				case 4:  					helpTopic = "khtpDataNotebookImportWizStep5";  					break;  				case 5:  					helpTopic = "khtpDataNotebookImportWizStep6";  					break;  				case 6:  					helpTopic = "khtpDataNotebookImportWizStep7";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,OnHelpButton,The following statement contains a magic number: switch (CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpDataNotebookImportWizStep1";  					break;  				case 1:  					helpTopic = "khtpDataNotebookImportWizStep2";  					break;  				case 2:  					helpTopic = "khtpDataNotebookImportWizStep3";  					break;  				case 3:  					helpTopic = "khtpDataNotebookImportWizStep4";  					break;  				case 4:  					helpTopic = "khtpDataNotebookImportWizStep5";  					break;  				case 5:  					helpTopic = "khtpDataNotebookImportWizStep6";  					break;  				case 6:  					helpTopic = "khtpDataNotebookImportWizStep7";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,OnHelpButton,The following statement contains a magic number: switch (CurrentStepNumber)  			{  				case 0:  					helpTopic = "khtpDataNotebookImportWizStep1";  					break;  				case 1:  					helpTopic = "khtpDataNotebookImportWizStep2";  					break;  				case 2:  					helpTopic = "khtpDataNotebookImportWizStep3";  					break;  				case 3:  					helpTopic = "khtpDataNotebookImportWizStep4";  					break;  				case 4:  					helpTopic = "khtpDataNotebookImportWizStep5";  					break;  				case 5:  					helpTopic = "khtpDataNotebookImportWizStep6";  					break;  				case 6:  					helpTopic = "khtpDataNotebookImportWizStep7";  					break;  				default:  					Debug.Assert(false' "Reached a step without a help file defined for it");  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,OnCancelButton,The following statement contains a magic number: if (m_fDirtySettings || (Control.ModifierKeys & Keys.Shift) == Keys.Shift)  			{  				// LT-7057: if no settings file' don't ask to save  				if (UsesInvalidFileNames(true))  					return;	// finsih with out prompting to save...    				// ask to save the settings  				DialogResult result = MessageBox.Show(this'  					LexTextControls.ksAskRememberImportSettings'  					LexTextControls.ksSaveSettings_'  					MessageBoxButtons.YesNoCancel'  					MessageBoxIcon.Question'  					MessageBoxDefaultButton.Button3);    				if (result == DialogResult.Yes)  				{  					// before saving we need to make sure all the data structures are populated  					while (CurrentStepNumber <= 6)  					{  						EnableNextButton();  						m_CurrentStepNumber++;  					}  					SaveSettings();  				}  				else if (result == DialogResult.Cancel)  				{  					// This is how do we stop the cancel process...  					this.DialogResult = DialogResult.None;  					m_fCanceling = false;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,btnModifyContentMapping_Click,The following statement contains a magic number: using (AnthroFieldMappingDlg dlg = new AnthroFieldMappingDlg())  			{  				ListViewItem lvi = m_lvContentMapping.SelectedItems[0];  				RnSfMarker rsfm = lvi.Tag as RnSfMarker;  				var app = m_propertyTable.GetValue<IApp>("App");  				dlg.Initialize(m_cache' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' app' rsfm'  					m_SfmFile' m_mapFlidName' m_stylesheet' m_mediator' m_propertyTable);  				if (dlg.ShowDialog(this) == DialogResult.OK)  				{  					rsfm = dlg.Results;  					lvi.SubItems[3].Text = rsfm.m_sName;  					lvi.Tag = rsfm;  					m_fDirtySettings = true;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,btnModifyCharMapping_Click,The following statement contains a magic number: using (ImportCharMappingDlg dlg = new ImportCharMappingDlg())  			{  				CharMapping cm = lvi.Tag as CharMapping;  				IApp app = m_propertyTable.GetValue<IApp>("App");  				dlg.Initialize(m_cache' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' app' m_stylesheet' cm);  				if (dlg.ShowDialog(this) == DialogResult.OK)  				{  					cm.BeginMarker = dlg.BeginMarker;  					cm.EndMarker = dlg.EndMarker;  					cm.EndWithWord = dlg.EndWithWord;  					cm.DestinationWritingSystemId = dlg.WritingSystemId;  					cm.DestinationStyle = dlg.StyleName;  					cm.IgnoreMarkerOnImport = dlg.IgnoreOnImport;  					ListViewItem lviNew = CreateListItemForCharMapping(cm);  					lvi.SubItems[0].Text = lviNew.SubItems[0].Text;  					lvi.SubItems[1].Text = lviNew.SubItems[1].Text;  					lvi.SubItems[2].Text = lviNew.SubItems[2].Text;  					lvi.SubItems[3].Text = lviNew.SubItems[3].Text;  					m_fDirtySettings = true;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,btnModifyCharMapping_Click,The following statement contains a magic number: using (ImportCharMappingDlg dlg = new ImportCharMappingDlg())  			{  				CharMapping cm = lvi.Tag as CharMapping;  				IApp app = m_propertyTable.GetValue<IApp>("App");  				dlg.Initialize(m_cache' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' app' m_stylesheet' cm);  				if (dlg.ShowDialog(this) == DialogResult.OK)  				{  					cm.BeginMarker = dlg.BeginMarker;  					cm.EndMarker = dlg.EndMarker;  					cm.EndWithWord = dlg.EndWithWord;  					cm.DestinationWritingSystemId = dlg.WritingSystemId;  					cm.DestinationStyle = dlg.StyleName;  					cm.IgnoreMarkerOnImport = dlg.IgnoreOnImport;  					ListViewItem lviNew = CreateListItemForCharMapping(cm);  					lvi.SubItems[0].Text = lviNew.SubItems[0].Text;  					lvi.SubItems[1].Text = lviNew.SubItems[1].Text;  					lvi.SubItems[2].Text = lviNew.SubItems[2].Text;  					lvi.SubItems[3].Text = lviNew.SubItems[3].Text;  					m_fDirtySettings = true;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,btnModifyCharMapping_Click,The following statement contains a magic number: using (ImportCharMappingDlg dlg = new ImportCharMappingDlg())  			{  				CharMapping cm = lvi.Tag as CharMapping;  				IApp app = m_propertyTable.GetValue<IApp>("App");  				dlg.Initialize(m_cache' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' app' m_stylesheet' cm);  				if (dlg.ShowDialog(this) == DialogResult.OK)  				{  					cm.BeginMarker = dlg.BeginMarker;  					cm.EndMarker = dlg.EndMarker;  					cm.EndWithWord = dlg.EndWithWord;  					cm.DestinationWritingSystemId = dlg.WritingSystemId;  					cm.DestinationStyle = dlg.StyleName;  					cm.IgnoreMarkerOnImport = dlg.IgnoreOnImport;  					ListViewItem lviNew = CreateListItemForCharMapping(cm);  					lvi.SubItems[0].Text = lviNew.SubItems[0].Text;  					lvi.SubItems[1].Text = lviNew.SubItems[1].Text;  					lvi.SubItems[2].Text = lviNew.SubItems[2].Text;  					lvi.SubItems[3].Text = lviNew.SubItems[3].Text;  					m_fDirtySettings = true;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,btnModifyCharMapping_Click,The following statement contains a magic number: using (ImportCharMappingDlg dlg = new ImportCharMappingDlg())  			{  				CharMapping cm = lvi.Tag as CharMapping;  				IApp app = m_propertyTable.GetValue<IApp>("App");  				dlg.Initialize(m_cache' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' app' m_stylesheet' cm);  				if (dlg.ShowDialog(this) == DialogResult.OK)  				{  					cm.BeginMarker = dlg.BeginMarker;  					cm.EndMarker = dlg.EndMarker;  					cm.EndWithWord = dlg.EndWithWord;  					cm.DestinationWritingSystemId = dlg.WritingSystemId;  					cm.DestinationStyle = dlg.StyleName;  					cm.IgnoreMarkerOnImport = dlg.IgnoreOnImport;  					ListViewItem lviNew = CreateListItemForCharMapping(cm);  					lvi.SubItems[0].Text = lviNew.SubItems[0].Text;  					lvi.SubItems[1].Text = lviNew.SubItems[1].Text;  					lvi.SubItems[2].Text = lviNew.SubItems[2].Text;  					lvi.SubItems[3].Text = lviNew.SubItems[3].Text;  					m_fDirtySettings = true;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,AllowQuickFinishButton,The following statement contains a magic number: if (m_CurrentStepNumber < 6 &&  				IsValidSfmFile(m_tbDatabaseFileName.Text) &&  				IsValidMapFile(m_tbSettingsFileName.Text))  			{  				if (!m_btnQuickFinish.Visible)  				{  					m_btnCancel.Left = m_ExtraButtonLeft;  					m_btnCancel.Visible = true;  					m_btnQuickFinish.Visible = true;  				}  				return true;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,FillFlidNameMap,The following statement contains a magic number: int[] flidMissing = new int[] {  				RnGenericRecTags.kflidSubRecords'  				RnGenericRecTags.kflidCrossReferences'  				RnGenericRecTags.kflidReminders'  				4004028			// was kflidWeather at one time.  			};
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,FillFlidNameMap,The following statement contains a magic number: foreach (int flid in m_mdc.GetFieldIds())  			{  				if (flid >= (RnGenericRecTags.kClassId * 1000 + 500) &&  					flid <= (RnGenericRecTags.kClassId * 1000 + 999))  				{  					string sName = m_mdc.GetFieldLabel(flid);  					m_mapFlidName.Add(flid' sName);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,FillFlidNameMap,The following statement contains a magic number: foreach (int flid in m_mdc.GetFieldIds())  			{  				if (flid >= (RnGenericRecTags.kClassId * 1000 + 500) &&  					flid <= (RnGenericRecTags.kClassId * 1000 + 999))  				{  					string sName = m_mdc.GetFieldLabel(flid);  					m_mapFlidName.Add(flid' sName);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,FillFlidNameMap,The following statement contains a magic number: foreach (int flid in m_mdc.GetFieldIds())  			{  				if (flid >= (RnGenericRecTags.kClassId * 1000 + 500) &&  					flid <= (RnGenericRecTags.kClassId * 1000 + 999))  				{  					string sName = m_mdc.GetFieldLabel(flid);  					m_mapFlidName.Add(flid' sName);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,FillFlidNameMap,The following statement contains a magic number: foreach (int flid in m_mdc.GetFieldIds())  			{  				if (flid >= (RnGenericRecTags.kClassId * 1000 + 500) &&  					flid <= (RnGenericRecTags.kClassId * 1000 + 999))  				{  					string sName = m_mdc.GetFieldLabel(flid);  					m_mapFlidName.Add(flid' sName);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,DoImport,The following statement contains a magic number: using (new WaitCursor(this))  			{  				using (var progressDlg = new ProgressDialogWithTask(this))  				{  					progressDlg.Minimum = 0;  					progressDlg.Maximum = 100;  					progressDlg.AllowCancel = true;  					progressDlg.Restartable = true;  					progressDlg.Title = String.Format(LexTextControls.ksImportingFrom0' m_sSfmDataFile);  					m_sLogFile = (string)progressDlg.RunTask(true' ImportStdFmtFile'  						m_sSfmDataFile);  					if (m_chkDisplayImportReport.Checked && !String.IsNullOrEmpty(m_sLogFile))  					{  						using (Process.Start(m_sLogFile))  						{  						}  					}  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ImportStdFmtFile,The following statement contains a magic number: using (var uowHelper = new NonUndoableUnitOfWorkHelper(m_cache.ActionHandlerAccessor))  			{  				try  				{  					m_dtStart = DateTime.Now;  					FixSettingsForThisDatabase();  					int cLines = m_SfmFile.Lines.Count;  					progressDlg.Title = String.Format(LexTextControls.ksImportingFrom0' Path.GetFileName(m_sSfmDataFile));  					progressDlg.StepSize = 1;  					int cExistingRecords = m_cache.LangProject.ResearchNotebookOA.RecordsOC.Count;  					if (m_rbReplaceAllEntries.Checked && cExistingRecords > 0)  					{  						progressDlg.Minimum = 0;  						progressDlg.Maximum = cLines + 50;  						progressDlg.Message = LexTextControls.ksDeletingExistingRecords;  						// This is rather drastic' but it's what the user asked for!  						// REVIEW: Should we ask for confirmation before doing this?  						m_cRecordsDeleted = cExistingRecords;  						m_cache.LangProject.ResearchNotebookOA.RecordsOC.Clear();  						progressDlg.Step(50);  					}  					else  					{  						m_cRecordsDeleted = 0;  						progressDlg.Minimum = 0;  						progressDlg.Maximum = cLines;  					}  					progressDlg.Message = LexTextControls.ksImportingNewRecords;  					IRnGenericRec recPrev = null;  					IRnGenericRec rec = null;  					IRnGenericRecFactory factRec = m_cache.ServiceLocator.GetInstance<IRnGenericRecFactory>();  					IRnGenericRecRepository repoRec = m_cache.ServiceLocator.GetInstance<IRnGenericRecRepository>();  					ICmPossibilityRepository repoPoss = m_cache.ServiceLocator.GetInstance<ICmPossibilityRepository>();  					ICmPossibility defaultType = repoPoss.GetObject(RnResearchNbkTags.kguidRecObservation);  					for (int i = 0; i < cLines; ++i)  					{  						progressDlg.Step(1);  						if (progressDlg.Canceled)  						{  							LogMessage(LexTextControls.ksImportCanceledByUser' lineNumber);  							break;  						}  						Sfm2Xml.SfmField field = m_SfmFile.Lines[i];  						lineNumber = field.LineNumber;  						if (field.Marker.StartsWith("_"))  							continue;  						RnSfMarker rsf;  						if (!m_mapMkrRsf.TryGetValue(field.Marker' out rsf))  						{  							// complain?  log complaint? throw a fit?  							continue;  						}  						if (rsf.m_nLevel == 1)  						{  							recPrev = rec;  							rec = factRec.Create();  							m_cache.LangProject.ResearchNotebookOA.RecordsOC.Add(rec);  							rec.TypeRA = defaultType;  							++m_cRecordsRead;  						}  						else if (rsf.m_nLevel > 1)  						{  							// we don't handle this yet!  						}  						if (rsf.m_flid == 0)  							continue;  						CellarPropertyType cpt = (CellarPropertyType) m_mdc.GetFieldType(rsf.m_flid);  						int clidDst;  						switch (cpt)  						{  							case CellarPropertyType.ReferenceAtomic:  							case CellarPropertyType.ReferenceCollection:  							case CellarPropertyType.ReferenceSequence:  								clidDst = m_mdc.GetDstClsId(rsf.m_flid);  								switch (clidDst)  								{  									case RnGenericRecTags.kClassId:  										StoreLinkData(rec' rsf' field);  										break;  									case CrossReferenceTags.kClassId:  									case ReminderTags.kClassId:  										// we don't handle these yet  										break;  									default:  										int clidBase = clidDst;  										while (clidBase != 0 && clidBase != CmPossibilityTags.kClassId)  											clidBase = m_mdc.GetBaseClsId(clidBase);  										if (clidBase == CmPossibilityTags.kClassId)  											SetListReference(rec' rsf' field);  										break;  								}  								break;  							case CellarPropertyType.OwningAtomic:  							case CellarPropertyType.OwningCollection:  							case CellarPropertyType.OwningSequence:  								clidDst = m_mdc.GetDstClsId(rsf.m_flid);  								switch (clidDst)  								{  									case StTextTags.kClassId:  										Debug.Assert(cpt == CellarPropertyType.OwningAtomic);  										SetTextContent(rec' rsf' field);  										break;  									case RnRoledParticTags.kClassId:  										SetListReference(rec' rsf' field);  										break;  									case RnGenericRecTags.kClassId:  										break;  									default:  										// we don't handle these yet.  										MessageBox.Show("Need to handle owned RnGenericRec"' "DEBUG");  										break;  								}  								break;  							case CellarPropertyType.MultiString:  							case CellarPropertyType.MultiUnicode:  							case CellarPropertyType.String:  								SetStringValue(rec' rsf' field' cpt);  								break;  							case CellarPropertyType.GenDate:  								SetGenDateValue(rec' rsf' field);  								break;  							case CellarPropertyType.Time:  								SetDateTimeValue(rec' rsf' field);  								break;  							case CellarPropertyType.Unicode:  							case CellarPropertyType.Binary:  							case CellarPropertyType.Image:  							case CellarPropertyType.Boolean:  							case CellarPropertyType.Float:  							case CellarPropertyType.Guid:  							case CellarPropertyType.Integer:  							case CellarPropertyType.Numeric:  								break;  						}  					}  					ProcessStoredLinkData();  					uowHelper.RollBack = false;  				}  				catch (Exception e)  				{  					string sMsg = String.Format(LexTextControls.ksProblemImportingFrom'  												m_tbDatabaseFileName.Text' e.Message);  					LogMessage(sMsg' lineNumber);  					System.Windows.Forms.MessageBox.Show(this' sMsg);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ImportStdFmtFile,The following statement contains a magic number: using (var uowHelper = new NonUndoableUnitOfWorkHelper(m_cache.ActionHandlerAccessor))  			{  				try  				{  					m_dtStart = DateTime.Now;  					FixSettingsForThisDatabase();  					int cLines = m_SfmFile.Lines.Count;  					progressDlg.Title = String.Format(LexTextControls.ksImportingFrom0' Path.GetFileName(m_sSfmDataFile));  					progressDlg.StepSize = 1;  					int cExistingRecords = m_cache.LangProject.ResearchNotebookOA.RecordsOC.Count;  					if (m_rbReplaceAllEntries.Checked && cExistingRecords > 0)  					{  						progressDlg.Minimum = 0;  						progressDlg.Maximum = cLines + 50;  						progressDlg.Message = LexTextControls.ksDeletingExistingRecords;  						// This is rather drastic' but it's what the user asked for!  						// REVIEW: Should we ask for confirmation before doing this?  						m_cRecordsDeleted = cExistingRecords;  						m_cache.LangProject.ResearchNotebookOA.RecordsOC.Clear();  						progressDlg.Step(50);  					}  					else  					{  						m_cRecordsDeleted = 0;  						progressDlg.Minimum = 0;  						progressDlg.Maximum = cLines;  					}  					progressDlg.Message = LexTextControls.ksImportingNewRecords;  					IRnGenericRec recPrev = null;  					IRnGenericRec rec = null;  					IRnGenericRecFactory factRec = m_cache.ServiceLocator.GetInstance<IRnGenericRecFactory>();  					IRnGenericRecRepository repoRec = m_cache.ServiceLocator.GetInstance<IRnGenericRecRepository>();  					ICmPossibilityRepository repoPoss = m_cache.ServiceLocator.GetInstance<ICmPossibilityRepository>();  					ICmPossibility defaultType = repoPoss.GetObject(RnResearchNbkTags.kguidRecObservation);  					for (int i = 0; i < cLines; ++i)  					{  						progressDlg.Step(1);  						if (progressDlg.Canceled)  						{  							LogMessage(LexTextControls.ksImportCanceledByUser' lineNumber);  							break;  						}  						Sfm2Xml.SfmField field = m_SfmFile.Lines[i];  						lineNumber = field.LineNumber;  						if (field.Marker.StartsWith("_"))  							continue;  						RnSfMarker rsf;  						if (!m_mapMkrRsf.TryGetValue(field.Marker' out rsf))  						{  							// complain?  log complaint? throw a fit?  							continue;  						}  						if (rsf.m_nLevel == 1)  						{  							recPrev = rec;  							rec = factRec.Create();  							m_cache.LangProject.ResearchNotebookOA.RecordsOC.Add(rec);  							rec.TypeRA = defaultType;  							++m_cRecordsRead;  						}  						else if (rsf.m_nLevel > 1)  						{  							// we don't handle this yet!  						}  						if (rsf.m_flid == 0)  							continue;  						CellarPropertyType cpt = (CellarPropertyType) m_mdc.GetFieldType(rsf.m_flid);  						int clidDst;  						switch (cpt)  						{  							case CellarPropertyType.ReferenceAtomic:  							case CellarPropertyType.ReferenceCollection:  							case CellarPropertyType.ReferenceSequence:  								clidDst = m_mdc.GetDstClsId(rsf.m_flid);  								switch (clidDst)  								{  									case RnGenericRecTags.kClassId:  										StoreLinkData(rec' rsf' field);  										break;  									case CrossReferenceTags.kClassId:  									case ReminderTags.kClassId:  										// we don't handle these yet  										break;  									default:  										int clidBase = clidDst;  										while (clidBase != 0 && clidBase != CmPossibilityTags.kClassId)  											clidBase = m_mdc.GetBaseClsId(clidBase);  										if (clidBase == CmPossibilityTags.kClassId)  											SetListReference(rec' rsf' field);  										break;  								}  								break;  							case CellarPropertyType.OwningAtomic:  							case CellarPropertyType.OwningCollection:  							case CellarPropertyType.OwningSequence:  								clidDst = m_mdc.GetDstClsId(rsf.m_flid);  								switch (clidDst)  								{  									case StTextTags.kClassId:  										Debug.Assert(cpt == CellarPropertyType.OwningAtomic);  										SetTextContent(rec' rsf' field);  										break;  									case RnRoledParticTags.kClassId:  										SetListReference(rec' rsf' field);  										break;  									case RnGenericRecTags.kClassId:  										break;  									default:  										// we don't handle these yet.  										MessageBox.Show("Need to handle owned RnGenericRec"' "DEBUG");  										break;  								}  								break;  							case CellarPropertyType.MultiString:  							case CellarPropertyType.MultiUnicode:  							case CellarPropertyType.String:  								SetStringValue(rec' rsf' field' cpt);  								break;  							case CellarPropertyType.GenDate:  								SetGenDateValue(rec' rsf' field);  								break;  							case CellarPropertyType.Time:  								SetDateTimeValue(rec' rsf' field);  								break;  							case CellarPropertyType.Unicode:  							case CellarPropertyType.Binary:  							case CellarPropertyType.Image:  							case CellarPropertyType.Boolean:  							case CellarPropertyType.Float:  							case CellarPropertyType.Guid:  							case CellarPropertyType.Integer:  							case CellarPropertyType.Numeric:  								break;  						}  					}  					ProcessStoredLinkData();  					uowHelper.RollBack = false;  				}  				catch (Exception e)  				{  					string sMsg = String.Format(LexTextControls.ksProblemImportingFrom'  												m_tbDatabaseFileName.Text' e.Message);  					LogMessage(sMsg' lineNumber);  					System.Windows.Forms.MessageBox.Show(this' sMsg);  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,CreateImportReport,The following statement contains a magic number: using (StreamWriter sw = File.CreateText(sHtmlFile))  			{  				sw.WriteLine("<html>");  				sw.WriteLine("<head>");  				string sHeadInfo = String.Format(LexTextControls.ksImportLogForX' m_sSfmDataFile);  				sw.WriteLine(String.Format("  <title>{0}</title>"' sHeadInfo));  				WriteHtmlJavaScript(sw);	// add the script  				sw.WriteLine("</head>");  				sw.WriteLine("<body>");  				sw.WriteLine(String.Format("<h2>{0}</h2>"' sHeadInfo));  				long deltaTicks = m_dtEnd.Ticks - m_dtStart.Ticks;	// number of 100-nanosecond intervals  				int deltaMsec = (int)((deltaTicks + 5000L) / 10000L);	// round off to milliseconds  				int deltaSec = deltaMsec / 1000;  				string sDeltaTime = String.Format(LexTextControls.ksImportingTookTime'  					System.IO.Path.GetFileName(m_sSfmDataFile)' deltaSec' deltaMsec % 1000);  				sw.WriteLine("<p>{0}</p>"' sDeltaTime);  				sw.Write("<h3>");  				if (m_cRecordsDeleted == 0)  					sw.Write(LexTextControls.ksRecordsCreatedByImport' m_cRecordsRead);  				else  					sw.Write(LexTextControls.ksRecordsDeletedAndCreated' m_cRecordsDeleted' m_cRecordsRead);  				sw.WriteLine("</h3>");  				WriteMessageLines(sw);  				ListNewPossibilities(sw' LexTextControls.ksNewAnthropologyListItems' m_rgNewAnthroItem' "anthroEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewConfidenceListItems' m_rgNewConfidence' "confidenceEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewLocationListItems' m_rgNewLocation' "locationsEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewPeopleListItems' m_rgNewPeople' "peopleEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewPhraseTagListItems' m_rgNewPhraseTag' "");  				ListNewPossibilities(sw' LexTextControls.ksNewRecordTypeListItems' m_rgNewRecType' "recTypeEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewRestrictionListItems' m_rgNewRestriction' "restrictionsEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewStatusListItems' m_rgNewStatus' "statusEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewTimeOfDayListItems' m_rgNewTimeOfDay' "");  				// now for custom lists...  				foreach (Guid key in m_mapNewPossibilities.Keys)  				{  					ICmPossibilityList list = m_repoList.GetObject(key);  					string name = list.Name.BestAnalysisVernacularAlternative.Text;  					string message = String.Format(LexTextControls.ksNewCustomListItems' name);  					ListNewPossibilities(sw' message' m_mapNewPossibilities[key]' "");  				}  				sw.WriteLine("</body>");  				sw.WriteLine("</html>");  				sw.Close();  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,CreateImportReport,The following statement contains a magic number: using (StreamWriter sw = File.CreateText(sHtmlFile))  			{  				sw.WriteLine("<html>");  				sw.WriteLine("<head>");  				string sHeadInfo = String.Format(LexTextControls.ksImportLogForX' m_sSfmDataFile);  				sw.WriteLine(String.Format("  <title>{0}</title>"' sHeadInfo));  				WriteHtmlJavaScript(sw);	// add the script  				sw.WriteLine("</head>");  				sw.WriteLine("<body>");  				sw.WriteLine(String.Format("<h2>{0}</h2>"' sHeadInfo));  				long deltaTicks = m_dtEnd.Ticks - m_dtStart.Ticks;	// number of 100-nanosecond intervals  				int deltaMsec = (int)((deltaTicks + 5000L) / 10000L);	// round off to milliseconds  				int deltaSec = deltaMsec / 1000;  				string sDeltaTime = String.Format(LexTextControls.ksImportingTookTime'  					System.IO.Path.GetFileName(m_sSfmDataFile)' deltaSec' deltaMsec % 1000);  				sw.WriteLine("<p>{0}</p>"' sDeltaTime);  				sw.Write("<h3>");  				if (m_cRecordsDeleted == 0)  					sw.Write(LexTextControls.ksRecordsCreatedByImport' m_cRecordsRead);  				else  					sw.Write(LexTextControls.ksRecordsDeletedAndCreated' m_cRecordsDeleted' m_cRecordsRead);  				sw.WriteLine("</h3>");  				WriteMessageLines(sw);  				ListNewPossibilities(sw' LexTextControls.ksNewAnthropologyListItems' m_rgNewAnthroItem' "anthroEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewConfidenceListItems' m_rgNewConfidence' "confidenceEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewLocationListItems' m_rgNewLocation' "locationsEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewPeopleListItems' m_rgNewPeople' "peopleEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewPhraseTagListItems' m_rgNewPhraseTag' "");  				ListNewPossibilities(sw' LexTextControls.ksNewRecordTypeListItems' m_rgNewRecType' "recTypeEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewRestrictionListItems' m_rgNewRestriction' "restrictionsEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewStatusListItems' m_rgNewStatus' "statusEdit");  				ListNewPossibilities(sw' LexTextControls.ksNewTimeOfDayListItems' m_rgNewTimeOfDay' "");  				// now for custom lists...  				foreach (Guid key in m_mapNewPossibilities.Keys)  				{  					ICmPossibilityList list = m_repoList.GetObject(key);  					string name = list.Name.BestAnalysisVernacularAlternative.Text;  					string message = String.Format(LexTextControls.ksNewCustomListItems' name);  					ListNewPossibilities(sw' message' m_mapNewPossibilities[key]' "");  				}  				sw.WriteLine("</body>");  				sw.WriteLine("</html>");  				sw.Close();  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetDefaultForListRef,The following statement contains a magic number: switch (rsf.m_flid)  			{  				case RnGenericRecTags.kflidAnthroCodes:  					if (m_mapAnthroCode.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.AnthroListOA.PossibilitiesOS' m_mapAnthroCode);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapAnthroCode);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewAnthroItem(rgsHier);  					break;  				case RnGenericRecTags.kflidConfidence:  					if (m_mapConfidence.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.ConfidenceLevelsOA.PossibilitiesOS' m_mapConfidence);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapConfidence);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewConfidenceItem(rgsHier);  					break;  				case RnGenericRecTags.kflidLocations:  					if (m_mapLocation.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.LocationsOA.PossibilitiesOS' m_mapLocation);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapLocation);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewLocation(rgsHier);  					break;  				case RnGenericRecTags.kflidPhraseTags:  					if (m_mapPhraseTag.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.TextMarkupTagsOA.PossibilitiesOS' m_mapPhraseTag);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapPhraseTag);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewPhraseTag(rgsHier);  					break;  				case RnGenericRecTags.kflidResearchers:  				case RnGenericRecTags.kflidSources:  					if (m_mapPeople.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.PeopleOA.PossibilitiesOS' m_mapPeople);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapPeople);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewPerson(rgsHier);  					break;  				case RnGenericRecTags.kflidRestrictions:  					if (m_mapRestriction.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.RestrictionsOA.PossibilitiesOS' m_mapRestriction);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapRestriction);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewRestriction(rgsHier);  					break;  				case RnGenericRecTags.kflidStatus:  					if (m_mapStatus.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.StatusOA.PossibilitiesOS' m_mapStatus);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapStatus);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewStatus(rgsHier);  					break;  				case RnGenericRecTags.kflidTimeOfEvent:  					if (m_mapTimeOfDay.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.TimeOfDayOA.PossibilitiesOS' m_mapTimeOfDay);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapTimeOfDay);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewTimeOfDay(rgsHier);  					break;  				case RnGenericRecTags.kflidType:  					if (m_mapRecType.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.ResearchNotebookOA.RecTypesOA.PossibilitiesOS' m_mapRecType);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapRecType);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewRecType(rgsHier);  					break;  				case RnGenericRecTags.kflidParticipants:  					if (m_mapPeople.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.PeopleOA.PossibilitiesOS' m_mapPeople);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapPeople);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewPerson(rgsHier);  					break;  				default:  					// must be a custom field.  					Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  					// We don't yet have the necessary information in the new FDO/MetaDataCache.  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetDefaultForListRef,The following statement contains a magic number: switch (rsf.m_flid)  			{  				case RnGenericRecTags.kflidAnthroCodes:  					if (m_mapAnthroCode.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.AnthroListOA.PossibilitiesOS' m_mapAnthroCode);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapAnthroCode);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewAnthroItem(rgsHier);  					break;  				case RnGenericRecTags.kflidConfidence:  					if (m_mapConfidence.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.ConfidenceLevelsOA.PossibilitiesOS' m_mapConfidence);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapConfidence);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewConfidenceItem(rgsHier);  					break;  				case RnGenericRecTags.kflidLocations:  					if (m_mapLocation.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.LocationsOA.PossibilitiesOS' m_mapLocation);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapLocation);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewLocation(rgsHier);  					break;  				case RnGenericRecTags.kflidPhraseTags:  					if (m_mapPhraseTag.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.TextMarkupTagsOA.PossibilitiesOS' m_mapPhraseTag);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapPhraseTag);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewPhraseTag(rgsHier);  					break;  				case RnGenericRecTags.kflidResearchers:  				case RnGenericRecTags.kflidSources:  					if (m_mapPeople.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.PeopleOA.PossibilitiesOS' m_mapPeople);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapPeople);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewPerson(rgsHier);  					break;  				case RnGenericRecTags.kflidRestrictions:  					if (m_mapRestriction.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.RestrictionsOA.PossibilitiesOS' m_mapRestriction);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapRestriction);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewRestriction(rgsHier);  					break;  				case RnGenericRecTags.kflidStatus:  					if (m_mapStatus.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.StatusOA.PossibilitiesOS' m_mapStatus);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapStatus);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewStatus(rgsHier);  					break;  				case RnGenericRecTags.kflidTimeOfEvent:  					if (m_mapTimeOfDay.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.TimeOfDayOA.PossibilitiesOS' m_mapTimeOfDay);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapTimeOfDay);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewTimeOfDay(rgsHier);  					break;  				case RnGenericRecTags.kflidType:  					if (m_mapRecType.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.ResearchNotebookOA.RecTypesOA.PossibilitiesOS' m_mapRecType);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapRecType);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewRecType(rgsHier);  					break;  				case RnGenericRecTags.kflidParticipants:  					if (m_mapPeople.Count == 0)  						FillPossibilityMap(rsf' m_cache.LangProject.PeopleOA.PossibilitiesOS' m_mapPeople);  					rsf.m_tlo.m_default = FindPossibilityOrNull(rgsHier' m_mapPeople);  					if (rsf.m_tlo.m_default == null && !rsf.m_tlo.m_fIgnoreNewStuff)  						rsf.m_tlo.m_default = CreateNewPerson(rgsHier);  					break;  				default:  					// must be a custom field.  					Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  					// We don't yet have the necessary information in the new FDO/MetaDataCache.  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetTextContent,The following statement contains a magic number: switch (rsf.m_flid)  			{  				case RnGenericRecTags.kflidConclusions:  					if (rec.ConclusionsOA == null)  						rec.ConclusionsOA = m_factStText.Create();  					StoreTextData(rec.ConclusionsOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidDescription:  					if (rec.DescriptionOA == null)  						rec.DescriptionOA = m_factStText.Create();  					StoreTextData(rec.DescriptionOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidDiscussion:  					if (rec.DiscussionOA == null)  						rec.DiscussionOA = m_factStText.Create();  					StoreTextData(rec.DiscussionOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidExternalMaterials:  					if (rec.ExternalMaterialsOA == null)  						rec.ExternalMaterialsOA = m_factStText.Create();  					StoreTextData(rec.ExternalMaterialsOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidFurtherQuestions:  					if (rec.FurtherQuestionsOA == null)  						rec.FurtherQuestionsOA = m_factStText.Create();  					StoreTextData(rec.FurtherQuestionsOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidHypothesis:  					if (rec.HypothesisOA == null)  						rec.HypothesisOA = m_factStText.Create();  					StoreTextData(rec.HypothesisOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidPersonalNotes:  					if (rec.PersonalNotesOA == null)  						rec.PersonalNotesOA = m_factStText.Create();  					StoreTextData(rec.PersonalNotesOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidResearchPlan:  					if (rec.ResearchPlanOA == null)  						rec.ResearchPlanOA = m_factStText.Create();  					StoreTextData(rec.ResearchPlanOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidVersionHistory:  					if (rec.VersionHistoryOA == null)  						rec.VersionHistoryOA = m_factStText.Create();  					StoreTextData(rec.VersionHistoryOA' rsf' rgsParas);  					break;  				default:  					// Handle custom field (don't think any can exist yet' but...)  					Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  					IStText text;  					int hvo = m_cache.DomainDataByFlid.get_ObjectProp(rec.Hvo' rsf.m_flid);  					if (hvo == 0)  					{  						text = m_factStText.Create();  						m_cache.DomainDataByFlid.SetObjProp(rec.Hvo' rsf.m_flid' text.Hvo);  					}  					else  					{  						if (m_repoStText == null)  							m_repoStText = m_cache.ServiceLocator.GetInstance<IStTextRepository>();  						text = m_repoStText.GetObject(hvo);  					}  					StoreTextData(text' rsf' rgsParas);  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetTextContent,The following statement contains a magic number: switch (rsf.m_flid)  			{  				case RnGenericRecTags.kflidConclusions:  					if (rec.ConclusionsOA == null)  						rec.ConclusionsOA = m_factStText.Create();  					StoreTextData(rec.ConclusionsOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidDescription:  					if (rec.DescriptionOA == null)  						rec.DescriptionOA = m_factStText.Create();  					StoreTextData(rec.DescriptionOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidDiscussion:  					if (rec.DiscussionOA == null)  						rec.DiscussionOA = m_factStText.Create();  					StoreTextData(rec.DiscussionOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidExternalMaterials:  					if (rec.ExternalMaterialsOA == null)  						rec.ExternalMaterialsOA = m_factStText.Create();  					StoreTextData(rec.ExternalMaterialsOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidFurtherQuestions:  					if (rec.FurtherQuestionsOA == null)  						rec.FurtherQuestionsOA = m_factStText.Create();  					StoreTextData(rec.FurtherQuestionsOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidHypothesis:  					if (rec.HypothesisOA == null)  						rec.HypothesisOA = m_factStText.Create();  					StoreTextData(rec.HypothesisOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidPersonalNotes:  					if (rec.PersonalNotesOA == null)  						rec.PersonalNotesOA = m_factStText.Create();  					StoreTextData(rec.PersonalNotesOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidResearchPlan:  					if (rec.ResearchPlanOA == null)  						rec.ResearchPlanOA = m_factStText.Create();  					StoreTextData(rec.ResearchPlanOA' rsf' rgsParas);  					break;  				case RnGenericRecTags.kflidVersionHistory:  					if (rec.VersionHistoryOA == null)  						rec.VersionHistoryOA = m_factStText.Create();  					StoreTextData(rec.VersionHistoryOA' rsf' rgsParas);  					break;  				default:  					// Handle custom field (don't think any can exist yet' but...)  					Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  					IStText text;  					int hvo = m_cache.DomainDataByFlid.get_ObjectProp(rec.Hvo' rsf.m_flid);  					if (hvo == 0)  					{  						text = m_factStText.Create();  						m_cache.DomainDataByFlid.SetObjProp(rec.Hvo' rsf.m_flid' text.Hvo);  					}  					else  					{  						if (m_repoStText == null)  							m_repoStText = m_cache.ServiceLocator.GetInstance<IStTextRepository>();  						text = m_repoStText.GetObject(hvo);  					}  					StoreTextData(text' rsf' rgsParas);  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetStringValue,The following statement contains a magic number: switch (rsf.m_flid)  			{  				case RnGenericRecTags.kflidTitle:  					rec.Title = tss;  					break;  				default:  					// must be a custom field.  					Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  					switch (cpt)  					{  						case CellarPropertyType.MultiString:  						case CellarPropertyType.MultiUnicode:  							m_cache.DomainDataByFlid.SetMultiStringAlt(rec.Hvo' rsf.m_flid' rsf.m_sto.m_ws.Handle' tss);  							break;  						case CellarPropertyType.String:  							m_cache.DomainDataByFlid.SetString(rec.Hvo' rsf.m_flid' tss);  							break;  					}  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetStringValue,The following statement contains a magic number: switch (rsf.m_flid)  			{  				case RnGenericRecTags.kflidTitle:  					rec.Title = tss;  					break;  				default:  					// must be a custom field.  					Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  					switch (cpt)  					{  						case CellarPropertyType.MultiString:  						case CellarPropertyType.MultiUnicode:  							m_cache.DomainDataByFlid.SetMultiStringAlt(rec.Hvo' rsf.m_flid' rsf.m_sto.m_ws.Handle' tss);  							break;  						case CellarPropertyType.String:  							m_cache.DomainDataByFlid.SetString(rec.Hvo' rsf.m_flid' tss);  							break;  					}  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetGenDateValue,The following statement contains a magic number: switch (rsf.m_flid)  			{  				case RnGenericRecTags.kflidDateOfEvent:  					rec.DateOfEvent = gdt;  					break;  				default:  					// must be a custom field.  					Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  					// There's no way to pass a GenDate item into a custom field!  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetGenDateValue,The following statement contains a magic number: switch (rsf.m_flid)  			{  				case RnGenericRecTags.kflidDateOfEvent:  					rec.DateOfEvent = gdt;  					break;  				default:  					// must be a custom field.  					Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  					// There's no way to pass a GenDate item into a custom field!  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: for (; sFmt.Length > 0; sFmt = sFmt.Substring(cch))  			{  				ch = sFmt[0];  				for (i = 1; i < sFmt.Length; ++i)  				{  					if (sFmt[i] != ch)  						break;  				}  				cch = i;  				switch (ch)  				{  					case 'd':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						switch (cch)  						{  							case 1:	// d  							case 2:	// dd  								fDayPresent = true;  								fError = !TryParseLeadingNumber(ref sDate' out gdi.mday);  								if (fError || gdi.mday > 31)  									return sDate;  								break;  							case 3:	// ddd - Abbreviated day of week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayAbbr' out gdi.wday);  								if (fError)  									return sDate;  								break;  							case 4:	// dddd - Unabbreviated day of the week  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsDayName' out gdi.wday);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'M':  						if (CheckForQuestionMarks(ref gdi' ref sDate))  						{  							if (sDate.Length == 0)  								return String.Empty;  							else  								break;  						}  						fMonthPresent = true;  						switch (cch)  						{  							case 1:	// M  							case 2:	// MM  								fError = !TryParseLeadingNumber(ref sDate' out gdi.ymon);  								if (fError || gdi.ymon > 12)  									return sDate;  								break;  							case 3: // MMM - Abbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthAbbr' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							case 4:	// MMMM - Unabbreviated month name  								fError = !TryMatchAgainstNameList(ref sDate' m_rgsMonthName' out gdi.ymon);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'y':  						if (sDate.StartsWith("?"))  						{  							gdi.error = true;  							return sDate;  						}  						fYearPresent = true;  						int year;  						int thisyear = DateTime.Now.Year;  						switch (cch)  						{  							case 1:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 9)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 2:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError || year > 99)  									return sDate;  								gdi.year = 2000 + year;  								if (gdi.year > thisyear)  									gdi.year -= 100;  								break;  							case 4:  								fError = !TryParseLeadingNumber(ref sDate' out year);  								if (fError)  									return sDate;  								break;  							default:  								return sDate;  						}  						break;    					case 'g':  						// TODO SteveMc: IMPLEMENT ME!  						return sDate;    					case '\'': // quoted text  						//cch = ParseFmtQuotedText (sFmt' sDate);  						//if (cch < 0)  						//    return 0; // text not found  						break;    					case ' ':  						sDate = sDate.Trim();  						break;    					default:  						// Check for matching separators.  						sDate = sDate.Trim();  						for (int j = 0; j < cch; ++j)  						{  							if (j >= sDate.Length || sDate[j] != ch)  								return sDate;  						}  						sDate = sDate.Substring(cch);  						sDate = sDate.Trim();  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ParseFormattedDate,The following statement contains a magic number: gdi.error = !ValidateDate(fYearPresent ? gdi.year : 2000' fMonthPresent ? gdi.ymon : 1'  				fDayPresent ? gdi.mday : 1);
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year < -9999 || year > 9999 || year == 0)  				return false;
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year < -9999 || year > 9999 || year == 0)  				return false;
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (month < 1 || month > 12)  				return false;
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: int days_in_month = 31;
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following statement contains a magic number: if (year == 1752 && month == 9)  			{  				days_in_month = 19; // the month the calendar was changed  			}  			else  			{  				switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetDateTimeValue,The following statement contains a magic number: switch (rsf.m_flid)  			{  				case RnGenericRecTags.kflidDateCreated:  					rec.DateCreated = dt;  					break;  				case RnGenericRecTags.kflidDateModified:  					rec.DateModified = dt;  					break;  				default:  					// must be a custom field.  					Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  					SilTime.SetTimeProperty(m_cache.DomainDataByFlid' rec.Hvo' rsf.m_flid' dt);  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetDateTimeValue,The following statement contains a magic number: switch (rsf.m_flid)  			{  				case RnGenericRecTags.kflidDateCreated:  					rec.DateCreated = dt;  					break;  				case RnGenericRecTags.kflidDateModified:  					rec.DateModified = dt;  					break;  				default:  					// must be a custom field.  					Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  					SilTime.SetTimeProperty(m_cache.DomainDataByFlid' rec.Hvo' rsf.m_flid' dt);  					break;  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ProcessStoredLinkData,The following statement contains a magic number: foreach (var pend in m_pendingLinks)  			{  				IRnGenericRec rec;  				var sData = pend.Field.Data;  				if (mapTitleRec.TryGetValue(sData' out rec))  				{  					if (SetLink(pend' rec))  						continue;  				}  				else  				{  					var idx1 = sData.IndexOf(" - ");  					var idx2 = sData.LastIndexOf(" - ");  					if (idx1 != idx2)  					{  						idx1 += 3;  						var sTitle = sData.Substring(idx1' idx2 - idx1);  						if (mapTitleRec.TryGetValue(sTitle' out rec))  						{  							if (SetLink(pend' rec))  								continue;  						}  					}  				}  				// log an error.  				LogMessage(  					String.Format(SIL.FieldWorks.LexText.Controls.LexTextControls.ksCannotMakeDesiredLink'  						pend.Field.Marker' pend.Field.Data)'  					pend.Field.LineNumber);    			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetListReference,The following statement contains a magic number: foreach (var sItem in rgsData)  			{  				switch (rsf.m_flid)  				{  					case RnGenericRecTags.kflidAnthroCodes:  						if (!StoreAnthroCode(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidConfidence:  						if (!StoreConfidence(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidLocations:  						if (!StoreLocation(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidPhraseTags:  						if (!StorePhraseTag(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidResearchers:  						if (!StoreResearcher(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidRestrictions:  						if (!StoreRestriction(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidSources:  						if (!StoreSource(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidStatus:  						if (!StoreStatus(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidTimeOfEvent:  						if (!StoreTimeOfEvent(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidType:  						if (!StoreRecType(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidParticipants:  						if (!StoreParticipant(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					default:  						// must be a custom field.  						Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  						Guid guidList = m_mdc.GetFieldListRoot(rsf.m_flid);  						if (guidList != Guid.Empty)  						{  							if (m_repoList == null)  								m_repoList = m_cache.ServiceLocator.GetInstance<ICmPossibilityListRepository>();  							ICmPossibilityList list = m_repoList.GetObject(guidList);  							if (list != null)  							{  								if (!StoreCustomListRefItem(rec' rsf' sItem' list))  									LogCannotFindListItem(sItem' field);  								break;  							}  						}  						LogMessage(  							String.Format(LexTextControls.ksCannotFindPossibilityList' field.Marker)'  							field.LineNumber);  						return;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetListReference,The following statement contains a magic number: foreach (var sItem in rgsData)  			{  				switch (rsf.m_flid)  				{  					case RnGenericRecTags.kflidAnthroCodes:  						if (!StoreAnthroCode(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidConfidence:  						if (!StoreConfidence(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidLocations:  						if (!StoreLocation(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidPhraseTags:  						if (!StorePhraseTag(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidResearchers:  						if (!StoreResearcher(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidRestrictions:  						if (!StoreRestriction(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidSources:  						if (!StoreSource(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidStatus:  						if (!StoreStatus(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidTimeOfEvent:  						if (!StoreTimeOfEvent(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidType:  						if (!StoreRecType(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					case RnGenericRecTags.kflidParticipants:  						if (!StoreParticipant(rec' rsf' sItem))  							LogCannotFindListItem(sItem' field);  						break;  					default:  						// must be a custom field.  						Debug.Assert(rsf.m_flid >= (RnGenericRecTags.kClassId * 1000) + 500);  						Guid guidList = m_mdc.GetFieldListRoot(rsf.m_flid);  						if (guidList != Guid.Empty)  						{  							if (m_repoList == null)  								m_repoList = m_cache.ServiceLocator.GetInstance<ICmPossibilityListRepository>();  							ICmPossibilityList list = m_repoList.GetObject(guidList);  							if (list != null)  							{  								if (!StoreCustomListRefItem(rec' rsf' sItem' list))  									LogCannotFindListItem(sItem' field);  								break;  							}  						}  						LogMessage(  							String.Format(LexTextControls.ksCannotFindPossibilityList' field.Marker)'  							field.LineNumber);  						return;  				}  			}
Magic Number,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,InitializeComponent,The following statement contains a magic number: this.StepPageCount = 7;
Missing Default,SIL.FieldWorks.LexText.Controls,EntryGoSearchEngine,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\EntryGoSearchEngine.cs,IsIndexResetRequired,The following switch statement is missing a default case: switch (flid)  			{  				case LexEntryTags.kflidCitationForm:  				case LexEntryTags.kflidLexemeForm:  				case LexEntryTags.kflidAlternateForms:  				case LexEntryTags.kflidSenses:  				case MoFormTags.kflidForm:  				case LexSenseTags.kflidSenses:  				case LexSenseTags.kflidGloss:  				case LexSenseTags.kflidDefinition:  				case LexSenseTags.kflidReversalEntries:  				case ReversalIndexEntryTags.kflidReversalForm:  					return true;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,EntryGoSearchEngine,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\EntryGoSearchEngine.cs,IsFieldMultiString,The following switch statement is missing a default case: switch (field.Flid)  			{  				case LexEntryTags.kflidCitationForm:  				case LexEntryTags.kflidLexemeForm:  				case LexEntryTags.kflidAlternateForms:  				case LexSenseTags.kflidGloss:  				case LexSenseTags.kflidDefinition:  				case LexSenseTags.kflidReversalEntries:  					return true;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,InsertEntrySearchEngine,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntrySearchEngine.cs,IsIndexResetRequired,The following switch statement is missing a default case: switch (flid)  			{  				case LexEntryTags.kflidCitationForm:  				case LexEntryTags.kflidLexemeForm:  				case LexEntryTags.kflidAlternateForms:  				case LexEntryTags.kflidSenses:  				case MoFormTags.kflidForm:  				case LexSenseTags.kflidSenses:  				case LexSenseTags.kflidGloss:  					return true;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,InsertEntrySearchEngine,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntrySearchEngine.cs,IsFieldMultiString,The following switch statement is missing a default case: switch (field.Flid)  			{  				case LexEntryTags.kflidCitationForm:  				case LexEntryTags.kflidLexemeForm:  				case LexEntryTags.kflidAlternateForms:  				case LexSenseTags.kflidGloss:  					return true;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,PatternVcBase,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PatternVcBase.cs,DisplayVariant,The following switch statement is missing a default case: switch (frag)  			{  				case kfragEmpty:  					tss = m_empty;  					break;    				case kfragLeftBracketUpHook:  					tss = m_leftBracketUpHook;  					break;    				case kfragLeftBracketExt:  					tss = m_leftBracketExt;  					break;    				case kfragLeftBracketLowHook:  					tss = m_leftBracketLowHook;  					break;    				case kfragRightBracketUpHook:  					tss = m_rightBracketUpHook;  					break;    				case kfragRightBracketExt:  					tss = m_rightBracketExt;  					break;    				case kfragRightBracketLowHook:  					tss = m_rightBracketLowHook;  					break;    				case kfragLeftBracket:  					tss = m_leftBracket;  					break;    				case kfragRightBracket:  					tss = m_rightBracket;  					break;    				case kfragLeftParenUpHook:  					tss = m_leftParenUpHook;  					break;    				case kfragLeftParenExt:  					tss = m_leftParenExt;  					break;    				case kfragLeftParenLowHook:  					tss = m_leftParenLowHook;  					break;    				case kfragRightParenUpHook:  					tss = m_rightParenUpHook;  					break;    				case kfragRightParenExt:  					tss = m_rightParenExt;  					break;    				case kfragRightParenLowHook:  					tss = m_rightParenLowHook;  					break;    				case kfragLeftParen:  					tss = m_leftParen;  					break;    				case kfragRightParen:  					tss = m_rightParen;  					break;    				case kfragQuestions:  					tss = m_questions;  					break;    				case kfragZeroWidthSpace:  					tss = m_zwSpace;  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,RecordGoSearchEngine,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\RecordGoSearchEngine.cs,IsIndexResetRequired,The following switch statement is missing a default case: switch (flid)  			{  				case RnResearchNbkTags.kflidRecords:  				case RnGenericRecTags.kflidSubRecords:  				case RnGenericRecTags.kflidTitle:  					return true;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,RecordGoSearchEngine,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\RecordGoSearchEngine.cs,IsFieldMultiString,The following switch statement is missing a default case: switch (field.Flid)  			{  				case RnGenericRecTags.kflidTitle:  					return false;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,BaseGoDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\BaseGoDlg.cs,m_tbForm_KeyDown,The following switch statement is missing a default case: switch (e.KeyCode)  			{  				case Keys.Up:  					m_matchingObjectsBrowser.SelectPrevious();  					e.Handled = true;  					m_tbForm.Select();  					break;  				case Keys.Down:  					m_matchingObjectsBrowser.SelectNext();  					e.Handled = true;  					m_tbForm.Select();  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,InsertRecordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertRecordDlg.cs,OnClosing,The following switch statement is missing a default case: switch (m_owner.ClassID)  						{  							case RnResearchNbkTags.kClassId:  								m_newRecord = recFactory.Create((IRnResearchNbk) m_owner' m_titleTextBox.Tss' type);  								break;    							case RnGenericRecTags.kClassId:  								m_newRecord = recFactory.Create((IRnGenericRec) m_owner' m_titleTextBox.Tss' type);  								break;  						}
Missing Default,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteLexEntryRefBasics,The following switch statement is missing a default case: switch (ler.RefType)  				{  					case LexEntryRefTags.krtVariant:  						w.WriteLine("<trait name=\"variant-type\" value=\"\"/>");  						break;  					case LexEntryRefTags.krtComplexForm:  						w.WriteLine("<trait name=\"complex-form-type\" value=\"\"/>");  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteAlternateForm,The following switch statement is missing a default case: switch (alt.ClassID)  			{  				case MoStemAllomorphTags.kClassId:  					{  						var stemAllo = alt as IMoStemAllomorph;  						Debug.Assert(stemAllo != null);  						var refer = GetProperty(alt' "LiftRefAttribute") as string;  						if (!String.IsNullOrEmpty(refer))  							w.Write(" ref=\"{0}\""' MakeSafeAndNormalizedAttribute(refer));  						w.WriteLine(">");  						WriteAllFormsWithMarkers(w' null' null' "form"' alt);  						foreach (var env in stemAllo.PhoneEnvRC)  							WritePhEnvironment(w' env);  					}  					break;  				case MoAffixAllomorphTags.kClassId:  					{  						var affixAllo = alt as IMoAffixAllomorph;  						Debug.Assert(affixAllo != null);  						var refer = GetProperty(alt' "LiftRefAttribute") as string;  						if (!String.IsNullOrEmpty(refer))  							w.Write(" ref=\"{0}\""' MakeSafeAndNormalizedAttribute(refer));  						w.WriteLine(">");  						WriteAllFormsWithMarkers(w' null' null' "form"' alt);  						foreach (var env in affixAllo.PhoneEnvRC)  							WritePhEnvironment(w' env);  					}  					break;  				case MoAffixProcessTags.kClassId:  					{  						w.WriteLine(">");  						WriteAllFormsWithMarkers(w' null' null' "form"' alt);  					}  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteLexSense,The following switch statement is missing a default case: switch (sense.MorphoSyntaxAnalysisRA.ClassID)  				{  					case MoStemMsaTags.kClassId:  						WriteMoStemMsa(w' sense.MorphoSyntaxAnalysisRA as IMoStemMsa);  						break;  					case MoUnclassifiedAffixMsaTags.kClassId:  						WriteMoUnclassifiedAffixMsa(w' sense.MorphoSyntaxAnalysisRA as IMoUnclassifiedAffixMsa);  						break;  					case MoInflAffMsaTags.kClassId:  						WriteMoInflAffMsa(w' sense.MorphoSyntaxAnalysisRA as IMoInflAffMsa);  						break;  					case MoDerivAffMsaTags.kClassId:  						WriteMoDerivAffMsa(w' sense.MorphoSyntaxAnalysisRA as IMoDerivAffMsa);  						break;  					case MoDerivStepMsaTags.kClassId:  						WriteMoDerivStepMsa(w' sense.MorphoSyntaxAnalysisRA as IMoDerivStepMsa);  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,GetLiftExportMagicWsNameFromId,The following switch statement is missing a default case: switch (ws)  			{  				case WritingSystemServices.kwsAnal:  					return "kwsAnal";  				case WritingSystemServices.kwsVern:  					return "kwsVern";  				case WritingSystemServices.kwsAnals:  					return "kwsAnals";  				case WritingSystemServices.kwsVerns:  					return "kwsVerns";  				case WritingSystemServices.kwsAnalVerns:  					return "kwsAnalVerns";  				case WritingSystemServices.kwsVernAnals:  					return "kwsVernAnals";  			}
Missing Default,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,ConvertTsStringToLiftXml,The following switch statement is missing a default case: switch (tpt)  						{  							case (int)FwTextPropType.ktptNamedStyle:  								bldr.AppendFormat(" class=\"{0}\""' MakeSafeAndNormalizedAttribute(sProp));  								break;  							case (int)FwTextPropType.ktptObjData:  								AddObjPropData(bldr' sProp);  								break;  						}
Missing Default,SIL.FieldWorks.LexText.Controls,LiftExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftExporter.cs,WriteInflectionFeatureRange,The following switch statement is missing a default case: switch (featDefn.ClassID)  				{  					case FsClosedFeatureTags.kClassId:  						var closed = (IFsClosedFeature)featDefn;  						foreach (var value in closed.ValuesOC)  						{  							var name = String.Format("{0}-feature-value"'  								closed.Abbreviation.BestAnalysisVernacularAlternative.Text);  							WriteTrait(w' name' value.Abbreviation' m_wsBestAnalVern);  						}  						w.WriteLine("<trait name=\"feature-definition-type\" value=\"closed\"/>");  						break;  					case FsComplexFeatureTags.kClassId:  						var complex = (IFsComplexFeature)featDefn;  						if (complex.TypeRA != null)  							WriteTrait(w' "type"' complex.TypeRA.Abbreviation' m_wsBestAnalVern);  						w.WriteLine("<trait name=\"feature-definition-type\" value=\"complex\"/>");  						break;  					case FsOpenFeatureTags.kClassId:  						var open = (IFsOpenFeature)featDefn;  						if (open.WsSelector != 0)  							w.WriteLine("<trait name=\"ws-selector\" value=\"{0}\"/>"' open.WsSelector);  						if (!String.IsNullOrEmpty(open.WritingSystem))  							w.WriteLine("<trait name=\"writing-system\" value=\"{0}\"/>"'  								XmlUtils.MakeSafeXmlAttribute(open.WritingSystem));  						w.WriteLine("<trait name=\"feature-definition-type\" value=\"open\"/>");  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,GetRangeElementDetails,The following switch statement is missing a default case: switch (xn.Name)  				{  					case "label": xnLabel = xn; break;  					case "abbrev": xnAbbrev = xn; break;  					case "description": xnDescription = xn; break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,GetLiftExportMagicWsIdFromName,The following switch statement is missing a default case: switch (name)  			{  				case "kwsAnal":  					return WritingSystemServices.kwsAnal;  				case "kwsVern":  					return WritingSystemServices.kwsVern;  				case "kwsAnals":  					return WritingSystemServices.kwsAnals;  				case "kwsVerns":  					return WritingSystemServices.kwsVerns;  				case "kwsAnalVerns":  					return WritingSystemServices.kwsAnalVerns;  				case "kwsVernAnals":  					return WritingSystemServices.kwsVernAnals;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,StoreLexReference,The following switch statement is missing a default case: switch (lrt.MappingType)  			{  				case (int)LexRefTypeTags.MappingTypes.kmtEntryAsymmetricPair:  				case (int)LexRefTypeTags.MappingTypes.kmtEntryOrSenseAsymmetricPair:  				case (int)LexRefTypeTags.MappingTypes.kmtSenseAsymmetricPair:  					StoreAsymmetricPairRelations(refsAsYetUnmatched' lrt' rgRelation' ObjectIsFirstInRelation(rgRelation[0].RelationType' lrt));  					break;  				case (int)LexRefTypeTags.MappingTypes.kmtEntryPair:  				case (int)LexRefTypeTags.MappingTypes.kmtEntryOrSensePair:  				case (int)LexRefTypeTags.MappingTypes.kmtSensePair:  					StorePairRelations(refsAsYetUnmatched' lrt' rgRelation);  					break;  				case (int)LexRefTypeTags.MappingTypes.kmtEntryCollection:  				case (int)LexRefTypeTags.MappingTypes.kmtEntryOrSenseCollection:  				case (int)LexRefTypeTags.MappingTypes.kmtSenseCollection:  					CollapseCollectionRelationPairs(rgRelation' uniqueRelations);  					break;  				case (int)LexRefTypeTags.MappingTypes.kmtEntryOrSenseSequence:  				case (int)LexRefTypeTags.MappingTypes.kmtEntrySequence:  				case (int)LexRefTypeTags.MappingTypes.kmtSenseSequence:  					StoreSequenceRelation(refsAsYetUnmatched' lrt' rgRelation);  					break;  				case (int)LexRefTypeTags.MappingTypes.kmtEntryOrSenseTree:  				case (int)LexRefTypeTags.MappingTypes.kmtEntryTree:  				case (int)LexRefTypeTags.MappingTypes.kmtSenseTree:  				case (int)LexRefTypeTags.MappingTypes.kmtEntryOrSenseUnidirectional:  				case (int)LexRefTypeTags.MappingTypes.kmtEntryUnidirectional:  				case (int)LexRefTypeTags.MappingTypes.kmtSenseUnidirectional:  					StoreTreeRelation(refsAsYetUnmatched' lrt' rgRelation);  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureDefinition,The following switch statement is missing a default case: switch (type)  				{  					case "gloss-abbrev":  						xnGlossAbbrev = xn;  						break;  					case "right-gloss-sep":  						xnRightGlossSep = xn;  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureDefinition,The following switch statement is missing a default case: switch (sSubclassType)  			{  				case "complex":  					FinishMergingComplexFeatDefn(feat as IFsComplexFeature' sComplexType);  					break;  				case "open":  					FinishMergingOpenFeatDefn(feat as IFsOpenFeature' nWsSelector' sWs);  					break;  				case "closed":  					FinishMergingClosedFeatDefn(feat as IFsClosedFeature' rgsValues' id);  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureStrucType,The following switch statement is missing a default case: switch (name)  				{  					case "catalog-source-id":  						sCatalogId = XmlUtils.GetMandatoryAttributeValue(xn' "value");  						break;  					case "feature":  						rgsFeatures.Add(XmlUtils.GetMandatoryAttributeValue(xn' "value"));  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessFeatureValue,The following switch statement is missing a default case: switch (name)  				{  					case "catalog-source-id":  						sCatalogId = XmlUtils.GetAttributeValue(xn' "value");  						break;  					case "show-in-gloss":  						fShowInGloss = XmlUtils.GetBooleanAttributeValue(xn' "value");  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,EntryTraitsConflict,The following switch statement is missing a default case: switch (lt.Name.ToLowerInvariant())  				{  					case "entrytype":	// original FLEX export = EntryType  					case "entry-type":  						// This trait is no longer used by FLEX.  						break;  					case RangeNames.sDbMorphTypesOAold:	// original FLEX export = MorphType  					case RangeNames.sDbMorphTypesOA:  						if (le.LexemeFormOA != null && le.LexemeFormOA.MorphTypeRA != null)  						{  							IMoMorphType mmt = FindMorphType(lt.Value);  							if (le.LexemeFormOA.MorphTypeRA != mmt)  							{  								m_cdConflict = new ConflictingEntry("Morph Type"' le' this);  								return true;  							}  						}  						break;  					case "minorentrycondition":		// original FLEX export = MinorEntryCondition  					case "minor-entry-condition":  						// This trait is no longer used by FLEX.  						break;  					case "excludeasheadword":	// original FLEX export = ExcludeAsHeadword  					case "exclude-as-headword":  						// MDL: Remove when Lift interface is updated for ShowHeadwordIn  						break;  					case "donotuseforparsing":	// original FLEX export = DoNotUseForParsing  					case "do-not-use-for-parsing":  						bool fDontUse = XmlUtils.GetBooleanAttributeValue(lt.Value);  						if (le.DoNotUseForParsing != fDontUse)  						{  							m_cdConflict = new ConflictingEntry("Do Not Use For Parsing"' le' this);  							return true;  						}  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,EntryNotesConflict,The following switch statement is missing a default case: switch (note.Type.ToLowerInvariant())  				{  					case "bibliography":  						if (MultiTsStringsConflict(le.Bibliography' note.Content))  						{  							m_cdConflict = new ConflictingEntry("Bibliography"' le' this);  							return true;  						}  						break;  					case "comment":  						if (MultiTsStringsConflict(le.Comment' note.Content))  						{  							m_cdConflict = new ConflictingEntry("Note"' le' this);  							return true;  						}  						break;  					case RangeNames.sRestrictionsOA:  						if (MultiUnicodeStringsConflict(le.Restrictions' note.Content' false' Guid.Empty' 0))  						{  							m_cdConflict = new ConflictingEntry("Restrictions"' le' this);  							return true;  						}  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ProcessStTextField,The following switch statement is missing a default case: switch (m_msImport)  				{  					case MergeStyle.MsKeepOld:  						// Add any additional paragraphs to the end of the text.  						for (var i = cparaOld; i < cparaNew; ++i)  						{  							var para = paras[i];  							var stPara = paraFact.Create();  							text.ParagraphsOS.Add(stPara);  							if (!String.IsNullOrEmpty(para.StyleName))  								stPara.StyleName = para.StyleName;  							stPara.Contents = para.Contents;  						}  						break;  					case MergeStyle.MsKeepNew:  						// Replace old paragraph contents with the new.  If there are extra old paragraphs'  						// keep them.  (This decision is apt to change.)  						for (var i = 0; i < cparaNew; ++i)  						{  							var para = paras[i];  							IStTxtPara stPara;  							if (i < cparaOld)  							{  								stPara = text.ParagraphsOS[i] as IStTxtPara;  								if (stPara == null)  								{  									stPara = paraFact.Create();  									text.ParagraphsOS[i] = stPara;  								}  							}  							else  							{  								stPara = paraFact.Create();  								text.ParagraphsOS.Add(stPara);  							}  							if (!String.IsNullOrEmpty(para.StyleName))  								stPara.StyleName = para.StyleName;  							stPara.Contents = para.Contents;  						}  						//if (cparaNew < cparaOld)  						//    text.ParagraphsOS.Replace(cparaNew' cparaOld - cparaNew' new List<ICmObject>());  						break;  					case MergeStyle.MsKeepBoth:  						// If the new and old paragraphs differ (ignoring all style and writing system information)'  						// then append the new paragraph content to the old' with a Unicode line separator character  						// between them.  						var indexes = new List<int>();  						for (var i = 0; i < cparaNew; ++i)  						{  							var para = paras[i];  							IStTxtPara stPara;  							if (i < cparaOld)  							{  								stPara = text.ParagraphsOS[i] as IStTxtPara;  								if (stPara != null && para.Contents.Text == stPara.Contents.Text)  									continue;  								if (stPara != null)  								{  									var tisb = stPara.Contents.GetIncBldr();  									tisb.Append("\u2028");  									tisb.AppendTsString(para.Contents);  									stPara.Contents = tisb.GetString();  								}  								else  								{  									indexes.Add(i);  								}  							}  							else  							{  								stPara = paraFact.Create();  								text.ParagraphsOS.Add(stPara);  								if (!String.IsNullOrEmpty(para.StyleName))  									stPara.StyleName = para.StyleName;  								stPara.Contents = para.Contents;  							}  						}  						// handle incompatible paragraphs by inserting a new paragraph immediately following  						// the old one.  						for (var j = indexes.Count - 1; j >= 0; --j)  						{  							var ipara = indexes[j];  							var stPara = paraFact.Create();  							text.ParagraphsOS.Insert(ipara + 1' stPara);  							var para = paras[ipara];  							if (!String.IsNullOrEmpty(para.StyleName))  								stPara.StyleName = para.StyleName;  							stPara.Contents = para.Contents;  						}  						break;  					case MergeStyle.MsKeepOnlyNew:  						text.ParagraphsOS.Clear();  						Debug.Assert(text.ParagraphsOS.Count == 0);  						InsertAllParagraphs(text' paras' paraFact);  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,MoFormTraitsConflict,The following switch statement is missing a default case: switch (lt.Name.ToLowerInvariant())  				{  					case RangeNames.sDbMorphTypesOAold:	// original FLEX export = MorphType  					case RangeNames.sDbMorphTypesOA:  						if (mf.MorphTypeRA != null)  						{  							IMoMorphType mmt = FindMorphType(lt.Value);  							if (mf.MorphTypeRA != mmt)  								return true;  						}  						break;  					case "environment":  						if (mf is IMoStemAllomorph)  						{  							if ((mf as IMoStemAllomorph).PhoneEnvRC.Count > 0)  							{  								//int hvo = FindOrCreateEnvironment(lt.Value);  							}  						}  						else if (mf is IMoAffixAllomorph)  						{  							if ((mf as IMoAffixAllomorph).PhoneEnvRC.Count > 0)  							{  								//int hvo = FindOrCreateEnvironment(lt.Value);  							}  						}  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,EtymologyFieldsConflict,The following switch statement is missing a default case: switch (field.Type.ToLowerInvariant())  				{  					case "comment":  						if (MultiTsStringsConflict(lexety.Comment' field.Content))  							return true;  						break;  					case "languagenotes":  						if (MultiTsStringsConflict(lexety.LanguageNotes' field.Content))  							return true;  						break;  					case "preccomment":  						if (MultiTsStringsConflict(lexety.PrecComment' field.Content))  							return true;  						break;  					case "note":  						if (MultiTsStringsConflict(lexety.Note' field.Content))  							return true;  						break;  					case "bibliography":  						if (MultiTsStringsConflict(lexety.Bibliography' field.Content))  							return true;  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,ExampleNotesConflict,The following switch statement is missing a default case: switch (note.Type.ToLowerInvariant())  				{  					case "reference":  						if (StringsConflict(les.Reference' GetFirstLiftTsString(note.Content)))  							return true;  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SenseNotesConflict,The following switch statement is missing a default case: switch (note.Type.ToLowerInvariant())  				{  					case "anthropology":  						if (MultiTsStringsConflict(ls.AnthroNote' note.Content))  						{  							m_cdConflict = new ConflictingSense("Anthropology Note"' ls' this);  							return true;  						}  						break;  					case "bibliography":  						if (MultiTsStringsConflict(ls.Bibliography' note.Content))  						{  							m_cdConflict = new ConflictingSense("Bibliography"' ls' this);  							return true;  						}  						break;  					case "discourse":  						if (MultiTsStringsConflict(ls.DiscourseNote' note.Content))  						{  							m_cdConflict = new ConflictingSense("Discourse Note"' ls' this);  							return true;  						}  						break;  					case "encyclopedic":  						if (MultiTsStringsConflict(ls.EncyclopedicInfo' note.Content))  						{  							m_cdConflict = new ConflictingSense("Encyclopedic Info"' ls' this);  							return true;  						}  						break;  					case "general":  						if (MultiTsStringsConflict(ls.GeneralNote' note.Content))  						{  							m_cdConflict = new ConflictingSense("General Note"' ls' this);  							return true;  						}  						break;  					case "grammar":  						if (MultiTsStringsConflict(ls.GrammarNote' note.Content))  						{  							m_cdConflict = new ConflictingSense("Grammar Note"' ls' this);  							return true;  						}  						break;  					case "phonology":  						if (MultiTsStringsConflict(ls.PhonologyNote' note.Content))  						{  							m_cdConflict = new ConflictingSense("Phonology Note"' ls' this);  							return true;  						}  						break;  					case RangeNames.sRestrictionsOA:  						if (MultiUnicodeStringsConflict(ls.Restrictions' note.Content' false' Guid.Empty' 0))  						{  							m_cdConflict = new ConflictingSense("Restrictions"' ls' this);  							return true;  						}  						break;  					case "semantics":  						if (MultiTsStringsConflict(ls.SemanticsNote' note.Content))  						{  							m_cdConflict = new ConflictingSense("Semantics Note"' ls' this);  							return true;  						}  						break;  					case "sociolinguistics":  						if (MultiTsStringsConflict(ls.SocioLinguisticsNote' note.Content))  						{  							m_cdConflict = new ConflictingSense("Sociolinguistics Note"' ls' this);  							return true;  						}  						break;  					case "source":  						IgnoreNewWs();  						if (StringsConflict(ls.Source' GetFirstLiftTsString(note.Content)))  						{  							m_cdConflict = new ConflictingSense("Source"' ls' this);  							return true;  						}  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,FlexLiftMerger,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerRanges.cs,SenseTraitsConflict,The following switch statement is missing a default case: switch (lt.Name.ToLowerInvariant())  				{  					case RangeNames.sAnthroListOA:  						ICmAnthroItem ant = FindOrCreateAnthroCode(lt.Value);  						// how do you detect conflicts in a reference list?  						break;  					case RangeNames.sSemanticDomainListOAold1:	// for WeSay 0.4 compatibility  					case RangeNames.sSemanticDomainListOAold2:  					case RangeNames.sSemanticDomainListOAold3:  					case RangeNames.sSemanticDomainListOA:  						poss = FindOrCreateSemanticDomain(lt.Value);  						// how do you detect conflicts in a reference list?  						break;  					case RangeNames.sDbDialectLabelsOA:  						poss = FindOrCreateDialect(lt.Value);  						break;  					case RangeNames.sDbDomainTypesOAold1:	// original FLEX export = DomainType  					case RangeNames.sDbDomainTypesOA:  						poss = FindOrCreateDomainType(lt.Value);  						// how do you detect conflicts in a reference list?  						break;  					case RangeNames.sDbSenseTypesOAold1:	// original FLEX export = SenseType  					case RangeNames.sDbSenseTypesOA:  						poss = FindOrCreateSenseType(lt.Value);  						if (ls.SenseTypeRA != null && ls.SenseTypeRA != poss)  						{  							m_cdConflict = new ConflictingSense("Sense Type"' ls' this);  							return true;  						}  						break;  					case RangeNames.sStatusOA:  						poss = FindOrCreateStatus(lt.Value);  						if (ls.StatusRA != null && ls.StatusRA != poss)  						{  							m_cdConflict = new ConflictingSense("Status"' ls' this);  							return true;  						}  						break;  					case RangeNames.sDbUsageTypesOAold:	// original FLEX export = UsageType  					case RangeNames.sDbUsageTypesOA:  						poss = FindOrCreateUsageType(lt.Value);  						// how do you detect conflicts in a reference list?  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,PendingLexEntryRef,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LiftMergerSupportCodeAndClasses.cs,ProcessRelationData,The following switch statement is missing a default case: switch (trait.Name)  					{  						case "complex-form-type":  							m_rgsComplexFormTypes.Add(trait.Value);  							knownTraits.Add(trait);  							break;  						case "variant-type":  							m_rgsVariantTypes.Add(trait.Value);  							knownTraits.Add(trait);  							break;  						case "hide-minor-entry":  							Int32.TryParse(trait.Value' out m_nHideMinorEntry);  							knownTraits.Add(trait);  							break;  						case "is-primary":  							m_fIsPrimary = (trait.Value.ToLowerInvariant() == "true");  							m_fExcludeAsHeadword = m_fIsPrimary;  							knownTraits.Add(trait);  							break;  					}
Missing Default,SIL.FieldWorks.LexText.Controls,InsertEntryDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\InsertEntryDlg.cs,SetDlgInfo,The following switch statement is missing a default case: switch (filter)  					{  						case MorphTypeFilterType.Prefix:  							if (mType.IsPrefixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Suffix:  							if (mType.IsSuffixishType)  								al.Add(mType);  							break;    						case MorphTypeFilterType.Any:  							al.Add(mType);  							break;  					}
Missing Default,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,CheckForMapFileVersionChanges,The following switch statement is missing a default case: switch (data.FwDestID)  				{  					case "lxrel":	// Lexical relation  					case "cref":	// Cross reference fields  					case "funold": // Old lexical function field  						if (data.RefFuncWS == string.Empty)  							data.RefFuncWS = topAnalysis;	// dont let it be blank for old map files  						break;    					case "subd":	// Subentry (Derivation)  					case "subc":	// Subentry (Compound)  					case "subi":	// Subentry (Idiom)  					case "subk":	// Subentry (Keyterm Phrase)  					case "subpd":	// Subentry (Phrasal Verb)  					case "subs":	// Subentry (Saying)  						data.FwDestID_Changed = "sub";	// new value  						data.RefFuncWS = topAnalysis;  						break;    					case "vard":	// Variant (Dialectal)  					case "varf":	// Variant (Free)  					case "vari":	// Variant (Inflectional)  					case "vars":	// Variant (Spelling)  					//case "varc":	// Variant (Comment)  						data.FwDestID_Changed = "var";	// new value  						data.RefFuncWS = topAnalysis;  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ProcessErrorLogErrors,The following switch statement is missing a default case: switch (Attribute.Name)  					{  						case "count":  							errorCount = Convert.ToInt32(Attribute.Value);  							break;  						case "listed":  							listedErrors = Convert.ToInt32(Attribute.Value);  							break;  					}
Missing Default,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ProcessErrorLogWarnings,The following switch statement is missing a default case: switch (Attribute.Name)  					{  					case "count":  						warningCount = Convert.ToInt32(Attribute.Value);  						break;  					}
Missing Default,SIL.FieldWorks.LexText.Controls,LexImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizard.cs,ProcessErrorLogCautions,The following switch statement is missing a default case: switch (Attribute.Name)  					{  						case "count":  							cautionCount = Convert.ToInt32(Attribute.Value);  							break;  						case "listed":  							listedCautions = Convert.ToInt32(Attribute.Value);  							break;  					}
Missing Default,SIL.FieldWorks.LexText.Controls,LexImportWizardLanguage,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardLanguage.cs,setupHelp,The following switch statement is missing a default case: switch(m_LinguaLinksImport)  			{  				case true:  					m_helpTopic = "khtpLinguaLinksImportLanguageMapping";  					break;  				case false:  					m_helpTopic = "khtpImportSFMLanguageMapping";  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,FillLexicalRefTypesCombo,The following switch statement is missing a default case: switch (lrt.MappingType)  						{  							case (int)MappingTypes.kmtEntryCollection:  							case (int)MappingTypes.kmtEntryPair:  							case (int)MappingTypes.kmtEntrySequence:  							case (int)MappingTypes.kmtEntryUnidirectional:  							case (int)MappingTypes.kmtEntryOrSenseCollection:  							case (int)MappingTypes.kmtEntryOrSensePair:  							case (int)MappingTypes.kmtEntryOrSenseSequence:  							case (int)MappingTypes.kmtEntryOrSenseUnidirectional:  								//abbr = lrt.Abbreviation.AnalysisDefaultWritingSystem.Text;  								//name = lrt.Name.AnalysisDefaultWritingSystem.Text;  								//AddAbbrAndNameInfo(abbr' name' "en"' null' null' null);  								AddAbbrAndNameInfo(lrt.Abbreviation' lrt.Name' null' null);  								break;  							case (int)MappingTypes.kmtEntryAsymmetricPair:  							case (int)MappingTypes.kmtEntryTree:  							case (int)MappingTypes.kmtEntryOrSenseAsymmetricPair:  							case (int)MappingTypes.kmtEntryOrSenseTree:  								//abbr = lrt.Abbreviation.AnalysisDefaultWritingSystem.Text;  								//name = lrt.Name.AnalysisDefaultWritingSystem.Text;  								//reverseAbbr = lrt.ReverseAbbreviation.AnalysisDefaultWritingSystem.Text;  								//reverseName = lrt.ReverseName.AnalysisDefaultWritingSystem.Text;  								//AddAbbrAndNameInfo(abbr' name' "en"' reverseAbbr' reverseName' "en");  								AddAbbrAndNameInfo(lrt.Abbreviation' lrt.Name' lrt.ReverseAbbreviation' lrt.ReverseName);  								break;  						}
Missing Default,SIL.FieldWorks.LexText.Controls,LexImportWizardMarker,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LexImportWizardMarker.cs,FillLexicalRefTypesCombo,The following switch statement is missing a default case: switch (lrt.MappingType)  						{  							case (int)MappingTypes.kmtSenseCollection:  							case (int)MappingTypes.kmtSensePair:  							case (int)MappingTypes.kmtSenseSequence:  							case (int)MappingTypes.kmtSenseUnidirectional:  							case (int)MappingTypes.kmtEntryOrSenseCollection:  							case (int)MappingTypes.kmtEntryOrSensePair:  							case (int)MappingTypes.kmtEntryOrSenseSequence:  							case (int)MappingTypes.kmtEntryOrSenseUnidirectional:  								//abbr = lrt.Abbreviation.AnalysisDefaultWritingSystem.Text;  								//name = lrt.Name.AnalysisDefaultWritingSystem.Text;  								//AddAbbrAndNameInfo(abbr' name' "en"' null' null' null);  								AddAbbrAndNameInfo(lrt.Abbreviation' lrt.Name' null' null);  								break;  							case (int)MappingTypes.kmtSenseAsymmetricPair:  							case (int)MappingTypes.kmtSenseTree:  							case (int)MappingTypes.kmtEntryOrSenseAsymmetricPair:  							case (int)MappingTypes.kmtEntryOrSenseTree:  								//abbr = lrt.Abbreviation.AnalysisDefaultWritingSystem.Text;  								//name = lrt.Name.AnalysisDefaultWritingSystem.Text;  								//reverseAbbr = lrt.ReverseAbbreviation.AnalysisDefaultWritingSystem.Text;  								//reverseName = lrt.ReverseName.AnalysisDefaultWritingSystem.Text;  								//AddAbbrAndNameInfo(abbr' name' "en"' reverseAbbr' reverseName' "en");  								AddAbbrAndNameInfo(lrt.Abbreviation' lrt.Name' lrt.ReverseAbbreviation' lrt.ReverseName);  								break;  						}
Missing Default,SIL.FieldWorks.LexText.Controls,LinkEntryOrSenseDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\LinkEntryOrSenseDlg.cs,SetDlgInfo,The following switch statement is missing a default case: switch (wp.m_title)  				{  					case "Identify sense":  						m_helpTopic = "khtpAddSenseToReversalEntry";  						m_btnHelp.Enabled = true;  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,GetPosFromCmObjectAndFlid,The following switch statement is missing a default case: switch (cobj.ClassID)  			{  				case MoInflAffMsaTags.kClassId:  					var infl = (IMoInflAffMsa) cobj;  					return infl.PartOfSpeechRA;  				case MoDerivAffMsaTags.kClassId:  					var deriv = (IMoDerivAffMsa) cobj;  					if (owningFlid == MoDerivAffMsaTags.kflidFromMsFeatures)  						return deriv.FromPartOfSpeechRA;  					if (owningFlid == MoDerivAffMsaTags.kflidToMsFeatures)  						return deriv.ToPartOfSpeechRA;  					break;  				case MoStemMsaTags.kClassId:  					var stem = (IMoStemMsa) cobj;  					return stem.PartOfSpeechRA;  				case MoStemNameTags.kClassId:  					var sn = (IMoStemName) cobj;  					return sn.Owner as IPartOfSpeech;  				case MoAffixAllomorphTags.kClassId:  					// get entry of the allomorph and then get the msa of first sense and return its (from) POS  					var entry = cobj.Owner as ILexEntry;  					if (entry == null)  						return null;  					var sense = entry.SensesOS[0];  					if (sense == null)  						return null;  					var msa = sense.MorphoSyntaxAnalysisRA;  					return GetPosFromCmObjectAndFlid(msa' MoDerivAffMsaTags.kflidFromMsFeatures);  			}
Missing Default,SIL.FieldWorks.LexText.Controls,MsaInflectionFeatureListDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\MsaInflectionFeatureListDlg.cs,BuildFeatureStructure,The following switch statement is missing a default case: switch (node.Kind)  			{  				case FeatureTreeNodeInfo.NodeKind.Complex:  					var complexFeat = m_cache.ServiceLocator.GetInstance<IFsComplexFeatureRepository>().GetObject(node.Hvo);  					var complex = fs.GetOrCreateValue(complexFeat);  					val = complex;  					val.FeatureRA = complexFeat;  					if (fs.TypeRA == null)  						fs.TypeRA = m_cache.LanguageProject.MsFeatureSystemOA.TypesOC.SingleOrDefault(type => type.FeaturesRS.Contains(complexFeat));  					fs = (IFsFeatStruc)complex.ValueOA;  					if (fs.TypeRA == null)  					{  						// this is the type of what's being embedded in the fs  						var cf = val.FeatureRA as IFsComplexFeature;  						if (cf != null)  						{  							fs.TypeRA = cf.TypeRA;  						}  					}  					break;  				case FeatureTreeNodeInfo.NodeKind.Closed:  					var closedFeat = m_cache.ServiceLocator.GetInstance<IFsClosedFeatureRepository>().GetObject(node.Hvo);  					val = fs.GetOrCreateValue(closedFeat);  					val.FeatureRA = closedFeat;  					if (fs.TypeRA == null)  					{  						// SingleOrDefault() gave an exception if 2 complex features used the same feature (LT-12780)  						fs.TypeRA = m_cache.LanguageProject.MsFeatureSystemOA.TypesOC.FirstOrDefault(type => type.FeaturesRS.Contains(closedFeat));  					}  					break;  				case FeatureTreeNodeInfo.NodeKind.SymFeatValue:  					var closed = val as IFsClosedValue;  					if (closed != null)  						closed.ValueRA = m_cache.ServiceLocator.GetInstance<IFsSymFeatValRepository>().GetObject(node.Hvo);  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls,PopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PopupTreeManager.cs,m_treeCombo_BeforeSelect,The following switch statement is missing a default case: switch (newSelNode.Hvo)  			{  				case kLine:  					e.Cancel = true;  					// It may be selected by keyboard action' which needs more care.  					if (e.Action == TreeViewAction.ByKeyboard)  					{  						// Select the next/previous one' rather than the line.  						HvoTreeNode oldSelNode = pt.SelectedNode as HvoTreeNode;  						if (oldSelNode != null)  						{  							if (oldSelNode == newSelNode.NextNode && newSelNode.PrevNode != null)  							//if (oldSelNode.Hvo == kEmpty && newSelNode.PrevNode != null)  							{  								// Up Arrow probably used.  								// Select node above the line in the tree view.  								pt.SelectedNode = newSelNode.PrevNode;  							}  							else if (newSelNode.NextNode != null)  							{  								// Down Arrow probably used.  								// Select <empty> POS.  								pt.SelectedNode = newSelNode.NextNode;  							}  							else  							{  								Debug.Assert(false); // multiple adjacent empty (separator line) nodes' or nothing else??  							}  						}  					}  					break;  					/* Nothing special to do' since it is handled as a normal POS.  					case kEmpty:  						PopupTree.OldSelectedNode = PopupTree.SelectedNode;  						//m_treeCombo.Tree.SelectedNode = null;  						break;  					*/  			}
Missing Default,SIL.FieldWorks.XWorks.MorphologyEditor,PhonologicalFeaturePopupTreeManager,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\PhonologicalFeaturePopupTreeManager.cs,m_treeCombo_AfterSelect,The following switch statement is missing a default case: switch (selectedNode.Hvo)  			{  				case kChoosePhonologicaFeatures:  					// Only launch the dialog by a mouse click (or simulated mouse click).  					if (e.Action != TreeViewAction.ByMouse)  						break;  					// Force the PopupTree to Hide() to trigger popupTree_PopupTreeClosed().  					// This will effectively revert the list selection to a previous confirmed state.  					// Whatever happens below' we don't want to actually leave the "Choose phonological features" node selected!  					// This is at least required if the user selects "Cancel" from the dialog below.  					// N.B. the above does not seem to be true; therefore we check for cancel and an empty result  					// and force the combo text to be what it should be.  					pt.Hide();  					using (PhonologicalFeatureChooserDlg dlg = new PhonologicalFeatureChooserDlg())  					{  						Cache.DomainDataByFlid.BeginUndoTask(LexTextControls.ksUndoInsertPhonologicalFeature' LexTextControls.ksRedoInsertPhonologicalFeature);  						var fs = CreateEmptyFeatureStructureInAnnotation(null);  						dlg.SetDlgInfo(Cache' m_mediator' m_propertyTable' fs);  						dlg.ShowIgnoreInsteadOfDontCare = true;  						dlg.SetHelpTopic("khtptoolBulkEditPhonemesChooserDlg");    						DialogResult result = dlg.ShowDialog(ParentForm);  						if (result == DialogResult.OK)  						{  							if (dlg.FS != null)  							{  								var sFeatures = dlg.FS.LongName;  								if (string.IsNullOrEmpty(sFeatures))  								{  									// user did not select anything in chooser; we want to show the last known node  									// in the dropdown' not "choose phonological feature".  									SetComboTextToLastConfirmedSelection();  								}  								else if (!pt.Nodes.ContainsKey(sFeatures))  								{  									var newSelectedNode = new HvoTreeNode(fs.LongNameTSS' fs.Hvo);  									pt.Nodes.Add(newSelectedNode);  									LoadPopupTree(fs.Hvo);  									selectedNode = newSelectedNode;  								}  							}  						}  						else if (result != DialogResult.Cancel)  						{  							dlg.HandleJump();  						}  						else if (result == DialogResult.Cancel)  						{  							// The user canceled out of the chooser; we want to show the last known node  							// in the dropdown' not "choose phonological feature".  							SetComboTextToLastConfirmedSelection();  						}  						Cache.DomainDataByFlid.EndUndoTask();  					}  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,GetFile,The following switch statement is missing a default case: switch (fileType)  			{  				case OFType.Database:  					openFileDialog.Filter = ResourceHelper.BuildFileFilter(FileFilterType.ShoeboxAnthropologyDatabase'  						FileFilterType.AllFiles);  					openFileDialog.Title = LexTextControls.ksSelectAnthropologyStdFmtFile;  					break;  				case OFType.Project:  					openFileDialog.Filter = ResourceHelper.BuildFileFilter(FileFilterType.ShoeboxProjectFiles'  						FileFilterType.AllFiles);  					openFileDialog.Title = LexTextControls.ksSelectShoeboxProjectFile;  					break;  				case OFType.Settings:  					openFileDialog.Filter = ResourceHelper.BuildFileFilter(FileFilterType.ImportMapping'  						FileFilterType.AllFiles);  					openFileDialog.Title = LexTextControls.ksSelectLoadImportSettingsFile;  					break;  				case OFType.SaveAs:  					openFileDialog.Filter = ResourceHelper.BuildFileFilter(FileFilterType.ImportMapping'  						FileFilterType.AllFiles);  					openFileDialog.Title = LexTextControls.ksSelectSaveImportSettingsFile;  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,WriteMarkerContents,The following switch statement is missing a default case: switch (FieldType(rsf.m_flid))  			{  				case SfFieldType.DateTime:  					foreach (string sFmt in rsf.m_dto.m_rgsFmt)  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("DateFormat");  						xw.WriteAttributeString("value"' sFmt);  						xw.WriteEndElement();  					}  					break;  				case SfFieldType.ListRef:  					if (!String.IsNullOrEmpty(rsf.m_tlo.m_sEmptyDefault))  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("Default");  						xw.WriteAttributeString("value"' rsf.m_tlo.m_sEmptyDefault);  						xw.WriteEndElement();  					}  					xw.WriteWhitespace(Environment.NewLine);  					xw.WriteStartElement("Match");  					xw.WriteAttributeString("value"'  						rsf.m_tlo.m_pnt == PossNameType.kpntName ? "name" : "abbr");  					xw.WriteEndElement();  					if (rsf.m_tlo.m_fHaveMulti)  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("Multiple");  						xw.WriteAttributeString("sep"' rsf.m_tlo.m_sDelimMulti);  						xw.WriteEndElement();  					}  					if (rsf.m_tlo.m_fHaveSub)  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("Subchoice");  						xw.WriteAttributeString("sep"' rsf.m_tlo.m_sDelimSub);  						xw.WriteEndElement();  					}  					if (rsf.m_tlo.m_fHaveBetween)  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("DelimitChoice");  						xw.WriteAttributeString("start"' rsf.m_tlo.m_sMarkStart);  						xw.WriteAttributeString("end"' rsf.m_tlo.m_sMarkEnd);  						xw.WriteEndElement();  					}  					if (rsf.m_tlo.m_fHaveBefore)  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("StopChoices");  						xw.WriteAttributeString("value"' rsf.m_tlo.m_sBefore);  						xw.WriteEndElement();  					}  					if (rsf.m_tlo.m_fIgnoreNewStuff)  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("IgnoreNewChoices");  						xw.WriteAttributeString("value"' "true");  						xw.WriteEndElement();  					}  					Debug.Assert(rsf.m_tlo.m_rgsMatch.Count == rsf.m_tlo.m_rgsReplace.Count);  					for (int j = 0; j < rsf.m_tlo.m_rgsMatch.Count; ++j)  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("MatchReplaceChoice");  						xw.WriteAttributeString("match"' rsf.m_tlo.m_rgsMatch[j]);  						xw.WriteAttributeString("replace"' rsf.m_tlo.m_rgsReplace[j]);  						xw.WriteEndElement();  					}  					if (!String.IsNullOrEmpty(rsf.m_tlo.m_wsId))  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("ItemWrtSys");  						xw.WriteAttributeString("ws"' rsf.m_tlo.m_wsId);  						xw.WriteEndElement();  					}  					break;  				case SfFieldType.String:  					xw.WriteWhitespace(Environment.NewLine);  					xw.WriteStartElement("StringWrtSys");  					xw.WriteAttributeString("ws"' rsf.m_sto.m_wsId);  					xw.WriteEndElement();  					break;  				case SfFieldType.Text:  					if (!String.IsNullOrEmpty(rsf.m_txo.m_sStyle))  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("TextStyle");  						xw.WriteAttributeString("value"' rsf.m_txo.m_sStyle);  						xw.WriteEndElement();  					}  					xw.WriteWhitespace(Environment.NewLine);  					xw.WriteStartElement("StartPara");  					if (rsf.m_txo.m_fStartParaBlankLine)  						xw.WriteAttributeString("afterBlankLine"' "true");  					if (rsf.m_txo.m_fStartParaIndented)  						xw.WriteAttributeString("forIndentedLine"' "true");  					if (rsf.m_txo.m_fStartParaNewLine)  						xw.WriteAttributeString("forEachLine"' "true");  					if (rsf.m_txo.m_fStartParaShortLine)  					{  						xw.WriteAttributeString("afterShortLine"' "true");  						xw.WriteAttributeString("shortLineLim"' rsf.m_txo.m_cchShortLim.ToString());  					}  					xw.WriteEndElement();  					if (!String.IsNullOrEmpty(rsf.m_txo.m_wsId))  					{  						xw.WriteWhitespace(Environment.NewLine);  						xw.WriteStartElement("DefaultParaWrtSys");  						xw.WriteAttributeString("ws"' rsf.m_txo.m_wsId);  						xw.WriteEndElement();  					}  					break;  				case SfFieldType.Link:  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,FieldType,The following switch statement is missing a default case: switch (clidDst)  					{  						case StTextTags.kClassId:  							Debug.Assert(cpt == CellarPropertyType.OwningAtomic);  							return SfFieldType.Text;  						case RnRoledParticTags.kClassId:  							return SfFieldType.ListRef;	// closest choice.  						case RnGenericRecTags.kClassId:  							break;  					}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,PrepareForNextTab,The following switch statement is missing a default case: switch (nCurrent)  			{  				case kstepFileAndSettings:  					bool fStayHere = UsesInvalidFileNames(false);  					if (fStayHere)  					{  						// Don't go anywhere' stay right here by going to the previous page.  						m_CurrentStepNumber = kstepFileAndSettings - 1;		// 1-based  						tabSteps.SelectedIndex = m_CurrentStepNumber - 1;	// 0-based  						UpdateStepLabel();  					}  					ReadSettings();  					break;  				case kstepEncodingConversion:  					InitializeContentMapping();  					break;  				case kstepContentMapping:  					InitializeKeyMarkers();  					break;  				case kstepKeyMarkers:  					InitializeCharMappings();  					break;  			}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ReadProjectFile,The following switch statement is missing a default case: switch (sMkr)  				{  					case "+db":  						if (sfmData.Length > 0)  						{  							string sData = Sfm2Xml.Converter.MultiToWideWithERROR(sfmData' 0'  								sfmData.Length - 1' Encoding.UTF8' out mwError' out badData);  							if (mwError == Sfm2Xml.Converter.MultiToWideError.None)  							{  								string sFile = Path.GetFileName(sData.Trim());  								fInDataDefs = sFile.ToLowerInvariant() == sDataFile;  							}  						}  						break;  					case "-db":  						fInDataDefs = false;  						break;  					case "mkrPriKey":  						if (fInDataDefs && sfmData.Length > 0)  						{  							string sData = Sfm2Xml.Converter.MultiToWideWithERROR(sfmData' 0'  								sfmData.Length - 1' Encoding.UTF8' out mwError' out badData);  							if (mwError == Sfm2Xml.Converter.MultiToWideError.None)  								m_recMkr = sData.Trim();  						}  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ReadTextMarker,The following switch statement is missing a default case: switch (xn.Name)  				{  					case "TextStyle":  						sfm.m_txo.m_sStyle = XmlUtils.GetMandatoryAttributeValue(xn' "value");  						break;  					case "StartPara":  						sfm.m_txo.m_fStartParaBlankLine = XmlUtils.GetOptionalBooleanAttributeValue(xn' "afterBlankLine"' false);  						sfm.m_txo.m_fStartParaIndented = XmlUtils.GetOptionalBooleanAttributeValue(xn' "forIndentedLine"' false);  						sfm.m_txo.m_fStartParaNewLine = XmlUtils.GetOptionalBooleanAttributeValue(xn' "forEachLine"' false);  						sfm.m_txo.m_fStartParaShortLine = XmlUtils.GetOptionalBooleanAttributeValue(xn' "afterShortLine"' false);  						sfm.m_txo.m_cchShortLim = 0;  						string sLim = XmlUtils.GetOptionalAttributeValue(xn' "shortLineLim");  						if (!String.IsNullOrEmpty(sLim))  							Int32.TryParse(sLim' out sfm.m_txo.m_cchShortLim);  						break;  					case "DefaultParaWrtSys":  						sfm.m_txo.m_wsId = XmlUtils.GetMandatoryAttributeValue(xn' "ws");  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ReadLinkMarker,The following switch statement is missing a default case: switch (xn.Name)  				{  					case "IgnoreEmpty":  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,FixSettingsForThisDatabase,The following switch statement is missing a default case: switch (FieldType(rsf.m_flid))  				{  					case SfFieldType.Link:  					case SfFieldType.DateTime:  						break;  					case SfFieldType.ListRef:  						SetDefaultForListRef(rsf);  						char[] rgchSplit = new char[1] { ' ' };  						if (!String.IsNullOrEmpty(rsf.m_tlo.m_sDelimMulti))  							rsf.m_tlo.m_rgsDelimMulti = rsf.m_tlo.m_sDelimMulti.Split(rgchSplit' StringSplitOptions.RemoveEmptyEntries);  						if (!String.IsNullOrEmpty(rsf.m_tlo.m_sDelimSub))  							rsf.m_tlo.m_rgsDelimSub = rsf.m_tlo.m_sDelimSub.Split(rgchSplit' StringSplitOptions.RemoveEmptyEntries);  						if (!String.IsNullOrEmpty(rsf.m_tlo.m_sMarkStart))  							rsf.m_tlo.m_rgsMarkStart = rsf.m_tlo.m_sMarkStart.Split(rgchSplit' StringSplitOptions.RemoveEmptyEntries);  						if (!String.IsNullOrEmpty(rsf.m_tlo.m_sMarkEnd))  							rsf.m_tlo.m_rgsMarkEnd = rsf.m_tlo.m_sMarkEnd.Split(rgchSplit' StringSplitOptions.RemoveEmptyEntries);  						if (!String.IsNullOrEmpty(rsf.m_tlo.m_sBefore))  							rsf.m_tlo.m_rgsBefore = rsf.m_tlo.m_sBefore.Split(rgchSplit' StringSplitOptions.RemoveEmptyEntries);  						if (String.IsNullOrEmpty(rsf.m_tlo.m_wsId))  							rsf.m_tlo.m_ws = m_cache.ServiceLocator.WritingSystems.DefaultAnalysisWritingSystem;  						else  							m_cache.ServiceLocator.WritingSystemManager.GetOrSet(rsf.m_tlo.m_wsId' out rsf.m_tlo.m_ws);  						break;  					case SfFieldType.String:  						if (String.IsNullOrEmpty(rsf.m_sto.m_wsId))  							rsf.m_sto.m_ws = m_cache.ServiceLocator.WritingSystems.DefaultAnalysisWritingSystem;  						else  							m_cache.ServiceLocator.WritingSystemManager.GetOrSet(rsf.m_sto.m_wsId' out rsf.m_sto.m_ws);  						break;  					case SfFieldType.Text:  						if (String.IsNullOrEmpty(rsf.m_txo.m_wsId))  							rsf.m_txo.m_ws = m_cache.ServiceLocator.WritingSystems.DefaultAnalysisWritingSystem;  						else  							m_cache.ServiceLocator.WritingSystemManager.GetOrSet(rsf.m_txo.m_wsId' out rsf.m_txo.m_ws);  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetStringValue,The following switch statement is missing a default case: switch (cpt)  					{  						case CellarPropertyType.MultiString:  						case CellarPropertyType.MultiUnicode:  							m_cache.DomainDataByFlid.SetMultiStringAlt(rec.Hvo' rsf.m_flid' rsf.m_sto.m_ws.Handle' tss);  							break;  						case CellarPropertyType.String:  							m_cache.DomainDataByFlid.SetString(rec.Hvo' rsf.m_flid' tss);  							break;  					}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,ValidateDate,The following switch statement is missing a default case: switch (month)  				{  					case 2:		// February  						days_in_month = (((year%4) == 0 && (year%100) != 0) || (year%1000) == 0) ? 29 : 28;  						break;  					case 4:		// April  					case 6:		// June  					case 9:		// September  					case 11:	// November  						days_in_month = 30;  						break;  				}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,SetLink,The following switch statement is missing a default case: switch (pend.Marker.m_flid)  			{  				case RnGenericRecTags.kflidCounterEvidence:  					pend.Record.CounterEvidenceRS.Add(rec);  					return true;  				case RnGenericRecTags.kflidSeeAlso:  					pend.Record.SeeAlsoRC.Add(rec);  					return true;  				case RnGenericRecTags.kflidSupersededBy:  					pend.Record.SupersededByRC.Add(rec);  					return true;  				case RnGenericRecTags.kflidSupportingEvidence:  					pend.Record.SupportingEvidenceRS.Add(rec);  					return true;  			}
Missing Default,SIL.FieldWorks.LexText.Controls.DataNotebook,NotebookImportWiz,C:\repos\sillsdev_FieldWorks\Src\LexText\LexTextControls\DataNotebook\NotebookImportWiz.cs,StoreCustomListRefItem,The following switch statement is missing a default case: switch (list.ItemClsid)  						{  							case CmPossibilityTags.kClassId:  								creator = PossibilityCreator;  								break;  							case CmLocationTags.kClassId:  								creator = LocationCreator;  								break;  							case CmPersonTags.kClassId:  								creator = PersonCreator;  								break;  							case CmAnthroItemTags.kClassId:  								creator = AnthroItemCreator;  								break;  							case CmCustomItemTags.kClassId:  								creator = CustomItemCreator;  								break;  							case CmSemanticDomainTags.kClassId:  								creator = SemanticDomainCreator;  								break;  							// These are less likely' but legal' so we have to allow for them.  							case MoMorphTypeTags.kClassId:  								creator = MorphTypeCreator;  								break;  							case PartOfSpeechTags.kClassId:  								creator = NewPartOfSpeechCreator;  								break;  							case LexEntryTypeTags.kClassId:  								creator = NewLexEntryTypeCreator;  								break;  							case LexRefTypeTags.kClassId:  								creator = NewLexRefTypeCreator;  								break;  						}
