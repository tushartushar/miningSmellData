Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,Convert,The method has 180 lines of code.
Long Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ValidateHierarchy,The method has 117 lines of code.
Long Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ProcessSFMData,The method has 197 lines of code.
Long Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ProcessSfmFileNewLogic,The method has 173 lines of code.
Long Method,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The method has 100 lines of code.
Long Method,Sfm2Xml,STATICS,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Statics.cs,NewMapFileBuilder,The method has 201 lines of code.
Complex Method,Sfm2Xml,ClsFieldDescription,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsFieldDescription.cs,RebuildMeaningEntry,Cyclomatic complexity of the method is 8
Complex Method,Sfm2Xml,ClsFieldDescription,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsFieldDescription.cs,ToXmlBaseString,Cyclomatic complexity of the method is 17
Complex Method,Sfm2Xml,ClsHierarchyEntry,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsHierarchyEntry.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,Sfm2Xml,ClsHierarchyEntry,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsHierarchyEntry.cs,FindRootFromHash,Cyclomatic complexity of the method is 9
Complex Method,Sfm2Xml,ClsInFieldMarker,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsInFieldMarker.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ReadAndOutputSettings,Cyclomatic complexity of the method is 8
Complex Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ReadHierarchy,Cyclomatic complexity of the method is 9
Complex Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ValidateHierarchy,Cyclomatic complexity of the method is 20
Complex Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ValidateFieldDescriptions,Cyclomatic complexity of the method is 10
Complex Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ValidateCustomFieldDescriptions,Cyclomatic complexity of the method is 10
Complex Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,AddToOpenObjects,Cyclomatic complexity of the method is 9
Complex Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ProcessSFMData,Cyclomatic complexity of the method is 21
Complex Method,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ProcessSfmFileNewLogic,Cyclomatic complexity of the method is 20
Complex Method,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,Cyclomatic complexity of the method is 8
Complex Method,Sfm2Xml,ImportObjectManager,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,AddNewEntry,Cyclomatic complexity of the method is 9
Complex Method,Sfm2Xml,ByteReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,getNextSfmMarkerAndData,Cyclomatic complexity of the method is 8
Complex Method,Sfm2Xml,ByteReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,GetBytesUptoNextSfmMarker,Cyclomatic complexity of the method is 13
Complex Method,Sfm2Xml,SfmFileReaderEx,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,Sfm2Xml,ClsLog,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Log.cs,OutputErrorElement,Cyclomatic complexity of the method is 8
Complex Method,Sfm2Xml,STATICS,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Statics.cs,NewMapFileBuilder,Cyclomatic complexity of the method is 23
Long Parameter List,Sfm2Xml,ClsFieldDescription,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsFieldDescription.cs,ClsFieldDescription,The method has 6 parameters. Parameters: marker' name' datatype' lang' abbr' fwID
Long Parameter List,Sfm2Xml,ClsFieldDescription,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsFieldDescription.cs,ReadAndOutputXmlNode,The method has 6 parameters. Parameters: fieldNode' languages' topAnalysisWS' xmlOutput' langsToIgnore' fieldsToIgnore
Long Parameter List,Sfm2Xml,ClsFieldDescriptionWrapper,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsFieldDescription.cs,ClsFieldDescriptionWrapper,The method has 6 parameters. Parameters: marker' name' datatype' lang' abbr' fwID
Long Parameter List,Sfm2Xml,ClsCustomFieldDescription,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsFieldDescription.cs,ClsCustomFieldDescription,The method has 6 parameters. Parameters: fdClass' uiClass' flid' big' wsSelector' baseFD
Long Parameter List,Sfm2Xml,ClsCustomFieldDescription,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsFieldDescription.cs,ClsCustomFieldDescription,The method has 11 parameters. Parameters: fdClass' uiClass' flid' big' wsSelector' marker' name' datatype' lang' abbr' fwID
Long Parameter List,Sfm2Xml,ClsCustomFieldDescription,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsFieldDescription.cs,ReadAndOutputXmlNode,The method has 6 parameters. Parameters: fieldNode' languages' topAnalysisWS' xmlOutput' langsToIgnore' fieldsToIgnore
Long Parameter List,Sfm2Xml,ClsHierarchyEntry,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsHierarchyEntry.cs,ClsHierarchyEntry,The method has 6 parameters. Parameters: name' partof' beginFields' additionalFields' multiFields' uniqueFields
Long Parameter List,Sfm2Xml,ClsInFieldMarker,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsInFieldMarker.cs,ClsInFieldMarker,The method has 8 parameters. Parameters: begin' endList' fEndWithWord' fEndWithField' lang' xmlLang' style' ignore
Long Parameter List,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,Convert,The method has 6 parameters. Parameters: SfmFileName' MappingFileName' OutputFileName' vernWs' regWs' natWs
Long Parameter List,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,MultiToWideWithERROR,The method has 6 parameters. Parameters: multi' start' end' encodingToUse' err' badBytes
Long Parameter List,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ConvertBytes,The method has 6 parameters. Parameters: marker' data' start' end' converter' lineNumber
Long Parameter List,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,AddUniqueMarker,The method has 6 parameters. Parameters: foundMarkers' rawData' markerData' inFieldMarker' foundPos' isBeginMarker
Long Parameter List,Sfm2Xml,ImportObjectManager,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,CanUseBeginMarkerOnExistingEntry,The method has 5 parameters. Parameters: entryName' sfm' sfmData' line' isUnique
Long Parameter List,Sfm2Xml,ImportObjectManager,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,AddNewEntry,The method has 6 parameters. Parameters: name' sfm' sfmData' line' isUnique' addedEntry
Long Parameter List,Sfm2Xml,CRC,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\CRC.cs,CalculateCRC_N,The method has 5 parameters. Parameters: buffer' count' lastValue' bFirst' bLast
Long Parameter List,Sfm2Xml,FieldHierarchyInfo,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FieldHierarchyInfo.cs,FieldHierarchyInfo,The method has 5 parameters. Parameters: marker' dest' lang' begin' destClass
Long Parameter List,Sfm2Xml,ByteReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,CopySpaceIfMatched,The method has 6 parameters. Parameters: readData' readPos' limitPos' writeData' writePos' searchData
Long Parameter List,Sfm2Xml,LexImportCustomField,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\LexImportField.cs,LexImportCustomField,The method has 13 parameters. Parameters: fdClass' uiClass' flid' big' wsSelector' name' uiDest' prop' sig' list' multi' unique' mdf
Long Parameter List,Sfm2Xml,LexImportField,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\LexImportField.cs,LexImportField,The method has 8 parameters. Parameters: name' uiDest' prop' sig' list' multi' unique' mdf
Long Parameter List,Sfm2Xml,STATICS,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Statics.cs,NewMapFileBuilder,The method has 7 parameters. Parameters: uiLangs' ILexFields' ICustomFields' sfmInfo' listInFieldMarkers' saveAsFileName' listOptions
Long Identifier,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,,The length of the parameter m_FieldDescriptionsTableNotFound is 32.
Long Statement,Sfm2Xml,ClsInFieldMarker,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsInFieldMarker.cs,ReadXmlNode,The length of the statement  "							Converter.Log.AddError("Error in Mapping File: Unknown 'lang' value '" + Attribute.Value + "' in the 'fieldDescriptions' section."); " is 132.
Long Statement,Sfm2Xml,ClsLanguage,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsLanguage.cs,ReadXmlNode,The length of the statement  "//				Converter.Log.AddError("Error in Mapping File: language '" + m_LangId + "' is invalid because its 'map' attribute is not defined."); " is 138.
Long Statement,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ValidateLanguages,The length of the statement  "					Log.AddFatalError(String.Format(Sfm2XmlStrings.UnknownEncodingConvertersMap0InLanguage1' language.EncCvtrMap' language.KEY)); " is 125.
Long Statement,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ReadAndOutputFieldDescriptions,The length of the statement  "				if (FieldDescription.ReadAndOutputXmlNode(FieldNode' m_Languages' m_topAnalysisWS' xmlOutput' ref m_LangsToIgnore' ref m_FieldsToIgnore)) " is 137.
Long Statement,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ReadAndOutputCustomFieldDescriptions,The length of the statement  "				if (FieldDescription.ReadAndOutputXmlNode(FieldNode' m_Languages' m_topAnalysisWS' xmlOutput' ref m_LangsToIgnore' ref m_FieldsToIgnore)) " is 137.
Long Statement,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,AddToOpenObjects,The length of the statement  "////								m_autoFieldsPossible[currentLocation.Name] as AutoFieldInfo;	//  AutoFieldInfo(currentLocation.Name' sfm' "ASDF"); " is 126.
Long Statement,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,AddUniqueMarker,The length of the statement  "			System.Diagnostics.Debug.WriteLine(" ** Found <" + markerData + "> at position="+foundPos.ToString()+"' isBegin="+isBeginMarker.ToString()); " is 140.
Long Statement,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,AddUniqueMarker,The length of the statement  "							return AddUniqueMarker(ref foundMarkers' ref rawData' oldMarker.Marker' oldMarker.ClsInFieldMarker' foundPos' oldMarker.IsBegin); " is 129.
Long Statement,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ProcessSFMData,The length of the statement  "					string convertedData = ConvertBytes(mainFieldDescription.SFM' markerData' iMarkerDataPos' markerStartPos' currentConverter' lineNumber); " is 136.
Long Statement,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ProcessSFMData,The length of the statement  "			string convertedDataString = ConvertBytes(mainFieldDescription.SFM' markerData' iMarkerDataPos' markerData.Length' currentConverter' lineNumber); " is 145.
Long Statement,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ProcessSFMData,The length of the statement  "						Log.AddError(m_SfmFileName' lineNumber' String.Format(Sfm2XmlStrings.X1HasAnUnrecognizedDateForm2' lineNumber.ToString()' mainFieldDescription.SFM' convertedDataString)); " is 170.
Long Statement,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,CharDataBeforeMarkerMessage,The length of the statement  "						nLineNumber' Converter.MultiToWide(sfmData' System.Text.Encoding.UTF8).Replace(System.Environment.NewLine' " ").Trim()); " is 120.
Long Statement,Sfm2Xml,ImportObjectManager,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,AddToOpenObjects,The length of the statement  "//						System.Diagnostics.Debug.WriteLine("Possibly a case where the sfm is already used and a new one needs to be started.?"); " is 128.
Long Statement,Sfm2Xml,ImportObject,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,AddSFMasAutoField,The length of the statement  "						////								m_autoFieldsPossible[currentLocation.Name] as AutoFieldInfo;	//  AutoFieldInfo(currentLocation.Name' sfm' "ASDF"); " is 126.
Long Statement,Sfm2Xml,ByteReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,GetNextSfmMarkerAndData,The length of the statement  "				m_hasLookAhead = getNextSfmMarkerAndData(out m_sfmLookAheadMarker' out m_sfmLookAheadData' out m_sfmLookAheadMarkerBadBytes); " is 125.
Long Statement,Sfm2Xml,ByteReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,GetNextSfmMarkerAndData,The length of the statement  "				m_hasLookAhead = getNextSfmMarkerAndData(out m_sfmLookAheadMarker' out m_sfmLookAheadData' out m_sfmLookAheadMarkerBadBytes); " is 125.
Long Statement,Sfm2Xml,STATICS,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Statics.cs,NewMapFileBuilder,The length of the statement  "				System.Diagnostics.Debug.Assert(lfield != null' "Error in the data assumptions: fwDestID=<" + fieldInfo.FwDestID + ">"); " is 120.
Long Statement,Sfm2Xml,STATICS,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Statics.cs,NewMapFileBuilder,The length of the statement  "					System.Diagnostics.Debug.Assert(lfield != null' "Error in the data assumptions: fwDestID=<" + fieldInfo.FwDestID + ">"); " is 120.
Long Statement,Sfm2Xml,STATICS,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Statics.cs,NewMapFileBuilder,The length of the statement  "					tmp = new ClsFieldDescriptionWrapper(fieldInfo.SFM' lfield.UIName' lfield.DataType' fieldInfo.Lang' lfield.IsAbbrField' fieldInfo.FwDestID); " is 140.
Long Statement,Sfm2Xml,STATICS,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Statics.cs,NewMapFileBuilder,The length of the statement  "//				ILexImportCustomField lfield = ICustomFields.GetField(fieldInfo.FwDestID' out className) as ILexImportCustomField; " is 120.
Long Statement,Sfm2Xml,STATICS,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Statics.cs,NewMapFileBuilder,The length of the statement  "				//// tmp = new ClsFieldDescriptionWrapper(fieldInfo.SFM' lfield.UIName' lfield.DataType' fieldInfo.Lang' lfield.IsAbbrField' fieldInfo.FwDestID); " is 145.
Long Statement,Sfm2Xml,STATICS,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Statics.cs,NewMapFileBuilder,The length of the statement  "				ClsCustomFieldDescription tmp = new ClsCustomFieldDescription(lfield.Class' className' /*lfield.CustomFieldID'*/ lfield.FLID' lfield.Big' lfield.WsSelector' " is 156.
Complex Conditional,Sfm2Xml,ClsInFieldMarker,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsInFieldMarker.cs,GenerateElementName,The conditional expression  "Char.IsLetterOrDigit(ch) || ch == '.' || ch == '-' || ch == '_'"  is complex.
Complex Conditional,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ProcessSFMandData,The conditional expression  "(c >= 0x0020 && c<=0xd7ff) ||		// try to test by order of most common/expected  					(c >= 0xe000 && c<=0xfffd) ||  					c == 0x09 || c == 0x0d || c== 0x0a"  is complex.
Complex Conditional,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ProcessSFMandData,The conditional expression  "cfd.MeaningID == "lex" || // cfd.MeaningID == "cit"  ||  					cfd.MeaningID == "allo" || cfd.MeaningID == "ulf" ||  					cfd.MeaningID == "var" || cfd.MeaningID == "sub""  is complex.
Complex Conditional,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The conditional expression  "(m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80)"  is complex.
Complex Conditional,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The conditional expression  "(m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+3 || (m_Data[i+3] & kLeft2BitsMask) != 0x80)"  is complex.
Complex Conditional,Sfm2Xml,LexImportField,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\LexImportField.cs,ReadBoolValue,The conditional expression  "boolValue.ToLowerInvariant() == "yes" || boolValue.ToLowerInvariant() == "y" ||  					boolValue.ToLowerInvariant() == "true" || boolValue.ToLowerInvariant() == "t" ||  					boolValue == "1""  is complex.
Complex Conditional,Sfm2Xml,LexImportField,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\LexImportField.cs,ReadBoolValue,The conditional expression  "boolValue.ToLowerInvariant() == "no" || boolValue.ToLowerInvariant() == "n" ||  					boolValue.ToLowerInvariant() == "false" || boolValue.ToLowerInvariant() == "f" ||  					boolValue == "0""  is complex.
Virtual Method Call from Constructor,Sfm2Xml,SfmFileReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,SfmFileReader,The constructor "SfmFileReader" calls a virtual method "Init".
Empty Catch Block,Sfm2Xml,CRC,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\CRC.cs,FileCRC,The method has an empty catch block.
Empty Catch Block,Sfm2Xml,SfmFileReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,Init,The method has an empty catch block.
Empty Catch Block,Sfm2Xml,SfmFileReaderEx,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,Init,The method has an empty catch block.
Empty Catch Block,Sfm2Xml,SfmFile,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,Init,The method has an empty catch block.
Magic Number,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ConvertWs,The following statement contains a magic number: if (m_Languages.ContainsKey(langId))  			{  				char [] delim = new char [] {':'};  				string [] values = data.Split(delim);  				if (values.Length != 2)	// should only be two elements per string  					return;  				string xmlLang = values[0].Trim();  				string map = values[1].Trim();  				ClsLanguage lang = m_Languages[langId] as ClsLanguage;  //				if (lang == null)  //				{  //					System.Diagnostics.Debug.WriteLine("No language with landId of '" + langId +"'");  //					return;  //				}  				// if it was previously 'ignore' then remove from ignore list  				if (m_LangsToIgnore.ContainsKey(langId))  //lang.XmlLang == "ignore")  				{  					m_LangsToIgnore.Remove(langId);  				}  				bool xmlLangDiff = (lang.XmlLang != xmlLang);  				bool mapDiff = (lang.EncCvtrMap != map);  				if (xmlLangDiff || mapDiff)  				{  					string msg;  					if (xmlLangDiff && mapDiff)  					{  						if (map != null && map.Length > 0)  						{  							msg = String.Format(Sfm2XmlStrings.LanguagesEntry_0_lang_1_2_map_3_4'  								langId' lang.XmlLang' xmlLang' lang.EncCvtrMap' map);  						}  						else  						{  							msg = String.Format(Sfm2XmlStrings.LanguagesEntry_0_lang_1_2_map_3'  								langId' lang.XmlLang' xmlLang' lang.EncCvtrMap);  						}  					}  					else if (xmlLangDiff)  					{  						msg = String.Format(Sfm2XmlStrings.LanguagesEntry_0_lang_1_2'  							langId' lang.XmlLang' xmlLang);  					}  					else  					{  						if (map != null && map.Length > 0)  						{  							msg = String.Format(Sfm2XmlStrings.LanguagesEntry_0_map_1_2'  								langId' lang.EncCvtrMap' map);  						}  						else  						{  							msg = String.Format(Sfm2XmlStrings.LanguagesEntry_0_map_1'  								langId' lang.EncCvtrMap);  						}  					}  					Log.AddWarning(msg);  					lang.Convert(xmlLang' map);  				}  			}  			else  			{  				// lang that isn't defined' possible future warning  			}
Magic Number,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,Convert,The following statement contains a magic number: using (System.Xml.XmlTextWriter xmlOutput = new System.Xml.XmlTextWriter(m_OutputFileName' System.Text.Encoding.UTF8))  			{  				xmlOutput.Formatting = System.Xml.Formatting.Indented;  				xmlOutput.Indentation = 2;    				WriteOutputFileComment(SfmFileName' MappingFileName' OutputFileName' xmlOutput);    				xmlOutput.WriteComment(" database is the root element for this file ");  				xmlOutput.WriteStartElement("database");    				System.Xml.XmlDocument xmlMap = new System.Xml.XmlDocument();  				try  				{  					xmlMap.Load(m_MappingFileName);  				}  				catch (System.Xml.XmlException e)  				{  					string ErrMsg = String.Format(Sfm2XmlStrings.InvalidMappingFile0_1' m_MappingFileName' e.Message);  					Log.AddError(ErrMsg);  					// put out the warnings and errors  					Log.FlushTo(xmlOutput);  					xmlOutput.WriteEndElement(); // Close the Database node  					xmlOutput.Close();  					return;  				}    				ReadLanguages(xmlMap);    				// === Process the command line args relating to languages ===  				// National ws  				if (natWs.ToLowerInvariant() == STATICS.Ignore)  					IgnoreWs("nat");  				else if (natWs.ToLowerInvariant() == "no-convert")  					NoConvertWs("nat");  				else if (natWs.Length > 0)  					ConvertWs("nat"' natWs);    				// Regional ws  				if (regWs.ToLowerInvariant() == STATICS.Ignore)  					IgnoreWs("reg");  				else if (regWs.ToLowerInvariant() == "no-convert")  					NoConvertWs("reg");  				else if (regWs.Length > 0)  					ConvertWs("reg"' regWs);    				// Vern ws  	//			if (vernWs.ToLowerInvariant() == "ignore")  	//				IgnoreWs("vern");  				if (vernWs.ToLowerInvariant() == "no-convert")  					NoConvertWs("vern");  				else if (vernWs.Length > 0)  					ConvertWs("vern"' vernWs);    				try  				{  					ReadHierarchy(xmlMap);  					ReadAndOutputSettings(xmlMap' xmlOutput);    					// read the mapping file and build internal classes / objects and  					// add field descriptions to output file  					ReadFieldDescriptions(xmlMap);	//  ReadAndOutputFieldDescriptions(xmlMap' xmlOutput);  					ReadCustomFieldDescriptions(xmlMap);    					// read the mapping file inline markers  					ReadInFieldMarkers(xmlMap);    					// Now vaildate the data read in. This must be done in the follwoing order:  					// Languages' Field Descriptions' Hierarchy. Infield Markers must be validated  					// after Languages. This order is needed because the later checks rely on  					// success of the earlier ones.  					ValidateLanguages();	// throw if bad language data  					ValidateFieldDescriptions();  					ValidateCustomFieldDescriptions();  					ValidateHierarchy();  					ValidateInfieldMarkers();  				}  				catch (System.Exception e)  				{  					string ErrMsg = String.Format(Sfm2XmlStrings.UnhandledException0' e.Message);  					Log.AddError(ErrMsg);  				}    				string nl = System.Environment.NewLine;  				string comments = nl;  				comments += " ================================================================" + nl;  				comments += " Element: " + m_Root.Name + nl;  				comments += "  This element contains the inputfile in an XML format." + nl;  				comments += " ================================================================" + nl;  				xmlOutput.WriteComment(comments);  	//			xmlOutput.WriteComment(" This element contains the inputfile in an XML format ");    				try  				{  					//			xmlOutput.WriteStartElement(m_Root.Name);  					//			ProcessSfmFile(xmlOutput);  					ProcessSfmFileNewLogic(xmlOutput);  				}  				catch (System.Exception e)  				{  					string ErrMsg = String.Format(Sfm2XmlStrings.UnhandledException0' e.Message);  					Log.AddError(ErrMsg);  				}  #if false  				if (m_autoFieldsUsed.Count > 0)  				{  					xmlOutput.WriteComment(" This is where the autofield info goes after the data has been processed. ");  					xmlOutput.WriteStartElement("autofields");  					foreach(DictionaryEntry autoEntry in m_autoFieldsUsed)  					{  						AutoFieldInfo afi = autoEntry.Value as AutoFieldInfo;  						xmlOutput.WriteStartElement("field");  						xmlOutput.WriteAttributeString("class"' afi.className);  						xmlOutput.WriteAttributeString("sfm"' afi.sfmName);  						xmlOutput.WriteAttributeString("fwid"' afi.fwDest);  						xmlOutput.WriteEndElement();  					}  					xmlOutput.WriteEndElement();  				}  #endif  				// put out the field descriptions with the autofield info integrated in: for xslt processing...  				comments = nl;  				comments += " ================================================================" + nl;  				comments += " Element: fieldDescriptions" + nl;  				comments += "  This element is put out after the data so that auto fields can be" + nl;  				comments += "  added here.  Otherwise' we'd have to make two passes over the data." + nl;  				comments += "  The additional information related to auto fields is used in the" + nl;  				comments += "  XSLT processing for building the phase2 output file." + nl;  				comments += " ================================================================" + nl;  				xmlOutput.WriteComment(comments);    				xmlOutput.WriteStartElement("fieldDescriptions");  				foreach(DictionaryEntry fieldEntry in m_FieldDescriptionsTable)  				{  					ClsFieldDescription fd = fieldEntry.Value as ClsFieldDescription;  					if (fd is ClsCustomFieldDescription)  						continue;	// the custom fields will be put out in a CustomFields section following...    					if (m_autoFieldsBySFM.ContainsKey(fd.SFM))  					{  						ArrayList afiBysfm = m_autoFieldsBySFM[fd.SFM] as ArrayList;  						foreach(AutoFieldInfo afi in afiBysfm)  						{  							fd.AddAutoFieldInfo(afi.className' afi.fwDest);  						}  					}  					fd.ToXmlLangString(xmlOutput);  	//				string xmldata = fd.ToXmlLangString(xmlOutput);  					// xmlOutput.WriteRaw(xmldata);  				}  				xmlOutput.WriteEndElement();    				// put out the field descriptions with the autofield info integrated in: for xslt processing...  				comments = nl;  				comments += " ================================================================" + nl;  				comments += " Element: CustomFieldDescriptions" + nl;  				comments += " ================================================================" + nl;  				xmlOutput.WriteComment(comments);    				xmlOutput.WriteStartElement("CustomFieldDescriptions");  				foreach (DictionaryEntry fieldEntry in m_FieldDescriptionsTable)  				{  					ClsCustomFieldDescription fd = fieldEntry.Value as ClsCustomFieldDescription;  					if (fd == null)  						continue;	// not a custom field    					fd.ToXmlLangString(xmlOutput);  	//				string xmldata = fd.ToXmlLangString(xmlOutput);  					// xmlOutput.WriteRaw(xmldata);  				}  				xmlOutput.WriteEndElement();    				// put out the infield descriptions for xslt processing...  				comments = nl;  				comments += " ================================================================" + nl;  				comments += " Element: inFieldMarkers" + nl;  				comments += "  This is where the infield / inline markers are put out." + nl;  				comments += " ================================================================" + nl;  				xmlOutput.WriteComment(comments);    				OutputInFieldMarkers(xmlOutput);    #if false    				<!-- This is where the autofield information goes.  Needed to make sense  					-- of the field and Records elements that use autofields -->  				<autofields>  					<field class="Entry" sfm="dan" fwid="eires"/>  				</autofields>  #endif    				// put out the warnings and errors  				Log.FlushTo(xmlOutput);  				xmlOutput.WriteEndElement(); // Close the Database node  				xmlOutput.Close();  			}
Magic Number,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ConvertBytes,The following statement contains a magic number: if (end - start <= 0)  			{  				// if the data to convert is of length zero (or less) then just return an empty string  				return result;  			}  			else if (converter != null)  			{  				int len = end-start;  				byte[] subData = new byte[len];  				for (int i=0; i<len; i++)  					subData[i] = data[start+i];    				try  				{  					result = converter.ConvertToUnicode(subData);  				}  				catch (System.Exception e)  				{  					Log.AddUniqueHighPriorityError(converter.Name'  						String.Format(Sfm2XmlStrings.EncodingConverter0Failed1' converter.Name' e.Message));  				}  			}  			else  			{  				// We have no Encoding Converter' so assume text is in UTF8  				byte[] workspace = new byte[end - start];  				for (int i = 0; i < end - start; i++)  					workspace[i] = data[start + i];  				ClsStringToOrFromBytes workspaceAsString = new ClsStringToOrFromBytes(workspace);  				int cMaxCodes = 20;  				if (m_cIllegalCodes < cMaxCodes)  				{  					byte badCodePoint;  					int badBytePosition;  					int badByteCount;	// add a count msg to the line.  					if (!workspaceAsString.IsUTF8String(out badCodePoint' out badBytePosition' out badByteCount))  					{  						// contains non-utf8 data  						if (badByteCount > ClsStringToOrFromBytes.MaxInvalidBytes)  							Log.AddError(m_SfmFileName' lineNumber'  								String.Format(Sfm2XmlStrings.Line0_SFM1ContainsIllegalUTF8Count2Max3IndexData4'  								lineNumber' marker' badByteCount' ClsStringToOrFromBytes.MaxInvalidBytes'  								workspaceAsString.InvalidByteString()));  						else if (badByteCount > 1)  							Log.AddError(m_SfmFileName' lineNumber'  								String.Format(Sfm2XmlStrings.Line0_SFM1ContainsIllegalUTF8Count2IndexData3'  								lineNumber' marker' badByteCount' workspaceAsString.InvalidByteString()));  						else  							Log.AddError(m_SfmFileName' lineNumber'  								String.Format(Sfm2XmlStrings.Line0_SFM1ContainsIllegalUTF8Code2'  								lineNumber' marker' System.Convert.ToString(badCodePoint' 16)));  						m_cIllegalCodes++;	// += badByteCount;  						if (m_cIllegalCodes == cMaxCodes)  						{  							Log.AddError(m_SfmFileName' m_SfmLineNumber' String.Format(Sfm2XmlStrings.InvalidCodepointsHaveBeenLogged' cMaxCodes));  						}  					}  				}  				result = workspaceAsString.String();  			}
Magic Number,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ConvertBytes,The following statement contains a magic number: if (end - start <= 0)  			{  				// if the data to convert is of length zero (or less) then just return an empty string  				return result;  			}  			else if (converter != null)  			{  				int len = end-start;  				byte[] subData = new byte[len];  				for (int i=0; i<len; i++)  					subData[i] = data[start+i];    				try  				{  					result = converter.ConvertToUnicode(subData);  				}  				catch (System.Exception e)  				{  					Log.AddUniqueHighPriorityError(converter.Name'  						String.Format(Sfm2XmlStrings.EncodingConverter0Failed1' converter.Name' e.Message));  				}  			}  			else  			{  				// We have no Encoding Converter' so assume text is in UTF8  				byte[] workspace = new byte[end - start];  				for (int i = 0; i < end - start; i++)  					workspace[i] = data[start + i];  				ClsStringToOrFromBytes workspaceAsString = new ClsStringToOrFromBytes(workspace);  				int cMaxCodes = 20;  				if (m_cIllegalCodes < cMaxCodes)  				{  					byte badCodePoint;  					int badBytePosition;  					int badByteCount;	// add a count msg to the line.  					if (!workspaceAsString.IsUTF8String(out badCodePoint' out badBytePosition' out badByteCount))  					{  						// contains non-utf8 data  						if (badByteCount > ClsStringToOrFromBytes.MaxInvalidBytes)  							Log.AddError(m_SfmFileName' lineNumber'  								String.Format(Sfm2XmlStrings.Line0_SFM1ContainsIllegalUTF8Count2Max3IndexData4'  								lineNumber' marker' badByteCount' ClsStringToOrFromBytes.MaxInvalidBytes'  								workspaceAsString.InvalidByteString()));  						else if (badByteCount > 1)  							Log.AddError(m_SfmFileName' lineNumber'  								String.Format(Sfm2XmlStrings.Line0_SFM1ContainsIllegalUTF8Count2IndexData3'  								lineNumber' marker' badByteCount' workspaceAsString.InvalidByteString()));  						else  							Log.AddError(m_SfmFileName' lineNumber'  								String.Format(Sfm2XmlStrings.Line0_SFM1ContainsIllegalUTF8Code2'  								lineNumber' marker' System.Convert.ToString(badCodePoint' 16)));  						m_cIllegalCodes++;	// += badByteCount;  						if (m_cIllegalCodes == cMaxCodes)  						{  							Log.AddError(m_SfmFileName' m_SfmLineNumber' String.Format(Sfm2XmlStrings.InvalidCodepointsHaveBeenLogged' cMaxCodes));  						}  					}  				}  				result = workspaceAsString.String();  			}
Magic Number,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,ProcessSFMData,The following statement contains a magic number: if (mainFieldDescription.Type.ToLowerInvariant() == "date")  			{  				// handle any date processing here - validating and changing forms  				try  				{  					DateTime dt = System.DateTime.Parse(convertedDataString);  					if (dt.Year < 1800)  						throw new Exception();	// SQL Server insists year >= 1753 for datetime.  See LT-8073.  					string newDate = dt.ToString("yyy-MM-dd hh:mm:ss.fff");  					convertedDataString = convertedDataString.Replace(System.Environment.NewLine' "");	// remove newlines    					if (newDate.IndexOf(convertedDataString) < 0)  					{  						Log.AddSFMWarning(mainFieldDescription.SFM'  							String.Format(Sfm2XmlStrings.DateChangedFrom1To2'  								mainFieldDescription.SFM' convertedDataString' newDate));  					}  					convertedDataString = newDate;  				}  				catch  				{  					// LT-5352: don't log date errors if the dt field is empty  					if (convertedDataString.Trim().Length > 0)  					{  						Log.AddError(m_SfmFileName' lineNumber' String.Format(Sfm2XmlStrings.X1HasAnUnrecognizedDateForm2' lineNumber.ToString()' mainFieldDescription.SFM' convertedDataString));  						convertedDataString = "";	// don't pass it on - ignore it  					}  				}  			}
Magic Number,Sfm2Xml,Converter,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,CharDataBeforeMarkerMessage,The following statement contains a magic number: if (sfmData.Length > 50)  			{  				emsg = String.Format(Sfm2XmlStrings.X1CharactersFoundBeforeMarker'  					nLineNumber' sfmData.Length);  			}  			else  			{  				try  				{  					emsg = String.Format(Sfm2XmlStrings.Data1FoundBeforeMarker'  						nLineNumber' Converter.MultiToWide(sfmData' System.Text.Encoding.UTF8).Replace(System.Environment.NewLine' " ").Trim());  				}  				catch  				{  					emsg = String.Format(Sfm2XmlStrings.X1CharactersSomeInvalidFoundBeforeMarker'  						nLineNumber' sfmData.Length);  				}  			}
Magic Number,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,InvalidByteString,The following statement contains a magic number: while (m_invalidBytes.Count > 0)  				{  					DP data = m_invalidBytes.Dequeue();  					sb.Append(string.Format("{0}:0x{1}"' data.offset' System.Convert.ToString(data.data' 16)));  					if (m_invalidBytes.Count > 0)  						sb.Append("' ");  				}
Magic Number,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The following statement contains a magic number: for (int i = 0; i < m_Data.Length; i += sequenceLen)  				{  					byte by = m_Data[i];  					bool foundError = false;  					// If the leftmost bit is 0' then this is a 1-byte character  					if ((by & kLeft1BitMask) == 0)  						sequenceLen = 1;  					else if((by & kLeft3BitsMask) == kLeft2BitsMask)  					{  						// If the byte starts with 110' then this will be the first byte  						// of a 2-byte sequence  						sequenceLen = 2;  						// if the second byte does not start with 10 then the sequence is invalid  						if(m_ByteLength <= i+1 || (m_Data[i + 1] & kLeft2BitsMask) != 0x80)  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft4BitsMask) == kLeft3BitsMask)  					{  						// If the byte starts with 1110' then this will be the first byte of  						// a 3-byte sequence  						sequenceLen = 3;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft5BitsMask) == kLeft4BitsMask)  					{  						// if the byte starts with 11110' then this will be the first byte of  						// a 4-byte sequence  						sequenceLen = 4;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+3 || (m_Data[i+3] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else  					{  						badCodePoint = by;  						bytePosition = i+1;	// not zero based' but 1 based for user  						if (!findAllErrors)  							return false;  						foundError = true;  					}    					if (foundError)  					{  						if (m_invalidBytes.Count < MaxInvalidBytes)  							m_invalidBytes.Enqueue(new DP(bytePosition' badCodePoint));  						System.Diagnostics.Debug.WriteLine("badData: index=" + System.Convert.ToString(i + 1) + " ");  						bytesUntilNextCodePoint = i;  						// now search until we find a valid begin byte for utf8 sequence  						while (++i < m_ByteLength && IsValidBeginByte(m_Data[i]) == false)  						{  							if (m_invalidBytes.Count < MaxInvalidBytes)  								m_invalidBytes.Enqueue(new DP(i + 1' m_Data[i]));  						}  						sequenceLen = 0;  						bytesUntilNextCodePoint = i - bytesUntilNextCodePoint;  						badBytes += bytesUntilNextCodePoint;	// bytes including bytes to get to start byte  						foundANYError = true;  					}  //					else if (sequenceLen > 1)  //						multiByteSequenceFound = true;  				}
Magic Number,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The following statement contains a magic number: for (int i = 0; i < m_Data.Length; i += sequenceLen)  				{  					byte by = m_Data[i];  					bool foundError = false;  					// If the leftmost bit is 0' then this is a 1-byte character  					if ((by & kLeft1BitMask) == 0)  						sequenceLen = 1;  					else if((by & kLeft3BitsMask) == kLeft2BitsMask)  					{  						// If the byte starts with 110' then this will be the first byte  						// of a 2-byte sequence  						sequenceLen = 2;  						// if the second byte does not start with 10 then the sequence is invalid  						if(m_ByteLength <= i+1 || (m_Data[i + 1] & kLeft2BitsMask) != 0x80)  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft4BitsMask) == kLeft3BitsMask)  					{  						// If the byte starts with 1110' then this will be the first byte of  						// a 3-byte sequence  						sequenceLen = 3;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft5BitsMask) == kLeft4BitsMask)  					{  						// if the byte starts with 11110' then this will be the first byte of  						// a 4-byte sequence  						sequenceLen = 4;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+3 || (m_Data[i+3] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else  					{  						badCodePoint = by;  						bytePosition = i+1;	// not zero based' but 1 based for user  						if (!findAllErrors)  							return false;  						foundError = true;  					}    					if (foundError)  					{  						if (m_invalidBytes.Count < MaxInvalidBytes)  							m_invalidBytes.Enqueue(new DP(bytePosition' badCodePoint));  						System.Diagnostics.Debug.WriteLine("badData: index=" + System.Convert.ToString(i + 1) + " ");  						bytesUntilNextCodePoint = i;  						// now search until we find a valid begin byte for utf8 sequence  						while (++i < m_ByteLength && IsValidBeginByte(m_Data[i]) == false)  						{  							if (m_invalidBytes.Count < MaxInvalidBytes)  								m_invalidBytes.Enqueue(new DP(i + 1' m_Data[i]));  						}  						sequenceLen = 0;  						bytesUntilNextCodePoint = i - bytesUntilNextCodePoint;  						badBytes += bytesUntilNextCodePoint;	// bytes including bytes to get to start byte  						foundANYError = true;  					}  //					else if (sequenceLen > 1)  //						multiByteSequenceFound = true;  				}
Magic Number,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The following statement contains a magic number: for (int i = 0; i < m_Data.Length; i += sequenceLen)  				{  					byte by = m_Data[i];  					bool foundError = false;  					// If the leftmost bit is 0' then this is a 1-byte character  					if ((by & kLeft1BitMask) == 0)  						sequenceLen = 1;  					else if((by & kLeft3BitsMask) == kLeft2BitsMask)  					{  						// If the byte starts with 110' then this will be the first byte  						// of a 2-byte sequence  						sequenceLen = 2;  						// if the second byte does not start with 10 then the sequence is invalid  						if(m_ByteLength <= i+1 || (m_Data[i + 1] & kLeft2BitsMask) != 0x80)  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft4BitsMask) == kLeft3BitsMask)  					{  						// If the byte starts with 1110' then this will be the first byte of  						// a 3-byte sequence  						sequenceLen = 3;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft5BitsMask) == kLeft4BitsMask)  					{  						// if the byte starts with 11110' then this will be the first byte of  						// a 4-byte sequence  						sequenceLen = 4;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+3 || (m_Data[i+3] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else  					{  						badCodePoint = by;  						bytePosition = i+1;	// not zero based' but 1 based for user  						if (!findAllErrors)  							return false;  						foundError = true;  					}    					if (foundError)  					{  						if (m_invalidBytes.Count < MaxInvalidBytes)  							m_invalidBytes.Enqueue(new DP(bytePosition' badCodePoint));  						System.Diagnostics.Debug.WriteLine("badData: index=" + System.Convert.ToString(i + 1) + " ");  						bytesUntilNextCodePoint = i;  						// now search until we find a valid begin byte for utf8 sequence  						while (++i < m_ByteLength && IsValidBeginByte(m_Data[i]) == false)  						{  							if (m_invalidBytes.Count < MaxInvalidBytes)  								m_invalidBytes.Enqueue(new DP(i + 1' m_Data[i]));  						}  						sequenceLen = 0;  						bytesUntilNextCodePoint = i - bytesUntilNextCodePoint;  						badBytes += bytesUntilNextCodePoint;	// bytes including bytes to get to start byte  						foundANYError = true;  					}  //					else if (sequenceLen > 1)  //						multiByteSequenceFound = true;  				}
Magic Number,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The following statement contains a magic number: for (int i = 0; i < m_Data.Length; i += sequenceLen)  				{  					byte by = m_Data[i];  					bool foundError = false;  					// If the leftmost bit is 0' then this is a 1-byte character  					if ((by & kLeft1BitMask) == 0)  						sequenceLen = 1;  					else if((by & kLeft3BitsMask) == kLeft2BitsMask)  					{  						// If the byte starts with 110' then this will be the first byte  						// of a 2-byte sequence  						sequenceLen = 2;  						// if the second byte does not start with 10 then the sequence is invalid  						if(m_ByteLength <= i+1 || (m_Data[i + 1] & kLeft2BitsMask) != 0x80)  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft4BitsMask) == kLeft3BitsMask)  					{  						// If the byte starts with 1110' then this will be the first byte of  						// a 3-byte sequence  						sequenceLen = 3;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft5BitsMask) == kLeft4BitsMask)  					{  						// if the byte starts with 11110' then this will be the first byte of  						// a 4-byte sequence  						sequenceLen = 4;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+3 || (m_Data[i+3] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else  					{  						badCodePoint = by;  						bytePosition = i+1;	// not zero based' but 1 based for user  						if (!findAllErrors)  							return false;  						foundError = true;  					}    					if (foundError)  					{  						if (m_invalidBytes.Count < MaxInvalidBytes)  							m_invalidBytes.Enqueue(new DP(bytePosition' badCodePoint));  						System.Diagnostics.Debug.WriteLine("badData: index=" + System.Convert.ToString(i + 1) + " ");  						bytesUntilNextCodePoint = i;  						// now search until we find a valid begin byte for utf8 sequence  						while (++i < m_ByteLength && IsValidBeginByte(m_Data[i]) == false)  						{  							if (m_invalidBytes.Count < MaxInvalidBytes)  								m_invalidBytes.Enqueue(new DP(i + 1' m_Data[i]));  						}  						sequenceLen = 0;  						bytesUntilNextCodePoint = i - bytesUntilNextCodePoint;  						badBytes += bytesUntilNextCodePoint;	// bytes including bytes to get to start byte  						foundANYError = true;  					}  //					else if (sequenceLen > 1)  //						multiByteSequenceFound = true;  				}
Magic Number,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The following statement contains a magic number: for (int i = 0; i < m_Data.Length; i += sequenceLen)  				{  					byte by = m_Data[i];  					bool foundError = false;  					// If the leftmost bit is 0' then this is a 1-byte character  					if ((by & kLeft1BitMask) == 0)  						sequenceLen = 1;  					else if((by & kLeft3BitsMask) == kLeft2BitsMask)  					{  						// If the byte starts with 110' then this will be the first byte  						// of a 2-byte sequence  						sequenceLen = 2;  						// if the second byte does not start with 10 then the sequence is invalid  						if(m_ByteLength <= i+1 || (m_Data[i + 1] & kLeft2BitsMask) != 0x80)  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft4BitsMask) == kLeft3BitsMask)  					{  						// If the byte starts with 1110' then this will be the first byte of  						// a 3-byte sequence  						sequenceLen = 3;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft5BitsMask) == kLeft4BitsMask)  					{  						// if the byte starts with 11110' then this will be the first byte of  						// a 4-byte sequence  						sequenceLen = 4;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+3 || (m_Data[i+3] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else  					{  						badCodePoint = by;  						bytePosition = i+1;	// not zero based' but 1 based for user  						if (!findAllErrors)  							return false;  						foundError = true;  					}    					if (foundError)  					{  						if (m_invalidBytes.Count < MaxInvalidBytes)  							m_invalidBytes.Enqueue(new DP(bytePosition' badCodePoint));  						System.Diagnostics.Debug.WriteLine("badData: index=" + System.Convert.ToString(i + 1) + " ");  						bytesUntilNextCodePoint = i;  						// now search until we find a valid begin byte for utf8 sequence  						while (++i < m_ByteLength && IsValidBeginByte(m_Data[i]) == false)  						{  							if (m_invalidBytes.Count < MaxInvalidBytes)  								m_invalidBytes.Enqueue(new DP(i + 1' m_Data[i]));  						}  						sequenceLen = 0;  						bytesUntilNextCodePoint = i - bytesUntilNextCodePoint;  						badBytes += bytesUntilNextCodePoint;	// bytes including bytes to get to start byte  						foundANYError = true;  					}  //					else if (sequenceLen > 1)  //						multiByteSequenceFound = true;  				}
Magic Number,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The following statement contains a magic number: for (int i = 0; i < m_Data.Length; i += sequenceLen)  				{  					byte by = m_Data[i];  					bool foundError = false;  					// If the leftmost bit is 0' then this is a 1-byte character  					if ((by & kLeft1BitMask) == 0)  						sequenceLen = 1;  					else if((by & kLeft3BitsMask) == kLeft2BitsMask)  					{  						// If the byte starts with 110' then this will be the first byte  						// of a 2-byte sequence  						sequenceLen = 2;  						// if the second byte does not start with 10 then the sequence is invalid  						if(m_ByteLength <= i+1 || (m_Data[i + 1] & kLeft2BitsMask) != 0x80)  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft4BitsMask) == kLeft3BitsMask)  					{  						// If the byte starts with 1110' then this will be the first byte of  						// a 3-byte sequence  						sequenceLen = 3;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft5BitsMask) == kLeft4BitsMask)  					{  						// if the byte starts with 11110' then this will be the first byte of  						// a 4-byte sequence  						sequenceLen = 4;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+3 || (m_Data[i+3] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else  					{  						badCodePoint = by;  						bytePosition = i+1;	// not zero based' but 1 based for user  						if (!findAllErrors)  							return false;  						foundError = true;  					}    					if (foundError)  					{  						if (m_invalidBytes.Count < MaxInvalidBytes)  							m_invalidBytes.Enqueue(new DP(bytePosition' badCodePoint));  						System.Diagnostics.Debug.WriteLine("badData: index=" + System.Convert.ToString(i + 1) + " ");  						bytesUntilNextCodePoint = i;  						// now search until we find a valid begin byte for utf8 sequence  						while (++i < m_ByteLength && IsValidBeginByte(m_Data[i]) == false)  						{  							if (m_invalidBytes.Count < MaxInvalidBytes)  								m_invalidBytes.Enqueue(new DP(i + 1' m_Data[i]));  						}  						sequenceLen = 0;  						bytesUntilNextCodePoint = i - bytesUntilNextCodePoint;  						badBytes += bytesUntilNextCodePoint;	// bytes including bytes to get to start byte  						foundANYError = true;  					}  //					else if (sequenceLen > 1)  //						multiByteSequenceFound = true;  				}
Magic Number,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The following statement contains a magic number: for (int i = 0; i < m_Data.Length; i += sequenceLen)  				{  					byte by = m_Data[i];  					bool foundError = false;  					// If the leftmost bit is 0' then this is a 1-byte character  					if ((by & kLeft1BitMask) == 0)  						sequenceLen = 1;  					else if((by & kLeft3BitsMask) == kLeft2BitsMask)  					{  						// If the byte starts with 110' then this will be the first byte  						// of a 2-byte sequence  						sequenceLen = 2;  						// if the second byte does not start with 10 then the sequence is invalid  						if(m_ByteLength <= i+1 || (m_Data[i + 1] & kLeft2BitsMask) != 0x80)  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft4BitsMask) == kLeft3BitsMask)  					{  						// If the byte starts with 1110' then this will be the first byte of  						// a 3-byte sequence  						sequenceLen = 3;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft5BitsMask) == kLeft4BitsMask)  					{  						// if the byte starts with 11110' then this will be the first byte of  						// a 4-byte sequence  						sequenceLen = 4;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+3 || (m_Data[i+3] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else  					{  						badCodePoint = by;  						bytePosition = i+1;	// not zero based' but 1 based for user  						if (!findAllErrors)  							return false;  						foundError = true;  					}    					if (foundError)  					{  						if (m_invalidBytes.Count < MaxInvalidBytes)  							m_invalidBytes.Enqueue(new DP(bytePosition' badCodePoint));  						System.Diagnostics.Debug.WriteLine("badData: index=" + System.Convert.ToString(i + 1) + " ");  						bytesUntilNextCodePoint = i;  						// now search until we find a valid begin byte for utf8 sequence  						while (++i < m_ByteLength && IsValidBeginByte(m_Data[i]) == false)  						{  							if (m_invalidBytes.Count < MaxInvalidBytes)  								m_invalidBytes.Enqueue(new DP(i + 1' m_Data[i]));  						}  						sequenceLen = 0;  						bytesUntilNextCodePoint = i - bytesUntilNextCodePoint;  						badBytes += bytesUntilNextCodePoint;	// bytes including bytes to get to start byte  						foundANYError = true;  					}  //					else if (sequenceLen > 1)  //						multiByteSequenceFound = true;  				}
Magic Number,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The following statement contains a magic number: for (int i = 0; i < m_Data.Length; i += sequenceLen)  				{  					byte by = m_Data[i];  					bool foundError = false;  					// If the leftmost bit is 0' then this is a 1-byte character  					if ((by & kLeft1BitMask) == 0)  						sequenceLen = 1;  					else if((by & kLeft3BitsMask) == kLeft2BitsMask)  					{  						// If the byte starts with 110' then this will be the first byte  						// of a 2-byte sequence  						sequenceLen = 2;  						// if the second byte does not start with 10 then the sequence is invalid  						if(m_ByteLength <= i+1 || (m_Data[i + 1] & kLeft2BitsMask) != 0x80)  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft4BitsMask) == kLeft3BitsMask)  					{  						// If the byte starts with 1110' then this will be the first byte of  						// a 3-byte sequence  						sequenceLen = 3;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft5BitsMask) == kLeft4BitsMask)  					{  						// if the byte starts with 11110' then this will be the first byte of  						// a 4-byte sequence  						sequenceLen = 4;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+3 || (m_Data[i+3] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else  					{  						badCodePoint = by;  						bytePosition = i+1;	// not zero based' but 1 based for user  						if (!findAllErrors)  							return false;  						foundError = true;  					}    					if (foundError)  					{  						if (m_invalidBytes.Count < MaxInvalidBytes)  							m_invalidBytes.Enqueue(new DP(bytePosition' badCodePoint));  						System.Diagnostics.Debug.WriteLine("badData: index=" + System.Convert.ToString(i + 1) + " ");  						bytesUntilNextCodePoint = i;  						// now search until we find a valid begin byte for utf8 sequence  						while (++i < m_ByteLength && IsValidBeginByte(m_Data[i]) == false)  						{  							if (m_invalidBytes.Count < MaxInvalidBytes)  								m_invalidBytes.Enqueue(new DP(i + 1' m_Data[i]));  						}  						sequenceLen = 0;  						bytesUntilNextCodePoint = i - bytesUntilNextCodePoint;  						badBytes += bytesUntilNextCodePoint;	// bytes including bytes to get to start byte  						foundANYError = true;  					}  //					else if (sequenceLen > 1)  //						multiByteSequenceFound = true;  				}
Magic Number,Sfm2Xml,ClsStringToOrFromBytes,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Converter.cs,IsUTF8String,The following statement contains a magic number: for (int i = 0; i < m_Data.Length; i += sequenceLen)  				{  					byte by = m_Data[i];  					bool foundError = false;  					// If the leftmost bit is 0' then this is a 1-byte character  					if ((by & kLeft1BitMask) == 0)  						sequenceLen = 1;  					else if((by & kLeft3BitsMask) == kLeft2BitsMask)  					{  						// If the byte starts with 110' then this will be the first byte  						// of a 2-byte sequence  						sequenceLen = 2;  						// if the second byte does not start with 10 then the sequence is invalid  						if(m_ByteLength <= i+1 || (m_Data[i + 1] & kLeft2BitsMask) != 0x80)  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft4BitsMask) == kLeft3BitsMask)  					{  						// If the byte starts with 1110' then this will be the first byte of  						// a 3-byte sequence  						sequenceLen = 3;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else if((by & kLeft5BitsMask) == kLeft4BitsMask)  					{  						// if the byte starts with 11110' then this will be the first byte of  						// a 4-byte sequence  						sequenceLen = 4;  						if ((m_ByteLength <= i+1 || (m_Data[i+1] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+2 || (m_Data[i+2] & kLeft2BitsMask) != 0x80) ||  							(m_ByteLength <= i+3 || (m_Data[i+3] & kLeft2BitsMask) != 0x80))  						{  							badCodePoint = by;  							bytePosition = i+1;	// not zero based' but 1 based for user  							if (!findAllErrors)  								return false;  							foundError = true;  						}  					}  					else  					{  						badCodePoint = by;  						bytePosition = i+1;	// not zero based' but 1 based for user  						if (!findAllErrors)  							return false;  						foundError = true;  					}    					if (foundError)  					{  						if (m_invalidBytes.Count < MaxInvalidBytes)  							m_invalidBytes.Enqueue(new DP(bytePosition' badCodePoint));  						System.Diagnostics.Debug.WriteLine("badData: index=" + System.Convert.ToString(i + 1) + " ");  						bytesUntilNextCodePoint = i;  						// now search until we find a valid begin byte for utf8 sequence  						while (++i < m_ByteLength && IsValidBeginByte(m_Data[i]) == false)  						{  							if (m_invalidBytes.Count < MaxInvalidBytes)  								m_invalidBytes.Enqueue(new DP(i + 1' m_Data[i]));  						}  						sequenceLen = 0;  						bytesUntilNextCodePoint = i - bytesUntilNextCodePoint;  						badBytes += bytesUntilNextCodePoint;	// bytes including bytes to get to start byte  						foundANYError = true;  					}  //					else if (sequenceLen > 1)  //						multiByteSequenceFound = true;  				}
Magic Number,Sfm2Xml,CRC,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\CRC.cs,CRC,The following statement contains a magic number: m_CRCTable = new uint[256];
Magic Number,Sfm2Xml,CRC,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\CRC.cs,BuildCRCTable,The following statement contains a magic number: for (uint i = 0; i <= 255; i++)  			{  				uint crc = i;  				for (int j = 8; j > 0; j--)  				{  					if ((crc & 1) == 1)  						crc = (crc >> 1) ^ m_CRC32_POLYNOMIAL;  					else  						crc >>= 1;  				}  				m_CRCTable[i] = crc;  			}
Magic Number,Sfm2Xml,CRC,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\CRC.cs,BuildCRCTable,The following statement contains a magic number: for (uint i = 0; i <= 255; i++)  			{  				uint crc = i;  				for (int j = 8; j > 0; j--)  				{  					if ((crc & 1) == 1)  						crc = (crc >> 1) ^ m_CRC32_POLYNOMIAL;  					else  						crc >>= 1;  				}  				m_CRCTable[i] = crc;  			}
Magic Number,Sfm2Xml,CRC,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\CRC.cs,CalculateCRC,The following statement contains a magic number: while (index < count)  			{  				b = buffer[index++];  				uint temp1 = (crc >> 8) & 0x00FFFFFF;  				uint temp2 = m_CRCTable[((int)crc ^ b) & 0xff];  				crc = temp1 ^ temp2;  			}
Magic Number,Sfm2Xml,CRC,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\CRC.cs,CalculateCRC_N,The following statement contains a magic number: while (index < count)  			{  				b = buffer[index++];  				uint temp1 = (crc >> 8) & 0x00FFFFFF;  				uint temp2 = m_CRCTable[((int)crc ^ b) & 0xff];  				crc = temp1 ^ temp2;  			}
Magic Number,Sfm2Xml,ByteReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,CheckforAndHandleBOM,The following statement contains a magic number: if (m_foundBOM)	// has one  			{  				if (m_BOMEncoding == System.Text.Encoding.UTF8)  				{  					// no extra processing needed for UTF8 - this is the default format  				}  				else if (m_BOMEncoding == System.Text.Encoding.Unicode ||  					m_BOMEncoding == System.Text.Encoding.BigEndianUnicode)  				{  					System.Text.UTF8Encoding utf8Encoder = new System.Text.UTF8Encoding(false' true);  					try  					{  						// decode the wide Unicode byte data to wide chars  						System.Text.Decoder uniDecoder = m_BOMEncoding.GetDecoder();  						int charCount = uniDecoder.GetCharCount(m_FileData' 2' m_FileData.Length-2);  						char[] chars = new Char[charCount];  						uniDecoder.GetChars(m_FileData' 2' m_FileData.Length-2' chars' 0);    						// decode the wide chars to utf8 bytes  						int newLength = utf8Encoder.GetByteCount(chars);  						m_FileData = new byte[newLength];  						utf8Encoder.GetBytes(chars' 0' chars.Length' m_FileData' 0);    						// log msg for user to see  						if (m_Log != null)  							m_Log.AddWarning(String.Format(Sfm2XmlStrings.FileConvertedFrom0To1'  								m_BOMEncoding.WebName' utf8Encoder.WebName));  					}  					catch (System.Exception e)  					{  						if (m_Log != null)  						{  							m_Log.AddFatalError(String.Format(Sfm2XmlStrings.CannotConvertFileFrom0To1'  								m_BOMEncoding.WebName' utf8Encoder.WebName));  							m_Log.AddFatalError(String.Format(Sfm2XmlStrings.Exception0' e.Message));  						}  						m_position = 0;  						m_FileData = new byte[0];	// don't process anything  					}  				}  				else  				{  					m_position = 0;  					m_FileData = new byte[0];	// don't process anything  					if (m_Log != null)  						m_Log.AddFatalError(Sfm2XmlStrings.CannotProcessUtf32Files);  				}  			}
Magic Number,Sfm2Xml,ByteReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,CheckforAndHandleBOM,The following statement contains a magic number: if (m_foundBOM)	// has one  			{  				if (m_BOMEncoding == System.Text.Encoding.UTF8)  				{  					// no extra processing needed for UTF8 - this is the default format  				}  				else if (m_BOMEncoding == System.Text.Encoding.Unicode ||  					m_BOMEncoding == System.Text.Encoding.BigEndianUnicode)  				{  					System.Text.UTF8Encoding utf8Encoder = new System.Text.UTF8Encoding(false' true);  					try  					{  						// decode the wide Unicode byte data to wide chars  						System.Text.Decoder uniDecoder = m_BOMEncoding.GetDecoder();  						int charCount = uniDecoder.GetCharCount(m_FileData' 2' m_FileData.Length-2);  						char[] chars = new Char[charCount];  						uniDecoder.GetChars(m_FileData' 2' m_FileData.Length-2' chars' 0);    						// decode the wide chars to utf8 bytes  						int newLength = utf8Encoder.GetByteCount(chars);  						m_FileData = new byte[newLength];  						utf8Encoder.GetBytes(chars' 0' chars.Length' m_FileData' 0);    						// log msg for user to see  						if (m_Log != null)  							m_Log.AddWarning(String.Format(Sfm2XmlStrings.FileConvertedFrom0To1'  								m_BOMEncoding.WebName' utf8Encoder.WebName));  					}  					catch (System.Exception e)  					{  						if (m_Log != null)  						{  							m_Log.AddFatalError(String.Format(Sfm2XmlStrings.CannotConvertFileFrom0To1'  								m_BOMEncoding.WebName' utf8Encoder.WebName));  							m_Log.AddFatalError(String.Format(Sfm2XmlStrings.Exception0' e.Message));  						}  						m_position = 0;  						m_FileData = new byte[0];	// don't process anything  					}  				}  				else  				{  					m_position = 0;  					m_FileData = new byte[0];	// don't process anything  					if (m_Log != null)  						m_Log.AddFatalError(Sfm2XmlStrings.CannotProcessUtf32Files);  				}  			}
Magic Number,Sfm2Xml,ByteReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,CheckforAndHandleBOM,The following statement contains a magic number: if (m_foundBOM)	// has one  			{  				if (m_BOMEncoding == System.Text.Encoding.UTF8)  				{  					// no extra processing needed for UTF8 - this is the default format  				}  				else if (m_BOMEncoding == System.Text.Encoding.Unicode ||  					m_BOMEncoding == System.Text.Encoding.BigEndianUnicode)  				{  					System.Text.UTF8Encoding utf8Encoder = new System.Text.UTF8Encoding(false' true);  					try  					{  						// decode the wide Unicode byte data to wide chars  						System.Text.Decoder uniDecoder = m_BOMEncoding.GetDecoder();  						int charCount = uniDecoder.GetCharCount(m_FileData' 2' m_FileData.Length-2);  						char[] chars = new Char[charCount];  						uniDecoder.GetChars(m_FileData' 2' m_FileData.Length-2' chars' 0);    						// decode the wide chars to utf8 bytes  						int newLength = utf8Encoder.GetByteCount(chars);  						m_FileData = new byte[newLength];  						utf8Encoder.GetBytes(chars' 0' chars.Length' m_FileData' 0);    						// log msg for user to see  						if (m_Log != null)  							m_Log.AddWarning(String.Format(Sfm2XmlStrings.FileConvertedFrom0To1'  								m_BOMEncoding.WebName' utf8Encoder.WebName));  					}  					catch (System.Exception e)  					{  						if (m_Log != null)  						{  							m_Log.AddFatalError(String.Format(Sfm2XmlStrings.CannotConvertFileFrom0To1'  								m_BOMEncoding.WebName' utf8Encoder.WebName));  							m_Log.AddFatalError(String.Format(Sfm2XmlStrings.Exception0' e.Message));  						}  						m_position = 0;  						m_FileData = new byte[0];	// don't process anything  					}  				}  				else  				{  					m_position = 0;  					m_FileData = new byte[0];	// don't process anything  					if (m_Log != null)  						m_Log.AddFatalError(Sfm2XmlStrings.CannotProcessUtf32Files);  				}  			}
Magic Number,Sfm2Xml,ByteReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,CheckforAndHandleBOM,The following statement contains a magic number: if (m_foundBOM)	// has one  			{  				if (m_BOMEncoding == System.Text.Encoding.UTF8)  				{  					// no extra processing needed for UTF8 - this is the default format  				}  				else if (m_BOMEncoding == System.Text.Encoding.Unicode ||  					m_BOMEncoding == System.Text.Encoding.BigEndianUnicode)  				{  					System.Text.UTF8Encoding utf8Encoder = new System.Text.UTF8Encoding(false' true);  					try  					{  						// decode the wide Unicode byte data to wide chars  						System.Text.Decoder uniDecoder = m_BOMEncoding.GetDecoder();  						int charCount = uniDecoder.GetCharCount(m_FileData' 2' m_FileData.Length-2);  						char[] chars = new Char[charCount];  						uniDecoder.GetChars(m_FileData' 2' m_FileData.Length-2' chars' 0);    						// decode the wide chars to utf8 bytes  						int newLength = utf8Encoder.GetByteCount(chars);  						m_FileData = new byte[newLength];  						utf8Encoder.GetBytes(chars' 0' chars.Length' m_FileData' 0);    						// log msg for user to see  						if (m_Log != null)  							m_Log.AddWarning(String.Format(Sfm2XmlStrings.FileConvertedFrom0To1'  								m_BOMEncoding.WebName' utf8Encoder.WebName));  					}  					catch (System.Exception e)  					{  						if (m_Log != null)  						{  							m_Log.AddFatalError(String.Format(Sfm2XmlStrings.CannotConvertFileFrom0To1'  								m_BOMEncoding.WebName' utf8Encoder.WebName));  							m_Log.AddFatalError(String.Format(Sfm2XmlStrings.Exception0' e.Message));  						}  						m_position = 0;  						m_FileData = new byte[0];	// don't process anything  					}  				}  				else  				{  					m_position = 0;  					m_FileData = new byte[0];	// don't process anything  					if (m_Log != null)  						m_Log.AddFatalError(Sfm2XmlStrings.CannotProcessUtf32Files);  				}  			}
Magic Number,Sfm2Xml,ByteReader,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,GetEOLForThisFile,The following statement contains a magic number: int endPos = 1000;
Magic Number,Sfm2Xml,SfmFileReaderEx,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\FileReader.cs,SfmFileReaderEx,The following statement contains a magic number: m_byteCount = new int[256];
Magic Number,Sfm2Xml,LexImportCustomField,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\LexImportField.cs,LexImportCustomField,The following statement contains a magic number: const int kclidLexEntry = 5002;
Magic Number,Sfm2Xml,LexImportCustomField,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\LexImportField.cs,LexImportCustomField,The following statement contains a magic number: const int kclidLexSense = 5016;
Magic Number,Sfm2Xml,LexImportFields,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\LexImportFields.cs,GetCustomFieldClassFromClassID,The following statement contains a magic number: const int kclidLexEntry = 5002;
Magic Number,Sfm2Xml,LexImportFields,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\LexImportFields.cs,GetCustomFieldClassFromClassID,The following statement contains a magic number: const int kclidLexSense = 5016;
Magic Number,Sfm2Xml,LexImportFields,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\LexImportFields.cs,GetCustomFieldClassFromClassID,The following statement contains a magic number: const int kclidMoForm = 5035;
Magic Number,Sfm2Xml,LexImportFields,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\LexImportFields.cs,GetCustomFieldClassFromClassID,The following statement contains a magic number: const int kclidLexExampleSentence = 5004;
Magic Number,Sfm2Xml,ClsLog,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Log.cs,OutputSfmInfo,The following statement contains a magic number: foreach (DictionaryEntry sfmInfo in m_sfmData)  			{  				SfmData data = sfmInfo.Value as SfmData;  				string sfm = sfmInfo.Key as string;  				int ttlCount = data.m_WithData + data.m_WithoutData + data.m_NotDefined;  				if (ttlCount > 0)  				{  					xmlOutput.WriteStartElement("SfmInfo");  					xmlOutput.WriteAttributeString("sfm"' sfm);  					int usagePercent = (int)((double)data.m_WithData / (double)ttlCount * 100);  					xmlOutput.WriteAttributeString("ttlCount"' ttlCount.ToString());  					if (data.m_WithoutData > 0)  						xmlOutput.WriteAttributeString("emptyCount"' data.m_WithoutData.ToString());  					xmlOutput.WriteAttributeString("usagePercent"' usagePercent.ToString());    					// add the raw counts for other calculations  					xmlOutput.WriteAttributeString("withDataCount"' data.m_WithData.ToString());  					xmlOutput.WriteAttributeString("withoutDataCount"' data.m_WithoutData.ToString());  					xmlOutput.WriteAttributeString("notDefinedCount"' data.m_NotDefined.ToString());    					xmlOutput.WriteEndElement();  				}  			}
Magic Number,Sfm2Xml,STATICS,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\Statics.cs,NewMapFileBuilder,The following statement contains a magic number: System.Text.StringBuilder XMLText = new System.Text.StringBuilder(8192);
Missing Default,Sfm2Xml,ClsFieldDescription,C:\repos\sillsdev_FieldWorks\Src\Utilities\SfmToXml\ClsFieldDescription.cs,MakeValidFwId,The following switch statement is missing a default case: switch (value)  			{  				//case "lxrel":	// Lexical relation  				//case "cref":	// Cross reference fields  				//    if (data.RefFuncWS == string.Empty)  				//        data.RefFuncWS = topAnalysis;	// dont let it be blank for old map files  				//    break;    				case "subd":	// Subentry (Derivation)  					m_RefFunc = "Derivative";  					result = "sub";	// new value  					break;  				case "subc":	// Subentry (Compound)  					m_RefFunc = "Compound";  					result = "sub";	// new value  					break;  				case "subi":	// Subentry (Idiom)  					m_RefFunc = "Idiom";  					result = "sub";	// new value  					break;  				case "subk":	// Subentry (Keyterm Phrase)  					m_RefFunc = "";  					result = "sub";	// new value  					break;  				case "subpd":	// Subentry (Phrasal Verb)  					m_RefFunc = "Phrasal Verb";  					result = "sub";	// new value  					break;  				case "subs":	// Subentry (Saying)  					m_RefFunc = "Saying";  					result = "sub";	// new value  					break;  					//data.RefFuncWS = topAnalysis;    				case "vard":	// Variant (Dialectal)  					m_RefFunc = "Dialectal Variant";  					result = "var";	// new value  					break;  				case "varf":	// Variant (Free)  					m_RefFunc = "Free Variant";  					result = "var";	// new value  					break;  				case "vari":	// Variant (Inflectional)  					m_RefFunc = "Irregularly Inflected Form";  					result = "var";	// new value  					break;  				case "vars":	// Variant (Spelling)  					m_RefFunc = "Spelling Variant";  					result = "var";	// new value  					break;  				case "varc":	// Variant (Comment)  					//data.RefFuncWS = topAnalysis;  					break;  			}
