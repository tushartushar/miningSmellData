Implementation smell,Namespace,Class,File,Method,Description
Complex Method,SIL.FieldWorks.Filters,DateTimeMatcher,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\DateTimeMatcher.cs,GenDateIsBeforeDate,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.Filters,DateTimeMatcher,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\DateTimeMatcher.cs,GenDateMightBeBeforeDate,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.Filters,DateTimeMatcher,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\DateTimeMatcher.cs,GenDateIsAfterDate,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.Filters,DateTimeMatcher,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\DateTimeMatcher.cs,GenDateMightBeAfterDate,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.Filters,StringFinderCompare,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,Compare,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.Filters,StringFinderCompare,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.Filters,IcuComparer,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,Compare,Cyclomatic complexity of the method is 8
Virtual Method Call from Constructor,SIL.FieldWorks.Filters,FindResultSorter,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\FindResultSorter.cs,FindResultSorter,The constructor "FindResultSorter" calls a virtual method "getComparer".
Virtual Method Call from Constructor,SIL.FieldWorks.Filters,FindResultSorter,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\FindResultSorter.cs,FindResultSorter,The constructor "FindResultSorter" calls a virtual method "getComparer".
Virtual Method Call from Constructor,SIL.FieldWorks.Filters,AndSorterComparer,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,AndSorterComparer,The constructor "AndSorterComparer" calls a virtual method "getComparer".
Magic Number,SIL.FieldWorks.Filters,LazyManyOnePathSortItem,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\ManyOnePathSortItem.cs,LazyManyOnePathSortItem,The following statement contains a magic number: if (chunks.Length > 1)  			{  				var pathLen = chunks.Length/2;  				m_pathObjects = new ICmObjectOrId[pathLen];  				m_pathFlids = new int[pathLen];  				for (int i = 0; i < pathLen; i++)  				{  					m_pathFlids[i] = int.Parse(chunks[i*2 + 1]);  					m_pathObjects[i] = ParseGuidRep(repo' chunks[i * 2 + 2]);  				}  			}
Magic Number,SIL.FieldWorks.Filters,LazyManyOnePathSortItem,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\ManyOnePathSortItem.cs,LazyManyOnePathSortItem,The following statement contains a magic number: if (chunks.Length > 1)  			{  				var pathLen = chunks.Length/2;  				m_pathObjects = new ICmObjectOrId[pathLen];  				m_pathFlids = new int[pathLen];  				for (int i = 0; i < pathLen; i++)  				{  					m_pathFlids[i] = int.Parse(chunks[i*2 + 1]);  					m_pathObjects[i] = ParseGuidRep(repo' chunks[i * 2 + 2]);  				}  			}
Magic Number,SIL.FieldWorks.Filters,LazyManyOnePathSortItem,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\ManyOnePathSortItem.cs,LazyManyOnePathSortItem,The following statement contains a magic number: if (chunks.Length > 1)  			{  				var pathLen = chunks.Length/2;  				m_pathObjects = new ICmObjectOrId[pathLen];  				m_pathFlids = new int[pathLen];  				for (int i = 0; i < pathLen; i++)  				{  					m_pathFlids[i] = int.Parse(chunks[i*2 + 1]);  					m_pathObjects[i] = ParseGuidRep(repo' chunks[i * 2 + 2]);  				}  			}
Magic Number,SIL.FieldWorks.Filters,LazyManyOnePathSortItem,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\ManyOnePathSortItem.cs,LazyManyOnePathSortItem,The following statement contains a magic number: if (chunks.Length > 1)  			{  				var pathLen = chunks.Length/2;  				m_pathObjects = new ICmObjectOrId[pathLen];  				m_pathFlids = new int[pathLen];  				for (int i = 0; i < pathLen; i++)  				{  					m_pathFlids[i] = int.Parse(chunks[i*2 + 1]);  					m_pathObjects[i] = ParseGuidRep(repo' chunks[i * 2 + 2]);  				}  			}
Magic Number,SIL.FieldWorks.Filters,PropertyRecordSorter,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,Sort,The following statement contains a magic number: if (m_comp is LcmCompare)  			{  				//(m_comp as FdoCompare).Init();  				(m_comp as LcmCompare).ComparisonNoter = this;  				m_comparisonsDone = 0;  				m_percentDone = 0;  				// Make sure at least 1 so we don't divide by zero.  				m_comparisonsEstimated = Math.Max(records.Count * (int)Math.Ceiling(Math.Log(records.Count' 2.0))' 1);  			}
Magic Number,SIL.FieldWorks.Filters,RecordSorter,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,ComparisonOccurred,The following statement contains a magic number: int newPercentDone = m_comparisonsDone*100/m_comparisonsEstimated;
Magic Number,SIL.FieldWorks.Filters,RecordSorter,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,ComparisonOccurred,The following statement contains a magic number: SetPercentDone(Math.Min(m_percentDone' 100));
Magic Number,SIL.FieldWorks.Filters,LcmCompare,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,GetHashCode,The following statement contains a magic number: if (m_fUseKeys)  					hash *= 3;
Magic Number,SIL.FieldWorks.Filters,AndSorterComparer,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,GetHashCode,The following statement contains a magic number: if (m_comps != null)  					hash += m_comps.Count * 3;
Magic Number,SIL.FieldWorks.Filters,AndSorterComparer,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,GetHashCode,The following statement contains a magic number: if (m_sorters != null)  					hash += m_sorters.Count * 17;
Magic Number,SIL.FieldWorks.Filters,GenRecordSorter,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,Sort,The following statement contains a magic number: if (m_comp is StringFinderCompare)  			{  				(m_comp as StringFinderCompare).Init();  				(m_comp as StringFinderCompare).ComparisonNoter = this;  				m_comparisonsDone = 0;  				m_percentDone = 0;  				// Make sure at least 1 so we don't divide by zero.  				m_comparisonsEstimated = Math.Max(records.Count*(int)Math.Ceiling(Math.Log(records.Count' 2.0))' 1);  			}
Magic Number,SIL.FieldWorks.Filters,StringFinderCompare,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,GetHashCode,The following statement contains a magic number: if (m_fSortedByLength)  				hash *= 3;
Magic Number,SIL.FieldWorks.Filters,StringFinderCompare,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,GetHashCode,The following statement contains a magic number: if (m_fSortedFromEnd)  				hash *= 17;
Magic Number,SIL.FieldWorks.Filters,StringFinderCompare,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,GetHashCode,The following statement contains a magic number: if (m_objToKey != null)  				hash += m_objToKey.Count * 53;
Magic Number,SIL.FieldWorks.Filters,IcuComparer,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\RecordSorter.cs,GetHashCode,The following statement contains a magic number: if (m_htskey != null)  				hash += m_htskey.Count * 53;
Missing Default,SIL.FieldWorks.Filters,DateTimeMatcher,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\DateTimeMatcher.cs,Matches,The following switch statement is missing a default case: switch (m_type)  				{  					case DateMatchType.After:  						return time >= m_start;  					case DateMatchType.Before:  						return time <= m_end;  					case DateMatchType.Range:  					case DateMatchType.On:  						return time >= m_start && time <= m_end;  					case DateMatchType.NotRange:  						return time < m_start || time > m_end;  				}
Missing Default,SIL.FieldWorks.Filters,DateTimeMatcher,C:\repos\sillsdev_FieldWorks\Src\Common\Filters\DateTimeMatcher.cs,Matches,The following switch statement is missing a default case: switch (m_type)  				{  					case DateMatchType.After:  						return GenDateIsAfterDate(gen' m_start' IsStartAD);  					case DateMatchType.Before:  						return GenDateIsBeforeDate(gen' m_end' IsEndAD);  					case DateMatchType.Range:  					case DateMatchType.On:  						return GenDateIsInRange(gen);  					case DateMatchType.NotRange:  						return !GenDateIsInRange(gen);  				}
