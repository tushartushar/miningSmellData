Implementation smell,Namespace,Class,File,Method,Description
Long Method,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,InitializeComponent,The method has 140 lines of code.
Long Method,SIL.FieldWorks.UnicodeCharEditor,ErrorCodesExtensionMethods,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\ErrorCodes.cs,GetDescription,The method has 136 lines of code.
Long Method,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,InitializeComponent,The method has 377 lines of code.
Long Method,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,ModifyUCDFile,The method has 191 lines of code.
Complex Method,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,ModifyUCDFile,Cyclomatic complexity of the method is 16
Long Parameter List,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,AddToLists,The method has 6 parameters. Parameters: line' puaDefinition' addToBidi' removeFromBidi' addToNorm' removeFromNorm
Long Parameter List,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,WriteCodepointBlock,The method has 10 parameters. Parameters: writer' blockName' beginning' end' puaCharacters' data' addToBidi' removeFromBidi' addToNorm' removeFromNorm
Long Parameter List,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,ReadToEndOfSection,The method has 5 parameters. Parameters: reader' writer' lastProperty' currentCount' ucdCharacter
Long Parameter List,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,WriteBidiCodepointBlock,The method has 8 parameters. Parameters: writer' originalBeginningCode' originalEndCode' codepointsWithinRange' generalCategory' firstName' lastName' add
Long Parameter List,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,WriteBidiRange,The method has 7 parameters. Parameters: writer' beginning' end' generalCategory' firstName' lastName' bidiValue
Long Parameter List,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,WriteRange,The method has 5 parameters. Parameters: writer' beginning' end' name' data
Long Identifier,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,,The length of the parameter m_cbCompatabilityDecomposition is 30.
Long Statement,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,m_btnDelete_Click,The length of the statement  "					string msg = String.Format("Deleting the character definition for {0} cannot be undone.  Do you want to continue?"' spec.CodePoint); " is 132.
Long Statement,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(CharEditorWindow)); " is 136.
Long Statement,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,SetDialogProperties,The length of the statement  "				Debug.Assert(false' "Dialog must be set to Add or Modify (using the Modify property) before SetDialogProperties is called"); " is 124.
Long Statement,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(CustomCharDlg)); " is 133.
Long Statement,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,InitializeComponent,The length of the statement  "			this.m_cbGeneralCategory.SelectedIndexChanged += new System.EventHandler(this.m_cbGeneralCategory_SelectedIndexChanged); " is 120.
Long Statement,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,InitializeComponent,The length of the statement  "			this.m_cbCompatabilityDecomposition.SelectedIndexChanged += new System.EventHandler(this.m_cbCompatabilityDecomposition_SelectedIndexChanged); " is 142.
Long Statement,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,CheckForIcuLocked,The length of the statement  "					LogFile.AddLine(String.Format(" File Access Error: {0}. Asking user to Retry or Cancel. Caller={1}"' lockedFile' caller)); " is 122.
Complex Conditional,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,ModifyUCDFile,The conditional expression  "line.IndexOf('#') != -1 && line.IndexOf('[') != -1 && line.IndexOf(']') != -1 && indexDotDot != -1  								&& (line.IndexOf('#') < line.IndexOf('['))  								&& (line.IndexOf('[') < line.IndexOf(']'))  								&& (line.IndexOf(']') < indexDotDot)"  is complex.
Empty Catch Block,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,FindCachedIcuEntry,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.UnicodeCharEditor,Program,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\Program.cs,DeleteTemporaryFiles,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,RemoveFile,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.UnicodeCharEditor,PUAMigrator,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAMigrator.cs,Run,The method has an empty catch block.
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,GetListViewSubItemsArray,The following statement contains a magic number: var rgs = new string[10];
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,GetListViewSubItemsArray,The following statement contains a magic number: rgs[2] = cs.GeneralCategory.ToString();
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,GetListViewSubItemsArray,The following statement contains a magic number: rgs[3] = cs.CanonicalCombiningClass.ToString();
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,GetListViewSubItemsArray,The following statement contains a magic number: rgs[4] = cs.BidiClass.ToString();
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,GetListViewSubItemsArray,The following statement contains a magic number: rgs[5] = cs.Decomposition;
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,GetListViewSubItemsArray,The following statement contains a magic number: rgs[6] = cs.BidiMirrored.ToString();
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,GetListViewSubItemsArray,The following statement contains a magic number: rgs[7] = cs.Upper;
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,GetListViewSubItemsArray,The following statement contains a magic number: rgs[8] = cs.Lower;
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,GetListViewSubItemsArray,The following statement contains a magic number: rgs[9] = cs.Title;
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,ParseCodeField,The following statement contains a magic number: if (rgsCode.Length != 2)  				return false;
Magic Number,SIL.FieldWorks.UnicodeCharEditor,Program,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\Program.cs,Main,The following statement contains a magic number: for (int i = 0; i < args.Length; ++i)  			{  				if (args[i] == "-i" || args[i] == "-install" || args[i] == "--install")  					fInstall = true;  				else if (args[i] == "--cleanup")  				{  					if (i + 1 >= args.Length)  						return;    					var iterationCount = 0;  					var pid = int.Parse(args[i + 1]);  					while (Process.GetProcesses().Any(p => p.Id == pid) && iterationCount < 300)  					{  						// wait 1s then try again  						Thread.Sleep(1000);  						iterationCount++;  					}  					if (iterationCount < 300)  						DeleteTemporaryFiles();  					return;  				}  				else  					fBadArg = true;  			}
Magic Number,SIL.FieldWorks.UnicodeCharEditor,Program,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\Program.cs,Main,The following statement contains a magic number: for (int i = 0; i < args.Length; ++i)  			{  				if (args[i] == "-i" || args[i] == "-install" || args[i] == "--install")  					fInstall = true;  				else if (args[i] == "--cleanup")  				{  					if (i + 1 >= args.Length)  						return;    					var iterationCount = 0;  					var pid = int.Parse(args[i + 1]);  					while (Process.GetProcesses().Any(p => p.Id == pid) && iterationCount < 300)  					{  						// wait 1s then try again  						Thread.Sleep(1000);  						iterationCount++;  					}  					if (iterationCount < 300)  						DeleteTemporaryFiles();  					return;  				}  				else  					fBadArg = true;  			}
Magic Number,SIL.FieldWorks.UnicodeCharEditor,Program,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\Program.cs,Main,The following statement contains a magic number: for (int i = 0; i < args.Length; ++i)  			{  				if (args[i] == "-i" || args[i] == "-install" || args[i] == "--install")  					fInstall = true;  				else if (args[i] == "--cleanup")  				{  					if (i + 1 >= args.Length)  						return;    					var iterationCount = 0;  					var pid = int.Parse(args[i + 1]);  					while (Process.GetProcesses().Any(p => p.Id == pid) && iterationCount < 300)  					{  						// wait 1s then try again  						Thread.Sleep(1000);  						iterationCount++;  					}  					if (iterationCount < 300)  						DeleteTemporaryFiles();  					return;  				}  				else  					fBadArg = true;  			}
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,ValidCodepoint,The following statement contains a magic number: if( codepoint.Length < 4)  				return ErrorMessageHandler.ErrorMessage.shortCodepoint;
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,ValidCodepoint,The following statement contains a magic number: if( codepoint.Length > 6)  				return ErrorMessageHandler.ErrorMessage.longCodepoint;
Magic Number,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,ValidCodepoint,The following statement contains a magic number: var codepointValue = Convert.ToInt32(codepoint' 16);
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,InstallPUACharacters,The following statement contains a magic number: try  			{  				// 0. Intro: Prepare files    				// 0.1: File names  				var unidataDir = Path.Combine(IcuDir' "data");  				var unicodeDataFilename = Path.Combine(IcuDir' "UnicodeDataOverrides.txt");  				var originalUnicodeDataFilename = Path.Combine(unidataDir' "UnicodeDataOverrides.txt");  				var nfcOverridesFileName = Path.Combine(IcuDir' "nfcOverrides.txt"); // Intermediate we will generate  				var nfkcOverridesFileName = Path.Combine(IcuDir' "nfkcOverrides.txt"); // Intermediate we will generate    				// 0.2: Create a one-time backup that will not be over written if the file exists  				BackupOrig(unicodeDataFilename);    				// 0.3: Create a stack of files to restore if we encounter and error  				//			This allows us to work with the original files  				// If we are successful we call this.RemoveBackupFiles() to clean up  				// If we are not we call this.RestoreFiles() to restore the original files  				//		and delete the backups  				var unicodeDataBackup = CreateBackupFile(unicodeDataFilename);  				AddUndoFileFrame(unicodeDataFilename' unicodeDataBackup);    				//Initialize and populate the parser if necessary  				// 1. Maps our XML file to a list of PUACharacter objects.  				ParseCustomCharsFile(filename);    				// (Step 1 has been moved before the "intro")  				// 2. Sort the PUA characters  				m_chars.Sort();    				// 3. Open the file for reading and writing  				// 4. Insert the PUA via their codepoints  				InsertCharacters(m_chars.ToArray()' originalUnicodeDataFilename' unicodeDataFilename);    				// 5. Generate the modified normalization file inputs.  				using (var reader = new StreamReader(unicodeDataFilename' Encoding.ASCII))  				{  					using (var writeNfc = new StreamWriter(nfcOverridesFileName' false' Encoding.ASCII))  					using (var writeNfkc = new StreamWriter(nfkcOverridesFileName' false' Encoding.ASCII))  					{  						reader.Peek(); // force autodetection of encoding.  						try  						{  							string line;  							while ((line = reader.ReadLine()) != null)  							{  								if (line.StartsWith("Code") || line.StartsWith("block")) // header line or special instruction  									continue;  								// Extract the first' fourth' and sixth fields.  								var match = new Regex("^([^;]*);[^;]*;[^;]*;([^;]*);[^;]*;([^;]*);").Match(line);  								if (!match.Success)  									continue;  								string codePoint = match.Groups[1].Value.Trim();  								string combiningClass = match.Groups[2].Value.Trim();  								string decomp = match.Groups[3].Value.Trim();  								if (!string.IsNullOrEmpty(combiningClass) && combiningClass != "0")  								{  									writeNfc.WriteLine(codePoint + ":" + combiningClass);  								}  								if (!string.IsNullOrEmpty(decomp))  								{  									if (decomp.StartsWith("<"))  									{  										int index = decomp.IndexOf(">"' StringComparison.InvariantCulture);  										if (index < 0)  											continue; // badly formed' ignore it.  										decomp = decomp.Substring(index + 1).Trim();  									}  									// otherwise we should arguably write to nfc.txt  									// If exactly two code points write codePoint=decomp  									// otherwise write codePoint>decomp  									// However' we should not be modifying standard normalization.  									// For now treat them all as compatibility only.  									writeNfkc.WriteLine(codePoint + ">" + decomp);  								}  							}    						}  						finally  						{  							writeNfc.Close();  							writeNfkc.Close();  							reader.Close();  						}  					}  				}      				// 6. Run the "gennorm2" commands to write the actual files  				RunICUTools(unidataDir' nfcOverridesFileName' nfkcOverridesFileName);    				RemoveBackupFiles();  			}  			catch (Exception)  			{  				RestoreFiles();  				throw;  			}  			finally  			{  				RemoveTempFiles();  			}
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,InstallPUACharacters,The following statement contains a magic number: try  			{  				// 0. Intro: Prepare files    				// 0.1: File names  				var unidataDir = Path.Combine(IcuDir' "data");  				var unicodeDataFilename = Path.Combine(IcuDir' "UnicodeDataOverrides.txt");  				var originalUnicodeDataFilename = Path.Combine(unidataDir' "UnicodeDataOverrides.txt");  				var nfcOverridesFileName = Path.Combine(IcuDir' "nfcOverrides.txt"); // Intermediate we will generate  				var nfkcOverridesFileName = Path.Combine(IcuDir' "nfkcOverrides.txt"); // Intermediate we will generate    				// 0.2: Create a one-time backup that will not be over written if the file exists  				BackupOrig(unicodeDataFilename);    				// 0.3: Create a stack of files to restore if we encounter and error  				//			This allows us to work with the original files  				// If we are successful we call this.RemoveBackupFiles() to clean up  				// If we are not we call this.RestoreFiles() to restore the original files  				//		and delete the backups  				var unicodeDataBackup = CreateBackupFile(unicodeDataFilename);  				AddUndoFileFrame(unicodeDataFilename' unicodeDataBackup);    				//Initialize and populate the parser if necessary  				// 1. Maps our XML file to a list of PUACharacter objects.  				ParseCustomCharsFile(filename);    				// (Step 1 has been moved before the "intro")  				// 2. Sort the PUA characters  				m_chars.Sort();    				// 3. Open the file for reading and writing  				// 4. Insert the PUA via their codepoints  				InsertCharacters(m_chars.ToArray()' originalUnicodeDataFilename' unicodeDataFilename);    				// 5. Generate the modified normalization file inputs.  				using (var reader = new StreamReader(unicodeDataFilename' Encoding.ASCII))  				{  					using (var writeNfc = new StreamWriter(nfcOverridesFileName' false' Encoding.ASCII))  					using (var writeNfkc = new StreamWriter(nfkcOverridesFileName' false' Encoding.ASCII))  					{  						reader.Peek(); // force autodetection of encoding.  						try  						{  							string line;  							while ((line = reader.ReadLine()) != null)  							{  								if (line.StartsWith("Code") || line.StartsWith("block")) // header line or special instruction  									continue;  								// Extract the first' fourth' and sixth fields.  								var match = new Regex("^([^;]*);[^;]*;[^;]*;([^;]*);[^;]*;([^;]*);").Match(line);  								if (!match.Success)  									continue;  								string codePoint = match.Groups[1].Value.Trim();  								string combiningClass = match.Groups[2].Value.Trim();  								string decomp = match.Groups[3].Value.Trim();  								if (!string.IsNullOrEmpty(combiningClass) && combiningClass != "0")  								{  									writeNfc.WriteLine(codePoint + ":" + combiningClass);  								}  								if (!string.IsNullOrEmpty(decomp))  								{  									if (decomp.StartsWith("<"))  									{  										int index = decomp.IndexOf(">"' StringComparison.InvariantCulture);  										if (index < 0)  											continue; // badly formed' ignore it.  										decomp = decomp.Substring(index + 1).Trim();  									}  									// otherwise we should arguably write to nfc.txt  									// If exactly two code points write codePoint=decomp  									// otherwise write codePoint>decomp  									// However' we should not be modifying standard normalization.  									// For now treat them all as compatibility only.  									writeNfkc.WriteLine(codePoint + ">" + decomp);  								}  							}    						}  						finally  						{  							writeNfc.Close();  							writeNfkc.Close();  							reader.Close();  						}  					}  				}      				// 6. Run the "gennorm2" commands to write the actual files  				RunICUTools(unidataDir' nfcOverridesFileName' nfkcOverridesFileName);    				RemoveBackupFiles();  			}  			catch (Exception)  			{  				RestoreFiles();  				throw;  			}  			finally  			{  				RemoveTempFiles();  			}
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,InsertCharacters,The following statement contains a magic number: using (var reader = new StreamReader(originalOverrides' Encoding.ASCII))  			{  				reader.Peek();	// force autodetection of encoding.  				using (var writer = new StreamWriter(customOverrides' false' Encoding.ASCII))  				{  					try  					{  						// Insert the PUA via their codepoints    						string line;  						var lastCode = 0;  						// Start looking at the first codepoint  						var codeIndex = 0;  						var newCode = Convert.ToInt32(puaDefinitions[codeIndex].CodePoint' 16);    						// Used to find the type for casting ArrayLists to IPuaCharacter[]  						//var factory = new PuaCharacterFactory();  						//var puaCharForType = factory.Create("");  						//var puaCharType = puaCharForType.GetType();    						//While there is a line to be read in the file  						while ((line = reader.ReadLine()) != null)  						{  							// skip entirely blank lines  							if (line.Length <= 0)  								continue;  							if (line.StartsWith("Code") || line.StartsWith("block")) // header line or special instruction  							{  								writer.WriteLine(line);  								continue;  							}    							//Grab codepoint  							var strFileCode = line.Substring(0' line.IndexOf(';')).Trim(); // current code in file  							var fileCode = Convert.ToInt32(strFileCode' 16);    							// If the new codepoint is greater than the last one processed in the file' but  							// less than or equal to the current codepoint in the file.  							if (newCode > lastCode && newCode <= fileCode)  							{  								while (newCode <= fileCode)  								{  									LogCodepoint(puaDefinitions[codeIndex].CodePoint);    									// Replace the line with the new PuaDefinition  									writer.WriteLine("{0} #{1}"' puaDefinitions[codeIndex]' m_comment);  									lastCode = newCode;    									// Look for the next PUA codepoint that we wish to insert' we are done  									// with this one If we are all done' push through the rest of the file.  									if (++codeIndex >= puaDefinitions.Length)  									{  										// Write out the original top of the section if it hasn't been replaced.  										if (fileCode != lastCode)  										{  											writer.WriteLine(line);  										}  										while ((line = reader.ReadLine()) != null)  											writer.WriteLine(line);  										break;  									}  									newCode = Convert.ToInt32(puaDefinitions[codeIndex].CodePoint' 16);  								}  								if (codeIndex >= puaDefinitions.Length)  									break;  								// Write out the original top of the section if it hasn't been replaced.  								if (fileCode != lastCode)  								{  									writer.WriteLine(line);  								}  							}  							//if it's not a first tag and the codepoints don't match  							else  							{  								writer.WriteLine(line);  							}  							lastCode = fileCode;  						}  						// Output any codepoints after the old end  						while (codeIndex < puaDefinitions.Length)  						{  							LogCodepoint(puaDefinitions[codeIndex].CodePoint);    							// Add a line with the new PuaDefinition  							writer.WriteLine("{0} #{1}"' puaDefinitions[codeIndex]' m_comment);  							codeIndex++;  						}  					}  					finally  					{  						writer.Flush();  						writer.Close();  						reader.Close();  					}  				}  			}
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,InsertCharacters,The following statement contains a magic number: using (var reader = new StreamReader(originalOverrides' Encoding.ASCII))  			{  				reader.Peek();	// force autodetection of encoding.  				using (var writer = new StreamWriter(customOverrides' false' Encoding.ASCII))  				{  					try  					{  						// Insert the PUA via their codepoints    						string line;  						var lastCode = 0;  						// Start looking at the first codepoint  						var codeIndex = 0;  						var newCode = Convert.ToInt32(puaDefinitions[codeIndex].CodePoint' 16);    						// Used to find the type for casting ArrayLists to IPuaCharacter[]  						//var factory = new PuaCharacterFactory();  						//var puaCharForType = factory.Create("");  						//var puaCharType = puaCharForType.GetType();    						//While there is a line to be read in the file  						while ((line = reader.ReadLine()) != null)  						{  							// skip entirely blank lines  							if (line.Length <= 0)  								continue;  							if (line.StartsWith("Code") || line.StartsWith("block")) // header line or special instruction  							{  								writer.WriteLine(line);  								continue;  							}    							//Grab codepoint  							var strFileCode = line.Substring(0' line.IndexOf(';')).Trim(); // current code in file  							var fileCode = Convert.ToInt32(strFileCode' 16);    							// If the new codepoint is greater than the last one processed in the file' but  							// less than or equal to the current codepoint in the file.  							if (newCode > lastCode && newCode <= fileCode)  							{  								while (newCode <= fileCode)  								{  									LogCodepoint(puaDefinitions[codeIndex].CodePoint);    									// Replace the line with the new PuaDefinition  									writer.WriteLine("{0} #{1}"' puaDefinitions[codeIndex]' m_comment);  									lastCode = newCode;    									// Look for the next PUA codepoint that we wish to insert' we are done  									// with this one If we are all done' push through the rest of the file.  									if (++codeIndex >= puaDefinitions.Length)  									{  										// Write out the original top of the section if it hasn't been replaced.  										if (fileCode != lastCode)  										{  											writer.WriteLine(line);  										}  										while ((line = reader.ReadLine()) != null)  											writer.WriteLine(line);  										break;  									}  									newCode = Convert.ToInt32(puaDefinitions[codeIndex].CodePoint' 16);  								}  								if (codeIndex >= puaDefinitions.Length)  									break;  								// Write out the original top of the section if it hasn't been replaced.  								if (fileCode != lastCode)  								{  									writer.WriteLine(line);  								}  							}  							//if it's not a first tag and the codepoints don't match  							else  							{  								writer.WriteLine(line);  							}  							lastCode = fileCode;  						}  						// Output any codepoints after the old end  						while (codeIndex < puaDefinitions.Length)  						{  							LogCodepoint(puaDefinitions[codeIndex].CodePoint);    							// Add a line with the new PuaDefinition  							writer.WriteLine("{0} #{1}"' puaDefinitions[codeIndex]' m_comment);  							codeIndex++;  						}  					}  					finally  					{  						writer.Flush();  						writer.Close();  						reader.Close();  					}  				}  			}
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,InsertCharacters,The following statement contains a magic number: using (var reader = new StreamReader(originalOverrides' Encoding.ASCII))  			{  				reader.Peek();	// force autodetection of encoding.  				using (var writer = new StreamWriter(customOverrides' false' Encoding.ASCII))  				{  					try  					{  						// Insert the PUA via their codepoints    						string line;  						var lastCode = 0;  						// Start looking at the first codepoint  						var codeIndex = 0;  						var newCode = Convert.ToInt32(puaDefinitions[codeIndex].CodePoint' 16);    						// Used to find the type for casting ArrayLists to IPuaCharacter[]  						//var factory = new PuaCharacterFactory();  						//var puaCharForType = factory.Create("");  						//var puaCharType = puaCharForType.GetType();    						//While there is a line to be read in the file  						while ((line = reader.ReadLine()) != null)  						{  							// skip entirely blank lines  							if (line.Length <= 0)  								continue;  							if (line.StartsWith("Code") || line.StartsWith("block")) // header line or special instruction  							{  								writer.WriteLine(line);  								continue;  							}    							//Grab codepoint  							var strFileCode = line.Substring(0' line.IndexOf(';')).Trim(); // current code in file  							var fileCode = Convert.ToInt32(strFileCode' 16);    							// If the new codepoint is greater than the last one processed in the file' but  							// less than or equal to the current codepoint in the file.  							if (newCode > lastCode && newCode <= fileCode)  							{  								while (newCode <= fileCode)  								{  									LogCodepoint(puaDefinitions[codeIndex].CodePoint);    									// Replace the line with the new PuaDefinition  									writer.WriteLine("{0} #{1}"' puaDefinitions[codeIndex]' m_comment);  									lastCode = newCode;    									// Look for the next PUA codepoint that we wish to insert' we are done  									// with this one If we are all done' push through the rest of the file.  									if (++codeIndex >= puaDefinitions.Length)  									{  										// Write out the original top of the section if it hasn't been replaced.  										if (fileCode != lastCode)  										{  											writer.WriteLine(line);  										}  										while ((line = reader.ReadLine()) != null)  											writer.WriteLine(line);  										break;  									}  									newCode = Convert.ToInt32(puaDefinitions[codeIndex].CodePoint' 16);  								}  								if (codeIndex >= puaDefinitions.Length)  									break;  								// Write out the original top of the section if it hasn't been replaced.  								if (fileCode != lastCode)  								{  									writer.WriteLine(line);  								}  							}  							//if it's not a first tag and the codepoints don't match  							else  							{  								writer.WriteLine(line);  							}  							lastCode = fileCode;  						}  						// Output any codepoints after the old end  						while (codeIndex < puaDefinitions.Length)  						{  							LogCodepoint(puaDefinitions[codeIndex].CodePoint);    							// Add a line with the new PuaDefinition  							writer.WriteLine("{0} #{1}"' puaDefinitions[codeIndex]' m_comment);  							codeIndex++;  						}  					}  					finally  					{  						writer.Flush();  						writer.Close();  						reader.Close();  					}  				}  			}
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,AddToLists,The following statement contains a magic number: string decomposition = GetField(line' 5);
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,AddToLists,The following statement contains a magic number: string puaRawDecomp = puaDefinition.Data[5 - 1];
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,AddHex,The following statement contains a magic number: long sum = Convert.ToInt64(hex' 16) + num;
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,AddHex,The following statement contains a magic number: return Convert.ToString(sum' 16).ToUpper();
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,SubHex,The following statement contains a magic number: return (int)(Convert.ToInt64(hex' 16) - Convert.ToInt64(hex2' 16));
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,SubHex,The following statement contains a magic number: return (int)(Convert.ToInt64(hex' 16) - Convert.ToInt64(hex2' 16));
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,ModifyUCDFile,The following statement contains a magic number: while ((dontRead && line != null) || (line = tr.ReadLine()) != null)  			{  				dontRead = false;  				if (HasBidiData(line))  				{  					// We found another valid codepoint' increment the count  					IncrementCount(ref rangeCount' line);    					var currentProperty = GetProperty(line);    					// If this is a new section of bidi class values  					if (!ucdCharacters[0].SameRegion(currentProperty' lastProperty))  					{  						lastProperty = currentProperty;  						// Find one of the ucdCharacters in this range in the list of ucdCharacters to add.  						var fFound = false;  						for (codeIndex = 0; codeIndex < ucdCharacters.Count; codeIndex++)  						{  							var ch = ucdCharacters[codeIndex];  							if (ch != null && ch.CompareTo(currentProperty) == 0)  							{  								fFound = true;  								break;  							}  						}    						// if we don't have any characters to put in this section  						if (!fFound)  						{  							tw.WriteLine(line);  							line = ReadToEndOfSection(tr' tw' lastProperty' rangeCount' ucdCharacters[0]);  							rangeCount = 0;  							dontRead = true;  							continue;  						}  					}    					#region insert_the_PUACharacter  					//Grab codepoint  					string code = line.Substring(0' line.IndexOf(';')).Trim();    					//If it's a range of codepoints  					if (code.IndexOf('.') != -1)  					{  						#region if_range  						//Grabs the end codepoint  						string endCode = code.Substring(code.IndexOf("..") + 2).Trim();  						code = code.Substring(0' code.IndexOf("..")).Trim();    						//A dynamic array that contains our range of codepoints and the properties to go with it  						var codepointsWithinRange = new List<IUcdCharacter>();    						// If the IPuaCharacter we want to insert is before the range  						while (  							//If this is the last one stop looking for more  							StillInRange(codeIndex' ucdCharacters' currentProperty) &&  							// For every character before the given value  							(ucdCharacters[codeIndex]).CompareCodePoint(code) < 0  							)  						{  							//Insert characters before the code  							AddUCDLine(tw' ucdCharacters[codeIndex]' add);  							codeIndex++;  						}  						while (  							//If this is the last one stop looking for more  							StillInRange(codeIndex' ucdCharacters' currentProperty) &&  							// While our xmlCodepoint satisfies: code <= xmlCodepoint <= endCode  							(ucdCharacters[codeIndex]).CompareCodePoint(endCode) < 1  							)  						{  							//Adds the puaCharacter to the list of codepoints that are in range  							codepointsWithinRange.Add(ucdCharacters[codeIndex]);  							codeIndex++;  						}  						//If we found any codepoints in the range to insert  						if (codepointsWithinRange.Count > 0)  						{  							#region parse_comments  							//Do lots of smart stuff to insert the PUA characters into the block  							string generalCategory = "";  							//Contains the beginning and ending range names  							string firstName = "";  							string lastName = "";    							//If a comment exists on the line in the proper format  							// e.g.   ---  # --- [ --- ] --- ... ---  							if (line.IndexOf('#') != -1 && line.IndexOf('[') != -1  								&& (line.IndexOf('#') <= line.IndexOf('[')))  							{  								//Grabs the general category  								generalCategory = line.Substring(line.IndexOf('#') + 1' line.IndexOf('[') - line.IndexOf('#') - 1).Trim();  							}  							//find the index of the second ".." in the line  							int indexDotDot = line.Substring(line.IndexOf(']')).IndexOf("..");  							if (indexDotDot != -1)  								indexDotDot += line.IndexOf(']');    							//int cat = line.IndexOf(']') ;    							if (line.IndexOf('#') != -1 && line.IndexOf('[') != -1 && line.IndexOf(']') != -1 && indexDotDot != -1  								&& (line.IndexOf('#') < line.IndexOf('['))  								&& (line.IndexOf('[') < line.IndexOf(']'))  								&& (line.IndexOf(']') < indexDotDot)  								)  							{  								//Grab the name of the first character in the range  								firstName = line.Substring(line.IndexOf(']') + 1' indexDotDot - line.IndexOf(']') - 1).Trim();  								//Grab the name of the last character in the range  								lastName = line.Substring(indexDotDot + 2).Trim();  							}  							#endregion  							WriteBidiCodepointBlock(tw' code' endCode' codepointsWithinRange'  								generalCategory' firstName' lastName' add);  						}  						else  						{  							tw.WriteLine(line);  						}  						#endregion  					}  					//if the codepoint in the file is equal to the codepoint that we want to insert  					else  					{  						if (MiscUtils.CompareHex(code' ucdCharacters[codeIndex].CodePoint) > 0)  						{  							// Insert the new PuaDefinition before the line (as well as any others that might be)  							while (  								//If this is the last one stop looking for more  								StillInRange(codeIndex' ucdCharacters' currentProperty) &&  								// For every character before the given value  								ucdCharacters[codeIndex].CompareCodePoint(code) < 0  								)  							{  								//Insert characters before the code  								AddUCDLine(tw' ucdCharacters[codeIndex]' add);  								codeIndex++;  							}  						}  						//if the codepoint in the file is equal to the codepoint that we want to insert  						if (StillInRange(codeIndex' ucdCharacters' currentProperty) &&  							(code == ucdCharacters[codeIndex].CodePoint))  						{  							// Replace the line with the new PuaDefinition  							AddUCDLine(tw' ucdCharacters[codeIndex]' add);  							// Look for the next PUA codepoint that we wish to insert  							codeIndex++;  						}  						//if it's not a first tag and the codepoints don't match  						else  						{  							tw.WriteLine(line);  						}  					}    					//If we have no more codepoints to insert in this section' then just finish writing this section  					if (!StillInRange(codeIndex' ucdCharacters' currentProperty))  					{  						line = ReadToEndOfSection(tr' tw' lastProperty' rangeCount' ucdCharacters[0]);  						rangeCount = 0;  						dontRead = true;  						continue;  					}  					#endregion  				}  				//If it's a comment' simply write it out  				else  				{  					// find the total count comment and replace it with the current count.  					if (line.ToLowerInvariant().IndexOf("total code points") != -1)  					{  						line = "# Total code points:" + rangeCount;  						rangeCount = 0;  					}  					tw.WriteLine(line);  				}  			}
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,ModifyUCDFile,The following statement contains a magic number: while ((dontRead && line != null) || (line = tr.ReadLine()) != null)  			{  				dontRead = false;  				if (HasBidiData(line))  				{  					// We found another valid codepoint' increment the count  					IncrementCount(ref rangeCount' line);    					var currentProperty = GetProperty(line);    					// If this is a new section of bidi class values  					if (!ucdCharacters[0].SameRegion(currentProperty' lastProperty))  					{  						lastProperty = currentProperty;  						// Find one of the ucdCharacters in this range in the list of ucdCharacters to add.  						var fFound = false;  						for (codeIndex = 0; codeIndex < ucdCharacters.Count; codeIndex++)  						{  							var ch = ucdCharacters[codeIndex];  							if (ch != null && ch.CompareTo(currentProperty) == 0)  							{  								fFound = true;  								break;  							}  						}    						// if we don't have any characters to put in this section  						if (!fFound)  						{  							tw.WriteLine(line);  							line = ReadToEndOfSection(tr' tw' lastProperty' rangeCount' ucdCharacters[0]);  							rangeCount = 0;  							dontRead = true;  							continue;  						}  					}    					#region insert_the_PUACharacter  					//Grab codepoint  					string code = line.Substring(0' line.IndexOf(';')).Trim();    					//If it's a range of codepoints  					if (code.IndexOf('.') != -1)  					{  						#region if_range  						//Grabs the end codepoint  						string endCode = code.Substring(code.IndexOf("..") + 2).Trim();  						code = code.Substring(0' code.IndexOf("..")).Trim();    						//A dynamic array that contains our range of codepoints and the properties to go with it  						var codepointsWithinRange = new List<IUcdCharacter>();    						// If the IPuaCharacter we want to insert is before the range  						while (  							//If this is the last one stop looking for more  							StillInRange(codeIndex' ucdCharacters' currentProperty) &&  							// For every character before the given value  							(ucdCharacters[codeIndex]).CompareCodePoint(code) < 0  							)  						{  							//Insert characters before the code  							AddUCDLine(tw' ucdCharacters[codeIndex]' add);  							codeIndex++;  						}  						while (  							//If this is the last one stop looking for more  							StillInRange(codeIndex' ucdCharacters' currentProperty) &&  							// While our xmlCodepoint satisfies: code <= xmlCodepoint <= endCode  							(ucdCharacters[codeIndex]).CompareCodePoint(endCode) < 1  							)  						{  							//Adds the puaCharacter to the list of codepoints that are in range  							codepointsWithinRange.Add(ucdCharacters[codeIndex]);  							codeIndex++;  						}  						//If we found any codepoints in the range to insert  						if (codepointsWithinRange.Count > 0)  						{  							#region parse_comments  							//Do lots of smart stuff to insert the PUA characters into the block  							string generalCategory = "";  							//Contains the beginning and ending range names  							string firstName = "";  							string lastName = "";    							//If a comment exists on the line in the proper format  							// e.g.   ---  # --- [ --- ] --- ... ---  							if (line.IndexOf('#') != -1 && line.IndexOf('[') != -1  								&& (line.IndexOf('#') <= line.IndexOf('[')))  							{  								//Grabs the general category  								generalCategory = line.Substring(line.IndexOf('#') + 1' line.IndexOf('[') - line.IndexOf('#') - 1).Trim();  							}  							//find the index of the second ".." in the line  							int indexDotDot = line.Substring(line.IndexOf(']')).IndexOf("..");  							if (indexDotDot != -1)  								indexDotDot += line.IndexOf(']');    							//int cat = line.IndexOf(']') ;    							if (line.IndexOf('#') != -1 && line.IndexOf('[') != -1 && line.IndexOf(']') != -1 && indexDotDot != -1  								&& (line.IndexOf('#') < line.IndexOf('['))  								&& (line.IndexOf('[') < line.IndexOf(']'))  								&& (line.IndexOf(']') < indexDotDot)  								)  							{  								//Grab the name of the first character in the range  								firstName = line.Substring(line.IndexOf(']') + 1' indexDotDot - line.IndexOf(']') - 1).Trim();  								//Grab the name of the last character in the range  								lastName = line.Substring(indexDotDot + 2).Trim();  							}  							#endregion  							WriteBidiCodepointBlock(tw' code' endCode' codepointsWithinRange'  								generalCategory' firstName' lastName' add);  						}  						else  						{  							tw.WriteLine(line);  						}  						#endregion  					}  					//if the codepoint in the file is equal to the codepoint that we want to insert  					else  					{  						if (MiscUtils.CompareHex(code' ucdCharacters[codeIndex].CodePoint) > 0)  						{  							// Insert the new PuaDefinition before the line (as well as any others that might be)  							while (  								//If this is the last one stop looking for more  								StillInRange(codeIndex' ucdCharacters' currentProperty) &&  								// For every character before the given value  								ucdCharacters[codeIndex].CompareCodePoint(code) < 0  								)  							{  								//Insert characters before the code  								AddUCDLine(tw' ucdCharacters[codeIndex]' add);  								codeIndex++;  							}  						}  						//if the codepoint in the file is equal to the codepoint that we want to insert  						if (StillInRange(codeIndex' ucdCharacters' currentProperty) &&  							(code == ucdCharacters[codeIndex].CodePoint))  						{  							// Replace the line with the new PuaDefinition  							AddUCDLine(tw' ucdCharacters[codeIndex]' add);  							// Look for the next PUA codepoint that we wish to insert  							codeIndex++;  						}  						//if it's not a first tag and the codepoints don't match  						else  						{  							tw.WriteLine(line);  						}  					}    					//If we have no more codepoints to insert in this section' then just finish writing this section  					if (!StillInRange(codeIndex' ucdCharacters' currentProperty))  					{  						line = ReadToEndOfSection(tr' tw' lastProperty' rangeCount' ucdCharacters[0]);  						rangeCount = 0;  						dontRead = true;  						continue;  					}  					#endregion  				}  				//If it's a comment' simply write it out  				else  				{  					// find the total count comment and replace it with the current count.  					if (line.ToLowerInvariant().IndexOf("total code points") != -1)  					{  						line = "# Total code points:" + rangeCount;  						rangeCount = 0;  					}  					tw.WriteLine(line);  				}  			}
Magic Number,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,IncrementCount,The following statement contains a magic number: if (code.IndexOf('.') != -1)  			{  				//Grabs the end codepoint  				var endCode = code.Substring(code.IndexOf("..") + 2).Trim();  				code = code.Substring(0' code.IndexOf("..")).Trim();  				// Add all the characters in the range.  				currentCount += SubHex(endCode' code) + 1;  			}  			// we found another valid codepoint  			else  				currentCount++;
Missing Default,SIL.FieldWorks.UnicodeCharEditor,CharEditorWindow,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CharEditorWindow.cs,OnClosing,The following switch statement is missing a default case: switch (res)  				{  					case DialogResult.Cancel:  						e.Cancel = true;  						return;  					case DialogResult.Yes:  						m_btnSave_Click(this' e);  						break;  				}
Missing Default,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,SetEnableBasedOnGeneralCategory,The following switch statement is missing a default case: switch (majorClass)  			{  				case 'N':  					m_cbNumericType.Enabled = true;  					m_txtNumericValue.Enabled = true;  					m_chBidiMirrored.Enabled = false;  					break;  				case 'L':  					m_txtUpperEquiv.Enabled = true;  					m_txtLowerEquiv.Enabled = true;  					m_txtTitleEquiv.Enabled = true;  					m_chBidiMirrored.Enabled = false;  					break;  				case 'C':  					m_cbNumericType.Enabled = true;  					m_txtNumericValue.Enabled = true;  					m_txtUpperEquiv.Enabled = true;  					m_txtLowerEquiv.Enabled = true;  					m_txtTitleEquiv.Enabled = true;  					m_cbCanonicalCombClass.Enabled = true;  					break;  				case 'M':  					if( subClass == 'e' )  						break;  					m_cbCanonicalCombClass.Enabled = true;  					break;  				case 'Z':  					m_chBidiMirrored.Enabled = false;  					break;  			}
Missing Default,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,SetEnableBasedOnGeneralCategory,The following switch statement is missing a default case: switch (majorClass)  			{  				case 'N':  					if( subClass == 'd' )  					{  						m_cbNumericType.SelectedItem = UcdProperty.GetInstance(Icu.UNumericType.U_NT_DECIMAL);  						m_cbNumericType.Enabled = false;  					}  					break;  			}
Missing Default,SIL.FieldWorks.UnicodeCharEditor,CustomCharDlg,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\CustomCharDlg.cs,IsValid,The following switch statement is missing a default case: switch ( unicodePropertyType )  			{  				case UnicodePropertyType.name:  					return char.IsLetter(character) || character == ' ' || character == '-';  				case UnicodePropertyType.codepoint:  					return ('A' <= char.ToUpper(character) &&  char.ToUpper(character) <= 'F') || char.IsNumber(character);  				case UnicodePropertyType.decomposition:  					return IsValid(character' UnicodePropertyType.codepoint) || character == ' ';  				case UnicodePropertyType.numeric:  					return char.IsNumber(character) || character == '/' || character == '.' || character == '-';  			}
Missing Default,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,WriteBidiRange,The following switch statement is missing a default case: switch (MiscUtils.CompareHex(end' beginning))  			{  				case -1:  					break;  				case 0:  					writer.WriteLine("{0'-14}; {1} # {2'-8} {3} OR {4}"'  						beginning' bidiValue' generalCategory' firstName' lastName);  					break;  				case 1:  					string range = beginning + ".." + end;  					string codeCount = "[" + codeRangeCount + "]";  					writer.WriteLine("{0'-14}; {1} # {2} {3'5} {4}..{5}"'  						range' bidiValue' generalCategory' codeCount' firstName' lastName);  					break;  			}
Missing Default,SIL.FieldWorks.UnicodeCharEditor,PUAInstaller,C:\repos\sillsdev_FieldWorks\Src\UnicodeCharEditor\PUAInstaller.cs,WriteRange,The following switch statement is missing a default case: switch (MiscUtils.CompareHex(end' beginning))  			{  				case -1:  					break;  				case 0:  					writer.WriteLine("{0};<{1}>{2}"' beginning' name' data);  					break;  				case 1:  					writer.WriteLine("{0};<{1}' First>{2}"' beginning' name' data);  					writer.WriteLine("{0};<{1}' Last>{2}"' end' name' data);  					break;  			}
