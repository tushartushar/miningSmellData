Implementation smell,Namespace,Class,File,Method,Description
Long Method,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,CheckVerseNumbers,The method has 152 lines of code.
Long Method,SILUBS.ScriptureChecks,QTokenProcessor,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\QuotationCheck.cs,CheckQuote,The method has 101 lines of code.
Complex Method,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,Check,Cyclomatic complexity of the method is 10
Complex Method,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,CheckChapterNumbers,Cyclomatic complexity of the method is 9
Complex Method,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,CheckForMissingChapters,Cyclomatic complexity of the method is 8
Complex Method,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,CheckVerseNumbers,Cyclomatic complexity of the method is 20
Complex Method,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,ParseVerseNumber,Cyclomatic complexity of the method is 11
Complex Method,SILUBS.ScriptureChecks,CharactersCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\CharactersCheck.cs,GetReferences,Cyclomatic complexity of the method is 9
Complex Method,SILUBS.ScriptureChecks,PunctuationCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,GetReferences,Cyclomatic complexity of the method is 13
Complex Method,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,IntermediateFinalize,Cyclomatic complexity of the method is 9
Complex Method,SILUBS.ScriptureChecks,QTokenProcessor,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\QuotationCheck.cs,CheckQuote,Cyclomatic complexity of the method is 20
Complex Method,SILUBS.ScriptureChecks,RepeatedWordsCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\RepeatedWordsCheck.cs,GetReferences,Cyclomatic complexity of the method is 8
Long Parameter List,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,AnyOverlappingVerses,The method has 5 parameters. Parameters: start1' end1' start2' end2' commonVerses
Long Parameter List,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,AddError,The method has 5 parameters. Parameters: token' offset' length' message' args
Long Parameter List,SILUBS.ScriptureChecks,QTokenProcessor,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\QuotationCheck.cs,QTokenProcessor,The method has 5 parameters. Parameters: dataSource' charCategorizer' qmCategorizer' desiredKey' results
Long Statement,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,CheckVerseNumbers,The length of the statement  "				else if ((parseResult != ParseVerseResult.InvalidFormat) && VersesAlreadyFound(curVerseStart' curVerseEnd' versesFound) && " is 122.
Long Statement,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,IntermediateFinalize,The length of the statement  "					Debug.Assert(pTok != null || tok2.TokenType == PunctuationTokenType.punctuation' "Quote separator should never be the first non-whitespace character in a sequence (after all' it IS whitespace!)"); " is 196.
Complex Conditional,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,CheckVerseNumbers,The conditional expression  "(parseResult != ParseVerseResult.InvalidFormat) && VersesAlreadyFound(curVerseStart' curVerseEnd' versesFound) &&  					!(expectingPartB && vrsPart == VersePart.PartB)"  is complex.
Complex Conditional,SILUBS.ScriptureChecks,CharactersCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\CharactersCheck.cs,GetReferences,The conditional expression  "(lookingForASpecificKey && keyMatches) ||  						(!lookingForASpecificKey && !invalidCharactersOnly) ||  						(invalidCharactersOnly && invalidItem)"  is complex.
Complex Conditional,SILUBS.ScriptureChecks,ProcessMatchedPairTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\MatchedPairsCheck.cs,RecordOverlappingPairs,The conditional expression  "m_pairList.IsOpen(tok1.Text) && m_pairList.IsOpen(tok2.Text) &&  				m_pairList.IsMatchedPair(tok1.Text' tok3.Text) &&  				m_pairList.IsMatchedPair(tok2.Text' tok4.Text)"  is complex.
Complex Conditional,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,ProcessPunctuation,The conditional expression  "m_puncts[m_puncts.Count - 3].IsInitial && m_puncts[m_puncts.Count - 1].IsInitial ||  						m_puncts[m_puncts.Count - 3].IsFinal && m_puncts[m_puncts.Count - 1].IsFinal"  is complex.
Magic Number,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,GetParameters,The following statement contains a magic number: string numberRange = string.Format("[{1}-{2}][{0}-{2}]*"' scriptDigitZero'  				(char)(scriptDigitZero + 1)' (char)(scriptDigitZero + 9));
Magic Number,SILUBS.ScriptureChecks,ChapterVerseCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,AnyOverlappingVerses,The following statement contains a magic number: commonVerses = (common.Count <= 2 ? common.ToArray() :  					new object[] { common[0]' common[common.Count - 1] });
Magic Number,SILUBS.ScriptureChecks,ChapterToken,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\ChapterVerseCheck.cs,ChapterToken,The following statement contains a magic number: m_chapNumber *= 10;
Magic Number,SILUBS.ScriptureChecks,ProcessMatchedPairTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\MatchedPairsCheck.cs,RemoveIfMatchedPairFound,The following statement contains a magic number: m_pairTokensFound.Count < 2
Magic Number,SILUBS.ScriptureChecks,ProcessMatchedPairTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\MatchedPairsCheck.cs,RemoveIfMatchedPairFound,The following statement contains a magic number: TextTokenSubstring possibleOpen = m_pairTokensFound[m_pairTokensFound.Count - 2];
Magic Number,SILUBS.ScriptureChecks,ProcessMatchedPairTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\MatchedPairsCheck.cs,RecordOverlappingPairs,The following statement contains a magic number: m_pairTokensFound.Count < 4
Magic Number,SILUBS.ScriptureChecks,ProcessMatchedPairTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\MatchedPairsCheck.cs,RecordOverlappingPairs,The following statement contains a magic number: TextTokenSubstring tok1 = m_pairTokensFound[m_pairTokensFound.Count - 4];
Magic Number,SILUBS.ScriptureChecks,ProcessMatchedPairTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\MatchedPairsCheck.cs,RecordOverlappingPairs,The following statement contains a magic number: TextTokenSubstring tok2 = m_pairTokensFound[m_pairTokensFound.Count - 3];
Magic Number,SILUBS.ScriptureChecks,ProcessMatchedPairTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\MatchedPairsCheck.cs,RecordOverlappingPairs,The following statement contains a magic number: TextTokenSubstring tok3 = m_pairTokensFound[m_pairTokensFound.Count - 2];
Magic Number,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,ProcessPunctuation,The following statement contains a magic number: m_puncts[m_puncts.Count - 2].TokenType = PunctuationTokenType.quoteSeparator;
Magic Number,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,ProcessPunctuation,The following statement contains a magic number: m_puncts[m_puncts.Count - 3].IsInitial && m_puncts[m_puncts.Count - 1].IsInitial ||  						m_puncts[m_puncts.Count - 3].IsFinal && m_puncts[m_puncts.Count - 1].IsFinal
Magic Number,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,ProcessPunctuation,The following statement contains a magic number: m_puncts[m_puncts.Count - 3].IsInitial && m_puncts[m_puncts.Count - 1].IsInitial ||  						m_puncts[m_puncts.Count - 3].IsFinal && m_puncts[m_puncts.Count - 1].IsFinal
Magic Number,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,ProcessPunctuation,The following statement contains a magic number: m_puncts[m_puncts.Count - 2].TokenType == PunctuationTokenType.whitespace &&  					!m_puncts[m_puncts.Count - 2].IsParaBreak &&  					m_puncts[m_puncts.Count - 3].TokenType == PunctuationTokenType.punctuation
Magic Number,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,ProcessPunctuation,The following statement contains a magic number: m_puncts[m_puncts.Count - 2].TokenType == PunctuationTokenType.whitespace &&  					!m_puncts[m_puncts.Count - 2].IsParaBreak &&  					m_puncts[m_puncts.Count - 3].TokenType == PunctuationTokenType.punctuation
Magic Number,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,ProcessPunctuation,The following statement contains a magic number: m_puncts[m_puncts.Count - 2].TokenType == PunctuationTokenType.whitespace &&  					!m_puncts[m_puncts.Count - 2].IsParaBreak &&  					m_puncts[m_puncts.Count - 3].TokenType == PunctuationTokenType.punctuation
Magic Number,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,ProcessPunctuation,The following statement contains a magic number: m_puncts.Count >= 3
Missing Default,SILUBS.ScriptureChecks,ProcessPunctationTokens,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\PunctuationCheck.cs,FinalizeResult,The following switch statement is missing a default case: switch (m_level)  			{  				case CheckingLevel.Advanced:  					AdvancedFinalize(currentPTok' desiredKey' result);  					break;  				case CheckingLevel.Intermediate:  					IntermediateFinalize(desiredKey' result);  					break;  				case CheckingLevel.Basic:  					BasicFinalize(desiredKey' result);  					break;  			}
Missing Default,SILUBS.ScriptureChecks,QTokenProcessor,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\QuotationCheck.cs,GetExpectedContinuerLevel,The following switch statement is missing a default case: switch (paraCont)  			{  				case ParagraphContinuationType.RequireOutermost: return 1;  				case ParagraphContinuationType.RequireInnermost: return currentLevel;  				case ParagraphContinuationType.RequireAll:  					for (int i = 1; i <= currentLevel; i++)  					{  						if (m_qmCategorizer.GetContinuationMarkForLevel(i) == continuer)  							return i;  					}  					break;  			}
Missing Default,SILUBS.ScriptureChecks,CapitalizationCheck,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Lib\src\ScrChecks\CapitalizationCheck.cs,GetErrorMessage,The following switch statement is missing a default case: switch (capReasonType)  			{  				case StyleCapInfo.CapCheckTypes.SentenceInitial:  					return dataSource.GetLocalizedString("Sentence should begin with a capital letter");  				case StyleCapInfo.CapCheckTypes.Heading:  					return dataSource.GetLocalizedString("Heading should begin with a capital letter");  				case StyleCapInfo.CapCheckTypes.Title:  					return dataSource.GetLocalizedString("Title should begin with a capital letter");  				case StyleCapInfo.CapCheckTypes.List:  					return dataSource.GetLocalizedString("List paragraphs should begin with a capital letter");  				case StyleCapInfo.CapCheckTypes.Table:  					return dataSource.GetLocalizedString("Table contents should begin with a capital letter");  				case StyleCapInfo.CapCheckTypes.ProperNoun:  					return dataSource.GetLocalizedString("Proper nouns should begin with a capital letter");  				case StyleCapInfo.CapCheckTypes.Special:  					return String.Format(dataSource.GetLocalizedString(  						"Text in the {0} style should begin with a capital letter")' styleName);  			}
