Implementation smell,Namespace,Class,File,Method,Description
Complex Method,SIL.FieldWorks.Common.FwUtils,CharacterCategorizer,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\CharacterCategorizer.cs,WordAndPuncts,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.Common.FwUtils,FLExBridgeHelper,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FLExBridgeHelper.cs,LaunchFieldworksBridge,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.Common.FwUtils,FwAppArgs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwLinkArgs.cs,ParseCommandLine,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.Common.FwUtils,FwAppArgs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwLinkArgs.cs,CommandLineSwitch,Cyclomatic complexity of the method is 13
Long Parameter List,SIL.FieldWorks.Common.FwUtils,CachePair,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\CachePair.cs,FindOrCreateSec,The method has 6 parameters. Parameters: hvoReal' clid' hvoOwner' flidOwn' flidName' tss
Long Parameter List,SIL.FieldWorks.Common.FwUtils,CachePair,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\CachePair.cs,FindOrCreateSec,The method has 7 parameters. Parameters: hvoReal' clid' hvoOwner' flidOwn' name' flidName' ws
Long Parameter List,SIL.FieldWorks.Common.FwUtils,CachePair,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\CachePair.cs,FindOrCreateSecAnalysis,The method has 6 parameters. Parameters: hvoReal' clid' hvoOwner' flidOwn' name' flidName
Long Parameter List,SIL.FieldWorks.Common.FwUtils,CachePair,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\CachePair.cs,FindOrCreateSecVern,The method has 6 parameters. Parameters: hvoReal' clid' hvoOwner' flidOwn' name' flidName
Long Parameter List,SIL.FieldWorks.Common.FwUtils,FLExBridgeHelper,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FLExBridgeHelper.cs,LaunchFieldworksBridge,The method has 10 parameters. Parameters: projectFolder' userName' command' projectGuid' fwmodelVersionNumber' liftModelVersionNumber' writingSystemId' onNonBlockerCommandComplete' changesReceived' projectName
Long Parameter List,SIL.FieldWorks.Common.FwUtils,FLExBridgeHelper,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FLExBridgeHelper.cs,LaunchFlexBridge,The method has 6 parameters. Parameters: host' command' args' onNonBlockerCommandComplete' changesReceived' projectName
Long Parameter List,SIL.FieldWorks.Common.FwUtils,FwUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwUtils.cs,GetTokenInformation,The method has 5 parameters. Parameters: hToken' tokenInfoClass' tokenInformation' tokeInfoLength' returnLength
Long Parameter List,SIL.FieldWorks.Common.FwUtils,InvalidComboInfo,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\QuotationMarks.cs,InvalidComboInfo,The method has 5 parameters. Parameters: level1' level1IsOpener' level2' level2IsOpener' qmark
Long Parameter List,SIL.FieldWorks.Common.FwUtils,TextFileDataSource,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\TextFileDataSource.cs,TextFileDataSource,The method has 6 parameters. Parameters: scrChecksDllFile' scrCheck' fileData' scrRefFormatString' parameters' categorizer
Long Parameter List,SIL.FieldWorks.Common.FwUtils,Win32,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\Win32Wrappers.cs,PeekMessage,The method has 5 parameters. Parameters: msg' hWnd' wFilterMin' wFilterMax' wFlag
Long Parameter List,SIL.FieldWorks.Common.FwUtils,Win32,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\Win32Wrappers.cs,SetScrollRange,The method has 5 parameters. Parameters: hWnd' nBar' nMinPos' nMaxPos' fRedraw
Long Parameter List,SIL.FieldWorks.Common.FwUtils,Win32,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\Win32Wrappers.cs,GetDiskFreeSpace,The method has 5 parameters. Parameters: rootPathName' sectorsPerCluster' bytesPerSector' numberOfFreeClusters' totalNumberOfClusters
Long Parameter List,SIL.FieldWorks.Common.FwUtils,IMessageBox,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MessageBoxUtils.cs,Show,The method has 5 parameters. Parameters: owner' text' caption' buttons' icon
Long Parameter List,SIL.FieldWorks.Common.FwUtils,IMessageBox,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MessageBoxUtils.cs,Show,The method has 10 parameters. Parameters: owner' text' caption' buttons' icon' defaultButton' options' helpFilePath' navigator' param
Long Parameter List,SIL.FieldWorks.Common.FwUtils,MessageBoxUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MessageBoxUtils.cs,Show,The method has 10 parameters. Parameters: owner' text' caption' buttons' icon' defaultButton' options' helpFilePath' navigator' param
Long Parameter List,SIL.FieldWorks.Common.FwUtils,MessageBoxUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MessageBoxUtils.cs,Show,The method has 9 parameters. Parameters: text' caption' buttons' icon' defaultButton' options' helpFilePath' navigator' param
Long Parameter List,SIL.FieldWorks.Common.FwUtils,MessageBoxUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MessageBoxUtils.cs,Show,The method has 5 parameters. Parameters: owner' text' caption' buttons' icon
Long Parameter List,SIL.FieldWorks.Common.FwUtils,MessageBoxAdapter,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MessageBoxUtils.cs,Show,The method has 5 parameters. Parameters: owner' text' caption' buttons' icon
Long Parameter List,SIL.FieldWorks.Common.FwUtils,MessageBoxAdapter,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MessageBoxUtils.cs,Show,The method has 10 parameters. Parameters: owner' text' caption' buttons' icon' defaultButton' options' helpFilePath' navigator' param
Long Parameter List,SIL.FieldWorks.Common.FwUtils,ThreadHelper,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\ThreadHelper.cs,ShowMessageBox,The method has 5 parameters. Parameters: owner' text' caption' buttons' icon
Long Parameter List,SIL.FieldWorks.Common.FwUtils,ImagePicture,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\ImagePicture.cs,Render,The method has 10 parameters. Parameters: hdc' x' y' cx' cy' xSrc' ySrc' cxSrc' cySrc' prcWBounds
Long Parameter List,SIL.FieldWorks.Common.FwUtils,ImagePicture,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\ImagePicture.cs,Render,The method has 10 parameters. Parameters: hdc' x' y' cx' cy' xSrc' ySrc' cxSrc' cySrc' prcWBounds
Long Identifier,SIL.FieldWorks.Common.FwUtils,FwRegistryHelper,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwRegistryHelper.cs,UpgradeUserSettingsIfNeeded,The length of the parameter fieldWorksVersionlessRegistryKey is 32.
Long Identifier,SIL.FieldWorks.Common.FwUtils,FwRegistryHelper,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwRegistryHelper.cs,,The length of the parameter OldFieldWorksRegistryKeyNameVersion7 is 36.
Long Identifier,SIL.FieldWorks.Common.FwUtils,FwRegistryHelper,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwRegistryHelper.cs,,The length of the parameter OldFieldWorksRegistryKeyNameVersion8 is 36.
Long Statement,SIL.FieldWorks.Common.FwUtils,MeasurementUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MeasurementUtils.cs,ExtractMeasurementInMillipoints,The length of the statement  "				if (((ichMsr = str.IndexOf(FwUtilsStrings.kstidIn.Trim())) > 0) || ((ichMsr = str.IndexOf(FwUtilsStrings.kstidInches.Trim())) > 0)) " is 131.
Long Statement,SIL.FieldWorks.Common.FwUtils,SimpleLogger,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\SimpleLogger.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.Common.FwUtils,GraphicsManager,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\GraphicsManager.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + " ******************"); " is 121.
Long Statement,SIL.FieldWorks.Common.FwUtils,GraphicsManager,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\GraphicsManager.cs,Init,The length of the statement  "					Logger.WriteEvent(String.Format("WARNING: failed to create m_graphics in GraphicsManager.Init({0}' {1}' {2})"' dpix' dpiy' zoom)); " is 130.
Complex Conditional,SIL.FieldWorks.Common.FwUtils,MatchedPairList,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MatchedPairs.cs,OpenComparer,The conditional expression  "(x == null && y == null) ||  				(string.IsNullOrEmpty(x.Open) && string.IsNullOrEmpty(y.Open))"  is complex.
Complex Conditional,SIL.FieldWorks.Common.FwUtils,MatchedPairList,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MatchedPairs.cs,CloseComparer,The conditional expression  "(x == null && y == null) ||  				(string.IsNullOrEmpty(x.Close) && string.IsNullOrEmpty(y.Close))"  is complex.
Complex Conditional,SIL.FieldWorks.Common.FwUtils,MatchedPairList,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MatchedPairs.cs,OpenCodeComparer,The conditional expression  "(x == null && y == null) ||  				(string.IsNullOrEmpty(x.Open) && string.IsNullOrEmpty(y.Open))"  is complex.
Complex Conditional,SIL.FieldWorks.Common.FwUtils,MatchedPairList,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MatchedPairs.cs,CloseCodeComparer,The conditional expression  "(x == null && y == null) ||  				(string.IsNullOrEmpty(x.Close) && string.IsNullOrEmpty(y.Close))"  is complex.
Complex Conditional,SIL.FieldWorks.Common.FwUtils,ShowHelp,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\ShowHelp.cs,ShowHelpTopic,The conditional expression  "helpTopicProvider == null || helpFileKey == null || helpTopicKey == null ||  				string.Empty.Equals(helpFileKey) || string.Empty.Equals(helpTopicKey)"  is complex.
Complex Conditional,SIL.FieldWorks.Common.FwUtils,UserActivityMonitor,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\UserActivityMonitor.cs,PreFilterMessage,The conditional expression  "(m.Msg >= (int) Win32.WinMsgs.WM_MOUSE_Min && m.Msg <= (int) Win32.WinMsgs.WM_MOUSE_Max)  				|| (m.Msg >= (int) Win32.WinMsgs.WM_KEY_Min && m.Msg <= (int) Win32.WinMsgs.WM_KEY_Max)"  is complex.
Empty Catch Block,SIL.FieldWorks.Common.FwUtils,FLExBridgeHelper,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FLExBridgeHelper.cs,KillTheHost,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.FwUtils,FwRegistryHelper,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwRegistryHelper.cs,UpgradeUserSettingsIfNeeded,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.FwUtils,Win32,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\Win32Wrappers.cs,GetCaptionFont,The method has an empty catch block.
Magic Number,SIL.FieldWorks.Common.FwUtils,AlphaOutline,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\AlphaOutline.cs,NumToAlphaOutline,The following statement contains a magic number: char digit = (char)('A' + ((value - 1) % 26));
Magic Number,SIL.FieldWorks.Common.FwUtils,AlphaOutline,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\AlphaOutline.cs,NumToAlphaOutline,The following statement contains a magic number: int digitCount = ((value - 1) / 26) + 1;
Magic Number,SIL.FieldWorks.Common.FwUtils,AlphaOutline,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\AlphaOutline.cs,AlphaOutlineToNum,The following statement contains a magic number: return ((int)stringValue[0] - (int)'A' + 1) + ((stringValue.Length - 1) * 26);
Magic Number,SIL.FieldWorks.Common.FwUtils,CharacterCategorizer,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\CharacterCategorizer.cs,IsSingleCharacterWord,The following statement contains a magic number: for (int i = 0; cc >= SingleCharacterWords[i] && SingleCharacterWords[i] != '\uffff'; i += 2)  			{  				if (cc <= SingleCharacterWords[i + 1])  					return true;  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,CharEnumeratorForByteArray,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\CharEnumeratorForByteArray.cs,GetEnumerator,The following statement contains a magic number: for (int i = 0; i < m_data.Length - 1; i += 2)  			{  				// ENHANCE: Need to change the byte order for Mac (or other big-endian) if we  				// support them  				yield return (char)(m_data[i] | m_data[i + 1] << 8);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,CharEnumeratorForByteArray,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\CharEnumeratorForByteArray.cs,GetEnumerator,The following statement contains a magic number: for (int i = 0; i < m_data.Length - 1; i += 2)  			{  				// ENHANCE: Need to change the byte order for Mac (or other big-endian) if we  				// support them  				yield return (char)(m_data[i] | m_data[i + 1] << 8);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,ConsoleProgress,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\ConsoleProgress.cs,ComputeGranularity,The following statement contains a magic number: m_grain = ((m_max - m_min) + 79) / 80;
Magic Number,SIL.FieldWorks.Common.FwUtils,ConsoleProgress,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\ConsoleProgress.cs,ComputeGranularity,The following statement contains a magic number: m_grain = ((m_max - m_min) + 79) / 80;
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: var exeName = new StringBuilder(255);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (exeName.Length > MaxLineLength + 9) // "Program: ".Length  			{  				bldr.Append("...");  				exeName.Remove(0' exeName.Length - MaxLineLength - 9);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (exeName.Length > MaxLineLength + 9) // "Program: ".Length  			{  				bldr.Append("...");  				exeName.Remove(0' exeName.Length - MaxLineLength - 9);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DebugProcs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DebugProcs.cs,GetMessage,The following statement contains a magic number: if (filePath.Length > MaxLineLength - 6) // "File: ".Length  			{  				// path doesn't fit in the line  				const int availLength = MaxLineLength - 6;    				// Determine where to put the ...  				var nameOnly = Path.DirectorySeparatorChar + Path.GetFileName(filePath);  				if ((availLength - availLength / 3) < (filePath.Length - nameOnly.Length) &&  					availLength / 3 > nameOnly.Length)  				{  					// path too long. Using first part of path and the filename string  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length));  					bldr.Append("...");  					bldr.AppendLine(nameOnly);  				}  				else if ((availLength - availLength/3) > (filePath.Length - nameOnly.Length))  				{  					// path is smaller. keeping full path and putting ... in the  					// middle of filename  					bldr.Append(filePath.Substring(0' availLength - 3 - nameOnly.Length/2)); // "...".Length  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length/2));  				}  				else  				{  					// both path and filename are long. Using first part of path. Using first  					// and last part of filename  					bldr.Append(filePath.Substring(0' availLength - availLength/3 - 3)); // "...".Length  					bldr.Append("...");  					bldr.Append(nameOnly.Substring(1' availLength/6 - 1));  					bldr.Append("...");  					bldr.AppendLine(nameOnly.Substring(nameOnly.Length - availLength/6 + 2));  				}  			}  			else  				bldr.AppendLine(filePath);
Magic Number,SIL.FieldWorks.Common.FwUtils,DriveUtil,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\DriveUtil.cs,GetLogicalDriveType,The following statement contains a magic number: try  			{  				// This check is here because when a ManagementObject is created by getting  				// the device ID for a diskette drive' the drive sounds like it's trying to  				// be accessed. That's annoying and time consuming. I'm going to go out on  				// a limb (a safe one' I think) and assume all drive's labeled 'A' and 'B'  				// are diskette drives.  				if (drive.ToUpper().StartsWith("A") || drive.ToUpper().StartsWith("B"))  					return DriveTypes.Removable;    				// Using the ManagmentObject (WMI) model to get drive types expects  				// drive specifications to be in the form "x:" (where x is the drive  				// letter). So if the caller passes a drive letter with the trailing  				// backslash' (which is quite likely if the caller used the  				// GetLogicalDrives() .Net method to get a list of available drives)'  				// strip it off.  				if (drive.EndsWith("\\"))  					drive = drive.Substring(0' 2);    				using (ManagementObject mo =  					new ManagementObject("win32_logicaldisk.DeviceID=\"" + drive + "\""))  				{  					// This is a funky cast' but that's what it took to force conformity.  					return (DriveTypes)((System.UInt32)(mo["DriveType"]));  				}  			}  			catch  			{  				return DriveTypes.Invalid;  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,FwDirectoryFinder,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwDirectoryFinder.cs,GetDirectory,The following statement contains a magic number: return dir.Length > 2 ? dir : dir + Path.DirectorySeparatorChar;
Magic Number,SIL.FieldWorks.Common.FwUtils,FwLinkArgs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwLinkArgs.cs,FwLinkArgs,The following statement contains a magic number: string query = HttpUtility.UrlDecode(url.Substring(23));
Magic Number,SIL.FieldWorks.Common.FwUtils,FwLinkArgs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwLinkArgs.cs,FwLinkArgs,The following statement contains a magic number: foreach (string prop in rgsProps)  			{  				string[] propPair = prop.Split('=');  				if (propPair.Length != 2)  					throw new ArgumentException(String.Format("invalid FwLinkArgs URL string: {0}"' url));  				switch (propPair[0])  				{  					case kTool:  						m_toolName = propPair[1];  						break;  					case kGuid:  						TargetGuid = new Guid(propPair[1]);  						break;  					case kTag:  						m_tag = propPair[1];  						break;  					default:  						PropertyTableEntries.Add(new Property(propPair[0]' propPair[1]));  						break;  				}  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,FwLinkArgs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwLinkArgs.cs,Decode,The following statement contains a magic number: if(value.IndexOf("bool:") > -1)  			{  				value = value.Substring(5);  				return bool.Parse(value);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,FwLinkArgs,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwLinkArgs.cs,FixSilfwUrlForCurrentProject,The following statement contains a magic number: for (int i = 0; i < properties.Length; ++i)  			{  				if (properties[i].StartsWith("database="))  				{  					idxDatabase = i;  					urlDatabase = properties[i].Substring(9);  				}  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,FwUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwUtils.cs,GetRcFromString,The following statement contains a magic number: string[] strVals = str.Split("'".ToCharArray()' 4);
Magic Number,SIL.FieldWorks.Common.FwUtils,FwUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwUtils.cs,GetRcFromString,The following statement contains a magic number: if (strVals != null)  			{  				int val;  				if (strVals.Length > 0 && Int32.TryParse(strVals[0]' out val))  					rc.X = val;  				if (strVals.Length > 1 && Int32.TryParse(strVals[1]' out val))  					rc.Y = val;  				if (strVals.Length > 2 && Int32.TryParse(strVals[2]' out val))  					rc.Width = val;  				if (strVals.Length > 3 && Int32.TryParse(strVals[3]' out val))  					rc.Height = val;  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,FwUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwUtils.cs,GetRcFromString,The following statement contains a magic number: if (strVals != null)  			{  				int val;  				if (strVals.Length > 0 && Int32.TryParse(strVals[0]' out val))  					rc.X = val;  				if (strVals.Length > 1 && Int32.TryParse(strVals[1]' out val))  					rc.Y = val;  				if (strVals.Length > 2 && Int32.TryParse(strVals[2]' out val))  					rc.Width = val;  				if (strVals.Length > 3 && Int32.TryParse(strVals[3]' out val))  					rc.Height = val;  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,FwUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwUtils.cs,GetRcFromString,The following statement contains a magic number: if (strVals != null)  			{  				int val;  				if (strVals.Length > 0 && Int32.TryParse(strVals[0]' out val))  					rc.X = val;  				if (strVals.Length > 1 && Int32.TryParse(strVals[1]' out val))  					rc.Y = val;  				if (strVals.Length > 2 && Int32.TryParse(strVals[2]' out val))  					rc.Width = val;  				if (strVals.Length > 3 && Int32.TryParse(strVals[3]' out val))  					rc.Height = val;  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,FwUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwUtils.cs,GetRcFromString,The following statement contains a magic number: if (strVals != null)  			{  				int val;  				if (strVals.Length > 0 && Int32.TryParse(strVals[0]' out val))  					rc.X = val;  				if (strVals.Length > 1 && Int32.TryParse(strVals[1]' out val))  					rc.Y = val;  				if (strVals.Length > 2 && Int32.TryParse(strVals[2]' out val))  					rc.Width = val;  				if (strVals.Length > 3 && Int32.TryParse(strVals[3]' out val))  					rc.Height = val;  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,FwUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwUtils.cs,GetSidForProcessToken,The following statement contains a magic number: int bufferLen = 256;
Magic Number,SIL.FieldWorks.Common.FwUtils,LayoutKeyUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\LayoutKeyUtils.cs,GetSuffixedPartOfNamedViewOrDuplicateNode,The following statement contains a magic number: if (keyAttributes.Length > 2 && keyAttributes[2] == NameAttr && stdKeyVals.Length > 2)  			{  				var userModifiedName = stdKeyVals[2];  				var index = userModifiedName.IndexOfAny(new[] { kcMarkLayoutCopy' kcMarkNodeCopy' kcMarkReversalIndex });  				var bugSuffixIndex = userModifiedName.IndexOf(kcMarkNodeCopyBug);  				if (index > 0 || bugSuffixIndex > 0)  				{  					// In data such as "publishStem_AsPara#selar491" the '_' does not indicate the beginning  					// of the suffix. Other valid situations are "publishCfCd%01_1.0" and the buggy situation "publishRootSubEntryType_1"  					// So only use the '_' to trim the string if the other correct suffix markers aren't found  					var adjustedIndex = index > 0 ? index : bugSuffixIndex;  					stdKeyVals[2] = userModifiedName.Substring(0' adjustedIndex);  					return userModifiedName.Substring(adjustedIndex);  				}  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,LayoutKeyUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\LayoutKeyUtils.cs,GetSuffixedPartOfNamedViewOrDuplicateNode,The following statement contains a magic number: if (keyAttributes.Length > 2 && keyAttributes[2] == NameAttr && stdKeyVals.Length > 2)  			{  				var userModifiedName = stdKeyVals[2];  				var index = userModifiedName.IndexOfAny(new[] { kcMarkLayoutCopy' kcMarkNodeCopy' kcMarkReversalIndex });  				var bugSuffixIndex = userModifiedName.IndexOf(kcMarkNodeCopyBug);  				if (index > 0 || bugSuffixIndex > 0)  				{  					// In data such as "publishStem_AsPara#selar491" the '_' does not indicate the beginning  					// of the suffix. Other valid situations are "publishCfCd%01_1.0" and the buggy situation "publishRootSubEntryType_1"  					// So only use the '_' to trim the string if the other correct suffix markers aren't found  					var adjustedIndex = index > 0 ? index : bugSuffixIndex;  					stdKeyVals[2] = userModifiedName.Substring(0' adjustedIndex);  					return userModifiedName.Substring(adjustedIndex);  				}  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,LayoutKeyUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\LayoutKeyUtils.cs,GetSuffixedPartOfNamedViewOrDuplicateNode,The following statement contains a magic number: if (keyAttributes.Length > 2 && keyAttributes[2] == NameAttr && stdKeyVals.Length > 2)  			{  				var userModifiedName = stdKeyVals[2];  				var index = userModifiedName.IndexOfAny(new[] { kcMarkLayoutCopy' kcMarkNodeCopy' kcMarkReversalIndex });  				var bugSuffixIndex = userModifiedName.IndexOf(kcMarkNodeCopyBug);  				if (index > 0 || bugSuffixIndex > 0)  				{  					// In data such as "publishStem_AsPara#selar491" the '_' does not indicate the beginning  					// of the suffix. Other valid situations are "publishCfCd%01_1.0" and the buggy situation "publishRootSubEntryType_1"  					// So only use the '_' to trim the string if the other correct suffix markers aren't found  					var adjustedIndex = index > 0 ? index : bugSuffixIndex;  					stdKeyVals[2] = userModifiedName.Substring(0' adjustedIndex);  					return userModifiedName.Substring(adjustedIndex);  				}  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,LayoutKeyUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\LayoutKeyUtils.cs,GetSuffixedPartOfNamedViewOrDuplicateNode,The following statement contains a magic number: if (keyAttributes.Length > 2 && keyAttributes[2] == NameAttr && stdKeyVals.Length > 2)  			{  				var userModifiedName = stdKeyVals[2];  				var index = userModifiedName.IndexOfAny(new[] { kcMarkLayoutCopy' kcMarkNodeCopy' kcMarkReversalIndex });  				var bugSuffixIndex = userModifiedName.IndexOf(kcMarkNodeCopyBug);  				if (index > 0 || bugSuffixIndex > 0)  				{  					// In data such as "publishStem_AsPara#selar491" the '_' does not indicate the beginning  					// of the suffix. Other valid situations are "publishCfCd%01_1.0" and the buggy situation "publishRootSubEntryType_1"  					// So only use the '_' to trim the string if the other correct suffix markers aren't found  					var adjustedIndex = index > 0 ? index : bugSuffixIndex;  					stdKeyVals[2] = userModifiedName.Substring(0' adjustedIndex);  					return userModifiedName.Substring(adjustedIndex);  				}  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,LayoutKeyUtils,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\LayoutKeyUtils.cs,GetSuffixedPartOfNamedViewOrDuplicateNode,The following statement contains a magic number: if (keyAttributes.Length > 2 && keyAttributes[2] == NameAttr && stdKeyVals.Length > 2)  			{  				var userModifiedName = stdKeyVals[2];  				var index = userModifiedName.IndexOfAny(new[] { kcMarkLayoutCopy' kcMarkNodeCopy' kcMarkReversalIndex });  				var bugSuffixIndex = userModifiedName.IndexOf(kcMarkNodeCopyBug);  				if (index > 0 || bugSuffixIndex > 0)  				{  					// In data such as "publishStem_AsPara#selar491" the '_' does not indicate the beginning  					// of the suffix. Other valid situations are "publishCfCd%01_1.0" and the buggy situation "publishRootSubEntryType_1"  					// So only use the '_' to trim the string if the other correct suffix markers aren't found  					var adjustedIndex = index > 0 ? index : bugSuffixIndex;  					stdKeyVals[2] = userModifiedName.Substring(0' adjustedIndex);  					return userModifiedName.Substring(adjustedIndex);  				}  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,MergeSort,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MergeSort.cs,InternalSort,The following statement contains a magic number: if (right > left)  			{  				int middle = (left + right) / 2;  				InternalSort(ref primary' left' middle' compare);  				InternalSort(ref primary' middle + 1' right' compare);    				int i' j' k;  				for (i = middle + 1; i > left; i--)  					secondary.SetValue(primary.GetValue(i - 1)' i - 1);  				for (j = middle; j < right; j++)  					secondary.SetValue(primary.GetValue(j + 1)' right + middle - j);  				for (k = left; k <= right; k++)  					primary.SetValue(  					(compare.Compare(secondary.GetValue(i)' secondary.GetValue(j)) < 0) ?  					secondary.GetValue(i++) :  					secondary.GetValue(j--)' k);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,MergeSort,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\MergeSort.cs,InternalSort,The following statement contains a magic number: if (right > left)  			{  				int middle = (left + right) / 2;  				InternalSort(ref primary' left' middle' compare);  				InternalSort(ref primary' middle + 1' right' compare);    				int i' j' k;  				for (i = middle + 1; i > left; i--)  					secondaryList[i - 1] = primary[i - 1];  				for (j = middle; j < right; j++)  					secondaryList[right + middle - j] = primary[j + 1];  				for (k = left; k <= right; k++)  					primary[k] = (compare.Compare(secondaryList[i]' secondaryList[j]) < 0) ?  					secondaryList[i++] : secondaryList[j--];  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,ParagraphCorrelation,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\ParagraphCorrelation.cs,AddToWordList,The following statement contains a magic number: foreach (string word in cleanPara.Split(punctuation))  			{  				// If the word is found' then increment the count  				int[] wordCounts = null;  				if (m_wordList.ContainsKey(word))  				{  					wordCounts = m_wordList[word];  					++wordCounts[paraIndex];  				}  				else  				{  					// If the word does not yet exist' then make an entry for it.  					wordCounts = new int[2];  					wordCounts[paraIndex] = 1;  					m_wordList[word] = wordCounts;  				}  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,QuotationMarksList,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\QuotationMarks.cs,NewList,The following statement contains a magic number: list.EnsureLevelExists(2);
Magic Number,SIL.FieldWorks.Common.FwUtils,WavConverter,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\WavConverter.cs,WavToMp3,The following statement contains a magic number: using (var outputStream = new MemoryStream())  			using (var inputStream = new MemoryStream(wavBytes))  			using (var fileReader = new WaveFileReader(inputStream))  			using (var fileWriter = new LameMP3FileWriter(outputStream' fileReader.WaveFormat' 128))  			{  				fileReader.CopyTo(fileWriter);  				mp3Bytes = outputStream.ToArray();  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,Win32,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\Win32Wrappers.cs,GetUnicodeRangesForFont,The following statement contains a magic number: using (Graphics g = Graphics.FromHwnd(IntPtr.Zero))  			{  				hdc = g.GetHdc();  				hFont = font.ToHfont();  				old = SelectObject(hdc' hFont);  				uint size = GetFontUnicodeRanges(hdc' IntPtr.Zero);  				glyphSet = Marshal.AllocHGlobal((int)size);  				GetFontUnicodeRanges(hdc' glyphSet);  				fontRanges = new List<FontRange>();  				int count = Marshal.ReadInt32(glyphSet' 12);    				for (int i = 0; i < count; i++)  				{  					FontRange range = new FontRange();  					range.Low = (UInt16)Marshal.ReadInt16(glyphSet' 16 + i * 4);  					range.High = (UInt16)(range.Low + Marshal.ReadInt16(glyphSet' 18 + i * 4) - 1);  					fontRanges.Add(range);  				}    				g.ReleaseHdc(hdc);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,Win32,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\Win32Wrappers.cs,GetUnicodeRangesForFont,The following statement contains a magic number: using (Graphics g = Graphics.FromHwnd(IntPtr.Zero))  			{  				hdc = g.GetHdc();  				hFont = font.ToHfont();  				old = SelectObject(hdc' hFont);  				uint size = GetFontUnicodeRanges(hdc' IntPtr.Zero);  				glyphSet = Marshal.AllocHGlobal((int)size);  				GetFontUnicodeRanges(hdc' glyphSet);  				fontRanges = new List<FontRange>();  				int count = Marshal.ReadInt32(glyphSet' 12);    				for (int i = 0; i < count; i++)  				{  					FontRange range = new FontRange();  					range.Low = (UInt16)Marshal.ReadInt16(glyphSet' 16 + i * 4);  					range.High = (UInt16)(range.Low + Marshal.ReadInt16(glyphSet' 18 + i * 4) - 1);  					fontRanges.Add(range);  				}    				g.ReleaseHdc(hdc);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,Win32,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\Win32Wrappers.cs,GetUnicodeRangesForFont,The following statement contains a magic number: using (Graphics g = Graphics.FromHwnd(IntPtr.Zero))  			{  				hdc = g.GetHdc();  				hFont = font.ToHfont();  				old = SelectObject(hdc' hFont);  				uint size = GetFontUnicodeRanges(hdc' IntPtr.Zero);  				glyphSet = Marshal.AllocHGlobal((int)size);  				GetFontUnicodeRanges(hdc' glyphSet);  				fontRanges = new List<FontRange>();  				int count = Marshal.ReadInt32(glyphSet' 12);    				for (int i = 0; i < count; i++)  				{  					FontRange range = new FontRange();  					range.Low = (UInt16)Marshal.ReadInt16(glyphSet' 16 + i * 4);  					range.High = (UInt16)(range.Low + Marshal.ReadInt16(glyphSet' 18 + i * 4) - 1);  					fontRanges.Add(range);  				}    				g.ReleaseHdc(hdc);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,Win32,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\Win32Wrappers.cs,GetUnicodeRangesForFont,The following statement contains a magic number: using (Graphics g = Graphics.FromHwnd(IntPtr.Zero))  			{  				hdc = g.GetHdc();  				hFont = font.ToHfont();  				old = SelectObject(hdc' hFont);  				uint size = GetFontUnicodeRanges(hdc' IntPtr.Zero);  				glyphSet = Marshal.AllocHGlobal((int)size);  				GetFontUnicodeRanges(hdc' glyphSet);  				fontRanges = new List<FontRange>();  				int count = Marshal.ReadInt32(glyphSet' 12);    				for (int i = 0; i < count; i++)  				{  					FontRange range = new FontRange();  					range.Low = (UInt16)Marshal.ReadInt16(glyphSet' 16 + i * 4);  					range.High = (UInt16)(range.Low + Marshal.ReadInt16(glyphSet' 18 + i * 4) - 1);  					fontRanges.Add(range);  				}    				g.ReleaseHdc(hdc);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,Win32,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\Win32Wrappers.cs,GetUnicodeRangesForFont,The following statement contains a magic number: using (Graphics g = Graphics.FromHwnd(IntPtr.Zero))  			{  				hdc = g.GetHdc();  				hFont = font.ToHfont();  				old = SelectObject(hdc' hFont);  				uint size = GetFontUnicodeRanges(hdc' IntPtr.Zero);  				glyphSet = Marshal.AllocHGlobal((int)size);  				GetFontUnicodeRanges(hdc' glyphSet);  				fontRanges = new List<FontRange>();  				int count = Marshal.ReadInt32(glyphSet' 12);    				for (int i = 0; i < count; i++)  				{  					FontRange range = new FontRange();  					range.Low = (UInt16)Marshal.ReadInt16(glyphSet' 16 + i * 4);  					range.High = (UInt16)(range.Low + Marshal.ReadInt16(glyphSet' 18 + i * 4) - 1);  					fontRanges.Add(range);  				}    				g.ReleaseHdc(hdc);  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,GraphicsManager,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\GraphicsManager.cs,Init,The following statement contains a magic number: if (m_cactInitGraphics == 0)  			{  				// We are asking for a VwGraphics but haven't been given a DC. Make one.  				// (ReleaseHdc is called in Uninit!)  				// TODO: we might want a graphics appropriate for our printer.  				m_graphics = m_parent.CreateGraphics();  				if (m_vwGraphics == null)  					m_vwGraphics = VwGraphicsWin32Class.Create();    				if (m_graphics != null)  				{  					if (dpix <= 0)  						dpix = (int) (m_graphics.DpiX*zoom);  					if (dpiy <= 0)  						dpiy = (int) (m_graphics.DpiY*zoom);  					IntPtr hdc = m_graphics.GetHdc();  					m_vwGraphics.Initialize(hdc);  				}  				else  				{  					// we think m_graphics should never be null. But it has happened (see e.g. LTB-708).  					// So provide a desperate fall-back.  					if (dpix <= 0)  						dpix = 96;  					if (dpiy <= 0)  						dpiy = 96;  					Logger.WriteEvent(String.Format("WARNING: failed to create m_graphics in GraphicsManager.Init({0}' {1}' {2})"' dpix' dpiy' zoom));  				}  				m_vwGraphics.XUnitsPerInch = dpix;  				m_vwGraphics.YUnitsPerInch = dpiy;  			}
Magic Number,SIL.FieldWorks.Common.FwUtils,GraphicsManager,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\GraphicsManager.cs,Init,The following statement contains a magic number: if (m_cactInitGraphics == 0)  			{  				// We are asking for a VwGraphics but haven't been given a DC. Make one.  				// (ReleaseHdc is called in Uninit!)  				// TODO: we might want a graphics appropriate for our printer.  				m_graphics = m_parent.CreateGraphics();  				if (m_vwGraphics == null)  					m_vwGraphics = VwGraphicsWin32Class.Create();    				if (m_graphics != null)  				{  					if (dpix <= 0)  						dpix = (int) (m_graphics.DpiX*zoom);  					if (dpiy <= 0)  						dpiy = (int) (m_graphics.DpiY*zoom);  					IntPtr hdc = m_graphics.GetHdc();  					m_vwGraphics.Initialize(hdc);  				}  				else  				{  					// we think m_graphics should never be null. But it has happened (see e.g. LTB-708).  					// So provide a desperate fall-back.  					if (dpix <= 0)  						dpix = 96;  					if (dpiy <= 0)  						dpiy = 96;  					Logger.WriteEvent(String.Format("WARNING: failed to create m_graphics in GraphicsManager.Init({0}' {1}' {2})"' dpix' dpiy' zoom));  				}  				m_vwGraphics.XUnitsPerInch = dpix;  				m_vwGraphics.YUnitsPerInch = dpiy;  			}
Missing Default,SIL.FieldWorks.Common.FwUtils,FwApplicationSettingsBase,C:\repos\sillsdev_FieldWorks\Src\Common\FwUtils\FwApplicationSettingsBase.cs,MigrateIfNecessary,The following switch statement is missing a default case: switch ((string) settingElem.Attribute("name"))  						{  							case "UpdateGlobalWSStore":  								UpdateGlobalWSStore = (bool) valueElem;  								break;  							case "WebonaryUser":  								WebonaryUser = (string) valueElem;  								break;  							case "WebonaryPass":  								WebonaryPass = (string) valueElem;  								break;  							case "Reporting":  								XmlReader reader = valueElem.CreateReader();  								reader.MoveToContent();  								string xml = reader.ReadInnerXml();  								Reporting = Xml.XmlSerializationHelper.DeserializeFromString<ReportingSettings>(xml);  								break;  							case "LocalKeyboards":  								LocalKeyboards = (string) valueElem;  								break;  						}
