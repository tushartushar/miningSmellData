Implementation smell,Namespace,Class,File,Method,Description
Long Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The method has 721 lines of code.
Long Method,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,RemoveItemsRequested,The method has 124 lines of code.
Long Method,SIL.FieldWorks.IText,ComplexConcMorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcMorphDlg.cs,InitializeComponent,The method has 289 lines of code.
Long Method,SIL.FieldWorks.IText,ComplexConcWordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordDlg.cs,InitializeComponent,The method has 251 lines of code.
Long Method,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,FindMatchingItems,The method has 104 lines of code.
Long Method,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,InitializeComponent,The method has 210 lines of code.
Long Method,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,Display,The method has 142 lines of code.
Long Method,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,DisplayVariant,The method has 126 lines of code.
Long Method,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,InitializeComponent,The method has 156 lines of code.
Long Method,SIL.FieldWorks.IText,EditMorphBreaksDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\EditMorphBreaksDlg.cs,InitializeComponent,The method has 241 lines of code.
Long Method,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The method has 181 lines of code.
Long Method,SIL.FieldWorks.IText,InterlinearExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,AddObjVecItems,The method has 106 lines of code.
Long Method,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,OnNextButton,The method has 140 lines of code.
Long Method,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,InitializeComponent,The method has 287 lines of code.
Long Method,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,ShowRecord,The method has 103 lines of code.
Long Method,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,InitializeComponent,The method has 269 lines of code.
Long Method,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,Display,The method has 252 lines of code.
Long Method,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,AddFreeformComment,The method has 143 lines of code.
Long Method,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,DisplayMorphBundle,The method has 133 lines of code.
Long Method,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,InitializeComponent,The method has 149 lines of code.
Long Method,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The method has 203 lines of code.
Long Method,SIL.FieldWorks.IText,ComplexConcParagraphData,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcParagraphData.cs,GenerateShape,The method has 164 lines of code.
Long Method,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,LoadRealDataIntoSec1,The method has 280 lines of code.
Long Method,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetLineOfCurrentSelectionAndNextTabStop,The method has 175 lines of code.
Long Method,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectOnOrBeyondLine,The method has 107 lines of code.
Long Method,SIL.FieldWorks.IText,IhMissingEntry,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,RunAddNewAllomorphDlg,The method has 146 lines of code.
Long Method,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,FinishItOff,The method has 442 lines of code.
Long Method,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,HandleMorpheme,The method has 122 lines of code.
Long Method,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,DoBasicFinding,The method has 182 lines of code.
Long Method,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,Display,The method has 117 lines of code.
Long Method,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,RebuildStatisticsTable,The method has 109 lines of code.
Long Method,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,FillInBookChildren,The method has 108 lines of code.
Long Method,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The method has 157 lines of code.
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,PopulateTextFromBIRDDoc,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,MergeTextWithBIRDDoc,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,SetVernacularLanguagesByUsage,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,CreateWordAnalysisStack,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,UpgradeToWordGloss,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,SetTextMetaAndMergeMedia,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,Cyclomatic complexity of the method is 17
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ImportInterlinear,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,AdjustPunctStringForCharacter,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert7,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,MakeAnalysisStringRep,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.IText,ComplexConcPatternModel,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternModel.cs,Search,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,RemoveItemsRequested,Cyclomatic complexity of the method is 24
Complex Method,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,GetHvoOfMsaPartOfSpeech,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,GetNumLines,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,InitCurrentList,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,ApproveAndMoveNextRecursive,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,InfoPane,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InfoPane.cs,InitializeInfoView,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,InterlinearExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,AddObj,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,MoveFocusBoxIntoPlace,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,OnKeyDown,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleArrowKeys,Cyclomatic complexity of the method is 14
Complex Method,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,OnAddWordGlossesToFreeTrans,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SetCpropPreviousForInsert,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleSelectionChange,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleClickSelection,Cyclomatic complexity of the method is 15
Complex Method,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,AddNote,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,ApproveAllSuggestedAnalyses,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,OnNextButton,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,CalculateTextCount,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,InterlinearTextsRecordClerk,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearTextsRecordClerk.cs,AddNewText,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,InterlinLineChoices,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinLineChoices.cs,WhereToMoveUpTo,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,GetAnalysisFromSelection,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,MakeContextMenu,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,SaveBookmarkFromRootBox,Cyclomatic complexity of the method is 15
Complex Method,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,ShowRecord,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,InterlinTaggingVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinTaggingChild.cs,CacheTagString,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,AddFreeformComment,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,DisplayLexGlossWithInflType,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,ComplexConcParagraphData,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcParagraphData.cs,GenerateShape,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.IText,ComplexConcParagraphData,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcParagraphData.cs,GetHvoOfMsaPartOfSpeech,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,LoadRealDataIntoSec1,Cyclomatic complexity of the method is 28
Complex Method,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,EstablishDefaultSense,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,ShowComboForSelection,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetLineOfCurrentSelectionAndNextTabStop,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,HandleLeftKey,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectOnOrBeyondLine,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,Dispose,Cyclomatic complexity of the method is 12
Complex Method,SIL.FieldWorks.IText,InterlinComboHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SyncMonomorphemicGlossAndPos,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.IText,IhMorphForm,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,AddAnalysesOf,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.IText,IhMissingEntry,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,BuildMorphItemsFromEntry,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,MorphItem,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,Compare,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,FinishItOff,Cyclomatic complexity of the method is 30
Complex Method,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,FindMatchingAnalysis,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,CheckAnalysis,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,HandleMorpheme,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,DoBasicFinding,Cyclomatic complexity of the method is 25
Complex Method,SIL.FieldWorks.IText,SandboxEditMonitor,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,BuildCurrentMorphsString,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,RebuildStatisticsTable,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,LoadScriptureTexts,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,LoadTextsFromGenres,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,FillInBookChildren,Cyclomatic complexity of the method is 15
Complex Method,SIL.FieldWorks.IText,WordBreakGuesser,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WordBreakGuesser.cs,Setup,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.IText,WordBreakGuesser,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WordBreakGuesser.cs,Guess,Cyclomatic complexity of the method is 11
Long Parameter List,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,UpdatePhraseTextForWordItems,The method has 5 parameters. Parameters: wsFactory' phraseText' word' lastWasWord' space
Long Parameter List,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,AddSegmentItemData,The method has 6 parameters. Parameters: cache' wsFactory' phrase' newSegment' textInFile' phraseText
Long Parameter List,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,SetTextMetaAndMergeMedia,The method has 5 parameters. Parameters: cache' interlinText' wsFactory' newText' merging
Long Parameter List,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,PopulateTextIfPossible,The method has 5 parameters. Parameters: options' newText' interlineartext' progress' version
Long Parameter List,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,GetSpaceAdjustedPunctString,The method has 5 parameters. Parameters: wsFactory' item' wordString' space' followsWord
Long Parameter List,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,AdjustPunctStringForCharacter,The method has 7 parameters. Parameters: wsFactory' item' wordString' punctChar' index' space' followsWord
Long Parameter List,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessSearchBuffer,The method has 5 parameters. Parameters: searchBuffer' size' bufferIt' buffer' bw
Long Parameter List,SIL.FieldWorks.IText,POSComboController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,POSComboController,The method has 8 parameters. Parameters: treeCombo' cache' list' ws' useAbbr' mediator' propertyTable' parent
Long Parameter List,SIL.FieldWorks.IText,EditMorphBreaksDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\EditMorphBreaksDlg.cs,Initialize,The method has 5 parameters. Parameters: tssWord' sMorphs' wsf' cache' stylesheet
Long Parameter List,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,OnNextBundle,The method has 5 parameters. Parameters: undoRedoText' fSaveGuess' skipFullyAnalyzedWords' fMakeDefaultSelection' fForward
Long Parameter List,SIL.FieldWorks.IText,FocusBoxControllerForDisplay,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,FocusBoxControllerForDisplay,The method has 5 parameters. Parameters: mediator' propertyTable' stylesheet' lineChoices' rightToLeft
Long Parameter List,SIL.FieldWorks.IText,StTextDataTree,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InfoPane.cs,ShowObject,The method has 5 parameters. Parameters: root' layoutName' layoutChoiceField' descendant' suppressFocusChange
Long Parameter List,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,Save,The method has 5 parameters. Parameters: textIndex' paragraphIndex' beginCharOffset' endCharOffset' fPersistNow
Long Parameter List,SIL.FieldWorks.IText,InterlinearExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,Create,The method has 6 parameters. Parameters: mode' cache' writer' objRoot' lineChoices' vc
Long Parameter List,SIL.FieldWorks.IText,InterlinearExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,InterlinearExporter,The method has 5 parameters. Parameters: cache' writer' objRoot' lineChoices' vc
Long Parameter List,SIL.FieldWorks.IText,InterlinearExporterForElan,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,InterlinearExporterForElan,The method has 5 parameters. Parameters: cache' writer' objRoot' lineChoices' vc
Long Parameter List,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,PropChanged,The method has 5 parameters. Parameters: hvo' tag' ivMin' cvIns' cvDel
Long Parameter List,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,DetectUpMove,The method has 8 parameters. Parameters: e' lines' lineNum' curSeg' curNoteIndex' where' isRightToLeft' isUpNewSeg
Long Parameter List,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,DetectDownMove,The method has 7 parameters. Parameters: e' lines' lineNum' curSeg' curNoteIndex' isRightToLeft' where
Long Parameter List,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,GetLineInfo,The method has 11 parameters. Parameters: curSeg' curNote' tag' ichAnchor' ichEnd' wid' id' lineNum' where' isRightToLeft' hasPrompt
Long Parameter List,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,GetCurrentTextObjects,The method has 8 parameters. Parameters: clev' rgvsli' tag' curParaIndex' curSegIndex' curNoteIndex' curSeg' curNote
Long Parameter List,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,GetCurrentSelection,The method has 6 parameters. Parameters: clev' rgvsli' tag' ichAnchor' ichEnd' ws
Long Parameter List,SIL.FieldWorks.IText,InterlinDocForAnalysisVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,UpdateProp,The method has 5 parameters. Parameters: vwsel' hvo' tag' frag' tssVal
Long Parameter List,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,GetFile,The method has 6 parameters. Parameters: currentFile' pathForInitialDirectory' types' checkFileExists' title' isValidFile
Long Parameter List,SIL.FieldWorks.IText,InterlinLineChoices,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinLineChoices.cs,Restore,The method has 5 parameters. Parameters: data' wsf' proj' defVern' defAnalysis
Long Parameter List,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,PropChanged,The method has 5 parameters. Parameters: hvo' tag' ivMin' cvIns' cvDel
Long Parameter List,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,TryGetLexGlossWithInflTypeTss,The method has 7 parameters. Parameters: possibleVariant' sense' spec' lineChoices' vernWsContext' inflType' result
Long Parameter List,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,DisplayLexGlossWithInflType,The method has 5 parameters. Parameters: vwenv' possibleVariant' sense' spec' inflType
Long Parameter List,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,LoadDataFor,The method has 7 parameters. Parameters: vwenv' rghvo' chvo' hvoParent' tag' frag' ihvoMin
Long Parameter List,SIL.FieldWorks.IText,PossibilityComboController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\PossibilityComboController.cs,PossibilityComboController,The method has 8 parameters. Parameters: treeCombo' cache' list' ws' useAbbr' mediator' propertyTable' parent
Long Parameter List,SIL.FieldWorks.IText,RawTextPane,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\RawTextPane.cs,MakeTextSelectionAndScrollToView,The method has 5 parameters. Parameters: ichMin' ichLim' ws' ipara' ihvoEnd
Long Parameter List,SIL.FieldWorks.IText,RawTextPane,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\RawTextPane.cs,GetSelectedWordPos,The method has 6 parameters. Parameters: sel' hvo' tag' ws' ichMin' ichLim
Long Parameter List,SIL.FieldWorks.IText,RawTextVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\RawTextPane.cs,UpdateProp,The method has 5 parameters. Parameters: vwsel' hvo' tag' frag' tssVal
Long Parameter List,SIL.FieldWorks.IText,Sandbox,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\Sandbox.cs,Sandbox,The method has 7 parameters. Parameters: cache' mediator' propertyTable' ss' choices' selected' focusBox
Long Parameter List,SIL.FieldWorks.IText,Sandbox,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\Sandbox.cs,Sandbox,The method has 5 parameters. Parameters: cache' mediator' propertyTable' ss' choices
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SandboxBase,The method has 5 parameters. Parameters: cache' mediator' propertyTable' ss' choices
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SandboxBase,The method has 6 parameters. Parameters: cache' mediator' propertyTable' ss' choices' hvoAnalysis
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CreateSecondaryAndCopyStrings,The method has 6 parameters. Parameters: flidChoices' hvoMain' flidMain' hvoSbWord' sdaMain' cda
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CopyStringsToSecondary,The method has 7 parameters. Parameters: writingSystems' sdaMain' hvoMain' flidMain' cda' hvoSec' flidSec
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CopyStringsToSecondary,The method has 7 parameters. Parameters: flidChoices' sdaMain' hvoMain' flidMain' cda' hvoSec' flidSec
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CacheStringAltForAllCurrentWs,The method has 7 parameters. Parameters: currentWsList' cda' hvoSec' flidSec' sdaMain' hvoMain' flidMain
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CacheStringAltForAllCurrentWs,The method has 5 parameters. Parameters: currentWsList' cda' hvoSec' flidSec' createStringAlt
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,LoadSecDataForEntry,The method has 8 parameters. Parameters: entryReal' senseReal' hvoSbWord' cda' wsVern' hvoMbSec' fGuessing' sdaMain
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CacheLexGlossWithInflTypeForAllCurrentWs,The method has 5 parameters. Parameters: possibleVariant' hvoLexSenseSec' wsVern' cda' inflType
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,MoveSelection,The method has 5 parameters. Parameters: rgvsli' tag' cpropPrevious' ichAnchor' ichEnd
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,FindNearestSelectionType,The method has 5 parameters. Parameters: selOrig' selType' xMin' xMaxCountOfPixels' dxPixelIncrement
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetLineOfCurrentSelectionAndNextTabStop,The method has 6 parameters. Parameters: fShift' currentLineIndex' startLineIndex' increment' fSkipIcon' iNextMorphIndex
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,NextPositionForLexEntryText,The method has 6 parameters. Parameters: increment' fOnNextLine' fIsPictureSel' currentLineIndex' startLineIndex' iNextMorphIndex
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectOnOrBeyondLine,The method has 5 parameters. Parameters: startLine' increment' iMorph' fSkipIconToTextField' fWrapToNextLine
Long Parameter List,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectOnOrBeyondLine,The method has 6 parameters. Parameters: startLine' limitLine' increment' iMorph' fSkipIconToTextField' fWrapToNextLine
Long Parameter List,SIL.FieldWorks.IText,InterlinComboHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,MakeCombo,The method has 6 parameters. Parameters: helpTopicProvider' tagComboIcon' sandbox' hvoMorph' rgvsli' hvoSelObject
Long Parameter List,SIL.FieldWorks.IText,InterlinComboHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,MakeNewSelection,The method has 5 parameters. Parameters: isliCopy' tag' ihvo' tagTextProp' ws
Long Parameter List,SIL.FieldWorks.IText,IhMissingEntry,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,AddMorphItemToList,The method has 7 parameters. Parameters: mf' ler' tssSense' sense' wsAnalysis' tssName' hvoLexEntry
Long Parameter List,SIL.FieldWorks.IText,IhMissingEntry,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetMorphItem,The method has 7 parameters. Parameters: mf' tssName' sense' tssSense' ler' hvoLexEntry' inflType
Long Parameter List,SIL.FieldWorks.IText,MorphItem,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,MorphItem,The method has 6 parameters. Parameters: hvoMorph' tssName' hvoSense' nameSense' hvoMsa' nameMsa
Long Parameter List,SIL.FieldWorks.IText,MorphItem,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,MorphItem,The method has 7 parameters. Parameters: hvoMorph' hvoMainEntryOfVariant' tssName' hvoSense' nameSense' hvoMsa' nameMsa
Long Parameter List,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,GetRealAnalysisMethod,The method has 10 parameters. Parameters: helpTopicProvider' owner' caches' hvoSbWord' oldAnalysis' wa' gloss' choices' tssForm' fWantOnlyWfiAnalysis
Long Parameter List,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,UpdateMlaIfDifferent,The method has 5 parameters. Parameters: hvoSrc' flidSrc' wsId' hvoDst' flidDest
Long Parameter List,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,IsMlSame,The method has 5 parameters. Parameters: hvoSrc' flidSrc' wsId' hvoDst' flidDest
Long Parameter List,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,IsMlSame,The method has 7 parameters. Parameters: hvoSrc' flidSrc' wsId' hvoDst' flidDest' tss' tssOld
Long Parameter List,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,MorphemeBreaker,The method has 5 parameters. Parameters: caches' input' hvoSbWord' wsVern' sandbox
Long Parameter List,SIL.FieldWorks.IText,SandboxEditMonitor,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,PropChanged,The method has 5 parameters. Parameters: hvo' tag' ivMin' cvIns' cvDel
Long Parameter List,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,GetBestAlt,The method has 5 parameters. Parameters: hvo' tag' wsPreferred' wsDefault' wsList
Long Parameter List,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,DisplayMorphForm,The method has 5 parameters. Parameters: vwenv' hvo' frag' ws' choiceIndex
Long Parameter List,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,AddOptionalNamedObj,The method has 8 parameters. Parameters: vwenv' hvo' tag' dummyTag' dummyFrag' tagIcon' ws' choiceIndex
Long Identifier,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,UpgradeToWordGloss,The length of the parameter fHasMultipleGlossesInSameLanguage is 33.
Long Identifier,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,,The length of the parameter m_fEnableScrollControlIntoView is 30.
Long Identifier,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,OnDisplayITexts_AddWordsToLexicon,The length of the parameter fCanDisplayAddWordsToLexiconPanelBarButton is 42.
Long Identifier,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,OnDisplayShowHiddenFields_interlinearEdit,The length of the parameter fCanDisplayAddWordsToLexiconPanelBarButton is 42.
Long Identifier,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,,The length of the parameter kfragSingleInterlinearAnalysisWithLabels is 40.
Long Identifier,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,,The length of the parameter kfragSingleInterlinearAnalysisWithLabelsLeftAlign is 49.
Long Identifier,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,EstablishDefaultEntry,The length of the parameter otherWritingSystemsForMorphForm is 31.
Long Identifier,SIL.FieldWorks.IText,SandboxEditMonitor,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,,The length of the parameter m_propChangesOccurredWhileNotMonitoring is 39.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,PopulateTextFromBIRDDoc,The length of the statement  "							//The segment is identified by a Guid' but apparently we don't have it in our current document' so make one with the guid " is 121.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,PopulateTextFromBIRDDoc,The length of the statement  "					ISegment newSegment = oldSegment as ISegment ?? cache.ServiceLocator.GetInstance<ISegmentFactory>().Create(newTextPara' offset); " is 128.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,MergeTextWithBIRDDoc,The length of the statement  "							else if(oldSegment == null) //The segment is identified by a Guid' but apparently we don't have it in our current document' so make one " is 135.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,MergeTextWithBIRDDoc,The length of the statement  "								oldSegment = cache.ServiceLocator.GetInstance<ISegmentFactory>().Create(newTextPara' offset' cache' new Guid(phrase.guid)); " is 123.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,MergeTextWithBIRDDoc,The length of the statement  "					ISegment newSegment = oldSegment as ISegment ?? cache.ServiceLocator.GetInstance<ISegmentFactory>().Create(newTextPara' offset); " is 128.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,UpdateParagraphTextForPhrase,The length of the statement  "				if (oldText.Length > 0 && !TsStringUtils.IsEndOfSentenceChar(oldText[oldText.Length - 1]' Icu.UCharCategory.U_OTHER_PUNCTUATION)) " is 129.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,UpdatePhraseTextForWordItems,The length of the statement  "						return; // only handle the baseline "txt" or "punct" once per "word" bundle' especially don't want extra writing system content in the baseline. " is 144.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,CheckAndAddLanguagesInternal,The length of the statement  "					// Saymore file? something else that doesn't know to do this? We will confuse the user if we try to treat all as analysis. " is 122.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,CheckAndAddLanguagesInternal,The length of the statement  "							IAsyncResult asyncResult = progress.SynchronizeInvoke.BeginInvoke(new ShowDialogAboveProgressbarDelegate(ShowDialogAboveProgressbar)' " is 133.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,CheckAndAddLanguagesInternal,The length of the statement  "							IAsyncResult asyncResult = progress.SynchronizeInvoke.BeginInvoke(new ShowDialogAboveProgressbarDelegate(ShowDialogAboveProgressbar)' " is 133.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ImportInterlinear,The length of the statement  "			return ImportInterlinear(new ImportInterlinearOptions { Progress = progress' BirdData = birdData' AllottedProgress = allottedProgress }' " is 136.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ShowPossibleMergeDialog,The length of the statement  "			IAsyncResult asyncResult = progress.SynchronizeInvoke.BeginInvoke(new ShowDialogAboveProgressbarDelegate(ShowDialogAboveProgressbar)' " is 133.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,GetSpaceAdjustedPunctString,The length of the statement  "				ITsString tempValue = AdjustPunctStringForCharacter(wsFactory' item' wordString' item.Value[index]' index' space' followsWord); " is 127.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,AdjustPunctStringForCharacter,The length of the statement  "					if(wordString.Text.LastIndexOfAny(new[] {'''''.''';''':'''?'''!''quote}) == wordString.Length - 1) //treat as ending characters " is 127.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,AdjustPunctStringForCharacter,The length of the statement  "						spaceAfter = punctChar != '"' || wordString.Length > 1; //quote characters are extra special' if we find them on their own " is 122.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The length of the statement  "					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error..."); " is 120.
Long Statement,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + " ******************"); " is 140.
Long Statement,SIL.FieldWorks.IText,ChooseTextWritingSystemDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseTextWritingSystemDlg.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 141.
Long Statement,SIL.FieldWorks.IText,ChooseTextWritingSystemDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseTextWritingSystemDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ChooseTextWritingSystemDlg)); " is 146.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternModel,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternModel.cs,Compile,The length of the statement  "				m_featSys.Add(new StringFeature(string.Format("entry-{0}"' ws.Handle)) {Description = string.Format("Entry-{0}"' ws.Abbreviation)}); " is 132.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternModel,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternModel.cs,Compile,The length of the statement  "				m_featSys.Add(new StringFeature(string.Format("form-{0}"' ws.Handle)) {Description = string.Format("Form-{0}"' ws.Abbreviation)}); " is 130.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternModel,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternModel.cs,Compile,The length of the statement  "				m_featSys.Add(new StringFeature(string.Format("gloss-{0}"' ws.Handle)) {Description = string.Format("Gloss-{0}"' ws.Abbreviation)}); " is 132.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternModel,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternModel.cs,Compile,The length of the statement  "				.Select(pos => new FeatureSymbol(pos.Hvo.ToString(CultureInfo.InvariantCulture)' pos.Abbreviation.BestAnalysisAlternative.Text))) " is 129.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternModel,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternModel.cs,Compile,The length of the statement  "				.SelectMany(poss => poss.SubPossibilitiesOS' (category' tag) => new FeatureSymbol(tag.Hvo.ToString(CultureInfo.InvariantCulture)' tag.Abbreviation.BestAnalysisAlternative.Text))) " is 178.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternModel,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternModel.cs,Compile,The length of the statement  "					m_featSys.Add(new ComplexFeature(complexFeat.Hvo.ToString(CultureInfo.InvariantCulture)) {Description = complexFeat.Abbreviation.BestAnalysisAlternative.Text' DefaultValue = FeatureStruct.New().Value}); " is 202.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternModel,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternModel.cs,Compile,The length of the statement  "					m_featSys.Add(new SymbolicFeature(closedFeat.Hvo.ToString(CultureInfo.InvariantCulture)' closedFeat.ValuesOC.Select(sym => " is 122.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternModel,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternModel.cs,Compile,The length of the statement  "			m_matcher = new Matcher<ComplexConcParagraphData' ShapeNode>(m_spanFactory' pattern' new MatcherSettings<ShapeNode> {UseDefaults = true}); " is 138.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternModel,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternModel.cs,Search,The length of the statement  "					if (lastFragment != null && lastFragment.GetMyBeginOffsetInPara() == startAnalysis.Item2 && lastFragment.GetMyEndOffsetInPara() == endAnalysis.Item3) " is 149.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordBdryNode,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordBdryNode.cs,GeneratePattern,The length of the statement  "			return new Constraint<ComplexConcParagraphData' ShapeNode>(FeatureStruct.New(featSys).Symbol("bdry").Symbol("wordBdry").Value); " is 127.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordNode,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordNode.cs,GeneratePattern,The length of the statement  "				IEnumerable<FeatureSymbol> symbols = Category.ReallyReallyAllPossibilities.Concat(Category).Select(pos => catFeat.PossibleSymbols[pos.Hvo.ToString(CultureInfo.InvariantCulture)]); " is 179.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordNode,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordNode.cs,GeneratePattern,The length of the statement  "			group.Children.Add(new Quantifier<ComplexConcParagraphData' ShapeNode>(0' 1' new Constraint<ComplexConcParagraphData' ShapeNode>(wordBdryFS)) {IsGreedy = false}); " is 162.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordNode,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordNode.cs,GeneratePattern,The length of the statement  "			group.Children.Add(new Quantifier<ComplexConcParagraphData' ShapeNode>(0' 1' new Constraint<ComplexConcParagraphData' ShapeNode>(wordBdryFS)) {IsGreedy = false}); " is 162.
Long Statement,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,Init,The length of the statement  "			m_view.Init(mediator' m_propertyTable' m_patternModel.Root.Hvo' this' new ComplexConcPatternVc(m_cache' propertyTable)' ComplexConcPatternVc.kfragPattern' " is 154.
Long Statement,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,CanAddConstraint,The length of the statement  "			return (start == -1 || !(parent.Children[start] is ComplexConcWordBdryNode)) && (end == parent.Children.Count || !(parent.Children[end] is ComplexConcWordBdryNode)); " is 165.
Long Statement,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,CanAddOr,The length of the statement  "				&& (index == parent.Children.Count || (!(parent.Children[index] is ComplexConcOrNode) && !(parent.Children[index] is ComplexConcWordBdryNode))); " is 144.
Long Statement,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,ParseUnparsedParagraphs,The length of the statement  "			IStTxtPara[] needsParsing = concDecorator.InterestingTexts.SelectMany(txt => txt.ParagraphsOS).Cast<IStTxtPara>().Where(para => !para.ParseIsCurrent).ToArray(); " is 160.
Long Statement,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,RemoveItemsRequested,The length of the statement  "							|| (!(parent.Children[i - 1] is ComplexConcMorphNode) || (i + 1 < parent.Children.Count && !(parent.Children[i + 1] is ComplexConcMorphNode)))) " is 143.
Long Statement,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,OnDisplayPatternNodeSetCriteria,The length of the statement  "			bool enable = sel.IsRange && nodes.Length == 1 && (nodes[0] is ComplexConcWordNode || nodes[0] is ComplexConcMorphNode || nodes[0] is ComplexConcTagNode); " is 154.
Long Statement,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ComplexConcControl)); " is 138.
Long Statement,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,InitializeComponent,The length of the statement  "			this.m_insertControl.Insert += new System.EventHandler<SIL.FieldWorks.LexText.Controls.InsertEventArgs>(this.m_insertControl_Insert); " is 133.
Long Statement,SIL.FieldWorks.IText,ComplexConcMorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcMorphDlg.cs,SetDlgInfo,The length of the statement  "			m_inflModel = new InflFeatureTreeModel(m_cache.LangProject.MsFeatureSystemOA' m_node.InflFeatures' m_imageList.Images[0]' m_imageList.Images[1]); " is 145.
Long Statement,SIL.FieldWorks.IText,ComplexConcMorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcMorphDlg.cs,m_valueComboBox_CreatingEditor,The length of the statement  "			comboBox.Items.AddRange(closedFeatNode.Feature.ValuesOC.OrderBy(v => v.Abbreviation.BestAnalysisAlternative.Text).Select(v => new SymbolicValue(v)).Cast<object>().ToArray()); " is 174.
Long Statement,SIL.FieldWorks.IText,ComplexConcMorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcMorphDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ComplexConcMorphDlg)); " is 139.
Long Statement,SIL.FieldWorks.IText,ComplexConcMorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcMorphDlg.cs,InitializeComponent,The length of the statement  "			this.m_valueComboBox.CreatingEditor += new System.EventHandler<Aga.Controls.Tree.NodeControls.EditEventArgs>(this.m_valueComboBox_CreatingEditor); " is 146.
Long Statement,SIL.FieldWorks.IText,ComplexConcMorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcMorphDlg.cs,InitializeComponent,The length of the statement  "			this.m_valueComboBox.IsEditEnabledValueNeeded += new System.EventHandler<Aga.Controls.Tree.NodeControls.NodeControlValueEventArgs>(this.m_valueComboBox_IsEditEnabledValueNeeded); " is 178.
Long Statement,SIL.FieldWorks.IText,ComplexConcMorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcMorphDlg.cs,InitializeComponent,The length of the statement  "			this.m_inflNotCheckBox.IsVisibleValueNeeded += new System.EventHandler<Aga.Controls.Tree.NodeControls.NodeControlValueEventArgs>(this.m_inflNotCheckBox_IsVisibleValueNeeded); " is 174.
Long Statement,SIL.FieldWorks.IText,ComplexConcMorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcMorphDlg.cs,InitializeComponent,The length of the statement  "			this.m_imageList.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("m_imageList.ImageStream"))); " is 122.
Long Statement,SIL.FieldWorks.IText,ComplexConcMorphNode,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcMorphNode.cs,GeneratePattern,The length of the statement  "				IEnumerable<FeatureSymbol> symbols = Category.ReallyReallyAllPossibilities.Concat(Category).Select(pos => catFeat.PossibleSymbols[pos.Hvo.ToString(CultureInfo.InvariantCulture)]); " is 179.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternNode,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternNode.cs,AddQuantifier,The length of the statement  "			return Minimum != 1 || Maximum != 1 ? new Quantifier<ComplexConcParagraphData' ShapeNode>(Minimum' Maximum' node) : node; " is 121.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternNode,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternNode.cs,AddStringValue,The length of the statement  "				var feat = featSys.GetFeature<StringFeature>(string.Format("{0}-{1}"' id' tss.get_WritingSystemAt(0).ToString(CultureInfo.InvariantCulture))); " is 142.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternNode,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternNode.cs,GetFeatureStruct,The length of the statement  "					fs.AddValue(featSys.GetFeature(kvp.Key.Hvo.ToString(CultureInfo.InvariantCulture))' GetFeatureStruct(featSys' childValues)); " is 124.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternNode,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternNode.cs,GetFeatureStruct,The length of the statement  "					fs.AddValue(symFeat' value.Negate ? new SymbolicFeatureValue(symFeat.PossibleSymbols.Except(symbol.ToEnumerable())) : new SymbolicFeatureValue(symbol)); " is 152.
Long Statement,SIL.FieldWorks.IText,ComplexConcTagDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcTagDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ComplexConcTagDlg)); " is 137.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordDlg.cs,SetDlgInfo,The length of the statement  "			m_inflModel = new InflFeatureTreeModel(m_cache.LangProject.MsFeatureSystemOA' m_node.InflFeatures' m_imageList.Images[0]' m_imageList.Images[1]); " is 145.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordDlg.cs,m_valueComboBox_CreatingEditor,The length of the statement  "			comboBox.Items.AddRange(closedFeatNode.Feature.ValuesOC.OrderBy(v => v.Abbreviation.BestAnalysisAlternative.Text).Select(v => new SymbolicValue(v)).Cast<object>().ToArray()); " is 174.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ComplexConcWordDlg)); " is 138.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordDlg.cs,InitializeComponent,The length of the statement  "			this.m_valueComboBox.CreatingEditor += new System.EventHandler<Aga.Controls.Tree.NodeControls.EditEventArgs>(this.m_valueComboBox_CreatingEditor); " is 146.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordDlg.cs,InitializeComponent,The length of the statement  "			this.m_valueComboBox.IsEditEnabledValueNeeded += new System.EventHandler<Aga.Controls.Tree.NodeControls.NodeControlValueEventArgs>(this.m_valueComboBox_IsEditEnabledValueNeeded); " is 178.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordDlg.cs,InitializeComponent,The length of the statement  "			this.m_inflNotCheckBox.IsVisibleValueNeeded += new System.EventHandler<Aga.Controls.Tree.NodeControls.NodeControlValueEventArgs>(this.m_inflNotCheckBox_IsVisibleValueNeeded); " is 174.
Long Statement,SIL.FieldWorks.IText,ComplexConcWordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordDlg.cs,InitializeComponent,The length of the statement  "			this.m_imageList.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("m_imageList.ImageStream"))); " is 122.
Long Statement,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,FindMatchingItems,The length of the statement  "						foreach (IWfiGloss gloss in m_cache.ServiceLocator.GetInstance<IWfiGlossRepository>().AllInstances().Where(g => g != targetGloss)) " is 130.
Long Statement,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ConcordanceControl)); " is 138.
Long Statement,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,InitializeComponent,The length of the statement  "			this.m_lnkSpecify.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.m_lnkSpecify_LinkClicked); " is 122.
Long Statement,SIL.FieldWorks.IText,OccurrencesOfSelectedUnit,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.IText,ConcordanceControlBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControlBase.cs,Init,The length of the statement  "			m_clerk = m_propertyTable.GetValue<OccurrencesOfSelectedUnit>(name) ?? (OccurrencesOfSelectedUnit)RecordClerkFactory.CreateClerk(m_mediator' m_propertyTable' m_configurationParameters' true); " is 191.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,Display,The length of the statement  "					vwenv.set_IntProperty((int)FwTextPropType.ktptBorderColor' (int)FwTextPropVar.ktpvDefault' (int)ColorUtil.ConvertColorToBGR(Color.Gray)); " is 137.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,DisplayVariant,The length of the statement  "								tss = CreateFeatureLine(feature.Abbreviation.BestAnalysisAlternative' value.Symbol.Abbreviation.BestAnalysisAlternative' value.Negate); " is 135.
Long Statement,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,DisplayVariant,The length of the statement  "					tss = node1.Maximum == -1 ? m_infinity : TsStringUtils.MakeString(node1.Maximum.ToString(CultureInfo.InvariantCulture)' m_cache.DefaultUserWs); " is 143.
Long Statement,SIL.FieldWorks.IText,ConcordanceWordList,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceWordList.cs,ReloadList,The length of the statement  "				reloadRequested = selectionChanged = false; // BEFORE base call' which could set CurrentIndex and cause stack overflow otherwise " is 128.
Long Statement,SIL.FieldWorks.IText,ConcordanceWordList,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceWordList.cs,UpdatePrivateList,The length of the statement  "				// REVIEW (FWR-1906): Do we need to do this reload only the first time' or also (as here) when the prop change is from undo or redo? " is 132.
Long Statement,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ConfigureInterlinDialog)); " is 143.
Long Statement,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,InitializeComponent,The length of the statement  "			this.imageList1.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("imageList1.ImageStream"))); " is 120.
Long Statement,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,getWsFromId,The length of the statement  "			Debug.Assert(!XmlViewsUtils.GetWsRequiresObject(id)' "Writing system is magic.  These should never be used in the Interlinear area."); " is 134.
Long Statement,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,getWsFromId,The length of the statement  "				Debug.Assert(ws != -50' "InterpretWsLabel was not able to interpret the Ws Label.  The most likely cause for this is that a magic ws was passed in."); " is 150.
Long Statement,SIL.FieldWorks.IText,CreateAllomorphTypeMismatchDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\CreateAllomorphTypeMismatchDlg.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.IText,CreateAllomorphTypeMismatchDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\CreateAllomorphTypeMismatchDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(CreateAllomorphTypeMismatchDlg)); " is 150.
Long Statement,SIL.FieldWorks.IText,DuplicateWordformFixer,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\DuplicateWordformFixer.cs,Process,The length of the statement  "			UndoableUnitOfWorkHelper.Do(ITextStrings.ksUndoMergeWordforms' ITextStrings.ksRedoMergeWordforms' cache.ActionHandlerAccessor' " is 126.
Long Statement,SIL.FieldWorks.IText,EditMorphBreaksDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\EditMorphBreaksDlg.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.IText,EditMorphBreaksDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\EditMorphBreaksDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(EditMorphBreaksDlg)); " is 138.
Long Statement,SIL.FieldWorks.IText,FilterAllTextsDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FilterAllTextsDialog.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FilterAllTextsDialog)); " is 140.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,SaveAnalysisForAnnotation,The length of the statement  "			// In case the wordform we point at has a form that doesn't match' we may need to set up an overidden form for the annotation. " is 126.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,IsFullyAnalyzed,The length of the statement  "			// Wordforms always need more (I suppose pathologically they might not if all analysis fields are turned off' but in that case' " is 127.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,IsFullyAnalyzed,The length of the statement  "						if (((IWfiGloss)analysis).Form.get_String(spec.GetActualWs(wf.Cache' analysis.Hvo' wf.Cache.DefaultAnalWs)).Length == 0) " is 120.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,AppendShortcutToToolTip,The length of the statement  "				// alter this one' since there can be two key combinations that should work for it (Control-key is not always necessary). " is 121.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 141.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FocusBoxController)); " is 138.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The length of the statement  "			this.btnLinkNextWord.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("btnLinkNextWord.BackgroundImage"))); " is 120.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The length of the statement  "			this.panelControlBar.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) " is 151.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The length of the statement  "			this.btnConfirmChangesForWholeText.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 165.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The length of the statement  "			this.btnConfirmChangesForWholeText.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("btnConfirmChangesForWholeText.BackgroundImage"))); " is 148.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The length of the statement  "			this.btnUndoChanges.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 150.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The length of the statement  "			this.btnConfirmChanges.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 153.
Long Statement,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The length of the statement  "			this.btnConfirmChanges.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("btnConfirmChanges.BackgroundImage"))); " is 124.
Long Statement,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ImageHolder)); " is 131.
Long Statement,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The length of the statement  "			this.buttonImages.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("buttonImages.ImageStream"))); " is 124.
Long Statement,SIL.FieldWorks.IText,InfoPane,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InfoPane.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 141.
Long Statement,SIL.FieldWorks.IText,InfoPane,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InfoPane.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(InfoPane)); " is 128.
Long Statement,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,SavePersisted,The length of the statement  "			m_propertyTable.SetProperty(BookmarkPropertyName("IndexOfParagraph")' m_iParagraph' PropertyTable.SettingsGroup.LocalSettings' false); " is 134.
Long Statement,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,SavePersisted,The length of the statement  "			m_propertyTable.SetProperty(BookmarkPropertyName("CharBeginOffset")' m_BeginOffset' PropertyTable.SettingsGroup.LocalSettings' false); " is 134.
Long Statement,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,SavePersisted,The length of the statement  "			m_propertyTable.SetProperty(BookmarkPropertyName("CharEndOffset")' m_EndOffset' PropertyTable.SettingsGroup.LocalSettings' false); " is 130.
Long Statement,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,SavePersisted,The length of the statement  "			m_propertyTable.SetPropertyPersistence(BookmarkPropertyName("IndexOfParagraph")' true' PropertyTable.SettingsGroup.LocalSettings); " is 130.
Long Statement,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,SavePersisted,The length of the statement  "			m_propertyTable.SetPropertyPersistence(BookmarkPropertyName("CharBeginOffset")' true' PropertyTable.SettingsGroup.LocalSettings); " is 129.
Long Statement,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,SavePersisted,The length of the statement  "			m_propertyTable.SetPropertyPersistence(BookmarkPropertyName("CharEndOffset")' true' PropertyTable.SettingsGroup.LocalSettings); " is 127.
Long Statement,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,Restore,The length of the statement  "			int restoredRecordIndex = m_propertyTable.GetIntProperty(RecordIndexBookmarkName' -1' PropertyTable.SettingsGroup.LocalSettings); " is 129.
Long Statement,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,Restore,The length of the statement  "			m_iParagraph = m_propertyTable.GetIntProperty(BookmarkPropertyName("IndexOfParagraph")' 0' PropertyTable.SettingsGroup.LocalSettings); " is 134.
Long Statement,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,Restore,The length of the statement  "			m_BeginOffset = m_propertyTable.GetIntProperty(BookmarkPropertyName("CharBeginOffset")' 0' PropertyTable.SettingsGroup.LocalSettings); " is 134.
Long Statement,SIL.FieldWorks.IText,InterAreaBookmark,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterAreaBookmark.cs,Restore,The length of the statement  "			m_EndOffset = m_propertyTable.GetIntProperty(BookmarkPropertyName("CharEndOffset")' 0' PropertyTable.SettingsGroup.LocalSettings); " is 130.
Long Statement,SIL.FieldWorks.IText,InterlinearExportDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExportDialog.cs,LaunchFilterTextsDialog,The length of the statement  "			var interestingTextsList = InterestingTextsDecorator.GetInterestingTextList(m_mediator' m_propertyTable' m_cache.ServiceLocator); " is 129.
Long Statement,SIL.FieldWorks.IText,InterlinearExportDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExportDialog.cs,LaunchFilterTextsDialog,The length of the statement  "			using (var dlg = new FilterTextsDialog(m_propertyTable.GetValue<IApp>("App")' m_cache' interestingTexts' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider"))) " is 172.
Long Statement,SIL.FieldWorks.IText,InterlinearExportDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExportDialog.cs,DoExport,The length of the statement  "			using (var dlg = new ProgressDialogWithTask(this) { IsIndeterminate = true' AllowCancel = false' Message = ITextStrings.ksExporting_ }) " is 135.
Long Statement,SIL.FieldWorks.IText,InterlinearExportDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExportDialog.cs,DoExport,The length of the statement  "					var fxtPath = (string)m_exportList.SelectedItems[0].Tag; // read fxtPath here to prevent access to m_exportList on another thread " is 129.
Long Statement,SIL.FieldWorks.IText,InterlinearExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,AddStringAltMember,The length of the statement  "			//but they may not be defined in other languages' using English on import and export should garauntee the correct behavior " is 122.
Long Statement,SIL.FieldWorks.IText,InterlinearExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,AddObj,The length of the statement  "			if (vc is InterlinVc && frag >= InterlinVc.kfragLineChoices && frag < InterlinVc.kfragLineChoices + (vc as InterlinVc).LineChoices.Count) " is 137.
Long Statement,SIL.FieldWorks.IText,InterlinearExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,AddObj,The length of the statement  "			if (vc is InterlinVc && frag >= InterlinVc.kfragLineChoices && frag < InterlinVc.kfragLineChoices + (vc as InterlinVc).LineChoices.Count) " is 137.
Long Statement,SIL.FieldWorks.IText,InterlinearImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearImportDlg.cs,m_btnOK_Click,The length of the statement  "						Path.Combine(FwDirectoryFinder.CodeDirectory' Path.Combine("Language Explorer"' "Import" + Path.DirectorySeparatorChar))); " is 122.
Long Statement,SIL.FieldWorks.IText,InterlinearImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearImportDlg.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 141.
Long Statement,SIL.FieldWorks.IText,InterlinearImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearImportDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(InterlinearImportDlg)); " is 140.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,UpdateWordforms,The length of the statement  "			// null ref exceptions in the absence of testing for this (LT-13702)' and we certainly don't need to update the focus box " is 121.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SelectOccurrence,The length of the statement  "			Debug.Assert(target.IsValid && !(target.Analysis is IPunctuationForm)' "Given annotation type should not be punctuation" " is 120.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SetFocusBoxSizeForVc,The length of the statement  "			if (newSize.Width == interlinDocForAnalysisVc.FocusBoxSize.Width && newSize.Height == interlinDocForAnalysisVc.FocusBoxSize.Height) " is 131.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,OnKeyDown,The length of the statement  "					if ((coAnchor is ISegment && (tsi.TagAnchor == SegmentTags.kflidFreeTranslation || tsi.TagAnchor == SegmentTags.kflidLiteralTranslation)) " is 137.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleSelectionChange,The length of the statement  "				//If the flid is -2 and it is an insertion point then we may have encountered a case where the selection has landed at the boundary between our (possibly empty) " is 160.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleSelectionChange,The length of the statement  "				//translation field and a literal string containing our magic Bidi marker character that helps keep things in the right order. " is 126.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleSelectionChange,The length of the statement  "				//Sometimes AssocPrev gets set so that we read the (non-existent) flid of the literal string and miss the fact that on the other side " is 133.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleSelectionChange,The length of the statement  "				//of the insertion point is the field we're looking for. The following code will attempt to make a selection that associates in " is 127.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,OnScroll,The length of the statement  "			Debug.WriteLine("scrolled interlinear view to " + AutoScrollPosition + " in range " + AutoScrollMinSize + " (focus box at " + FocusBox.Location + ")"); " is 151.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,FocusBox_SizeChanged,The length of the statement  "				m_rootb.PropChanged(FocusBox.SelectedOccurrence.Segment.Hvo' SegmentTags.kflidAnalyses' FocusBox.SelectedOccurrence.Index' 1' 1); " is 129.
Long Statement,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 141.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,m_browseLoadSettingsFileButon_Click,The length of the statement  "			m_loadSettingsFileBox.Text = GetFile(m_loadSettingsFileBox.Text' FirstInputFile' new[] { FileFilterType.ImportMapping' FileFilterType.AllFiles }' true' " is 151.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,AddSimpleItems,The length of the statement  "			results.AddRange(remaining.Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries).Select(x => x.Trim()).Where(x => !string.IsNullOrWhiteSpace(x))); " is 150.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,OnNextButton,The length of the statement  "				// Read the map file (unless we've been to this pane before...then use the saved settings)' integrate with the sfmcount info. " is 125.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,OnFinishButton,The length of the statement  "					// JohnT: I hate to just report and otherwise ignore all exceptions' but have not been able to find any doc of which ones' " is 122.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,GetDestinationsFilter,The length of the statement  "						  InterlinDestination.FreeTranslation'InterlinDestination.Id' InterlinDestination.Ignored' InterlinDestination.LiteralTranslation' " is 128.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,GetDestinationsFilter,The length of the statement  "						  InterlinDestination.Note' InterlinDestination.ParagraphBreak' InterlinDestination.Reference' InterlinDestination.Source' InterlinDestination.Title }; " is 149.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,m_btnCancel_Click,The length of the statement  "			var result = MessageBox.Show(this' ITextStrings.ksAskSaveSettings' ITextStrings.ksSaveSettingsCaption' MessageBoxButtons.YesNoCancel); " is 134.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,m_browseSaveSettingsFileButon_Click,The length of the statement  "			m_saveSettingsFileBox.Text = GetFile(m_saveSettingsFileBox.Text' FirstInputFile' new[] { FileFilterType.ImportMapping' FileFilterType.AllFiles }' false' " is 152.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(InterlinearSfmImportWizard)); " is 146.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,InitializeComponent,The length of the statement  "			this.m_useDefaultSettingsLink.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.m_useDefaultSettingsLink_LinkClicked); " is 146.
Long Statement,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,InitializeComponent,The length of the statement  "			this.m_mappingsList.MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(this.m_mappingsList_MouseDoubleClick); " is 121.
Long Statement,SIL.FieldWorks.IText,InterlinearTextsRecordClerk,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearTextsRecordClerk.cs,OnAddTexts,The length of the statement  "			using (var dlg = new FilterTextsDialog(m_propertyTable.GetValue<IApp>("App")' Cache' interestingTexts' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider"))) " is 170.
Long Statement,SIL.FieldWorks.IText,InterlinearTextsRecordClerk,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearTextsRecordClerk.cs,OnDisplayInsertInterlinText,The length of the statement  "				return true; // or should we just say' we don't know? But this command definitely should only be possible when this IS active. " is 126.
Long Statement,SIL.FieldWorks.IText,InterlinearTextsRecordClerk,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearTextsRecordClerk.cs,AddNewText,The length of the statement  "			// This is a workable alternative (where link is the one created above)' but means this code has to know about the FwXApp class. " is 128.
Long Statement,SIL.FieldWorks.IText,InterlinearTextsRecordClerk,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearTextsRecordClerk.cs,AddNewText,The length of the statement  "			// to return to its message loop' but it never does' because it is the same app that is trying to send the link' so it is busy " is 126.
Long Statement,SIL.FieldWorks.IText,InterlinLineChoices,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinLineChoices.cs,CreateSpec,The length of the statement  "			ColumnConfigureDialog.WsComboContent comboContent = ColumnConfigureDialog.WsComboContent.kwccAnalysis; // The usual choice " is 122.
Long Statement,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,GetRealWsFromSpec,The length of the statement  "				Debug.Assert(ws != -50' "InterpretWsLabel was not able to interpret the Ws Label.  The most likely cause for this is that a magic ws was passed in."); " is 150.
Long Statement,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,hideItem_Click,The length of the statement  "			RemoveContextButtonIfPresent(); // it will still have a spurious choice to hide the line we just hid; clicking may crash. " is 121.
Long Statement,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,OnConfigureInterlinear,The length of the statement  "			using (var dlg = new ConfigureInterlinDialog(m_cache' m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' " is 120.
Long Statement,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,ConvertBookmarkToAnalysis,The length of the statement  "				|| bookmark.IndexOfParagraph < 0 || bookmark.BeginCharOffset < 0 || bookmark.IndexOfParagraph >= RootStText.ParagraphsOS.Count) " is 127.
Long Statement,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 141.
Long Statement,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,ShowRecord,The length of the statement  "			if (Clerk.CurrentObjectHvo != 0 && !Cache.ServiceLocator.IsValidObjectId(Clerk.CurrentObjectHvo))	// RecordClerk is tracking an analysis " is 136.
Long Statement,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,ShowRecord,The length of the statement  "					// If we have restarted FLEx since this text was created' the WS has been lost and replaced with the global default of English. " is 127.
Long Statement,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,CreateOrRestoreBookmark,The length of the statement  "					m_bookmarks.Add(new Tuple<string' Guid>(CurrentTool' stText.Guid)' new InterAreaBookmark(this' Cache' m_propertyTable)); " is 120.
Long Statement,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,SelectAnnotation,The length of the statement  "				m_bookmarks[new Tuple<string' Guid>(CurrentTool' RootStText.Guid)].IndexOfParagraph >= 0 && CurrentInterlinearTabControl is IHandleBookmark) " is 140.
Long Statement,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,SelectAnnotation,The length of the statement  "				(CurrentInterlinearTabControl as IHandleBookmark).SelectBookmark(m_bookmarks[new Tuple<string' Guid>(CurrentTool' RootStText.Guid)]); " is 133.
Long Statement,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 141.
Long Statement,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(InterlinMaster)); " is 134.
Long Statement,SIL.FieldWorks.IText,InterlinMasterNoTitleBar,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMasterNoTitleBar.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.IText,InterlinMasterNoTitleContent,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMasterNoTitleContent.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.IText,InterlinPrintChild,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinPrintView.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 141.
Long Statement,SIL.FieldWorks.IText,InterlinTaggingChild,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinTaggingChild.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 141.
Long Statement,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,CheckDisposed,The length of the statement  "				throw new ObjectDisposedException(GetType().ToString()' "This object is being used after it has been disposed: this is an Error."); " is 131.
Long Statement,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,Display,The length of the statement  "					PreferredVernWs = WritingSystemServices.ActualWs(m_cache' WritingSystemServices.kwsVernInParagraph' hvo' StTxtParaTags.kflidSegments); " is 134.
Long Statement,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,AddAnalysisPos,The length of the statement  "				vwenv.AddObj(hvoAnalysis' this' kfragAnalysisCategoryChoices + choiceIndex); // causes recursive call with right hvoCurrent " is 123.
Long Statement,SIL.FieldWorks.IText,InterlinViewCacheLoader,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,RecordGuessIfAvailable,The length of the statement  "				SetInt(wagGuess.Analysis.Hvo' InterlinViewDataCache.OpinionAgentFlid' (int)GuessServices.GetOpinionAgent(wagGuess.Analysis)); " is 125.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(LinguaLinksImportDlg)); " is 140.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The length of the statement  "							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping); " is 129.
Long Statement,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The length of the statement  "											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode }); " is 144.
Long Statement,SIL.FieldWorks.IText,ComplexConcParagraphData,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcParagraphData.cs,GenerateShape,The length of the statement  "							foreach (int ws in mb.Form.AvailableWritingSystemIds.Union(mb.MorphRA == null ? Enumerable.Empty<int>() : mb.MorphRA.Form.AvailableWritingSystemIds)) " is 149.
Long Statement,SIL.FieldWorks.IText,ComplexConcParagraphData,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcParagraphData.cs,GenerateShape,The length of the statement  "								FeatureSymbol[] catSymbols = GetHvoOfMsaPartOfSpeech(mb.MsaRA).Select(hvo => catFeat.PossibleSymbols[hvo.ToString(CultureInfo.InvariantCulture)]).ToArray(); " is 156.
Long Statement,SIL.FieldWorks.IText,ComplexConcParagraphData,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcParagraphData.cs,GenerateShape,The length of the statement  "				if (tag.BeginAnalysisIndex >= tag.BeginSegmentRA.AnalysesRS.Count || tag.EndAnalysisIndex >= tag.EndSegmentRA.AnalysesRS.Count " is 126.
Long Statement,SIL.FieldWorks.IText,ComplexConcParagraphData,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcParagraphData.cs,GenerateShape,The length of the statement  "				if (!segments.TryGetValue(tag.BeginSegmentRA' out beginSegment) || !segments.TryGetValue(tag.EndSegmentRA' out endSegment)) " is 123.
Long Statement,SIL.FieldWorks.IText,ComplexConcParagraphData,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcParagraphData.cs,GenerateShape,The length of the statement  "				Annotation<ShapeNode> tagAnn = new Annotation<ShapeNode>(spanFactory.Create(beginAnnotation.Span.Start' endAnnotation.Span.End)' " is 128.
Long Statement,SIL.FieldWorks.IText,ComplexConcParagraphData,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcParagraphData.cs,GenerateShape,The length of the statement  "					FeatureStruct.New(featSys).Symbol("ttag").Symbol(tagType.Hvo.ToString(CultureInfo.InvariantCulture)).Value) { Data = tag }; " is 123.
Long Statement,SIL.FieldWorks.IText,ComplexConcParagraphData,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcParagraphData.cs,GetFeatureStruct,The length of the statement  "						featStruct.AddValue(featSys.GetFeature(complexVal.FeatureRA.Hvo.ToString(CultureInfo.InvariantCulture))' GetFeatureStruct(featSys' cfs)); " is 137.
Long Statement,SIL.FieldWorks.IText,AnnotationMoveHelper,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\RawTextPane.cs,CanEdit,The length of the statement  "				return m_rootSite.m_hvoRoot != 0 && m_rootSite != null && !m_rootSite.IsDisposed && !m_rootSite.ReadOnlyView && m_rootSite.m_vc.Editable; " is 137.
Long Statement,SIL.FieldWorks.IText,Sandbox,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\Sandbox.cs,Dispose,The length of the statement  "			System.Diagnostics.Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 141.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,VernCaseFuncs,The length of the statement  "			string locale = m_caches.MainCache.ServiceLocator.WritingSystemManager.Get(TsStringUtils.GetWsAtOffset(tss' 0)).IcuLocale; " is 122.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,LoadRealDataIntoSec1,The length of the statement  "					if (InterlinDoc != null) // can be null in Wordform Analyses tool and some unit tests' and we don't want to clear an existing analysis. " is 135.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CopyStringsToSecondary,The length of the statement  "					IList<int> currentAnalysisWsList = m_caches.MainCache.ServiceLocator.WritingSystems.CurrentAnalysisWritingSystems.Select(wsObj => wsObj.Handle).ToArray(); " is 154.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CopyStringsToSecondary,The length of the statement  "					IList<int> currentVernWsList = m_caches.MainCache.ServiceLocator.WritingSystems.CurrentVernacularWritingSystems.Select(wsObj => wsObj.Handle).ToArray(); " is 152.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CopyStringsToSecondary,The length of the statement  "			var writingSystems = m_caches.MainCache.ServiceLocator.WritingSystems.AllWritingSystems.Select(ws => ws.Handle).ToList(); " is 121.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CacheLexGlossWithInflTypeForAllCurrentWs,The length of the statement  "			IList<int> currentAnalysisWsList = m_caches.MainCache.ServiceLocator.WritingSystems.CurrentAnalysisWritingSystems.Select(wsObj => wsObj.Handle).ToArray(); " is 154.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CacheLexGlossWithInflTypeForAllCurrentWs,The length of the statement  "						return InterlinVc.TryGetLexGlossWithInflTypeTss(possibleVariant' sense' spec' choices' wsVern' inflType' out tssResult) ? " is 121.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,EstablishDefaultEntry,The length of the statement  "			var otherWritingSystemsForMorphForm = m_choices.OtherWritingSystemsForFlid(InterlinLineChoices.kflidMorphemes' RawWordformWs); " is 126.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectFirstAssociatedText,The length of the statement  "				selStartOfText = FindNearestSelectionType(selOrig' VwSelType.kstText' (uint)(rect.left - dxPixelIncrement)' (uint)xMaxCountOfPixels' -dxPixelIncrement); " is 152.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectFirstAssociatedText,The length of the statement  "				selStartOfText = FindNearestSelectionType(selOrig' VwSelType.kstText' (uint)(rect.right + dxPixelIncrement)' (uint)xMaxCountOfPixels' dxPixelIncrement); " is 152.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,HandleTab,The length of the statement  "			GetLineOfCurrentSelectionAndNextTabStop(fShift' out currentLineIndex' out startLineIndex' out increment' out fSkipIcon' out iNextMorphIndex); " is 141.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetLineOfCurrentSelection,The length of the statement  "			GetLineOfCurrentSelectionAndNextTabStop(false' out currentLineIndex' out startLineIndex' out increment' out fSkipIcon' out iNextMorphIndex); " is 140.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetLineOfCurrentSelectionAndNextTabStop,The length of the statement  "					NextPositionForLexEntryText(increment' fOnNextLine' fIsPictureSel' out currentLineIndex' out startLineIndex' ref iNextMorphIndex); " is 130.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetLineOfCurrentSelectionAndNextTabStop,The length of the statement  "								NextPositionForLexEntryText(increment' fOnNextLine' fIsPictureSel' out currentLineIndex' out startLineIndex' ref iNextMorphIndex); " is 130.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectAtStartOfMorph,The length of the statement  "				RootBox.MakeTextSelection(0' 2' selectIndexMorph' ktagSbNamedObjName' 0' 0' 0' this.RawWordformWs' false' -1' null' true); " is 122.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectAtEndOfMorph,The length of the statement  "				RootBox.MakeTextSelection(0' 2' selectIndexMorph' ktagSbNamedObjName' 0' cchName' cchName' this.RawWordformWs' false' -1' null' true); " is 134.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectAtEndOfMorph,The length of the statement  "				RootBox.MakeTextSelection(0' 1' selectIndexMorph' ktagSbMorphPostfix' 0' cchPostfix' cchPostfix' 0' false' -1' null' true); " is 123.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectTextNearestToNextIcon,The length of the statement  "			GetLineOfCurrentSelectionAndNextTabStop(fShift' out currentLineIndex' out startLineIndex' out increment' out fSkipIcon' out iNextMorphIndex); " is 141.
Long Statement,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,OnMouseMove,The length of the statement  "				Debug.WriteLine("SandboxBase.OnMouseMove(" + m_LastMouseMovePos.ToString() + "): rcSrcRoot = " + rcSrcRoot.ToString() + "' rcDstRoot = " + rcDstRoot.ToString()); " is 161.
Long Statement,SIL.FieldWorks.IText,InterlinComboHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CopySenseToWordGloss,The length of the statement  "						ITsString tssGloss = m_caches.MainCache.MainCacheAccessor.get_MultiStringAlt(hvoRealSense' LexSenseTags.kflidGloss' wsId); " is 122.
Long Statement,SIL.FieldWorks.IText,IhMorphForm,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SetupCombo,The length of the statement  "				// if we added the fullWordform (or the current breakdown is somehow empty although we may have an analysis)' then add the " is 122.
Long Statement,SIL.FieldWorks.IText,IhMorphForm,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SetupCombo,The length of the statement  "				if (currentBreakdown == string.Empty || (wa == null && tssForm != null && tssForm.Equals(ComboList.Items[0] as ITsString))) " is 123.
Long Statement,SIL.FieldWorks.IText,IhMorphForm,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SetupCombo,The length of the statement  "					m_items.Add(wa != null ? wa.Hvo : 0);	// [wfi] hvoAnalysis may equal '0' (for annotations that are instances of Wordform). " is 122.
Long Statement,SIL.FieldWorks.IText,IhMissingEntry,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CreateCoreMorphItemBasedOnSandboxCurrentState,The length of the statement  "					inflType = m_caches.MainCache.ServiceLocator.GetInstance<ILexEntryInflTypeRepository>().GetObject(m_caches.RealHvo(hvoInflType)); " is 129.
Long Statement,SIL.FieldWorks.IText,IhMissingEntry,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,CreateNewEntry,The length of the statement  "						cache.ServiceLocator.GetInstance<IActionHandler>()' ITextStrings.ksUndoAddAllomorphToSimilarEntry' ITextStrings.ksRedoAddAllomorphToSimilarEntry)) " is 146.
Long Statement,SIL.FieldWorks.IText,IhMissingEntry,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,BuildEntryComponents,The length of the statement  "					foreach (int ws in m_sandbox.Caches.MainCache.ServiceLocator.WritingSystems.CurrentAnalysisWritingSystems.Select(wsObj => wsObj.Handle)) " is 136.
Long Statement,SIL.FieldWorks.IText,IhMissingEntry,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,HandleSelectMorphComboItem,The length of the statement  "						UndoableUnitOfWorkHelper.Do(ITextStrings.ksUndoAddSense' ITextStrings.ksRedoAddSense' m_caches.MainCache.ActionHandlerAccessor' " is 127.
Long Statement,SIL.FieldWorks.IText,IhMissingWordPos,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,m_tree_Load,The length of the statement  "					m_pOSPopupTreeManager = new POSPopupTreeManager(m_tree' cache' cache.LangProject.PartsOfSpeechOA' cache.DefaultAnalWs' false' m_sandbox.Mediator' m_sandbox.m_propertyTable' m_sandbox.FindForm()); " is 195.
Long Statement,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,FinishItOff,The length of the statement  "				// if we're in a special mode for adding monomorphemic words to lexicon and the user's proposed analysis is monomorphemic' " is 122.
Long Statement,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,FinishItOff,The length of the statement  "					using (IhMorphEntry handler = InterlinComboHandler.MakeCombo(m_helpTopicProvider' ktagWordGlossIcon' m_sandbox' 0) as SandboxBase.IhMorphEntry) " is 143.
Long Statement,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,SbWordMainPosMatchesSenseMsaMainPos,The length of the statement  "					var msa = m_caches.MainCache.ServiceLocator.GetInstance<IMoMorphSynAnalysisRepository>().GetObject(morphItem.m_hvoMsa) as IMoStemMsa; " is 133.
Long Statement,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,GetBestGloss,The length of the statement  "						|| (cMatch == cBestMatch && cBlanks == cBestBlanks && best != null && AdditionalAlternatives(possibleGloss' wsIds) < AdditionalAlternatives(best' wsIds))) " is 154.
Long Statement,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,IsTrivialAnalysis,The length of the statement  "					&& possibleAnalysis.CategoryRA != m_caches.RealObject(m_sda.get_ObjectProp(m_hvoSbWord' ktagSbWordPos)) as IPartOfSpeech) " is 121.
Long Statement,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,CheckAnalysis,The length of the statement  "						// No to this blocked line' since this gets a ts string with a null underlying string' as it is not in the cache with the '0' hvo. " is 130.
Long Statement,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,CheckDisposed,The length of the statement  "					throw new ObjectDisposedException(GetType().ToString()' "This object is being used after it has been disposed: this is an Error."); " is 131.
Long Statement,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,GetActualWs,The length of the statement  "							m_caches.MainCache.ServiceLocator.WritingSystems.CurrentAnalysisWritingSystems.Select(wsObj => wsObj.Handle).ToArray()); " is 120.
Long Statement,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,GetActualWs,The length of the statement  "							m_caches.MainCache.ServiceLocator.WritingSystems.CurrentVernacularWritingSystems.Select(wsObj => wsObj.Handle).ToArray()); " is 122.
Long Statement,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,DisplayMorphForm,The length of the statement  "				bool fWantIcon = m_fIsMorphemeFormEditable && (frag == kfragFirstMorph) && m_choices.IsFirstOccurrenceOfFlid(choiceIndex); " is 122.
Long Statement,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,RebuildStatisticsTable,The length of the statement  "			statisticsBox.Text += Environment.NewLine + Environment.NewLine + Environment.NewLine + "\t" + ITextStrings.ksStatisticsViewTotalWordTypesText + "\t"; // Todo: find the right System.?.NewLine constant " is 200.
Long Statement,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,RebuildStatisticsTable,The length of the statement  "				statisticsBox.Text += Environment.NewLine + Environment.NewLine + "\t" + labText + "\t"; // Todo: find the right System.?.NewLine constant " is 138.
Long Statement,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,RebuildStatisticsTable,The length of the statement  "			statisticsBox.Text += Environment.NewLine + Environment.NewLine + Environment.NewLine + "\t" + ITextStrings.ksStatisticsViewTotalWordTokensText + "\t"; // Todo: find the right System.?.NewLine constant " is 201.
Long Statement,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,RebuildStatisticsTable,The length of the statement  "				statisticsBox.Text += Environment.NewLine + Environment.NewLine + "\t" + labText + "\t"; // Todo: find the right System.?.NewLine constant " is 138.
Long Statement,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,RebuildStatisticsTable,The length of the statement  "			statisticsBox.Text += Environment.NewLine + Environment.NewLine + Environment.NewLine + "\t" + ITextStrings.ksStatisticsViewTotalSentencesText + "\t"; // Todo: find the right System.?.NewLine constant " is 200.
Long Statement,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,FillInChildren,The length of the statement  "			if ((!(bookNode.Tag is IScrBook) && !(bookNode.Tag is int)) || bookNode.Nodes.Count != 1 || bookNode.Nodes[0].Name != ksDummyName) " is 130.
Long Statement,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,FillInBookChildren,The length of the statement  "				if (btProject != null && btProject.BookPresent(book.CanonicalNum) && !btProject.IsCheckSumCurrent(book.CanonicalNum' book.ImportedBtCheckSum.get_String(book.Cache.DefaultAnalWs).Text)) " is 184.
Long Statement,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,FillInBookChildren,The length of the statement  "				if (!scrFootnote.TryGetContainingSection(out containingSection) && !scrFootnote.TryGetContainingTitle(out containingTitle)) " is 123.
Long Statement,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,ImportBook,The length of the statement  "				importSettings = m_scr.FindOrCreateDefaultImportSettings(TypeOfImport.Paratext6' m_scriptureStylesheet' FwDirectoryFinder.TeStylesPath); " is 136.
Long Statement,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,ImportBook,The length of the statement  "			if (haveSomethingToImport && ReflectionHelper.GetBoolResult(ReflectionHelper.GetType("ParatextImport.dll"' "ParatextImport.ParatextImportManager")' "ImportParatext"' owningForm' m_cache' importSettings' m_scriptureStylesheet' App)) " is 231.
Long Statement,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,ImportBackTranslation,The length of the statement  "				importSettings = m_scr.FindOrCreateDefaultImportSettings(TypeOfImport.Paratext6' m_scriptureStylesheet' FwDirectoryFinder.TeStylesPath); " is 136.
Long Statement,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,ImportBackTranslation,The length of the statement  "			ReflectionHelper.GetBoolResult(ReflectionHelper.GetType("ParatextImport.dll"' "ParatextImport.ParatextImportManager")' "ImportParatext"' owningForm' m_cache' importSettings' m_scriptureStylesheet' App); " is 202.
Long Statement,SIL.FieldWorks.IText,WordBreakGuesser,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WordBreakGuesser.cs,Setup,The length of the statement  "			//Add all the stems from the Lexicon including all their allomorphs (as I understand this it will capture phrases as well -naylor Aug 2011) " is 139.
Long Statement,SIL.FieldWorks.IText,WordBreakGuesser,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WordBreakGuesser.cs,Setup,The length of the statement  "					foreach(var allomorph in allAllomorphs.Where(allomorph => (allomorph.MorphTypeRA != null && !allomorph.MorphTypeRA.IsBoundType))) //for every allomorph of the stem " is 163.
Long Statement,SIL.FieldWorks.IText,WordBreakGuesser,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WordBreakGuesser.cs,Guess,The length of the statement  "			//just grab the system from the first run' seems unlikely you'll be guessing wordbreaks on strings with runs in different writing systems " is 137.
Long Statement,SIL.FieldWorks.IText,WordBreakGuesser,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WordBreakGuesser.cs,Guess,The length of the statement  "			string[] distinctPhrases = vc != null ? txt.Split(vc.OtherCharacters.ToArray()' StringSplitOptions.None) //ws info was good' use it " is 131.
Long Statement,SIL.FieldWorks.IText,WordBreakGuesser,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WordBreakGuesser.cs,Guess,The length of the statement  "				UndoableUnitOfWorkHelper.Do(ITextStrings.ksUndoGuessWordBreaks' ITextStrings.ksRedoGuessWordBreaks' m_cache.ActionHandlerAccessor' " is 130.
Long Statement,SIL.FieldWorks.IText,WsListManager,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WsListManager.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + ". ******************"); " is 122.
Complex Conditional,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,RemoveItemsRequested,The conditional expression  "(parent.Children.Count == 1 && isFirstBdry)  						|| (parent.Children.Count > 1 && isFirstBdry && !(parent.Children[1] is ComplexConcMorphNode))"  is complex.
Complex Conditional,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,RemoveItemsRequested,The conditional expression  "parent.Children[i - 1] is ComplexConcWordBdryNode  							|| (!(parent.Children[i - 1] is ComplexConcMorphNode) || (i + 1 < parent.Children.Count && !(parent.Children[i + 1] is ComplexConcMorphNode)))"  is complex.
Complex Conditional,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,GetMatcher,The conditional expression  "!m_vwPattern.UseRegularExpressions  					&& m_vwPattern.MatchDiacritics  					&& m_vwPattern.MatchOldWritingSystem  					&& m_vwPattern.Pattern.RunCount == 1"  is complex.
Complex Conditional,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,ApplyAnalysisToInstancesOfWordform,The conditional expression  "occ.Analysis == newWordform || (occ.Analysis == oldWordform && occ.Index == 0 && SelectedOccurrence.Index == 0)"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,InterlinDocForAnalysis_RightMouseClickedEvent,The conditional expression  "GetTagAndObjForOnePropSelection(e.Selection' out hvoObj' out tagAnchor) &&  				(tagAnchor == SegmentTags.kflidFreeTranslation || tagAnchor == SegmentTags.kflidLiteralTranslation ||  				tagAnchor == NoteTags.kflidContent)"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,PropChanged,The conditional expression  "IsFocusBoxInstalled && FocusBox.SelectedOccurrence != null  				&& tag == SegmentTags.kflidAnalyses && FocusBox.SelectedOccurrence.Segment.Hvo == hvo"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,UpdateWordforms,The conditional expression  "IsFocusBoxInstalled && FocusBox.SelectedOccurrence != null && FocusBox.SelectedOccurrence.Analysis != null  				&& FocusBox.SelectedOccurrence.Analysis.Wordform != null  				&& wordforms.Contains(FocusBox.SelectedOccurrence.Analysis.Wordform)  				&& !FocusBox.IsDirty"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,OnKeyDown,The conditional expression  "(coAnchor is ISegment && (tsi.TagAnchor == SegmentTags.kflidFreeTranslation || tsi.TagAnchor == SegmentTags.kflidLiteralTranslation))  						|| (coAnchor is INote && tsi.TagAnchor == NoteTags.kflidContent)"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleArrowKeys,The conditional expression  "SelectedOccurrence == null &&  				(e.KeyCode == Keys.Down || e.KeyCode == Keys.Up ||  				 e.KeyCode == Keys.Right || e.KeyCode == Keys.Left) &&  				((e.KeyCode & Keys.Shift) != Keys.Shift) && ((e.KeyCode & Keys.Control) != Keys.Control)"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleArrowKeys,The conditional expression  "hasPrompt && (id == InterlinLineChoices.kflidFreeTrans ||  								  id == InterlinLineChoices.kflidLitTrans)  							  && (e.KeyCode == Keys.Left || e.KeyCode == Keys.Right)"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,OnAddWordGlossesToFreeTrans,The conditional expression  "bldr.Length > 0 && insert != null && insert.Length > 0 && !fOpenPunc"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleSelectionChange,The conditional expression  "m_cpropPrevForInsert > 0 && !sel.IsRange &&  					(helper.GetNumberOfPreviousProps(SelectionHelper.SelLimitType.Anchor) == 0 ||  					 helper.GetNumberOfPreviousProps(SelectionHelper.SelLimitType.End) == 0)"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,CalculateTextCount,The conditional expression  "interlinearMapping.Destination == InterlinDestination.Id ||  				   interlinearMapping.Destination == InterlinDestination.Source ||  				   interlinearMapping.Destination == InterlinDestination.Comment ||  				   interlinearMapping.Destination == InterlinDestination.Title ||  				   interlinearMapping.Destination == InterlinDestination.Abbreviation"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinLineChoices,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinLineChoices.cs,Add,The conditional expression  "fGotMorpheme && spec.MorphemeLevel && i >= firstMorphemeIndex &&  						(!this[i].MorphemeLevel ||  						spec.Flid == kflidMorphemes ||  						spec.Flid == kflidLexEntries && this[i].Flid != kflidMorphemes)"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,ConvertBookmarkToAnalysis,The conditional expression  "RootStText == null || RootStText.ParagraphsOS.Count == 0  				|| bookmark.IndexOfParagraph < 0 || bookmark.BeginCharOffset < 0 || bookmark.IndexOfParagraph >= RootStText.ParagraphsOS.Count"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,ShowRecord,The conditional expression  "Clerk is InterlinearTextsRecordClerk &&  				Clerk.CurrentObjectHvo == 0 && !m_fSuppressAutoCreate && !Clerk.ShouldNotModifyList  				&& Clerk.Filter == null"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,SelectAnnotation,The conditional expression  "RootStText != null && m_bookmarks.ContainsKey(new Tuple<string' Guid>(CurrentTool' RootStText.Guid)) &&  				m_bookmarks[new Tuple<string' Guid>(CurrentTool' RootStText.Guid)].IndexOfParagraph >= 0 && CurrentInterlinearTabControl is IHandleBookmark"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,m_tabCtrl_Selected,The conditional expression  "m_rtPane != null || m_infoPane != null || m_idcGloss != null || m_idcAnalyze != null  				|| m_taggingPane != null || m_printViewPane != null || m_constChartPane != null"  is complex.
Complex Conditional,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The conditional expression  "pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1)"  is complex.
Complex Conditional,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,LoadRealDataIntoSec1,The conditional expression  "fAdjustCase && CaseStatus == StringCaseStatus.title &&  						tssForm != null && tssForm.Length > 0"  is complex.
Complex Conditional,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,FindNearestSelectionType,The conditional expression  "dxPixelIncrement < 0 && pt.X > xLim ||  				dxPixelIncrement > 0 && pt.X < xLim"  is complex.
Complex Conditional,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,HandleEndKey,The conditional expression  "hvoObjE != hvoObjA || tagE != tagA || wsE != wsA || ichEnd != ichAnchor || ichEnd != tss.Length"  is complex.
Complex Conditional,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,HandleHomeKey,The conditional expression  "hvoObjE != hvoObjA || tagE != tagA || wsE != wsA || ichEnd != ichAnchor || ichEnd != 0"  is complex.
Complex Conditional,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetInfoForJumpToTool,The conditional expression  "tagOuter == ktagSbMorphGloss || tagOuter == ktagSbMorphPos || tagOuter == ktagSbMorphForm  						|| tagOuter == ktagSbMorphEntry"  is complex.
Complex Conditional,SIL.FieldWorks.IText,InterlinComboHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetComboItem,The conditional expression  "((item is ITsString) && (item as ITsString).Text == target) ||  							(item is ITssValue) && (item as ITssValue).AsTss.Text == target"  is complex.
Complex Conditional,SIL.FieldWorks.IText,IhMorphForm,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SetupCombo,The conditional expression  "currentBreakdown == string.Empty || (wa == null && tssForm != null && tssForm.Equals(ComboList.Items[0] as ITsString))"  is complex.
Complex Conditional,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,FinishItOff,The conditional expression  "oldAnalysis.MorphBundlesOS.Count == 1  								&& oldAnalysis.MorphBundlesOS[0].SenseRA != null  								&& oldAnalysis.MorphBundlesOS[0].SenseRA.MorphoSyntaxAnalysisRA is IMoStemMsa  								&& OnlyUsedThisOnce(oldAnalysis)  								&& OnlyUsedThisOnce(oldAnalysis.MorphBundlesOS[0].SenseRA)"  is complex.
Complex Conditional,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,FinishItOff,The conditional expression  "m_oldAnalysis != null &&  								ana == m_oldAnalysis.WfiAnalysis &&  								OnlyUsedThisOnce(ana) &&  								IsAnalysisHumanApproved(m_caches.MainCache' ana)"  is complex.
Complex Conditional,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,GetBestGloss,The conditional expression  "cMatch > cBestMatch  						|| (cMatch == cBestMatch && cBlanks > cBestBlanks)  						|| (cMatch == cBestMatch && cBlanks == cBestBlanks && best != null && AdditionalAlternatives(possibleGloss' wsIds) < AdditionalAlternatives(best' wsIds))"  is complex.
Complex Conditional,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,DoBasicFinding,The conditional expression  "(ichMin == 0 || fullForm[ichMin - 1] == ' ') &&  						(ichLim == fullForm.Length || fullForm[ichLim] == ' ')"  is complex.
Complex Conditional,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,IchLimOfMorphs,The conditional expression  "prevOffset != -1 && offset == prevOffset + 1 ||  						fBaseWordIsPhrase && offset == whiteSpaceOffsets[whiteSpaceOffsets.Count - 1]"  is complex.
Complex Conditional,SIL.FieldWorks.IText,TextsTriStateTreeView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TextsTriStateTreeView.cs,FillInChildren,The conditional expression  "(!(bookNode.Tag is IScrBook) && !(bookNode.Tag is int)) || bookNode.Nodes.Count != 1 || bookNode.Nodes[0].Name != ksDummyName"  is complex.
Virtual Method Call from Constructor,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,InterlinVc,The constructor "InterlinVc" calls a virtual method "GetSegmentLevelTags".
Virtual Method Call from Constructor,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SandboxBase,The constructor "SandboxBase" calls a virtual method "LoadForWordBundleAnalysis".
Empty Catch Block,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,GetMatchObject,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleSelectionChange,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,GetFiles,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,GetFile,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,GrabMousePtSelectionToTest,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,AddPaneBar,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,LoadDataFor,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.IText,RawTextPane,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\RawTextPane.cs,MakeTextSelectionAndScrollToView,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,MakeSelectionIcon,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,MakeSel,The method has an empty catch block.
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,GetPartOfPhrase,The following statement contains a magic number: foreach (var paragraph in interlinText.paragraphs)  			{  				foreach (var phrase in paragraph.phrases)  				{  					foreach (var word in phrase.WordsContent.Words)  					{  						strBldr.Append(word.Items[0].Value);  						strBldr.Append(" ");  						i++;  						if (i > 6)  						{  							strBldr.Append(" ...");  							return strBldr.ToString();  						}  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: Debug.Assert(parameters.Length == 3);
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: int startPhase = (int)parameters[2];
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: m_phaseProgressEnd = 150;
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: if (startPhase < 2)  			{  				dlg.Title = ITextStrings.ksLLImportProgress;  				dlg.Message = ITextStrings.ksLLImportPhase1;  				m_sErrorMsg = ITextStrings.ksTransformProblem1;  				if (!Convert1())  					return false;  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: m_progress.Step(150);
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: if (startPhase < 3)  			{  				m_sErrorMsg = ITextStrings.ksTransformProblem2;  				dlg.Message = ITextStrings.ksLLImportPhase2;  				if (!Convert2())  					return false;  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: m_progress.Step(75);
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: if (startPhase < 4)  			{  				m_sErrorMsg = ITextStrings.ksTransformProblem3;  				dlg.Message = ITextStrings.ksLLImportPhase3;  				if (!Convert3())  					return false;  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: m_progress.Step(25);
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: if (startPhase < 5)  			{  				m_sErrorMsg = ITextStrings.ksTransformProblem3A;  				if (!Convert4())  					return false;  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: m_progress.Step(25);
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: if (startPhase < 6)  			{  				m_sErrorMsg = ITextStrings.ksTransformProblem3B;  				if (!Convert5())  					return false;  				m_progress.Step(25);  			}  			else  			{  				m_progress.Step(75);  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: if (startPhase < 6)  			{  				m_sErrorMsg = ITextStrings.ksTransformProblem3B;  				if (!Convert5())  					return false;  				m_progress.Step(25);  			}  			else  			{  				m_progress.Step(75);  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: if (startPhase < 6)  			{  				m_sErrorMsg = ITextStrings.ksTransformProblem3B;  				if (!Convert5())  					return false;  				m_progress.Step(25);  			}  			else  			{  				m_progress.Step(75);  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Import,The following statement contains a magic number: if (runToCompletion)  			{  				m_sErrorMsg = ITextStrings.ksXMLParsingProblem4;  				dlg.Message = ITextStrings.ksLLImportPhase4;  				if (Convert6())  				{    					m_sErrorMsg = ITextStrings.ksFinishLLTextsProblem5;  					dlg.Message = ITextStrings.ksLLImportPhase5;  					m_shownProgress = m_phaseProgressStart = dlg.Position;  					m_phaseProgressEnd = 500;  					Convert7();  					return true;  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ImportInterlinear,The following statement contains a magic number: using (var stream = new FileStream((string) parameters[0]' FileMode.Open' FileAccess.Read))  			{  				LCModel.IText firstNewText = null;  				retValue = ImportInterlinear(dlg' stream' 100' ref firstNewText);  				FirstNewText = firstNewText;  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ImportInterlinear,The following statement contains a magic number: try  			{  				m_cache.DomainDataByFlid.BeginNonUndoableTask();  				progress.Message = ITextStrings.ksInterlinImportPhase1of2;  				var serializer = new XmlSerializer(typeof(BIRDDocument));  				doc = (BIRDDocument)serializer.Deserialize(birdData);  				Normalize(doc);  				int version = 0;  				if (!string.IsNullOrEmpty(doc.version))  					int.TryParse(doc.version' out version);  				progress.Position = initialProgress + allottedProgress / 2;  				progress.Message = ITextStrings.ksInterlinImportPhase2of2;  				if (doc.interlineartext != null)  				{  					int step = 0;  					foreach (var interlineartext in doc.interlineartext)  					{  						step++;  						ILangProject langProject = m_cache.LangProject;  						LCModel.IText newText = null;  						if (!String.IsNullOrEmpty(interlineartext.guid))  						{  							ICmObject repoObj;  							m_cache.ServiceLocator.ObjectRepository.TryGetObject(new Guid(interlineartext.guid)' out repoObj);  							newText = repoObj as LCModel.IText;  							if (newText != null && ShowPossibleMergeDialog(progress) == DialogResult.Yes)  							{  								continueMerge = MergeTextWithBIRDDoc(ref newText'  												new TextCreationParams  												{  													Cache = m_cache'  													InterlinText = interlineartext'  													Progress = progress'  													ImportOptions = options'  													Version = version  												});  							}  							else if (newText == null)  							{  								newText = m_cache.ServiceLocator.GetInstance<ITextFactory>().Create(m_cache' new Guid(interlineartext.guid));  								continueMerge = PopulateTextIfPossible(options' ref newText' interlineartext' progress' version);  							}  							else //user said do not merge.  							{  								//ignore the Guid; we shouldn't create another text with the same guid  								newText = m_cache.ServiceLocator.GetInstance<ITextFactory>().Create();  								continueMerge = PopulateTextIfPossible(options' ref newText' interlineartext' progress' version);  							}  						}  						else  						{  							newText = m_cache.ServiceLocator.GetInstance<ITextFactory>().Create();  							continueMerge = PopulateTextIfPossible(options' ref newText' interlineartext' progress' version);  						}  						if (!continueMerge)  							break;  						progress.Position = initialProgress + allottedProgress/2 + allottedProgress*step/2/doc.interlineartext.Length;  						if (firstNewText == null)  							firstNewText = newText;    					}  					mergeSucceeded = continueMerge;    				}  			}  			catch (Exception e)  			{  				Debug.Print(e.Message);  				Debug.Print(e.StackTrace);  			}  			finally  			{  				m_cache.DomainDataByFlid.EndNonUndoableTask();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ImportInterlinear,The following statement contains a magic number: try  			{  				m_cache.DomainDataByFlid.BeginNonUndoableTask();  				progress.Message = ITextStrings.ksInterlinImportPhase1of2;  				var serializer = new XmlSerializer(typeof(BIRDDocument));  				doc = (BIRDDocument)serializer.Deserialize(birdData);  				Normalize(doc);  				int version = 0;  				if (!string.IsNullOrEmpty(doc.version))  					int.TryParse(doc.version' out version);  				progress.Position = initialProgress + allottedProgress / 2;  				progress.Message = ITextStrings.ksInterlinImportPhase2of2;  				if (doc.interlineartext != null)  				{  					int step = 0;  					foreach (var interlineartext in doc.interlineartext)  					{  						step++;  						ILangProject langProject = m_cache.LangProject;  						LCModel.IText newText = null;  						if (!String.IsNullOrEmpty(interlineartext.guid))  						{  							ICmObject repoObj;  							m_cache.ServiceLocator.ObjectRepository.TryGetObject(new Guid(interlineartext.guid)' out repoObj);  							newText = repoObj as LCModel.IText;  							if (newText != null && ShowPossibleMergeDialog(progress) == DialogResult.Yes)  							{  								continueMerge = MergeTextWithBIRDDoc(ref newText'  												new TextCreationParams  												{  													Cache = m_cache'  													InterlinText = interlineartext'  													Progress = progress'  													ImportOptions = options'  													Version = version  												});  							}  							else if (newText == null)  							{  								newText = m_cache.ServiceLocator.GetInstance<ITextFactory>().Create(m_cache' new Guid(interlineartext.guid));  								continueMerge = PopulateTextIfPossible(options' ref newText' interlineartext' progress' version);  							}  							else //user said do not merge.  							{  								//ignore the Guid; we shouldn't create another text with the same guid  								newText = m_cache.ServiceLocator.GetInstance<ITextFactory>().Create();  								continueMerge = PopulateTextIfPossible(options' ref newText' interlineartext' progress' version);  							}  						}  						else  						{  							newText = m_cache.ServiceLocator.GetInstance<ITextFactory>().Create();  							continueMerge = PopulateTextIfPossible(options' ref newText' interlineartext' progress' version);  						}  						if (!continueMerge)  							break;  						progress.Position = initialProgress + allottedProgress/2 + allottedProgress*step/2/doc.interlineartext.Length;  						if (firstNewText == null)  							firstNewText = newText;    					}  					mergeSucceeded = continueMerge;    				}  			}  			catch (Exception e)  			{  				Debug.Print(e.Message);  				Debug.Print(e.StackTrace);  			}  			finally  			{  				m_cache.DomainDataByFlid.EndNonUndoableTask();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ImportInterlinear,The following statement contains a magic number: try  			{  				m_cache.DomainDataByFlid.BeginNonUndoableTask();  				progress.Message = ITextStrings.ksInterlinImportPhase1of2;  				var serializer = new XmlSerializer(typeof(BIRDDocument));  				doc = (BIRDDocument)serializer.Deserialize(birdData);  				Normalize(doc);  				int version = 0;  				if (!string.IsNullOrEmpty(doc.version))  					int.TryParse(doc.version' out version);  				progress.Position = initialProgress + allottedProgress / 2;  				progress.Message = ITextStrings.ksInterlinImportPhase2of2;  				if (doc.interlineartext != null)  				{  					int step = 0;  					foreach (var interlineartext in doc.interlineartext)  					{  						step++;  						ILangProject langProject = m_cache.LangProject;  						LCModel.IText newText = null;  						if (!String.IsNullOrEmpty(interlineartext.guid))  						{  							ICmObject repoObj;  							m_cache.ServiceLocator.ObjectRepository.TryGetObject(new Guid(interlineartext.guid)' out repoObj);  							newText = repoObj as LCModel.IText;  							if (newText != null && ShowPossibleMergeDialog(progress) == DialogResult.Yes)  							{  								continueMerge = MergeTextWithBIRDDoc(ref newText'  												new TextCreationParams  												{  													Cache = m_cache'  													InterlinText = interlineartext'  													Progress = progress'  													ImportOptions = options'  													Version = version  												});  							}  							else if (newText == null)  							{  								newText = m_cache.ServiceLocator.GetInstance<ITextFactory>().Create(m_cache' new Guid(interlineartext.guid));  								continueMerge = PopulateTextIfPossible(options' ref newText' interlineartext' progress' version);  							}  							else //user said do not merge.  							{  								//ignore the Guid; we shouldn't create another text with the same guid  								newText = m_cache.ServiceLocator.GetInstance<ITextFactory>().Create();  								continueMerge = PopulateTextIfPossible(options' ref newText' interlineartext' progress' version);  							}  						}  						else  						{  							newText = m_cache.ServiceLocator.GetInstance<ITextFactory>().Create();  							continueMerge = PopulateTextIfPossible(options' ref newText' interlineartext' progress' version);  						}  						if (!continueMerge)  							break;  						progress.Position = initialProgress + allottedProgress/2 + allottedProgress*step/2/doc.interlineartext.Length;  						if (firstNewText == null)  							firstNewText = newText;    					}  					mergeSucceeded = continueMerge;    				}  			}  			catch (Exception e)  			{  				Debug.Print(e.Message);  				Debug.Print(e.StackTrace);  			}  			finally  			{  				m_cache.DomainDataByFlid.EndNonUndoableTask();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,ProcessLanguageData,The following statement contains a magic number: if (buffer.Length > 0)  			{  				IEncConverter converter = null;  				string result = string.Empty;    				if (!string.IsNullOrEmpty(m_current.EncodingConverter))  				{  					converter = m_converters[m_current.EncodingConverter];  				}    				if (converter != null)  				{  					// Replace any make sure the &lt; &gt; &amp; and &quot;  					string[] specialEntities = new string[] { "&lt;"' "&gt;"' "&quot;"' "&amp;"};  					string[] actualXML = new string[] { "<"' ">"' "\""' "&"};  					bool[] replaced = new bool[] { false' false' false' false };  					bool anyReplaced = false;  					Debug.Assert(specialEntities.Length == actualXML.Length && actualXML.Length == replaced.Length' "Programming error...");    					StringBuilder sb = new StringBuilder(buffer);	// use a string builder for performance  					for (int i = 0; i < specialEntities.Length; i++)  					{  						if (buffer.Contains(specialEntities[i]))  						{  							replaced[i] = anyReplaced = true;  							sb = sb.Replace(specialEntities[i]' actualXML[i]);  						}  					}    					int len = sb.Length;	// buffer.Length;  					byte[] subData = new byte[len];  					for (int j = 0; j < len; j++)  					{  						subData[j] = (byte)sb[j];	// buffer[j];  					}    					try  					{  						result = converter.ConvertToUnicode(subData);  					}  					catch (System.Exception e)  					{  						ReportError(string.Format(ITextStrings.ksEncConvFailed'  							converter.Name' e.Message)' ITextStrings.ksLLEncConv);  					}    					// now put any of the four back to the Special Entity notation  					if (anyReplaced)	// only if we changed on input  					{  						sb = new StringBuilder(result);  						for (int i = specialEntities.Length-1; i >= 0; i--)  						{  							if (replaced[i])  							{  								sb = sb.Replace(actualXML[i]' specialEntities[i]);  							}  						}  						result = sb.ToString();  					}  				}  				else  				{  					result = buffer;  				}  				for (int j = 0; j < result.Length; j++)  				{  					if (128 > (ushort)result[j])  					{  						//0XXX XXXX  						bw.Write((byte)result[j]);  					}  					else if (2048 > (ushort)result[j])  					{  						//110X XXXX 10XX XXXX  						bw.Write((byte)(192 + ((ushort)result[j]) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  					else  					{  						//1110 XXXX 10XX XXXX 10XX XXXX}  						bw.Write((byte)(224 + ((ushort)result[j]) / 4096));  						bw.Write((byte)(128 + (((ushort)result[j]) & 4095) / 64));  						bw.Write((byte)(128 + (((ushort)result[j]) & 63)));  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,InitializeSearches,The following statement contains a magic number: searches[2] = "<AUni";
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,InitializeSearches,The following statement contains a magic number: searches[3] = "<ReversalIndexEntry";
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,InitializeSearches,The following statement contains a magic number: searches[4] = "<AStr";
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,InitializeSearches,The following statement contains a magic number: searches[5] = "<Link ";
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,InitializeSearches,The following statement contains a magic number: searches[6] = "<ICULocale24>";
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,InitializeSearches,The following statement contains a magic number: searches[7] = "<!DOCTYPE";
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: const int maxSearch = 8;
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,Convert1,The following statement contains a magic number: using (FileStream fsi = new FileStream(m_nextInput' FileMode.Open' FileAccess.Read)'  				fso = new FileStream(m_sTempDir + "LLPhase1Output.xml"' FileMode.Create' FileAccess.Write))  			{  				using (BinaryReader br = new BinaryReader(fsi))  				{  					using (BinaryWriter bw = new BinaryWriter(fso))  					{  						buffer = string.Empty;  						searchBuffer = string.Empty;  						rieBufferXML = string.Empty;  						rieBufferLangData = string.Empty;    						for (int i = 0; i < m_languageMappings.Length; i++)  						{  							LanguageMapping mapping = m_languageMappings[i];  							if (mapping.FwName == ITextStrings.ksIgnore || mapping.FwCode == string.Empty)  							{  								mapping.FwName = "zzzIgnore";  								mapping.FwCode = "zzzIgnore";  							}  						}      						//Start  						mode = modes.kStart;  						InitializeSearches(searches);  						for (j = 0; j < maxSearch; j++)  						{  							locs[j] = 0;  						}  						bufferIt = false;    						while (okay && fsi.Position < fsi.Length)  						{  							int m_currentProgress = m_phaseProgressStart + (int)Math.Floor((double)((m_phaseProgressEnd  								- m_phaseProgressStart) * fsi.Position / fsi.Length));  							if (m_currentProgress > m_shownProgress && m_currentProgress <= m_phaseProgressEnd)  							{  								m_progress.Step(m_currentProgress - m_shownProgress);  								m_shownProgress = m_currentProgress;  							}  							c = (char)br.ReadByte();  							found = false;  							int TempDiff = 0;  							for (j = 0; j < maxSearch; j++)  							{  								if (c == searches[j][locs[j]])  								{  									found = true;  									locs[j]++;  									if (locs[j] > TempDiff)  									{  										TempDiff = locs[j];  									}  								}  								else  								{  									locs[j] = 0;  								}  							}  							if (found)  							{  								searchBuffer += c;  								TempDiff = searchBuffer.Length - TempDiff;  								if (TempDiff > 0)  								{  									ProcessSearchBuffer(searchBuffer' TempDiff' bufferIt' ref buffer' bw);  									searchBuffer = searchBuffer.Substring(TempDiff' searchBuffer.Length - TempDiff);  								}  								if ((locs[0] == searches[0].Length) && (locs[0] == searchBuffer.Length))  								{  									string s = string.Format(ITextStrings.ksExpectedXButGotY' searches[1]' searches[0]);  									ReportError(s' ITextStrings.ksLLEncConv);  									s = "</Error>Parsing Error.  " + s;    									for (j = 0; j < s.Length; j++)  									{  										bw.Write((byte)s[j]);  									}  									bw.Close();  									fso.Close();  									okay = false;  								}  								else if ((locs[1] == searches[1].Length) && (locs[1] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Run  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "ws=\"";  										mode = modes.kRun1;  									}  									else if (mode == modes.kRun1)  									{  										// <Run ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = "\"";  										mode = modes.kRun2;  									}  									else if (mode == modes.kRun2)  									{  										// <Run ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Run>";  										searches[1] = ">";  										mode = modes.kRun3;  									}  									else if (mode == modes.kRun3)  									{  										// <Run ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "</Run>";  										mode = modes.kRun4;  									}  									else if (mode == modes.kRun4)  									{  										// <Run ws="en">Data</Run>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAUni1)  									{  										// <AUni ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "\"";  										mode = modes.kAUni2;  									}  									else if (mode == modes.kAUni2)  									{  										// <AUni ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = ">";  										mode = modes.kAUni3;  									}  									else if (mode == modes.kAUni3)  									{  										// <AUni ws="en">  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<AUni>";  										searches[1] = "</AUni>";  										mode = modes.kAUni4;  									}  									else if (mode == modes.kAUni4)  									{  										// <AUni ws="en">Data</AUni>  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kAStr1)  									{  										// <AStr ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "\"";  										mode = modes.kAStr2;  									}  									else if (mode == modes.kAStr2)  									{  										// <AStr ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = ">";  										mode = modes.kAStr3;  									}  									else if (mode == modes.kAStr3)  									{  										// <AStr ws="en">  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "</Uni>";  										mode = modes.kRIE2;  									}  									else if (mode == modes.kRIE2)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni>  										rieBufferLangData = buffer;  										bufferIt = true;  										buffer = string.Empty;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<WritingSystem5053>";  										mode = modes.kRIE3;  									}  									else if (mode == modes.kRIE3)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053>  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ReversalIndexEntry>";  										searches[1] = "<Link";  										mode = modes.kRIE4;  									}  									else if (mode == modes.kRIE4)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "ws=\"";  										mode = modes.kRIE5;  									}  									else if (mode == modes.kRIE5)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <ws="  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										rieBufferXML = buffer;  										buffer = string.Empty;  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</WritingSystem5053>";  										searches[1] = "\"";  										mode = modes.kRIE6;  									}  									else if (mode == modes.kRIE6)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en"  										ProcessLanguageCode2(buffer);  										if (m_current.FwCode != null)  											rieBufferXML += m_current.FwCode;  										ProcessLanguageData(rieBufferLangData' bw);  										bufferIt = false;  										ProcessSearchBuffer(rieBufferXML' rieBufferXML.Length' bufferIt' ref buffer' bw);  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</Entries5052>";  										searches[1] = "</WritingSystem5053>";  										mode = modes.kRIE7;  									}  									else if (mode == modes.kRIE7)  									{  										// <ReversalIndexEntry ... <Uni>Data</Uni> ... <WritingSystem5053> ... <Link ws="en" ... </WritingSystem5053>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" ws="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink2;  									}  									else if (mode == modes.kLink2)  									{  										// <Link target="XXXXXXX" ws="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLink3)  									{  										// <Link target="XXXXXXX" ws="en" form="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLink4;  									}  									else if (mode == modes.kLink4)  									{  										// <Link target="XXXXXXX" ws="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										mode = modes.kLink3;  									}  									else if (mode == modes.kLinkA2)  									{  										// <Link target="XXXXXXX" wsa="en"  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA4;  									}  									else if (mode == modes.kLinkA4)  									{  										// <Link target="XXXXXXX" wsa="en" form="Data"  										ProcessLanguageData(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "\"";  										searches[2] = "/>";  										searches[3] = "wsv=\"";  										mode = modes.kLinkA3;  									}  									else if (mode == modes.kICU1)  									{  										// <ICULocale24> <Uni>  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "</Uni>";  										mode = modes.kICU2;  									}  									else if (mode == modes.kICU2)  									{  										// <ICULocale24> <Uni>en</Uni>  										ProcessLanguageCode(buffer' bw);  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kDtd)  									{  										// <!DOCTYPE ... >  										ProcessSearchBuffer(searchBuffer' locs[1]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[2] == searches[2].Length) && (locs[2] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AUni  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</AUni>";  										searches[1] = "ws=\"";  										mode = modes.kAUni1;  									}  									else if ((mode == modes.kLink1) || (mode == modes.kLink3) || (mode == modes.kLinkA3))  									{  										// <Link ... /> or <Link ... ws="en" ... />  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									else if (mode == modes.kRIE1)  									{  										// <ReversalIndexEntry ... </ReversalIndexEntry>  										bufferIt = false;  										ProcessSearchBuffer(searchBuffer' locs[2]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										InitializeSearches(searches);  										mode = modes.kStart;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[3] == searches[3].Length) && (locs[3] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ReversalIndexEntry  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "<Uni>";  										searches[2] = "</ReversalIndexEntry>";  										mode = modes.kRIE1;  									}  									else if (mode == modes.kLink1)  									{  										// <Link target="XXXXXXX" wsa="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									else if (mode == modes.kLinkA3)  									{  										// <Link target="XXXXXXX" wsa="en" abbr="llcr" wsv="  										ProcessSearchBuffer(searchBuffer' locs[3]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = true;  										buffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "/>";  										searches[1] = "\"";  										mode = modes.kLinkA2;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[4] == searches[4].Length) && (locs[4] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <AStr  										ProcessSearchBuffer(searchBuffer' locs[4]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<Run>";  										searches[1] = "ws=\"";  										mode = modes.kAStr1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[5] == searches[5].Length) && (locs[5] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <Link  										ProcessSearchBuffer(searchBuffer' locs[5]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[1] = "ws=\"";  										searches[2] = "/>";  										searches[3] = "wsa=\"";  										mode = modes.kLink1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[6] == searches[6].Length) && (locs[6] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <ICULocale24>  										ProcessSearchBuffer(searchBuffer' locs[6]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										bufferIt = false;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "</ICULocale24>";  										searches[1] = "<Uni>";  										mode = modes.kICU1;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  								else if ((locs[7] == searches[7].Length) && (locs[7] == searchBuffer.Length))  								{  									if (mode == modes.kStart)  									{  										// <!DOCTYPE  										bufferIt = true;  										ProcessSearchBuffer(searchBuffer' locs[7]' bufferIt' ref buffer' bw);  										searchBuffer = string.Empty;  										for (j = 0; j < maxSearch; j++)  										{  											searches[j] = ">Dummy>";  										}  										searches[0] = "<";  										searches[1] = ">";  										mode = modes.kDtd;  									}  									for (j = 0; j < maxSearch; j++)  									{  										locs[j] = 0;  									}  								}  							}  							else  							{  								if (searchBuffer.Length > 0)  								{  									ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  									searchBuffer = string.Empty;  								}  								if (bufferIt)  								{  									buffer += c;  								}  								else  								{  									bw.Write((byte)c);  								}  							}  						}  						if (okay)  						{  							if (searchBuffer.Length > 0)  							{  								ProcessSearchBuffer(searchBuffer' searchBuffer.Length' bufferIt' ref buffer' bw);  							}  							bw.Close();  							br.Close();  							fsi.Close();  							fso.Close();  							m_nextInput = m_sTempDir + "LLPhase1Output.xml";  						}  						return okay;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,DoTransform,The following statement contains a magic number: try  			{  				Encoding Utf8 = new UTF8Encoding(false);    				//Create the XslTransform and load the stylesheet.  				XslCompiledTransform xslt = new XslCompiledTransform();  				xslt.Load(xsl' XsltSettings.TrustedXslt' null);    				//Load the XML data file.  				XPathDocument doc = new XPathDocument(xml);    				//Create an XmlTextWriter to output to the appropriate file. First make sure the expected  				//directory exists.  				if (!Directory.Exists(Path.GetDirectoryName(outputName)))  					Directory.CreateDirectory(Path.GetDirectoryName(outputName));  				File.Delete(outputName); // prevents re-importing the previous file if first step fails.  				using (var writer = new XmlTextWriter(outputName' Utf8))  				{  					writer.Formatting = Formatting.Indented;  					writer.Indentation = 2;    					//Transform the file.  					xslt.Transform(doc.CreateNavigator()' null' writer);  					writer.Close();  					return true;  				}  			}  			catch (Exception ex)  			{  				// For some reason during debugging of LLImportPhase1.xsl we hit an exception here  				// with an error saying "Common Language Runtime detected an invalid program".  				// It seems to be choking over the ThesaurusItems5016 template. Yet when the program  				//  is run outside the debugger' it doesn't hit this. The transform also works fine via MSXSL.???  				ReportError(ex.Message' ITextStrings.ksLLEncConv);  				//Console.WriteLine("{0} Exception caught."' ex);  				//Console.ReadLine();  				return false; // LT-7223 transform was failing with an invalid character and then going on!  			}
Magic Number,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,MakeSimpleString,The following statement contains a magic number: bldr.SetIntPropValues((int)FwTextPropType.ktptFontSize'  				(int)FwTextPropVar.ktpvMilliPoint' s_baseFontSize * 800);
Magic Number,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,FormTextProperties,The following statement contains a magic number: if (!fUseStyleSheet)  			{  				bldr.SetIntPropValues((int)FwTextPropType.ktptFontSize '  					(int)FwTextPropVar.ktpvMilliPoint' s_baseFontSize * 1000);  			}
Magic Number,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,GlossTextProperties,The following statement contains a magic number: if (!fUseStyleSheet)  			{  				bldr.SetIntPropValues((int)FwTextPropType.ktptFontSize '  					(int)FwTextPropVar.ktpvMilliPoint' s_baseFontSize * 1000);  			}
Magic Number,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,PartOfSpeechTextProperties,The following statement contains a magic number: if (!fUseStyleSheet)  			{  				bldr.SetIntPropValues((int)FwTextPropType.ktptFontSize '  					(int)FwTextPropVar.ktpvMilliPoint' (int)( s_baseFontSize * 1000* .8));  			}
Magic Number,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,PartOfSpeechTextProperties,The following statement contains a magic number: if (!fUseStyleSheet)  			{  				bldr.SetIntPropValues((int)FwTextPropType.ktptFontSize '  					(int)FwTextPropVar.ktpvMilliPoint' (int)( s_baseFontSize * 1000* .8));  			}
Magic Number,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,Activate,The following statement contains a magic number: if (combo != null)  			{    				combo.Location = new System.Drawing.Point(loc.left' loc.top);  				// 21 is the default height of a combo' the smallest reasonable size.  				combo.Size = new System.Drawing.Size(Math.Max(loc.right - loc.left + 30' 200)' Math.Max( loc.bottom - loc.top' 50));  				if (!m_owner.Controls.Contains(combo))  					m_owner.Controls.Add(combo);  			}  			else  			{  				ComboListBox c = (m_combo as ComboListBox);  				c.AdjustSize(500' 400); // these are maximums!  				c.Launch(m_owner.RectangleToScreen(loc)' Screen.GetWorkingArea(m_owner));  			}
Magic Number,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,Activate,The following statement contains a magic number: if (combo != null)  			{    				combo.Location = new System.Drawing.Point(loc.left' loc.top);  				// 21 is the default height of a combo' the smallest reasonable size.  				combo.Size = new System.Drawing.Size(Math.Max(loc.right - loc.left + 30' 200)' Math.Max( loc.bottom - loc.top' 50));  				if (!m_owner.Controls.Contains(combo))  					m_owner.Controls.Add(combo);  			}  			else  			{  				ComboListBox c = (m_combo as ComboListBox);  				c.AdjustSize(500' 400); // these are maximums!  				c.Launch(m_owner.RectangleToScreen(loc)' Screen.GetWorkingArea(m_owner));  			}
Magic Number,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,Activate,The following statement contains a magic number: if (combo != null)  			{    				combo.Location = new System.Drawing.Point(loc.left' loc.top);  				// 21 is the default height of a combo' the smallest reasonable size.  				combo.Size = new System.Drawing.Size(Math.Max(loc.right - loc.left + 30' 200)' Math.Max( loc.bottom - loc.top' 50));  				if (!m_owner.Controls.Contains(combo))  					m_owner.Controls.Add(combo);  			}  			else  			{  				ComboListBox c = (m_combo as ComboListBox);  				c.AdjustSize(500' 400); // these are maximums!  				c.Launch(m_owner.RectangleToScreen(loc)' Screen.GetWorkingArea(m_owner));  			}
Magic Number,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,Activate,The following statement contains a magic number: if (combo != null)  			{    				combo.Location = new System.Drawing.Point(loc.left' loc.top);  				// 21 is the default height of a combo' the smallest reasonable size.  				combo.Size = new System.Drawing.Size(Math.Max(loc.right - loc.left + 30' 200)' Math.Max( loc.bottom - loc.top' 50));  				if (!m_owner.Controls.Contains(combo))  					m_owner.Controls.Add(combo);  			}  			else  			{  				ComboListBox c = (m_combo as ComboListBox);  				c.AdjustSize(500' 400); // these are maximums!  				c.Launch(m_owner.RectangleToScreen(loc)' Screen.GetWorkingArea(m_owner));  			}
Magic Number,SIL.FieldWorks.IText,ChooseAnalysisHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseAnalysisHander.cs,Activate,The following statement contains a magic number: if (combo != null)  			{    				combo.Location = new System.Drawing.Point(loc.left' loc.top);  				// 21 is the default height of a combo' the smallest reasonable size.  				combo.Size = new System.Drawing.Size(Math.Max(loc.right - loc.left + 30' 200)' Math.Max( loc.bottom - loc.top' 50));  				if (!m_owner.Controls.Contains(combo))  					m_owner.Controls.Add(combo);  			}  			else  			{  				ComboListBox c = (m_combo as ComboListBox);  				c.AdjustSize(500' 400); // these are maximums!  				c.Launch(m_owner.RectangleToScreen(loc)' Screen.GetWorkingArea(m_owner));  			}
Magic Number,SIL.FieldWorks.IText,ChooseTextWritingSystemDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseTextWritingSystemDlg.cs,InitializeComponent,The following statement contains a magic number: this.label2.MaximumSize = new System.Drawing.Size(320' 78);
Magic Number,SIL.FieldWorks.IText,ChooseTextWritingSystemDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ChooseTextWritingSystemDlg.cs,InitializeComponent,The following statement contains a magic number: this.label2.MaximumSize = new System.Drawing.Size(320' 78);
Magic Number,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,RemoveItemsRequested,The following statement contains a magic number: if (parent != null && index != -1)  			{  				if (!parent.IsLeaf)  				{  					bool isFirstBdry = parent.Children[0] is ComplexConcWordBdryNode;  					if ((parent.Children.Count == 1 && isFirstBdry)  						|| (parent.Children.Count > 1 && isFirstBdry && !(parent.Children[1] is ComplexConcMorphNode)))  					{  						parent.Children.RemoveAt(0);  						if (index > 0)  							index--;  					}  				}  				if (parent.Children.Count > 1 && parent.Children[parent.Children.Count - 1] is ComplexConcWordBdryNode  					&& !(parent.Children[parent.Children.Count - 2] is ComplexConcMorphNode))  				{  					parent.Children.RemoveAt(parent.Children.Count - 1);  					if (index >= parent.Children.Count)  						index--;  				}  				for (int i = parent.Children.Count - 1; i > 0 ; i--)  				{  					if (parent.Children[i] is ComplexConcWordBdryNode)  					{  						if (parent.Children[i - 1] is ComplexConcWordBdryNode  							|| (!(parent.Children[i - 1] is ComplexConcMorphNode) || (i + 1 < parent.Children.Count && !(parent.Children[i + 1] is ComplexConcMorphNode))))  						{  							parent.Children.RemoveAt(i);  							if (index > i)  								index--;  						}  					}  				}    				if (!parent.IsLeaf && parent.Children[0] is ComplexConcOrNode)  				{  					parent.Children.RemoveAt(0);  					if (index > 0)  						index--;  				}  				if (!parent.IsLeaf && parent.Children[parent.Children.Count - 1] is ComplexConcOrNode)  				{  					parent.Children.RemoveAt(parent.Children.Count - 1);  					if (index >= parent.Children.Count)  						index--;  				}  				for (int i = parent.Children.Count - 1; i > 0 ; i--)  				{  					if (parent.Children[i] is ComplexConcOrNode && parent.Children[i - 1] is ComplexConcOrNode)  					{  						parent.Children.RemoveAt(i);  						if (index > i)  							index--;  					}  				}    				if (parent.Parent != null && parent.Children.Count == 1)  				{  					ComplexConcPatternNode p = parent.Parent;  					int parentIndex = GetNodeIndex(parent);  					p.Children.RemoveAt(parentIndex);  					p.Children.Insert(parentIndex' parent.Children[0]);  					index = index == 1 ? parentIndex + 1 : parentIndex;  				}  				else  				{  					while (parent.Parent != null && parent.IsLeaf)  					{  						ComplexConcPatternNode p = parent.Parent;  						index = GetNodeIndex(parent);  						p.Children.Remove(parent);  						parent = p;  					}  				}    				if (index >= parent.Children.Count)  					ReconstructView(parent' parent.Children.Count - 1' false);  				else  					ReconstructView(parent' index' true);  			}
Magic Number,SIL.FieldWorks.IText,ComplexConcMorphDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcMorphDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_categoryComboBox.DropDownWidth = 120;
Magic Number,SIL.FieldWorks.IText,ComplexConcTagDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcTagDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_tagComboBox.DropDownWidth = 120;
Magic Number,SIL.FieldWorks.IText,ComplexConcWordDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcWordDlg.cs,InitializeComponent,The following statement contains a magic number: this.m_categoryComboBox.DropDownWidth = 120;
Magic Number,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,SearchForMatches,The following statement contains a magic number: using (new WaitCursor(this))  			{  #if WANTPORT // FWR-2830 ConcordanceItemsVh no longer exists' we should display progress somehow though.  				if (ConcordanceItemsVh.Progress is NullProgressState)  				{  					ConcordanceItemsVh.Progress = FwXWindow.CreateMilestoneProgressState(m_mediator);  					fCreatedProgressState = true;  				}  #endif  				string sMatch = m_tbSearchText.Visible ? m_tbSearchText.Text.Trim() : m_cbSearchText.SelectedItem.ToString();  				if (sMatch.Length == 0)  					return new List<IParaFragment>();  				if (sMatch.Length > 1000)  				{  					sMatch = sMatch.Substring(0' 1000);  					MessageBox.Show(ITextStrings.ksMatchStringTooLong' ITextStrings.ksWarning);  					m_tbSearchText.Text = sMatch;  				}  				int ws = ((CoreWritingSystemDefinition) m_cbWritingSystem.SelectedItem).Handle;    				var conc = (ConcordLine) m_cbLine.SelectedItem;  				switch (conc.Line)  				{  					case ConcordanceLines.kBaseline:  						occurrences = UpdateConcordanceForBaseline(ws);  						break;  					case ConcordanceLines.kWord:  						occurrences = UpdateConcordanceForWord(ws);  						break;  					case ConcordanceLines.kMorphemes:  						occurrences = UpdateConcordanceForMorphemes(ws);  						break;  					case ConcordanceLines.kLexEntry:  						occurrences = UpdateConcordanceForLexEntry(ws);  						break;  					case ConcordanceLines.kLexGloss:  						occurrences = UpdateConcordanceForLexGloss(ws);  						break;  					case ConcordanceLines.kWordGloss:  						occurrences = UpdateConcordanceForWordGloss(ws);  						break;  					case ConcordanceLines.kFreeTranslation:  						occurrences = UpdateConcordanceForFreeTranslation(ws);  						break;  					case ConcordanceLines.kLiteralTranslation:  						occurrences = UpdateConcordanceForLiteralTranslation(ws);  						break;  					case ConcordanceLines.kNote:  						occurrences = UpdateConcordanceForNote(ws);  						break;  					case ConcordanceLines.kGramCategory:  						occurrences = UpdateConcordanceForGramInfo(ws);  						break;  					case ConcordanceLines.kWordCategory:  						occurrences = UpdateConcordanceForWordCategory(ws);  						break;  					case ConcordanceLines.kTags:  						occurrences = UpdateConcordanceForTag(ws);  						break;  					default:  						occurrences = new List<IParaFragment>();  						break;  				}  			}
Magic Number,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,SearchForMatches,The following statement contains a magic number: using (new WaitCursor(this))  			{  #if WANTPORT // FWR-2830 ConcordanceItemsVh no longer exists' we should display progress somehow though.  				if (ConcordanceItemsVh.Progress is NullProgressState)  				{  					ConcordanceItemsVh.Progress = FwXWindow.CreateMilestoneProgressState(m_mediator);  					fCreatedProgressState = true;  				}  #endif  				string sMatch = m_tbSearchText.Visible ? m_tbSearchText.Text.Trim() : m_cbSearchText.SelectedItem.ToString();  				if (sMatch.Length == 0)  					return new List<IParaFragment>();  				if (sMatch.Length > 1000)  				{  					sMatch = sMatch.Substring(0' 1000);  					MessageBox.Show(ITextStrings.ksMatchStringTooLong' ITextStrings.ksWarning);  					m_tbSearchText.Text = sMatch;  				}  				int ws = ((CoreWritingSystemDefinition) m_cbWritingSystem.SelectedItem).Handle;    				var conc = (ConcordLine) m_cbLine.SelectedItem;  				switch (conc.Line)  				{  					case ConcordanceLines.kBaseline:  						occurrences = UpdateConcordanceForBaseline(ws);  						break;  					case ConcordanceLines.kWord:  						occurrences = UpdateConcordanceForWord(ws);  						break;  					case ConcordanceLines.kMorphemes:  						occurrences = UpdateConcordanceForMorphemes(ws);  						break;  					case ConcordanceLines.kLexEntry:  						occurrences = UpdateConcordanceForLexEntry(ws);  						break;  					case ConcordanceLines.kLexGloss:  						occurrences = UpdateConcordanceForLexGloss(ws);  						break;  					case ConcordanceLines.kWordGloss:  						occurrences = UpdateConcordanceForWordGloss(ws);  						break;  					case ConcordanceLines.kFreeTranslation:  						occurrences = UpdateConcordanceForFreeTranslation(ws);  						break;  					case ConcordanceLines.kLiteralTranslation:  						occurrences = UpdateConcordanceForLiteralTranslation(ws);  						break;  					case ConcordanceLines.kNote:  						occurrences = UpdateConcordanceForNote(ws);  						break;  					case ConcordanceLines.kGramCategory:  						occurrences = UpdateConcordanceForGramInfo(ws);  						break;  					case ConcordanceLines.kWordCategory:  						occurrences = UpdateConcordanceForWordCategory(ws);  						break;  					case ConcordanceLines.kTags:  						occurrences = UpdateConcordanceForTag(ws);  						break;  					default:  						occurrences = new List<IParaFragment>();  						break;  				}  			}
Magic Number,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,MaxConcordanceMatches,The following statement contains a magic number: return 10000;
Magic Number,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,SetDefaultVisibilityOfItems,The following statement contains a magic number: if (fDefault)  			{  				m_lblTop.Text = ITextStrings.ksToSpecifyAConcordance_;  				m_lnkSpecify.Text = ITextStrings.ksBackToConcordedItem;  				m_lnkSpecify.Enabled = m_lnkSpecify.Visible = (m_hvoMatch != 0);  			}  			else  			{  				m_lblTop.Text = String.Format(ITextStrings.ksConcordedOn0' sConcordedOn);  				m_lnkSpecify.Text = ITextStrings.ksSpecifyConcordanceCriteria_;  				m_lnkSpecify.Enabled = m_lnkSpecify.Visible = true;  				m_fwtbItem.Location = new Point(m_lblTop.Location.X + m_lblTop.Width + 10' m_lblTop.Location.Y);  				m_fwtbItem.BorderStyle = BorderStyle.None;  			}
Magic Number,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,InitializeComponent,The following statement contains a magic number: this.m_cbSearchText.DropDownWidth = 120;
Magic Number,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,Display,The following statement contains a magic number: switch (frag)  			{  				case kfragPattern:  					VwLength tableLen;  					tableLen.nVal = 10000;  					tableLen.unit = VwUnit.kunPercent100;  					vwenv.OpenTable(1' tableLen' 0' VwAlignment.kvaCenter' VwFramePosition.kvfpVoid' VwRule.kvrlNone' 0' 0' false);  					VwLength patternLen;  					patternLen.nVal = 1;  					patternLen.unit = VwUnit.kunRelative;  					vwenv.MakeColumns(1' patternLen);  					vwenv.OpenTableBody();  					vwenv.OpenTableRow();    					vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom' (int)FwTextPropVar.ktpvMilliPoint' 1000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptBorderColor' (int)FwTextPropVar.ktpvDefault' (int)ColorUtil.ConvertColorToBGR(Color.Gray));  					vwenv.set_IntProperty((int)FwTextPropType.ktptAlign' (int)FwTextPropVar.ktpvEnum' (int)FwTextAlign.ktalCenter);  					vwenv.set_IntProperty((int)FwTextPropType.ktptPadBottom' (int)FwTextPropVar.ktpvMilliPoint' 2000);  					vwenv.OpenTableCell(1' 1);  					vwenv.OpenParagraph();  					if (((ComplexConcPatternSda) vwenv.DataAccess).Root.IsLeaf)  					{  						OpenSingleLinePile(vwenv' GetMaxNumLines(vwenv)' false);  						vwenv.Props = m_bracketProps;  						vwenv.AddProp(ComplexConcPatternSda.ktagChildren' this' kfragEmpty);  						CloseSingleLinePile(vwenv' false);  					}  					else  					{  						vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);  					}  					vwenv.CloseParagraph();  					vwenv.CloseTableCell();    					vwenv.CloseTableRow();  					vwenv.CloseTableBody();  					vwenv.CloseTable();  					break;    				case kfragNode:  					ComplexConcPatternNode node = ((ComplexConcPatternSda) vwenv.DataAccess).Nodes[hvo];  					int maxNumLines = GetMaxNumLines(vwenv);  					if (node is ComplexConcOrNode)  					{  						OpenSingleLinePile(vwenv' maxNumLines);  						vwenv.AddProp(ktagInnerNonBoundary' this' kfragOR);  						CloseSingleLinePile(vwenv' false);  					}  					else if (node is ComplexConcWordBdryNode)  					{  						OpenSingleLinePile(vwenv' maxNumLines);  						vwenv.AddProp(ktagInnerNonBoundary' this' kfragHash);  						CloseSingleLinePile(vwenv);  					}  					else if (node is ComplexConcGroupNode)  					{  						int numLines = GetNumLines(node);  						bool hasMinMax = node.Maximum != 1 || node.Minimum != 1;  						if (numLines == 1)  						{  							OpenSingleLinePile(vwenv' maxNumLines' false);  							// use normal parentheses for a single line group  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftParen);    							vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);    							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightParen);  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  							CloseSingleLinePile(vwenv' false);  						}  						else  						{  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginLeading' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagLeftNonBoundary' vwenv);  							vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftParenUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftParenExt);  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftParenLowHook);  							vwenv.CloseInnerPile();    							vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);    							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' vwenv);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightParenUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightParenExt);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightParenLowHook);  							vwenv.CloseInnerPile();  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  						}  					}  					else  					{  						bool hasMinMax = node.Maximum != 1 || node.Minimum != 1;  						int numLines = GetNumLines(node);  						if (numLines == 1)  						{  							OpenSingleLinePile(vwenv' maxNumLines' false);  							// use normal brackets for a single line constraint  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftBracket);    							DisplayFeatures(vwenv' node);    							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightBracket);  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  							CloseSingleLinePile(vwenv' false);  						}  						else  						{  							// left bracket pile  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginLeading' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagLeftNonBoundary' vwenv);  							vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftBracketUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftBracketExt);  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftBracketLowHook);  							vwenv.CloseInnerPile();    							// feature pile  							vwenv.set_IntProperty((int) FwTextPropType.ktptAlign' (int) FwTextPropVar.ktpvEnum' (int) FwTextAlign.ktalLeft);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagInnerNonBoundary' vwenv);  							DisplayFeatures(vwenv' node);  							vwenv.CloseInnerPile();    							// right bracket pile  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' vwenv);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightBracketUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightBracketExt);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightBracketLowHook);  							vwenv.CloseInnerPile();  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  						}  					}  					break;  			}
Magic Number,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,Display,The following statement contains a magic number: switch (frag)  			{  				case kfragPattern:  					VwLength tableLen;  					tableLen.nVal = 10000;  					tableLen.unit = VwUnit.kunPercent100;  					vwenv.OpenTable(1' tableLen' 0' VwAlignment.kvaCenter' VwFramePosition.kvfpVoid' VwRule.kvrlNone' 0' 0' false);  					VwLength patternLen;  					patternLen.nVal = 1;  					patternLen.unit = VwUnit.kunRelative;  					vwenv.MakeColumns(1' patternLen);  					vwenv.OpenTableBody();  					vwenv.OpenTableRow();    					vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom' (int)FwTextPropVar.ktpvMilliPoint' 1000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptBorderColor' (int)FwTextPropVar.ktpvDefault' (int)ColorUtil.ConvertColorToBGR(Color.Gray));  					vwenv.set_IntProperty((int)FwTextPropType.ktptAlign' (int)FwTextPropVar.ktpvEnum' (int)FwTextAlign.ktalCenter);  					vwenv.set_IntProperty((int)FwTextPropType.ktptPadBottom' (int)FwTextPropVar.ktpvMilliPoint' 2000);  					vwenv.OpenTableCell(1' 1);  					vwenv.OpenParagraph();  					if (((ComplexConcPatternSda) vwenv.DataAccess).Root.IsLeaf)  					{  						OpenSingleLinePile(vwenv' GetMaxNumLines(vwenv)' false);  						vwenv.Props = m_bracketProps;  						vwenv.AddProp(ComplexConcPatternSda.ktagChildren' this' kfragEmpty);  						CloseSingleLinePile(vwenv' false);  					}  					else  					{  						vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);  					}  					vwenv.CloseParagraph();  					vwenv.CloseTableCell();    					vwenv.CloseTableRow();  					vwenv.CloseTableBody();  					vwenv.CloseTable();  					break;    				case kfragNode:  					ComplexConcPatternNode node = ((ComplexConcPatternSda) vwenv.DataAccess).Nodes[hvo];  					int maxNumLines = GetMaxNumLines(vwenv);  					if (node is ComplexConcOrNode)  					{  						OpenSingleLinePile(vwenv' maxNumLines);  						vwenv.AddProp(ktagInnerNonBoundary' this' kfragOR);  						CloseSingleLinePile(vwenv' false);  					}  					else if (node is ComplexConcWordBdryNode)  					{  						OpenSingleLinePile(vwenv' maxNumLines);  						vwenv.AddProp(ktagInnerNonBoundary' this' kfragHash);  						CloseSingleLinePile(vwenv);  					}  					else if (node is ComplexConcGroupNode)  					{  						int numLines = GetNumLines(node);  						bool hasMinMax = node.Maximum != 1 || node.Minimum != 1;  						if (numLines == 1)  						{  							OpenSingleLinePile(vwenv' maxNumLines' false);  							// use normal parentheses for a single line group  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftParen);    							vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);    							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightParen);  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  							CloseSingleLinePile(vwenv' false);  						}  						else  						{  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginLeading' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagLeftNonBoundary' vwenv);  							vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftParenUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftParenExt);  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftParenLowHook);  							vwenv.CloseInnerPile();    							vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);    							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' vwenv);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightParenUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightParenExt);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightParenLowHook);  							vwenv.CloseInnerPile();  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  						}  					}  					else  					{  						bool hasMinMax = node.Maximum != 1 || node.Minimum != 1;  						int numLines = GetNumLines(node);  						if (numLines == 1)  						{  							OpenSingleLinePile(vwenv' maxNumLines' false);  							// use normal brackets for a single line constraint  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftBracket);    							DisplayFeatures(vwenv' node);    							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightBracket);  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  							CloseSingleLinePile(vwenv' false);  						}  						else  						{  							// left bracket pile  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginLeading' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagLeftNonBoundary' vwenv);  							vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftBracketUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftBracketExt);  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftBracketLowHook);  							vwenv.CloseInnerPile();    							// feature pile  							vwenv.set_IntProperty((int) FwTextPropType.ktptAlign' (int) FwTextPropVar.ktpvEnum' (int) FwTextAlign.ktalLeft);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagInnerNonBoundary' vwenv);  							DisplayFeatures(vwenv' node);  							vwenv.CloseInnerPile();    							// right bracket pile  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' vwenv);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightBracketUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightBracketExt);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightBracketLowHook);  							vwenv.CloseInnerPile();  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  						}  					}  					break;  			}
Magic Number,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,Display,The following statement contains a magic number: switch (frag)  			{  				case kfragPattern:  					VwLength tableLen;  					tableLen.nVal = 10000;  					tableLen.unit = VwUnit.kunPercent100;  					vwenv.OpenTable(1' tableLen' 0' VwAlignment.kvaCenter' VwFramePosition.kvfpVoid' VwRule.kvrlNone' 0' 0' false);  					VwLength patternLen;  					patternLen.nVal = 1;  					patternLen.unit = VwUnit.kunRelative;  					vwenv.MakeColumns(1' patternLen);  					vwenv.OpenTableBody();  					vwenv.OpenTableRow();    					vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom' (int)FwTextPropVar.ktpvMilliPoint' 1000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptBorderColor' (int)FwTextPropVar.ktpvDefault' (int)ColorUtil.ConvertColorToBGR(Color.Gray));  					vwenv.set_IntProperty((int)FwTextPropType.ktptAlign' (int)FwTextPropVar.ktpvEnum' (int)FwTextAlign.ktalCenter);  					vwenv.set_IntProperty((int)FwTextPropType.ktptPadBottom' (int)FwTextPropVar.ktpvMilliPoint' 2000);  					vwenv.OpenTableCell(1' 1);  					vwenv.OpenParagraph();  					if (((ComplexConcPatternSda) vwenv.DataAccess).Root.IsLeaf)  					{  						OpenSingleLinePile(vwenv' GetMaxNumLines(vwenv)' false);  						vwenv.Props = m_bracketProps;  						vwenv.AddProp(ComplexConcPatternSda.ktagChildren' this' kfragEmpty);  						CloseSingleLinePile(vwenv' false);  					}  					else  					{  						vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);  					}  					vwenv.CloseParagraph();  					vwenv.CloseTableCell();    					vwenv.CloseTableRow();  					vwenv.CloseTableBody();  					vwenv.CloseTable();  					break;    				case kfragNode:  					ComplexConcPatternNode node = ((ComplexConcPatternSda) vwenv.DataAccess).Nodes[hvo];  					int maxNumLines = GetMaxNumLines(vwenv);  					if (node is ComplexConcOrNode)  					{  						OpenSingleLinePile(vwenv' maxNumLines);  						vwenv.AddProp(ktagInnerNonBoundary' this' kfragOR);  						CloseSingleLinePile(vwenv' false);  					}  					else if (node is ComplexConcWordBdryNode)  					{  						OpenSingleLinePile(vwenv' maxNumLines);  						vwenv.AddProp(ktagInnerNonBoundary' this' kfragHash);  						CloseSingleLinePile(vwenv);  					}  					else if (node is ComplexConcGroupNode)  					{  						int numLines = GetNumLines(node);  						bool hasMinMax = node.Maximum != 1 || node.Minimum != 1;  						if (numLines == 1)  						{  							OpenSingleLinePile(vwenv' maxNumLines' false);  							// use normal parentheses for a single line group  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftParen);    							vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);    							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightParen);  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  							CloseSingleLinePile(vwenv' false);  						}  						else  						{  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginLeading' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagLeftNonBoundary' vwenv);  							vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftParenUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftParenExt);  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftParenLowHook);  							vwenv.CloseInnerPile();    							vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);    							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' vwenv);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightParenUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightParenExt);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightParenLowHook);  							vwenv.CloseInnerPile();  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  						}  					}  					else  					{  						bool hasMinMax = node.Maximum != 1 || node.Minimum != 1;  						int numLines = GetNumLines(node);  						if (numLines == 1)  						{  							OpenSingleLinePile(vwenv' maxNumLines' false);  							// use normal brackets for a single line constraint  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftBracket);    							DisplayFeatures(vwenv' node);    							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightBracket);  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  							CloseSingleLinePile(vwenv' false);  						}  						else  						{  							// left bracket pile  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginLeading' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagLeftNonBoundary' vwenv);  							vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftBracketUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftBracketExt);  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftBracketLowHook);  							vwenv.CloseInnerPile();    							// feature pile  							vwenv.set_IntProperty((int) FwTextPropType.ktptAlign' (int) FwTextPropVar.ktpvEnum' (int) FwTextAlign.ktalLeft);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagInnerNonBoundary' vwenv);  							DisplayFeatures(vwenv' node);  							vwenv.CloseInnerPile();    							// right bracket pile  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' vwenv);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightBracketUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightBracketExt);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightBracketLowHook);  							vwenv.CloseInnerPile();  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  						}  					}  					break;  			}
Magic Number,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,DisplayMinMax,The following statement contains a magic number: if (numLines == 1)  			{  				// if the inner context is a single line' then make the min value a subscript and the max value a superscript.  				// I tried to use the Views subscript and superscript properties' but they added extra space so that it would  				// have the same line height of a normal character' which is not what I wanted' so I compute the size myself  				int fontHeight = GetFontHeight(m_cache.DefaultUserWs);  				int superSubHeight = (fontHeight * 2) / 3;  				vwenv.set_IntProperty((int) FwTextPropType.ktptFontSize' (int) FwTextPropVar.ktpvMilliPoint' superSubHeight);  				vwenv.set_IntProperty((int) FwTextPropType.ktptLineHeight' (int) FwTextPropVar.ktpvMilliPoint' -superSubHeight);  				superOffset = superSubHeight / 2;  			}  			else  			{  				vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  			}
Magic Number,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,DisplayMinMax,The following statement contains a magic number: if (numLines == 1)  			{  				// if the inner context is a single line' then make the min value a subscript and the max value a superscript.  				// I tried to use the Views subscript and superscript properties' but they added extra space so that it would  				// have the same line height of a normal character' which is not what I wanted' so I compute the size myself  				int fontHeight = GetFontHeight(m_cache.DefaultUserWs);  				int superSubHeight = (fontHeight * 2) / 3;  				vwenv.set_IntProperty((int) FwTextPropType.ktptFontSize' (int) FwTextPropVar.ktpvMilliPoint' superSubHeight);  				vwenv.set_IntProperty((int) FwTextPropType.ktptLineHeight' (int) FwTextPropVar.ktpvMilliPoint' -superSubHeight);  				superOffset = superSubHeight / 2;  			}  			else  			{  				vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  			}
Magic Number,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,DisplayMinMax,The following statement contains a magic number: if (numLines == 1)  			{  				// if the inner context is a single line' then make the min value a subscript and the max value a superscript.  				// I tried to use the Views subscript and superscript properties' but they added extra space so that it would  				// have the same line height of a normal character' which is not what I wanted' so I compute the size myself  				int fontHeight = GetFontHeight(m_cache.DefaultUserWs);  				int superSubHeight = (fontHeight * 2) / 3;  				vwenv.set_IntProperty((int) FwTextPropType.ktptFontSize' (int) FwTextPropVar.ktpvMilliPoint' superSubHeight);  				vwenv.set_IntProperty((int) FwTextPropType.ktptLineHeight' (int) FwTextPropVar.ktpvMilliPoint' -superSubHeight);  				superOffset = superSubHeight / 2;  			}  			else  			{  				vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  			}
Magic Number,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,DisplayMinMax,The following statement contains a magic number: AddExtraLines(numLines - 2' ktagRightNonBoundary' vwenv);
Magic Number,SIL.FieldWorks.IText,ConcordanceWordList,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceWordList.cs,ParseInterestingTexts,The following statement contains a magic number: using (var progress = FwXWindow.CreateSimpleProgressState(m_propertyTable))  			{  				progress.SetMilestone(ITextStrings.ksParsing);  				foreach (var text in texts)  				{  					foreach (IStTxtPara para in text.ParagraphsOS)  					{  						done++;  						int newPercentDone = done * 100 / count;  						if (newPercentDone != progress.PercentDone)  						{  							progress.PercentDone = newPercentDone;  							progress.Breath();  						}  						if (para.ParseIsCurrent) continue;    						ParagraphParser.ParseParagraph(para);  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,InitCurrentList,The following statement contains a magic number: foreach (InterlinLineSpec ls in m_choices)  			{  				string[] cols = new string[2];    				cols[0] = TsStringUtils.NormalizeToNFC(m_choices.LabelFor(ls.Flid));    				string wsName = "";  				// This tries to find a matching ws from the combo box that would be displayed for this item  				// The reason we use the combo box is because that will give us names like "Default Analysis" instead of  				// the actual analysis ws name.  				foreach (WsComboItem item in WsComboItems(ls.ComboContent))  				{  					var ws = ls.IsMagicWritingSystem ? m_cache.LangProject.DefaultWsForMagicWs(ls.WritingSystem) : ls.WritingSystem;  					if (getWsFromId(item.Id) == ws)  					{  						wsName = item.ToString();  						break;  					}  					else  					{  						Debug.WriteLine(item.Id);  					}  				}  				// Last ditch effort  				if (wsName == "")  				{  					CoreWritingSystemDefinition wsObj = m_cache.ServiceLocator.WritingSystemManager.Get(ls.WritingSystem);  					if (wsObj != null)  						wsName = wsObj.DisplayLabel;  				}  				cols[1] = TsStringUtils.NormalizeToNFC(wsName);  				cols[1] = cols[1].Substring(0' Math.Min(cols[1].Length' 42));    				var item1WithToolTip = new ListViewItem(cols);  				item1WithToolTip.ToolTipText = TsStringUtils.NormalizeToNFC(wsName);    				currentList.Items.Add(item1WithToolTip);  			}
Magic Number,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,InitCurrentList,The following statement contains a magic number: foreach (InterlinLineSpec ls in m_choices)  			{  				string[] cols = new string[2];    				cols[0] = TsStringUtils.NormalizeToNFC(m_choices.LabelFor(ls.Flid));    				string wsName = "";  				// This tries to find a matching ws from the combo box that would be displayed for this item  				// The reason we use the combo box is because that will give us names like "Default Analysis" instead of  				// the actual analysis ws name.  				foreach (WsComboItem item in WsComboItems(ls.ComboContent))  				{  					var ws = ls.IsMagicWritingSystem ? m_cache.LangProject.DefaultWsForMagicWs(ls.WritingSystem) : ls.WritingSystem;  					if (getWsFromId(item.Id) == ws)  					{  						wsName = item.ToString();  						break;  					}  					else  					{  						Debug.WriteLine(item.Id);  					}  				}  				// Last ditch effort  				if (wsName == "")  				{  					CoreWritingSystemDefinition wsObj = m_cache.ServiceLocator.WritingSystemManager.Get(ls.WritingSystem);  					if (wsObj != null)  						wsName = wsObj.DisplayLabel;  				}  				cols[1] = TsStringUtils.NormalizeToNFC(wsName);  				cols[1] = cols[1].Substring(0' Math.Min(cols[1].Length' 42));    				var item1WithToolTip = new ListViewItem(cols);  				item1WithToolTip.ToolTipText = TsStringUtils.NormalizeToNFC(wsName);    				currentList.Items.Add(item1WithToolTip);  			}
Magic Number,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,getWsFromId,The following statement contains a magic number: int ws = -50;
Magic Number,SIL.FieldWorks.IText,ConfigureInterlinDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConfigureInterlinDialog.cs,getWsFromId,The following statement contains a magic number: try  			{  				if (!XmlViewsUtils.GetWsRequiresObject(id))  				{  					// Try to convert the ws parameter into an int.  Sometimes the parameter  					// cannot be interpreted without an object' such as when the ws is a magic  					// string that will change the actual ws depending on the contents of the  					// object.  In these cases' we give -50 as a known constant to check for.  					// This can possibly throw an exception' so we'll enclose it in a try block.  					ws = WritingSystemServices.InterpretWsLabel(m_cache' id' null' 0' 0' null);  				}  			}  			catch  			{  				Debug.Assert(ws != -50' "InterpretWsLabel was not able to interpret the Ws Label.  The most likely cause for this is that a magic ws was passed in.");  			}
Magic Number,SIL.FieldWorks.IText,FilterAllTextsDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FilterAllTextsDialog.cs,InitializeComponent,The following statement contains a magic number: this.m_treeTexts.ItemHeight = 16;
Magic Number,SIL.FieldWorks.IText,FilterTextsDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FilterTextsDialog.cs,InitializeComponent,The following statement contains a magic number: this.m_treeTexts.MinimumSize = new System.Drawing.Size(312' 264);
Magic Number,SIL.FieldWorks.IText,FilterTextsDialog,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FilterTextsDialog.cs,InitializeComponent,The following statement contains a magic number: this.m_treeTexts.MinimumSize = new System.Drawing.Size(312' 264);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,btnMenu_Click,The following statement contains a magic number: window.ShowContextMenu("mnuFocusBox"'  				btnMenu.PointToScreen(new Point(btnMenu.Width / 2' btnMenu.Height / 2))'  				null'  				null);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,btnMenu_Click,The following statement contains a magic number: window.ShowContextMenu("mnuFocusBox"'  				btnMenu.PointToScreen(new Point(btnMenu.Width / 2' btnMenu.Height / 2))'  				null'  				null);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelSidebar.Location = new System.Drawing.Point(104' 0);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelSidebar.Size = new System.Drawing.Size(23' 32);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelSidebar.Size = new System.Drawing.Size(23' 32);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnLinkNextWord.Size = new System.Drawing.Size(20' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnLinkNextWord.Size = new System.Drawing.Size(20' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelControlBar.Location = new System.Drawing.Point(0' 14);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelControlBar.MinimumSize = new System.Drawing.Size(104' 18);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelControlBar.MinimumSize = new System.Drawing.Size(104' 18);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelControlBar.Size = new System.Drawing.Size(104' 18);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelControlBar.Size = new System.Drawing.Size(104' 18);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelControlBar.TabIndex = 2;
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChangesForWholeText.Location = new System.Drawing.Point(66' 0);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChangesForWholeText.MaximumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChangesForWholeText.MaximumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChangesForWholeText.MinimumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChangesForWholeText.MinimumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChangesForWholeText.Size = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChangesForWholeText.Size = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChangesForWholeText.TabIndex = 4;
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnUndoChanges.Location = new System.Drawing.Point(44' 0);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnUndoChanges.MaximumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnUndoChanges.MaximumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnUndoChanges.MinimumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnUndoChanges.MinimumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnUndoChanges.Size = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnUndoChanges.Size = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnBreakPhrase.Location = new System.Drawing.Point(22' 0);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnBreakPhrase.Size = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnBreakPhrase.Size = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnBreakPhrase.TabIndex = 3;
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnMenu.MinimumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnMenu.MinimumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnMenu.Size = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnMenu.Size = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChanges.Location = new System.Drawing.Point(87' 0);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChanges.MinimumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChanges.MinimumSize = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChanges.Size = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChanges.Size = new System.Drawing.Size(16' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirmChanges.TabIndex = 2;
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelSandbox.Margin = new System.Windows.Forms.Padding(0' 0' 0' 3);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelSandbox.MinimumSize = new System.Drawing.Size(104' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelSandbox.MinimumSize = new System.Drawing.Size(104' 16);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelSandbox.Size = new System.Drawing.Size(104' 17);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelSandbox.Size = new System.Drawing.Size(104' 17);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.panelSandbox.TabIndex = 3;
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(224' 57);
Magic Number,SIL.FieldWorks.IText,FocusBoxController,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\FocusBoxController.ApproveAndMove.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(224' 57);
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(32' 40);
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(32' 40);
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(75' 56);
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(75' 56);
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(2' "Add Free Translation.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(3' "Add New Text.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(4' "Insert Note.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(5' "Find and Replace Text.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(6' "LinkWords.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(7' "BreakPhrase.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(8' "AddScripture.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(9' "ApprAndMoveNext.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(10' "BrowseAndMoveNext.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(11' "ME.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(12' "ZeroWidth.ico");
Magic Number,SIL.FieldWorks.IText,ImageHolder,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ImageHolder.cs,InitializeComponent,The following statement contains a magic number: this.buttonImages.Images.SetKeyName(13' "ApproveAll.ico");
Magic Number,SIL.FieldWorks.IText,InterlinearImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearImportDlg.cs,m_btnOK_Click,The following statement contains a magic number: using (var dlg = new ProgressDialogWithTask(this))  			{  				dlg.AllowCancel = false;  				dlg.Minimum = 0;  				dlg.Maximum = 500;  				using (new WaitCursor(this' true))  				{  					var import = new LinguaLinksImport(m_cache'  						Path.Combine(Path.GetTempPath()' "LanguageExplorer" + Path.DirectorySeparatorChar)'  						Path.Combine(FwDirectoryFinder.CodeDirectory' Path.Combine("Language Explorer"' "Import" + Path.DirectorySeparatorChar)));  					import.NextInput = m_tbFilename.Text;  					import.Error += import_Error;  					try  					{  						var fSuccess = (bool) dlg.RunTask(true' import.ImportInterlinear' m_tbFilename.Text);  						if (fSuccess)  						{  							DialogResult = DialogResult.OK; // only 'OK' if not exception  							var firstNewText = import.FirstNewText;  							if (firstNewText != null && m_mediator != null)  							{  								m_mediator.SendMessage("JumpToRecord"' firstNewText.Hvo);  							}  						}  						else  						{  							DialogResult = DialogResult.Abort; // unsuccessful import  							string message = ITextStrings.ksInterlinImportFailed + Environment.NewLine + Environment.NewLine;  							message += m_messages.ToString();  							MessageBox.Show(this' message' ITextStrings.ksImportFailed' MessageBoxButtons.OK'  								MessageBoxIcon.Warning);  						}  						Close();  					}  					catch (WorkerThreadException ex)  					{  						System.Diagnostics.Debug.WriteLine("Error: " + ex.InnerException.Message);    						MessageBox.Show(String.Format(import.ErrorMessage' ex.InnerException.Message)'  							ITextStrings.ksUnhandledError'  							MessageBoxButtons.OK' MessageBoxIcon.Error);  						DialogResult = DialogResult.Cancel;	// only 'OK' if not exception  						Close();  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SetFocusBoxSizeForVc,The following statement contains a magic number: if (width > 10000)  			{  				//				Debug.Assert(width < 10000); // Is something taking the full available width of MaxInt/2?  				width = 500; // arbitrary' may allow something to work more or less  			}
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SetFocusBoxSizeForVc,The following statement contains a magic number: if (width > 10000)  			{  				//				Debug.Assert(width < 10000); // Is something taking the full available width of MaxInt/2?  				width = 500; // arbitrary' may allow something to work more or less  			}
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SetFocusBoxSizeForVc,The following statement contains a magic number: Size newSize = new Size(width * 72000 / dpiX'  				FocusBox.Height * 72000 / dpiY);
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SetFocusBoxSizeForVc,The following statement contains a magic number: Size newSize = new Size(width * 72000 / dpiX'  				FocusBox.Height * 72000 / dpiY);
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SelectFirstTranslationOrNote,The following statement contains a magic number: var vsli = new SelLevInfo[3];
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SelectFirstTranslationOrNote,The following statement contains a magic number: vsli[2] = rgvsli[1];
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SelectFirstTranslationOrNote,The following statement contains a magic number: var vsli = new SelLevInfo[3];
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SelectFirstTranslationOrNote,The following statement contains a magic number: vsli[2].ihvo = segment.Paragraph.IndexInOwner;
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,SelectFirstTranslationOrNote,The following statement contains a magic number: vsli[2].tag = StTextTags.kflidParagraphs;
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,GetSandboxSelLocation,The following statement contains a magic number: if (m_vc.RightToLeft)  				left += 8;
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,GetCurrentTextObjects,The following statement contains a magic number: curParaIndex = rgvsli[clev - 2].ihvo;
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,GetCurrentTextObjects,The following statement contains a magic number: curSegIndex = rgvsli[clev - 3].ihvo;
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,GetCurrentTextObjects,The following statement contains a magic number: if (tag == NoteTags.kflidContent)  			{  				//if clev == 5 then we have both a Free Translation and some number of Notes  				//otherwise I assume we have only a Free Translation if clev == 4  				if (clev == 5)  				{  					curNoteIndex = rgvsli[0].ihvo; //if there are multiple Notes the index could be more than 0  					curNote = curSeg.NotesOS[curNoteIndex];  				}  			}
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,HandleSelectionChange,The following statement contains a magic number: try  			{  				base.HandleSelectionChange(prootb' vwselNew);  				IVwSelection sel = vwselNew;  				if (!sel.IsValid)  					sel = prootb.Selection;  				if (sel == null)  					return;  				SelectionHelper helper = SelectionHelper.Create(sel' prootb.Site);  				// Check whether the selection is on the proper line of a multilingual  				// annotation and' if not' fix it.  See LT-9421.  				if (m_cpropPrevForInsert > 0 && !sel.IsRange &&  					(helper.GetNumberOfPreviousProps(SelectionHelper.SelLimitType.Anchor) == 0 ||  					 helper.GetNumberOfPreviousProps(SelectionHelper.SelLimitType.End) == 0))  				{  					try  					{  						helper.SetNumberOfPreviousProps(SelectionHelper.SelLimitType.Anchor' m_cpropPrevForInsert);  						helper.SetNumberOfPreviousProps(SelectionHelper.SelLimitType.End' m_cpropPrevForInsert);  						helper.MakeBest(true);  						m_cpropPrevForInsert = -1;	// we've used this the one time it was needed.  					}  					catch (Exception exc)  					{  						if (exc != null)  							Debug.WriteLine(String.Format(  								"InterlinDocChild.SelectionChanged() trying to display prompt in proper line of annotation: {0}"' exc.Message));  					}  				}  				int flid = helper.GetTextPropId(SelectionHelper.SelLimitType.Anchor);  				//If the flid is -2 and it is an insertion point then we may have encountered a case where the selection has landed at the boundary between our (possibly empty)  				//translation field and a literal string containing our magic Bidi marker character that helps keep things in the right order.  				//Sometimes AssocPrev gets set so that we read the (non-existent) flid of the literal string and miss the fact that on the other side  				//of the insertion point is the field we're looking for. The following code will attempt to make a selection that associates in  				//the other direction to see if the flid we want is on the other side. [LT-10568]  				if (flid == -2 && !sel.IsRange && sel.SelType == VwSelType.kstText)  				{  					helper.AssocPrev = !helper.AssocPrev;  					try  					{  						var newSel = helper.MakeRangeSelection(this.RootBox' false);  						helper = SelectionHelper.Create(newSel' this);  						flid = helper.GetTextPropId(SelectionHelper.SelLimitType.Anchor);  					}  					catch (COMException)  					{  						// Ignore HResult E_Fail caused by Extended Keys (PgUp/PgDown) in non-editable text (LT-13500)  					}  				}  				//Fixes LT-9884 Crash when clicking on the blank space in Text & Words--->Print view area!  				if (helper.LevelInfo.Length == 0)  					return;  				int hvo = helper.LevelInfo[0].hvo;    				// If the selection is in a freeform or literal translation that is empty' display the prompt.  				if (SelIsInEmptyTranslation(helper' flid' hvo) && !m_rootb.IsCompositionInProgress)  				{  					var handlerExtensions = Cache.ActionHandlerAccessor as IActionHandlerExtensions;  					if (handlerExtensions != null && handlerExtensions.IsUndoTaskActive)  					{  						// Wait to make the changes until the task (typically typing backspace) completes.  						m_setupPromptHelper = helper;  						m_setupPromptFlid = flid;  						handlerExtensions.DoAtEndOfPropChanged(handlerExtensions_PropChangedCompleted);  					}  					else  					{  						// No undo task to tag on the end of' so do it now.  						SetupTranslationPrompt(helper' flid);  					}  				}  				else if (flid != kTagUserPrompt)  				{  					m_vc.SetActiveFreeform(0' 0' 0' 0); // clear any current prompt.  				}  				// do not extend the selection for a user prompt if the user is currently entering an IME composition'  				// since we are about to switch the prompt to a real comment field  				else if (helper.GetTextPropId(SelectionHelper.SelLimitType.End) == SimpleRootSite.kTagUserPrompt  					&& !m_rootb.IsCompositionInProgress)  				{  					// If the selection is entirely in a user prompt then extend the selection to cover the  					// entire prompt. This covers changes within the prompt' like clicking within it or continuing  					// a drag while making it.  					sel.ExtendToStringBoundaries();  					EditingHelper.SetKeyboardForSelection(sel);  				}  			}  			finally  			{  				m_fInSelectionChanged = false;  			}
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,AddNote,The following statement contains a magic number: SelLevInfo[] rgvsliNew = new SelLevInfo[rgvsli.Length - itagSegments + 2];
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,AddNote,The following statement contains a magic number: for (int i = 2; i < rgvsliNew.Length; i++)  				rgvsliNew[i] = rgvsli[i + itagSegments - 2];
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysis,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,AddNote,The following statement contains a magic number: for (int i = 2; i < rgvsliNew.Length; i++)  				rgvsliNew[i] = rgvsli[i + itagSegments - 2];
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysisVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,InterlinDocForAnalysisVc,The following statement contains a magic number: FocusBoxSize = new Size(100000' 50000);
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysisVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,InterlinDocForAnalysisVc,The following statement contains a magic number: FocusBoxSize = new Size(100000' 50000);
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysisVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,AddWordBundleInternal,The following statement contains a magic number: if (FocusBoxOccurrence != null)  			{  				int hvoSeg' tag' ihvo;  				vwenv.GetOuterObject(vwenv.EmbeddingLevel - 1' out hvoSeg' out tag' out ihvo);  				if (hvoSeg == FocusBoxOccurrence.Segment.Hvo && ihvo == FocusBoxOccurrence.Index)  				{  					// Leave room for the Sandbox instead of displaying the internlinear data.  					// The first argument makes it invisible in case a little bit of it shows around  					// the sandbox.  					// The last argument puts the 'Baseline' of the sandbox (which aligns with the base of the  					// first line of text) an appropriate distance from the top of the Sandbox. This aligns it's  					// top line of text properly.  					// Enhance JohnT: 90% of font height is not always exactly right' but it's the closest  					// I can get wihtout a new API to get the exact ascent of the font.  					int dympBaseline = Common.Widgets.FontHeightAdjuster.  						GetFontHeightForStyle("Normal"' m_stylesheet' m_wsVernForDisplay'  						m_cache.LanguageWritingSystemFactoryAccessor) * 9 / 10;  					uint transparent = 0xC0000000; // FwTextColor.kclrTransparent won't convert to uint  					vwenv.AddSimpleRect((int)transparent'  										FocusBoxSize.Width' FocusBoxSize.Height' -(FocusBoxSize.Height - dympBaseline));  					return;  				}  			}
Magic Number,SIL.FieldWorks.IText,InterlinDocForAnalysisVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocForAnalysis.cs,AddWordBundleInternal,The following statement contains a magic number: if (FocusBoxOccurrence != null)  			{  				int hvoSeg' tag' ihvo;  				vwenv.GetOuterObject(vwenv.EmbeddingLevel - 1' out hvoSeg' out tag' out ihvo);  				if (hvoSeg == FocusBoxOccurrence.Segment.Hvo && ihvo == FocusBoxOccurrence.Index)  				{  					// Leave room for the Sandbox instead of displaying the internlinear data.  					// The first argument makes it invisible in case a little bit of it shows around  					// the sandbox.  					// The last argument puts the 'Baseline' of the sandbox (which aligns with the base of the  					// first line of text) an appropriate distance from the top of the Sandbox. This aligns it's  					// top line of text properly.  					// Enhance JohnT: 90% of font height is not always exactly right' but it's the closest  					// I can get wihtout a new API to get the exact ascent of the font.  					int dympBaseline = Common.Widgets.FontHeightAdjuster.  						GetFontHeightForStyle("Normal"' m_stylesheet' m_wsVernForDisplay'  						m_cache.LanguageWritingSystemFactoryAccessor) * 9 / 10;  					uint transparent = 0xC0000000; // FwTextColor.kclrTransparent won't convert to uint  					vwenv.AddSimpleRect((int)transparent'  										FocusBoxSize.Width' FocusBoxSize.Height' -(FocusBoxSize.Height - dympBaseline));  					return;  				}  			}
Magic Number,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,OnNextButton,The following statement contains a magic number: if (CurrentStepNumber == 0)  			{  				// Populate m_mappingsList based on the selected files.  				var sfmcounts = new Dictionary<string' int>();  				var sfmOrder = new Dictionary<int' string>(); // key is 100000*fileNum + orderInFile' value is a marker  				int fileNum = 0;  				foreach (var pathName in InputFiles)  				{  					var reader = new SfmFileReaderEx(pathName);  					followedBy = reader.GetFollowedByInfo();  					foreach (string marker in reader.SfmInfo)  					{  						int oldVal;  						if (!sfmcounts.TryGetValue(marker' out oldVal))  						{  							// first time we've seen it: this file determines order;  							sfmOrder[fileNum * 100000 + reader.GetSFMOrder(marker)] = marker;  						}  						sfmcounts[marker] = oldVal + reader.GetSFMCount(marker);  					}  					fileNum++;  				}  				// Read the map file (unless we've been to this pane before...then use the saved settings)' integrate with the sfmcount info.  				var savedMappings = new Dictionary<string' InterlinearMapping>();  				m_oldMappings = m_firstTimeInMappingsPane ? LoadSettings() : new List<InterlinearMapping>((m_mappings));  				m_firstTimeInMappingsPane = false;  				foreach (var mapping in m_oldMappings)  					savedMappings[mapping.Marker] = mapping;  				m_mappings.Clear();  				var keys = new List<int>(sfmOrder.Keys);  				keys.Sort();  				foreach (var key in keys)  				{  					var marker = sfmOrder[key];  					InterlinearMapping mapping;  					if (savedMappings.TryGetValue(marker' out mapping))  					{  						mapping = new InterlinearMapping(mapping);  						if (string.IsNullOrEmpty(mapping.WritingSystem))  						{  							var ws = GetDefaultWs(mapping);  							if (ws != 0)  								mapping.WritingSystem = m_cache.WritingSystemFactory.GetStrFromWs(ws);  						}  						else if (mapping.WritingSystem == "{vern}")  							mapping.WritingSystem = m_cache.WritingSystemFactory.GetStrFromWs(m_cache.DefaultVernWs);  					}  					else  						mapping = new InterlinearMapping() {Marker = marker};  					mapping.Count = sfmcounts[marker].ToString();  					m_mappings.Add(mapping);  				}  				m_mappingsList.SuspendLayout();  				m_mappingsList.Items.Clear();  				foreach (var mapping in m_mappings)  				{  					var item = new ListViewItem("\\" + mapping.Marker);  					item.SubItems.Add(mapping.Count);  					item.SubItems.Add(GetDestinationName(mapping.Destination));  					item.SubItems.Add(mapping.WritingSystem != null ? GetWritingSystemName(mapping.WritingSystem) : "");  					item.SubItems.Add(mapping.Converter ?? "");  					m_mappingsList.Items.Add(item);  				}  				if (m_mappingsList.Items.Count > 0)  					m_mappingsList.SelectedIndices.Add(0);  				m_mappingsList.ResumeLayout();  			}  			else if(CurrentStepNumber == 1)  			{  				ICollection<CoreWritingSystemDefinition> currentVernacWSs = m_cache.LanguageProject.VernacularWritingSystems;  				ICollection<CoreWritingSystemDefinition> currentAnalysWSs = m_cache.LanguageProject.AnalysisWritingSystems;  				var vernToAdd = new ArrayList();  				var analysToAdd = new ArrayList();  				int textCount = CalculateTextCount(m_mappings' followedBy);  				foreach(var mapping in m_mappings)  				{  					if (mapping.Destination == InterlinDestination.Ignored)  						continue; // may well have no WS' in any case' we don't care whether it's in our list.  					bool creationCancelled = false;  					var ws = (CoreWritingSystemDefinition) m_cache.WritingSystemFactory.get_Engine(mapping.WritingSystem);  					if (mapping.Destination == InterlinDestination.Baseline || mapping.Destination == InterlinDestination.Wordform)  					{  						if(!currentVernacWSs.Contains(ws) && !vernToAdd.Contains(ws))  						{  							//Show creation dialog for Vernacular  							var result = MessageBox.Show(this'  														 String.Format(ITextStrings.ksImportSFMInterlinNewVernac' ws)'  														 String.Format(ITextStrings.ksImportSFMInterlinNewWSTitle' ws)' MessageBoxButtons.YesNo);  							if(result == DialogResult.Yes)  							{  								vernToAdd.Add(ws);  							}  							else //if they bail out we won't add any writing systems' they might change them all  							{  								return;  							}  						}  					}  					else  					{  						if(!currentAnalysWSs.Contains(ws) && !analysToAdd.Contains(ws))  						{  							var result = MessageBox.Show(this'  														 String.Format(ITextStrings.ksImportSFMInterlinNewAnalysis' ws)'  														 String.Format(ITextStrings.ksImportSFMInterlinNewWSTitle' ws)' MessageBoxButtons.YesNo);  							if (result == DialogResult.Yes)  							{  								analysToAdd.Add(ws);  							}  							else  //if they bail out we won't add any writing systems' they might change them all  							{  								return;  							}  						}  					}  				}  				NonUndoableUnitOfWorkHelper.DoUsingNewOrCurrentUOW(m_cache.ActionHandlerAccessor'  					() => //Add all the collected new languages into the project in their proper section.  					{  						foreach (CoreWritingSystemDefinition analysLang in analysToAdd)  						{  							m_cache.LanguageProject.AddToCurrentAnalysisWritingSystems(analysLang);  						}  						foreach (CoreWritingSystemDefinition vernLang in vernToAdd)  						{  							m_cache.LanguageProject.AddToCurrentVernacularWritingSystems(vernLang);  						}  					});  				if(textCount > 1)  				{  					numberOfTextsLabel.Text = String.Format(ITextStrings.ksImportSFMInterlinTextCount' textCount);  				}  				else  				{  					numberOfTextsLabel.Text = String.Empty;  				}  			}
Magic Number,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,OnFinishButton,The following statement contains a magic number: using (var dlg = new ProgressDialogWithTask(this))  			{  				dlg.AllowCancel = false;  				dlg.Minimum = 0;  				// Allow 100 units of progress for each file for now. This allows for plenty of resolution for the LL importer  				dlg.Maximum = InputFiles.Count() * 100;    				try  				{  					dlg.RunTask(true' DoConversion);  				}  				catch (WorkerThreadException ex) // any exception on the worker thread is converted to this  				{  					// JohnT: I hate to just report and otherwise ignore all exceptions' but have not been able to find any doc of which ones'  					// if any' EncConverters may throw.  					System.Diagnostics.Debug.WriteLine("Error: " + ex.InnerException.Message);  					MessageBox.Show(this' String.Format(ITextStrings.ksSfmImportProblem' ex.InnerException.Message)'  						ITextStrings.ksUnhandledError'  						MessageBoxButtons.OK' MessageBoxIcon.Error);  					DialogResult = DialogResult.Cancel;  					Close();  				}  			}
Magic Number,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,DoStage2Conversion,The following statement contains a magic number: using (var stage2Input = new MemoryStream(stage1))  			{  				var stage2Converter = new LinguaLinksImport(m_cache' null' null);  				// Until we have a better idea' assume we're half done with the import when we've produced the intermediate.  				// Allocate 5 progress units to the ImportInterlinear' in case it can do better resolution.  				// Enhance JohnT: we could divide the progress up based on the lengths of the files'  				// and possibly converter.Convert could move the bar along based on how far through the file it is.  				// ImportInterlinear could do something similar. However' procesing a single file is so quick  				// that this very crude approximation is good enough.  				dlg.Position += 50;  				stage2Converter.ImportInterlinear(dlg' stage2Input' 50' ref m_firstNewText);  			}
Magic Number,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,DoStage2Conversion,The following statement contains a magic number: using (var stage2Input = new MemoryStream(stage1))  			{  				var stage2Converter = new LinguaLinksImport(m_cache' null' null);  				// Until we have a better idea' assume we're half done with the import when we've produced the intermediate.  				// Allocate 5 progress units to the ImportInterlinear' in case it can do better resolution.  				// Enhance JohnT: we could divide the progress up based on the lengths of the files'  				// and possibly converter.Convert could move the bar along based on how far through the file it is.  				// ImportInterlinear could do something similar. However' procesing a single file is so quick  				// that this very crude approximation is good enough.  				dlg.Position += 50;  				stage2Converter.ImportInterlinear(dlg' stage2Input' 50' ref m_firstNewText);  			}
Magic Number,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,m_modifyMappingButton_Click,The following statement contains a magic number: using (var dlg = new SfmToTextsAndWordsMappingDlg())  			{  				var index = m_mappingsList.SelectedIndices[0];  				var mapping = m_mappings[index];  				var destinationsFilter = GetDestinationsFilter();  				dlg.SetupDlg(m_helpTopicProvider' m_propertyTable.GetValue<IApp>("App")' m_cache'  					mapping' destinationsFilter);  				dlg.ShowDialog(this);  				var item = m_mappingsList.Items[index];  				item.SubItems[2].Text = GetDestinationName(mapping.Destination);  				item.SubItems[3].Text = mapping.WritingSystem != null ? GetWritingSystemName(mapping.WritingSystem) : "";  				item.SubItems[4].Text = mapping.Converter;  			}
Magic Number,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,m_modifyMappingButton_Click,The following statement contains a magic number: using (var dlg = new SfmToTextsAndWordsMappingDlg())  			{  				var index = m_mappingsList.SelectedIndices[0];  				var mapping = m_mappings[index];  				var destinationsFilter = GetDestinationsFilter();  				dlg.SetupDlg(m_helpTopicProvider' m_propertyTable.GetValue<IApp>("App")' m_cache'  					mapping' destinationsFilter);  				dlg.ShowDialog(this);  				var item = m_mappingsList.Items[index];  				item.SubItems[2].Text = GetDestinationName(mapping.Destination);  				item.SubItems[3].Text = mapping.WritingSystem != null ? GetWritingSystemName(mapping.WritingSystem) : "";  				item.SubItems[4].Text = mapping.Converter;  			}
Magic Number,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,m_modifyMappingButton_Click,The following statement contains a magic number: using (var dlg = new SfmToTextsAndWordsMappingDlg())  			{  				var index = m_mappingsList.SelectedIndices[0];  				var mapping = m_mappings[index];  				var destinationsFilter = GetDestinationsFilter();  				dlg.SetupDlg(m_helpTopicProvider' m_propertyTable.GetValue<IApp>("App")' m_cache'  					mapping' destinationsFilter);  				dlg.ShowDialog(this);  				var item = m_mappingsList.Items[index];  				item.SubItems[2].Text = GetDestinationName(mapping.Destination);  				item.SubItems[3].Text = mapping.WritingSystem != null ? GetWritingSystemName(mapping.WritingSystem) : "";  				item.SubItems[4].Text = mapping.Converter;  			}
Magic Number,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,InitializeComponent,The following statement contains a magic number: this.secretShiftText.MaximumSize = new System.Drawing.Size(330' 0);
Magic Number,SIL.FieldWorks.IText,InterlinearSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearSfmImportWizard.cs,InitializeComponent,The following statement contains a magic number: this.StepPageCount = 3;
Magic Number,SIL.FieldWorks.IText,InterlinLineChoices,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinLineChoices.cs,Restore,The following statement contains a magic number: for (int i = 1; i < parts.Length; i++)  			{  				string[] flidAndWs = parts[i].Split('%');  				if (flidAndWs.Length != 2)  					throw new Exception("Unrecognized InterlinLineSpec: " + parts[i]);  				int flid = Int32.Parse(flidAndWs[0]);  				int ws = wsf.GetWsFromStr(flidAndWs[1]);  				result.Add(flid' ws);  			}
Magic Number,SIL.FieldWorks.IText,InterlinLineChoices,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinLineChoices.cs,OkToMoveDown,The following statement contains a magic number: if (n > Count - 2)  				return false;
Magic Number,SIL.FieldWorks.IText,InterlinLineChoices,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinLineChoices.cs,MoveDown,The following statement contains a magic number: if (n > Count - 2)  				return;
Magic Number,SIL.FieldWorks.IText,EditableInterlinLineChoices,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinLineChoices.cs,OkToRemove,The following statement contains a magic number: if (spec.Flid == kflidWord && spec.WritingSystem == m_wsDefVern &&  				ItemsWithFlids(new int[] {kflidWord}' new int[] {m_wsDefVern}).Count < 2)  			{  				message = ITextStrings.ksNeedWordLine;  				return false;  			}
Magic Number,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,MakeRootInternal,The following statement contains a magic number: m_rootb.MaxParasToScan = 2000;
Magic Number,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,SelectOccurrenceInIText,The following statement contains a magic number: var rgvsli = new SelLevInfo[3];
Magic Number,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,SelectOccurrenceInIText,The following statement contains a magic number: rgvsli[2].ihvo = point.Segment.Paragraph.IndexInOwner;
Magic Number,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,SelectOccurrenceInIText,The following statement contains a magic number: rgvsli[2].tag = StTextTags.kflidParagraphs;
Magic Number,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,ShowContextMenuIfNotClosing,The following statement contains a magic number: if (DateTime.Now.Ticks - m_ticksWhenContextMenuClosed > 50000) // 5ms!  			{  				m_labelContextMenu = MakeContextMenu(ilineChoice);  				m_labelContextMenu.Closed += m_labelContextMenu_Closed;  				m_labelContextMenu.Show(this' menuLocation.X' menuLocation.Y);  			}
Magic Number,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,GetRealWsFromSpec,The following statement contains a magic number: int ws = -50;
Magic Number,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,GetRealWsFromSpec,The following statement contains a magic number: try  			{  				ws = WritingSystemServices.InterpretWsLabel(Cache' spec.WsLabel(Cache).Text' null' 0' 0' null);  			}  			catch  			{  				Debug.Assert(ws != -50' "InterpretWsLabel was not able to interpret the Ws Label.  The most likely cause for this is that a magic ws was passed in.");  			}
Magic Number,SIL.FieldWorks.IText,InterlinPrintVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinPrintView.cs,Display,The following statement contains a magic number: switch (frag)  			{  				case kfragStText: // The whole text' root object for the InterlinDocChild.  					if (hvo == 0)  						return;		// What if the user deleted all the texts?  See LT-6727.  					IStText stText = m_coRepository.GetObject(hvo) as IStText;  					vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  						(int)FwTextPropVar.ktpvDefault'  						(int)TptEditable.ktptNotEditable);  					vwenv.OpenDiv();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 6000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  						(int)FwTextPropVar.ktpvMilliPoint' 24000);  					// Add both vernacular and analysis if we have them (LT-5561).  					bool fAddedVernacular = false;  					int wsVernTitle = 0;  					//  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstVern' out wsVernTitle))  					{  						vwenv.OpenParagraph();  						vwenv.AddStringAltMember(vtagStTextTitle' wsVernTitle' this);  						vwenv.CloseParagraph();  						fAddedVernacular = true;  					}  					int wsAnalysisTitle = 0;  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					ITsString tssAnal;  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstAnal' out wsAnalysisTitle' out tssAnal) &&  						!tssAnal.Equals(stText.Title.BestVernacularAlternative))  					{  						if (fAddedVernacular)  						{  							// display analysis title at smaller font size.  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 12000);  						}  						vwenv.AddStringAltMember(vtagStTextTitle' wsAnalysisTitle' this);  					}  					else  					{  						// just add a blank title.  						ITsString blankTitle = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(blankTitle);  					}  					vwenv.CloseParagraph();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					int wsSource = 0;  					if (stText.Source.TryWs(WritingSystemServices.kwsFirstVernOrAnal' out wsSource))  					{  						vwenv.OpenParagraph();  						vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  							(int)FwTextPropVar.ktpvMilliPoint' 12000);  						vwenv.AddStringAltMember(vtagStTextSource' wsSource' this);  						vwenv.CloseParagraph();  					}  					else  					{  						// just add a blank source.  						ITsString tssBlank = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(tssBlank);  					}  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					if (stText.OwningFlid == TextTags.kflidContents)  					{  						vwenv.AddObjProp((int)CmObjectFields.kflidCmObject_Owner' this' kfragTextDescription);  					}  					vwenv.CloseParagraph();  					base.Display(vwenv' hvo' frag);  					vwenv.CloseDiv();  					break;  				case kfragTextDescription:  					vwenv.AddStringAltMember(CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					break;  				default:  					base.Display(vwenv' hvo' frag);  					break;  			}
Magic Number,SIL.FieldWorks.IText,InterlinPrintVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinPrintView.cs,Display,The following statement contains a magic number: switch (frag)  			{  				case kfragStText: // The whole text' root object for the InterlinDocChild.  					if (hvo == 0)  						return;		// What if the user deleted all the texts?  See LT-6727.  					IStText stText = m_coRepository.GetObject(hvo) as IStText;  					vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  						(int)FwTextPropVar.ktpvDefault'  						(int)TptEditable.ktptNotEditable);  					vwenv.OpenDiv();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 6000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  						(int)FwTextPropVar.ktpvMilliPoint' 24000);  					// Add both vernacular and analysis if we have them (LT-5561).  					bool fAddedVernacular = false;  					int wsVernTitle = 0;  					//  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstVern' out wsVernTitle))  					{  						vwenv.OpenParagraph();  						vwenv.AddStringAltMember(vtagStTextTitle' wsVernTitle' this);  						vwenv.CloseParagraph();  						fAddedVernacular = true;  					}  					int wsAnalysisTitle = 0;  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					ITsString tssAnal;  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstAnal' out wsAnalysisTitle' out tssAnal) &&  						!tssAnal.Equals(stText.Title.BestVernacularAlternative))  					{  						if (fAddedVernacular)  						{  							// display analysis title at smaller font size.  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 12000);  						}  						vwenv.AddStringAltMember(vtagStTextTitle' wsAnalysisTitle' this);  					}  					else  					{  						// just add a blank title.  						ITsString blankTitle = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(blankTitle);  					}  					vwenv.CloseParagraph();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					int wsSource = 0;  					if (stText.Source.TryWs(WritingSystemServices.kwsFirstVernOrAnal' out wsSource))  					{  						vwenv.OpenParagraph();  						vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  							(int)FwTextPropVar.ktpvMilliPoint' 12000);  						vwenv.AddStringAltMember(vtagStTextSource' wsSource' this);  						vwenv.CloseParagraph();  					}  					else  					{  						// just add a blank source.  						ITsString tssBlank = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(tssBlank);  					}  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					if (stText.OwningFlid == TextTags.kflidContents)  					{  						vwenv.AddObjProp((int)CmObjectFields.kflidCmObject_Owner' this' kfragTextDescription);  					}  					vwenv.CloseParagraph();  					base.Display(vwenv' hvo' frag);  					vwenv.CloseDiv();  					break;  				case kfragTextDescription:  					vwenv.AddStringAltMember(CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					break;  				default:  					base.Display(vwenv' hvo' frag);  					break;  			}
Magic Number,SIL.FieldWorks.IText,InterlinPrintVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinPrintView.cs,Display,The following statement contains a magic number: switch (frag)  			{  				case kfragStText: // The whole text' root object for the InterlinDocChild.  					if (hvo == 0)  						return;		// What if the user deleted all the texts?  See LT-6727.  					IStText stText = m_coRepository.GetObject(hvo) as IStText;  					vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  						(int)FwTextPropVar.ktpvDefault'  						(int)TptEditable.ktptNotEditable);  					vwenv.OpenDiv();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 6000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  						(int)FwTextPropVar.ktpvMilliPoint' 24000);  					// Add both vernacular and analysis if we have them (LT-5561).  					bool fAddedVernacular = false;  					int wsVernTitle = 0;  					//  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstVern' out wsVernTitle))  					{  						vwenv.OpenParagraph();  						vwenv.AddStringAltMember(vtagStTextTitle' wsVernTitle' this);  						vwenv.CloseParagraph();  						fAddedVernacular = true;  					}  					int wsAnalysisTitle = 0;  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					ITsString tssAnal;  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstAnal' out wsAnalysisTitle' out tssAnal) &&  						!tssAnal.Equals(stText.Title.BestVernacularAlternative))  					{  						if (fAddedVernacular)  						{  							// display analysis title at smaller font size.  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 12000);  						}  						vwenv.AddStringAltMember(vtagStTextTitle' wsAnalysisTitle' this);  					}  					else  					{  						// just add a blank title.  						ITsString blankTitle = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(blankTitle);  					}  					vwenv.CloseParagraph();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					int wsSource = 0;  					if (stText.Source.TryWs(WritingSystemServices.kwsFirstVernOrAnal' out wsSource))  					{  						vwenv.OpenParagraph();  						vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  							(int)FwTextPropVar.ktpvMilliPoint' 12000);  						vwenv.AddStringAltMember(vtagStTextSource' wsSource' this);  						vwenv.CloseParagraph();  					}  					else  					{  						// just add a blank source.  						ITsString tssBlank = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(tssBlank);  					}  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					if (stText.OwningFlid == TextTags.kflidContents)  					{  						vwenv.AddObjProp((int)CmObjectFields.kflidCmObject_Owner' this' kfragTextDescription);  					}  					vwenv.CloseParagraph();  					base.Display(vwenv' hvo' frag);  					vwenv.CloseDiv();  					break;  				case kfragTextDescription:  					vwenv.AddStringAltMember(CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					break;  				default:  					base.Display(vwenv' hvo' frag);  					break;  			}
Magic Number,SIL.FieldWorks.IText,InterlinPrintVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinPrintView.cs,Display,The following statement contains a magic number: switch (frag)  			{  				case kfragStText: // The whole text' root object for the InterlinDocChild.  					if (hvo == 0)  						return;		// What if the user deleted all the texts?  See LT-6727.  					IStText stText = m_coRepository.GetObject(hvo) as IStText;  					vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  						(int)FwTextPropVar.ktpvDefault'  						(int)TptEditable.ktptNotEditable);  					vwenv.OpenDiv();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 6000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  						(int)FwTextPropVar.ktpvMilliPoint' 24000);  					// Add both vernacular and analysis if we have them (LT-5561).  					bool fAddedVernacular = false;  					int wsVernTitle = 0;  					//  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstVern' out wsVernTitle))  					{  						vwenv.OpenParagraph();  						vwenv.AddStringAltMember(vtagStTextTitle' wsVernTitle' this);  						vwenv.CloseParagraph();  						fAddedVernacular = true;  					}  					int wsAnalysisTitle = 0;  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					ITsString tssAnal;  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstAnal' out wsAnalysisTitle' out tssAnal) &&  						!tssAnal.Equals(stText.Title.BestVernacularAlternative))  					{  						if (fAddedVernacular)  						{  							// display analysis title at smaller font size.  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 12000);  						}  						vwenv.AddStringAltMember(vtagStTextTitle' wsAnalysisTitle' this);  					}  					else  					{  						// just add a blank title.  						ITsString blankTitle = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(blankTitle);  					}  					vwenv.CloseParagraph();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					int wsSource = 0;  					if (stText.Source.TryWs(WritingSystemServices.kwsFirstVernOrAnal' out wsSource))  					{  						vwenv.OpenParagraph();  						vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  							(int)FwTextPropVar.ktpvMilliPoint' 12000);  						vwenv.AddStringAltMember(vtagStTextSource' wsSource' this);  						vwenv.CloseParagraph();  					}  					else  					{  						// just add a blank source.  						ITsString tssBlank = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(tssBlank);  					}  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					if (stText.OwningFlid == TextTags.kflidContents)  					{  						vwenv.AddObjProp((int)CmObjectFields.kflidCmObject_Owner' this' kfragTextDescription);  					}  					vwenv.CloseParagraph();  					base.Display(vwenv' hvo' frag);  					vwenv.CloseDiv();  					break;  				case kfragTextDescription:  					vwenv.AddStringAltMember(CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					break;  				default:  					base.Display(vwenv' hvo' frag);  					break;  			}
Magic Number,SIL.FieldWorks.IText,InterlinPrintVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinPrintView.cs,Display,The following statement contains a magic number: switch (frag)  			{  				case kfragStText: // The whole text' root object for the InterlinDocChild.  					if (hvo == 0)  						return;		// What if the user deleted all the texts?  See LT-6727.  					IStText stText = m_coRepository.GetObject(hvo) as IStText;  					vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  						(int)FwTextPropVar.ktpvDefault'  						(int)TptEditable.ktptNotEditable);  					vwenv.OpenDiv();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 6000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  						(int)FwTextPropVar.ktpvMilliPoint' 24000);  					// Add both vernacular and analysis if we have them (LT-5561).  					bool fAddedVernacular = false;  					int wsVernTitle = 0;  					//  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstVern' out wsVernTitle))  					{  						vwenv.OpenParagraph();  						vwenv.AddStringAltMember(vtagStTextTitle' wsVernTitle' this);  						vwenv.CloseParagraph();  						fAddedVernacular = true;  					}  					int wsAnalysisTitle = 0;  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					ITsString tssAnal;  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstAnal' out wsAnalysisTitle' out tssAnal) &&  						!tssAnal.Equals(stText.Title.BestVernacularAlternative))  					{  						if (fAddedVernacular)  						{  							// display analysis title at smaller font size.  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 12000);  						}  						vwenv.AddStringAltMember(vtagStTextTitle' wsAnalysisTitle' this);  					}  					else  					{  						// just add a blank title.  						ITsString blankTitle = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(blankTitle);  					}  					vwenv.CloseParagraph();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					int wsSource = 0;  					if (stText.Source.TryWs(WritingSystemServices.kwsFirstVernOrAnal' out wsSource))  					{  						vwenv.OpenParagraph();  						vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  							(int)FwTextPropVar.ktpvMilliPoint' 12000);  						vwenv.AddStringAltMember(vtagStTextSource' wsSource' this);  						vwenv.CloseParagraph();  					}  					else  					{  						// just add a blank source.  						ITsString tssBlank = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(tssBlank);  					}  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					if (stText.OwningFlid == TextTags.kflidContents)  					{  						vwenv.AddObjProp((int)CmObjectFields.kflidCmObject_Owner' this' kfragTextDescription);  					}  					vwenv.CloseParagraph();  					base.Display(vwenv' hvo' frag);  					vwenv.CloseDiv();  					break;  				case kfragTextDescription:  					vwenv.AddStringAltMember(CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					break;  				default:  					base.Display(vwenv' hvo' frag);  					break;  			}
Magic Number,SIL.FieldWorks.IText,InterlinPrintVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinPrintView.cs,Display,The following statement contains a magic number: switch (frag)  			{  				case kfragStText: // The whole text' root object for the InterlinDocChild.  					if (hvo == 0)  						return;		// What if the user deleted all the texts?  See LT-6727.  					IStText stText = m_coRepository.GetObject(hvo) as IStText;  					vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  						(int)FwTextPropVar.ktpvDefault'  						(int)TptEditable.ktptNotEditable);  					vwenv.OpenDiv();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 6000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  						(int)FwTextPropVar.ktpvMilliPoint' 24000);  					// Add both vernacular and analysis if we have them (LT-5561).  					bool fAddedVernacular = false;  					int wsVernTitle = 0;  					//  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstVern' out wsVernTitle))  					{  						vwenv.OpenParagraph();  						vwenv.AddStringAltMember(vtagStTextTitle' wsVernTitle' this);  						vwenv.CloseParagraph();  						fAddedVernacular = true;  					}  					int wsAnalysisTitle = 0;  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					ITsString tssAnal;  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstAnal' out wsAnalysisTitle' out tssAnal) &&  						!tssAnal.Equals(stText.Title.BestVernacularAlternative))  					{  						if (fAddedVernacular)  						{  							// display analysis title at smaller font size.  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 12000);  						}  						vwenv.AddStringAltMember(vtagStTextTitle' wsAnalysisTitle' this);  					}  					else  					{  						// just add a blank title.  						ITsString blankTitle = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(blankTitle);  					}  					vwenv.CloseParagraph();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					int wsSource = 0;  					if (stText.Source.TryWs(WritingSystemServices.kwsFirstVernOrAnal' out wsSource))  					{  						vwenv.OpenParagraph();  						vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  							(int)FwTextPropVar.ktpvMilliPoint' 12000);  						vwenv.AddStringAltMember(vtagStTextSource' wsSource' this);  						vwenv.CloseParagraph();  					}  					else  					{  						// just add a blank source.  						ITsString tssBlank = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(tssBlank);  					}  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					if (stText.OwningFlid == TextTags.kflidContents)  					{  						vwenv.AddObjProp((int)CmObjectFields.kflidCmObject_Owner' this' kfragTextDescription);  					}  					vwenv.CloseParagraph();  					base.Display(vwenv' hvo' frag);  					vwenv.CloseDiv();  					break;  				case kfragTextDescription:  					vwenv.AddStringAltMember(CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					break;  				default:  					base.Display(vwenv' hvo' frag);  					break;  			}
Magic Number,SIL.FieldWorks.IText,InterlinPrintVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinPrintView.cs,Display,The following statement contains a magic number: switch (frag)  			{  				case kfragStText: // The whole text' root object for the InterlinDocChild.  					if (hvo == 0)  						return;		// What if the user deleted all the texts?  See LT-6727.  					IStText stText = m_coRepository.GetObject(hvo) as IStText;  					vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  						(int)FwTextPropVar.ktpvDefault'  						(int)TptEditable.ktptNotEditable);  					vwenv.OpenDiv();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 6000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  						(int)FwTextPropVar.ktpvMilliPoint' 24000);  					// Add both vernacular and analysis if we have them (LT-5561).  					bool fAddedVernacular = false;  					int wsVernTitle = 0;  					//  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstVern' out wsVernTitle))  					{  						vwenv.OpenParagraph();  						vwenv.AddStringAltMember(vtagStTextTitle' wsVernTitle' this);  						vwenv.CloseParagraph();  						fAddedVernacular = true;  					}  					int wsAnalysisTitle = 0;  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					ITsString tssAnal;  					if (stText.Title.TryWs(WritingSystemServices.kwsFirstAnal' out wsAnalysisTitle' out tssAnal) &&  						!tssAnal.Equals(stText.Title.BestVernacularAlternative))  					{  						if (fAddedVernacular)  						{  							// display analysis title at smaller font size.  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 12000);  						}  						vwenv.AddStringAltMember(vtagStTextTitle' wsAnalysisTitle' this);  					}  					else  					{  						// just add a blank title.  						ITsString blankTitle = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(blankTitle);  					}  					vwenv.CloseParagraph();  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					int wsSource = 0;  					if (stText.Source.TryWs(WritingSystemServices.kwsFirstVernOrAnal' out wsSource))  					{  						vwenv.OpenParagraph();  						vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  							(int)FwTextPropVar.ktpvMilliPoint' 12000);  						vwenv.AddStringAltMember(vtagStTextSource' wsSource' this);  						vwenv.CloseParagraph();  					}  					else  					{  						// just add a blank source.  						ITsString tssBlank = TsStringUtils.EmptyString(m_wsAnalysis);  						vwenv.AddString(tssBlank);  					}  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  						(int)FwTextPropVar.ktpvMilliPoint' 10000);  					vwenv.OpenParagraph();  					if (stText.OwningFlid == TextTags.kflidContents)  					{  						vwenv.AddObjProp((int)CmObjectFields.kflidCmObject_Owner' this' kfragTextDescription);  					}  					vwenv.CloseParagraph();  					base.Display(vwenv' hvo' frag);  					vwenv.CloseDiv();  					break;  				case kfragTextDescription:  					vwenv.AddStringAltMember(CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					break;  				default:  					base.Display(vwenv' hvo' frag);  					break;  			}
Magic Number,SIL.FieldWorks.IText,InterlinTaggingChild,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinTaggingChild.cs,OnLastBundle,The following statement contains a magic number: var levels = new SelLevInfo[3];
Magic Number,SIL.FieldWorks.IText,InterlinTaggingChild,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinTaggingChild.cs,OnLastBundle,The following statement contains a magic number: levels[2].tag = StTextTags.kflidParagraphs;
Magic Number,SIL.FieldWorks.IText,InterlinTaggingChild,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinTaggingChild.cs,OnLastBundle,The following statement contains a magic number: levels[2].ihvo = RootStText.ParagraphsOS.Count - 1;
Magic Number,SIL.FieldWorks.IText,InterlinTaggingChild,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinTaggingChild.cs,OnFirstBundle,The following statement contains a magic number: var levels = new SelLevInfo[3];
Magic Number,SIL.FieldWorks.IText,InterlinTaggingChild,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinTaggingChild.cs,OnFirstBundle,The following statement contains a magic number: levels[2].tag = StTextTags.kflidParagraphs;
Magic Number,SIL.FieldWorks.IText,InterlinTaggingChild,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinTaggingChild.cs,OnFirstBundle,The following statement contains a magic number: levels[2].ihvo = 0;
Magic Number,SIL.FieldWorks.IText,InterlinTaggingChild,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinTaggingChild.cs,OnMouseDown,The following statement contains a magic number: if (e.Button == MouseButtons.Right)  			{  				var selTest = GrabMousePtSelectionToTest(e);    				// Could be the user right-clicked on the labels?  				// If so' activate the base class method  				int dummy;  				if (UserClickedOnLabels(selTest' out dummy))  				{  					base.OnMouseDown(e);  					return;  				}    				// (LT-9415) if the user has right-clicked in a selected occurrence' bring  				// up context menu for those selected ocurrences.  				// otherwise' bring up the context menu for any newly selected occurrence.  				if (SelectedWordforms != null && SelectedWordforms.Count > 0)  				{  					var newSelectedOccurrences = GetSelectedOccurrences(selTest);  					// if we don't overlap with an existing occurrence selection then  					// make a new occurrence selection. (Otherwise' just make the context  					// menu based on the current selected occurrences).  					if (newSelectedOccurrences == null ||  						newSelectedOccurrences.Count == 0 ||  						!SelectedWordforms.Contains(newSelectedOccurrences[0]))  					{  						// make a new (occurrence) selection (via our SelectionChanged override)  						// before making the context menu.  						selTest.Install();  					}  				}  				// Make a context menu and show it' if I'm not just closing one!  				// This time test seems to be the only way to find out whether this click closed the last one.  				if (DateTime.Now.Ticks - m_ticksWhenContextMenuClosed > 50000) // 5ms!  				{  					m_taggingContextMenu = MakeContextMenu();  					m_taggingContextMenu.Closed += m_taggingContextMenu_Closed;  					m_taggingContextMenu.Show(this' e.X' e.Y);  				}  			} // end right mouse button handler  			else  			{  				base.OnMouseDown(e);  			}
Magic Number,SIL.FieldWorks.IText,InterlinTaggingVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinTaggingChild.cs,AddExtraBundleRows,The following statement contains a magic number: if (m_tagStrings.TryGetValue(key' out tss))  			{  				var stText = analysis.Segment.Owner.Owner;  				// If either the Segment's analyses sequence or the tags on the text change' we want to redraw this  				vwenv.NoteDependency(new [] { analysis.Segment.Hvo' stText.Hvo }'  					new [] { SegmentTags.kflidAnalyses' StTextTags.kflidTags }' 2);  				SetTrailingAlignmentIfNeeded(vwenv' tss);  				vwenv.AddString(tss);  			}
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,Display,The following statement contains a magic number: switch (frag)  			{  			case kfragStText:	// new root object for InterlinDocChild.  				SetupRealVernWsForDisplay(WritingSystemServices.ActualWs(m_cache' WritingSystemServices.kwsVernInParagraph'  					hvo' StTextTags.kflidParagraphs));  				vwenv.AddLazyVecItems(StTextTags.kflidParagraphs' this' kfragInterlinPara);  				break;  			case kfragInterlinPara: // Whole StTxtPara. This can be the root fragment in DE view.  				if (vwenv.DataAccess.get_VecSize(hvo' StTxtParaTags.kflidSegments) == 0)  				{  					vwenv.NoteDependency(new int[] { hvo }' new int[] { StTxtParaTags.kflidSegments }' 1);  					vwenv.AddString(m_tssEmptyPara);  				}  				else  				{  					PreferredVernWs = WritingSystemServices.ActualWs(m_cache' WritingSystemServices.kwsVernInParagraph' hvo' StTxtParaTags.kflidSegments);  					// Include the plain text version of the paragraph?  					vwenv.AddLazyVecItems(StTxtParaTags.kflidSegments' this' kfragParaSegment);  				}  				break;  			case kfragParaSegment:  				// Don't put anything in this segment if it is a 'label' segment (typically containing a verse  				// number for TE).  				var seg = m_segRepository.GetObject(hvo);  				if (seg.IsLabel)  					break;  				// This puts ten points between segments. There's always 5 points below each line of interlinear;  				// if there are no freeform annotations another 5 points makes 10 between segments.  				// If there are freeforms' we need the full 10 points after the last of them.  				var haveFreeform = seg.FreeTranslation != null || seg.LiteralTranslation != null || seg.NotesOS.Count > 0;  				vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  					(int)FwTextPropVar.ktpvMilliPoint' !haveFreeform ? 5000 : 10000);  				vwenv.OpenDiv();  				// Enhance JohnT: determine what the overall direction of the paragraph should  				// be and set it.  				if (m_mpBundleHeight == 0)  				{  					// First time...figure it out.  					int dmpx' dmpyAnal' dmpyVern;  					vwenv.get_StringWidth(m_tssEmptyAnalysis' null' out dmpx' out dmpyAnal);  					vwenv.get_StringWidth(m_tssEmptyVern' null' out dmpx' out dmpyVern);  					m_mpBundleHeight = dmpyAnal * 4 + dmpyVern * 3;  				}  				// The interlinear bundles are not editable.  				vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  					(int)FwTextPropVar.ktpvEnum' (int)TptEditable.ktptNotEditable);  				if (m_fRtl)  				{  					vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  						(int)FwTextPropVar.ktpvEnum' (int)FwTextToggleVal.kttvForceOn);  					vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  						(int)FwTextPropVar.ktpvEnum' (int) FwTextAlign.ktalRight);  				}  				vwenv.set_IntProperty((int)FwTextPropType.ktptSpellCheck' (int)FwTextPropVar.ktpvEnum'  					(int)SpellingModes.ksmDoNotCheck);  				vwenv.OpenParagraph();  				AddSegmentReference(vwenv' hvo);	// Calculate and display the segment reference.  				AddLabelPile(vwenv' m_cache' true' m_fShowMorphBundles);  				vwenv.AddObjVecItems(SegmentTags.kflidAnalyses' this' kfragBundle);  				// JohnT' 1 Feb 2008. Took this out as I can see no reason for it; AddObjVecItems handles  				// the dependency already. Adding it just means that any change to the forms list  				// regenerates a higher level than needed' which contributes to a great deal of scrolling  				// and flashing (LT-7470).  				// Originally added by Eric in revision 72 on the trunk as part of handling phrases.  				// Eric can't see any reason we need it now' either. If you find a need to re-insert it'  				// please document carefully the reasons it is needed and what bad consequences follow  				// from removing it.  				//vwenv.NoteDependency(new int[] { hvo }' new int[] { ktagSegmentForms }' 1);  				vwenv.CloseParagraph();  				// We'd get the same visual effect from just calling AddFreeformAnnotations here. But then a regenerate  				// such as happens when hiding or showing a prompt has to redisplay the whole segment. This initially  				// makes it lazy' then the lazy stuff gets expanded. In the process we may get undesired scrolling (LT-12248).  				// So we insert another layer of object' allowing just the freeforms to be regenerated.  				var flidSelf = Cache.MetaDataCacheAccessor.GetFieldId2(CmObjectTags.kClassId' "Self"' false);  				vwenv.AddObjProp(flidSelf' this' kfragFreeformBundle);  				vwenv.CloseDiv();  				break;  			case kfragFreeformBundle:  				AddFreeformAnnotations(vwenv' hvo);  				break;  			case kfragBundle: // One annotated word bundle; hvo is the IAnalysis object.  				// checking AllowLayout (especially in context of Undo/Redo make/break phrase)  				// helps prevent us from rebuilding the display until we've finished  				// reconstructing the data and cache. Otherwise we can crash.  				if (m_rootsite != null && !m_rootsite.AllowLayout)  					return;  				AddWordBundleInternal(hvo' vwenv);  				break;  			case kfragIsolatedAnalysis: // This one is used for an isolated HVO that is surely an analysis.  			{  				var wa = m_analRepository.GetObject(hvo);  				vwenv.AddObj(wa.Owner.Hvo' this' kfragWordformForm);  				if (m_fShowMorphBundles)  					vwenv.AddObj(hvo' this' kfragAnalysisMorphs);    				int chvoGlosses = wa.MeaningsOC.Count;  				for (int i = 0; i < m_WsList.AnalysisWsIds.Length; ++i)  				{  					SetColor(vwenv' LabelRGBFor(m_lineChoices.IndexOf(InterlinLineChoices.kflidWordGloss'  						m_WsList.AnalysisWsIds[i])));  					if (chvoGlosses == 0)  					{  						// There are no glosses' display something indicating it is missing.  						vwenv.AddProp(ktagAnalysisMissingGloss' this' kfragAnalysisMissingGloss);  					}  					else  					{  						vwenv.AddObjVec(WfiAnalysisTags.kflidMeanings' this' kfragWordGlossWs + i);  					}  				}  				AddAnalysisPos(vwenv' hvo' hvo' -1);  			}  				break;  			case kfragAnalysisMorphs:  				int cmorphs = 0;  				ICmObject co = m_coRepository.GetObject(hvo);  				if (co is IWfiAnalysis)  					cmorphs = (co as IWfiAnalysis).MorphBundlesOS.Count;  				// We really want a variable for this...there have been pathological cases where  				// m_fHaveOpenedParagraph changed during the construction of the paragraph' and we want to be  				// sure to close the paragraph if we opened it.  				var openedParagraph = !m_fHaveOpenedParagraph;  				if (openedParagraph)  					vwenv.OpenParagraph();  				if (cmorphs == 0)  				{  					DisplayMorphBundle(vwenv' 0);  				}  				else  				{  					vwenv.AddObjVecItems(WfiAnalysisTags.kflidMorphBundles' this' kfragMorphBundle);  				}  				if (openedParagraph)  					vwenv.CloseParagraph();  				break;  			case kfragMorphType: // for export only at present' display the  				vwenv.AddObjProp(MoFormTags.kflidMorphType' this' kfragPossibiltyAnalysisName);  				break;  			case kfragPossibiltyAnalysisName:  				vwenv.AddStringAltMember(CmPossibilityTags.kflidName' m_cache.DefaultAnalWs' this);  				break;    			case kfragMorphBundle: // the lines of morpheme information (hvo is a WfiMorphBundle)  				// Make an 'inner pile' to contain the bundle of morph information.  				// Give it 10 points of separation from whatever follows.  				DisplayMorphBundle(vwenv' hvo);  				break;  			case kfragSingleInterlinearAnalysisWithLabels:  				/*  				// This puts ten points between segments. There's always 5 points below each line of interlinear;  				// if there are no freeform annotations another 5 points makes 10 between segments.  				// If there are freeforms' we need the full 10 points after the last of them.  				int cfreeform = vwenv.get_DataAccess().get_VecSize(hvo' ktagSegFF);  				vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  					(int)FwTextPropVar.ktpvMilliPoint' cfreeform == 0 ? 5000 : 10000);  				*/  				vwenv.OpenDiv();  				DisplaySingleInterlinearAnalysisWithLabels(vwenv' hvo);  				vwenv.CloseDiv();  				break;  			// This frag is used to display a single interlin analysis that is always left-aligned' even for RTL languages  			case kfragSingleInterlinearAnalysisWithLabelsLeftAlign:  				vwenv.OpenDiv();  				vwenv.set_IntProperty((int)FwTextPropType.ktptPadLeading' (int)FwTextPropVar.ktpvMilliPoint' m_leftPadding);  				vwenv.OpenParagraph();  				vwenv.OpenInnerPile();  				DisplaySingleInterlinearAnalysisWithLabels(vwenv' hvo);  				vwenv.CloseInnerPile();  				vwenv.CloseParagraph();  				vwenv.CloseDiv();  				break;  			//case kfragDefaultSense: // Some default sense  			//	// NB: If the hvo is zero' then we need to go back to the normal missing sense display' after all.  			//	// (hvo isn't zero' even for cases where there isn't even a default value.)  			//	if (hvo > 0)  			//	{  			//		// Show default sense' in some other 'guess' color.  			//		SetGuessing(vwenv' false);  			//		foreach (int wsId in m_WsList.AnalysisWsIds)  			//			vwenv.AddStringAltMember(LexSenseTags.kflidGloss'  			//				wsId' this);  			//	}  			//	else  			//	{  			//		// Give up and show the missing sense row.  			//		vwenv.AddString(m_tssMissingSense);  			//	}  			//	break;  			case kfragWordformForm: // The form of a WviWordform.  				vwenv.AddStringAltMember(WfiWordformTags.kflidForm'  					m_wsVernForDisplay' this);  				break;  			case kfragPrefix:  				vwenv.AddUnicodeProp(MoMorphTypeTags.kflidPrefix' m_wsVernForDisplay' this);  				break;  			case kfragPostfix:  				vwenv.AddUnicodeProp(MoMorphTypeTags.kflidPostfix' m_wsVernForDisplay' this);  				break;  			case kfragSenseName: // The name (gloss) of a LexSense.  				foreach (int wsId in m_WsList.AnalysisWsIds)  					vwenv.AddStringAltMember(LexSenseTags.kflidGloss'  						wsId' this);  				break;  			case kfragCategory: // the category of a WfiAnalysis' a part of speech;  				// display the Abbreviation property inherited from CmPossibility.  				foreach(var wsId in m_WsList.AnalysisWsIds)  				{  					vwenv.AddStringAltMember(CmPossibilityTags.kflidAbbreviation' wsId' this);  				}  				break;  			default:  				if (frag >= kfragWordGlossWs && frag < kfragWordGlossWs + m_WsList.AnalysisWsIds.Length)  				{  					// Displaying one ws of the  form of a WfiGloss.  					int ws = m_WsList.AnalysisWsIds[frag - kfragWordGlossWs];  					vwenv.AddStringAltMember(WfiGlossTags.kflidForm' ws' this);  				}  				else if (frag >= kfragLineChoices && frag < kfragLineChoices + m_lineChoices.Count)  				{  					var spec = m_lineChoices[frag - kfragLineChoices];  					var ws = GetRealWsOrBestWsForContext(hvo' spec);  					vwenv.AddStringAltMember(spec.StringFlid' ws' this);  				}  				else if (frag >= kfragAnalysisCategoryChoices && frag < kfragAnalysisCategoryChoices + m_lineChoices.Count)  				{  					AddAnalysisPos(vwenv' hvo' hvo' frag - kfragAnalysisCategoryChoices);  				}  				else if (frag >= kfragMorphFormChoices && frag < kfragMorphFormChoices + m_lineChoices.Count)  				{  					InterlinLineSpec spec = m_lineChoices[frag - kfragMorphFormChoices];  					int wsActual = GetRealWsOrBestWsForContext(hvo' spec);  					DisplayMorphForm(vwenv' hvo' wsActual);  				}  				else if (frag >= kfragSegFfChoices && frag < kfragSegFfChoices + m_lineChoices.Count)  				{  					AddFreeformComment(vwenv' hvo' frag - kfragSegFfChoices);  				}  				else  				{  					throw new Exception("Bad fragment ID in InterlinVc.Display");  				}  				break;  		}
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,Display,The following statement contains a magic number: switch (frag)  			{  			case kfragStText:	// new root object for InterlinDocChild.  				SetupRealVernWsForDisplay(WritingSystemServices.ActualWs(m_cache' WritingSystemServices.kwsVernInParagraph'  					hvo' StTextTags.kflidParagraphs));  				vwenv.AddLazyVecItems(StTextTags.kflidParagraphs' this' kfragInterlinPara);  				break;  			case kfragInterlinPara: // Whole StTxtPara. This can be the root fragment in DE view.  				if (vwenv.DataAccess.get_VecSize(hvo' StTxtParaTags.kflidSegments) == 0)  				{  					vwenv.NoteDependency(new int[] { hvo }' new int[] { StTxtParaTags.kflidSegments }' 1);  					vwenv.AddString(m_tssEmptyPara);  				}  				else  				{  					PreferredVernWs = WritingSystemServices.ActualWs(m_cache' WritingSystemServices.kwsVernInParagraph' hvo' StTxtParaTags.kflidSegments);  					// Include the plain text version of the paragraph?  					vwenv.AddLazyVecItems(StTxtParaTags.kflidSegments' this' kfragParaSegment);  				}  				break;  			case kfragParaSegment:  				// Don't put anything in this segment if it is a 'label' segment (typically containing a verse  				// number for TE).  				var seg = m_segRepository.GetObject(hvo);  				if (seg.IsLabel)  					break;  				// This puts ten points between segments. There's always 5 points below each line of interlinear;  				// if there are no freeform annotations another 5 points makes 10 between segments.  				// If there are freeforms' we need the full 10 points after the last of them.  				var haveFreeform = seg.FreeTranslation != null || seg.LiteralTranslation != null || seg.NotesOS.Count > 0;  				vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  					(int)FwTextPropVar.ktpvMilliPoint' !haveFreeform ? 5000 : 10000);  				vwenv.OpenDiv();  				// Enhance JohnT: determine what the overall direction of the paragraph should  				// be and set it.  				if (m_mpBundleHeight == 0)  				{  					// First time...figure it out.  					int dmpx' dmpyAnal' dmpyVern;  					vwenv.get_StringWidth(m_tssEmptyAnalysis' null' out dmpx' out dmpyAnal);  					vwenv.get_StringWidth(m_tssEmptyVern' null' out dmpx' out dmpyVern);  					m_mpBundleHeight = dmpyAnal * 4 + dmpyVern * 3;  				}  				// The interlinear bundles are not editable.  				vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  					(int)FwTextPropVar.ktpvEnum' (int)TptEditable.ktptNotEditable);  				if (m_fRtl)  				{  					vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  						(int)FwTextPropVar.ktpvEnum' (int)FwTextToggleVal.kttvForceOn);  					vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  						(int)FwTextPropVar.ktpvEnum' (int) FwTextAlign.ktalRight);  				}  				vwenv.set_IntProperty((int)FwTextPropType.ktptSpellCheck' (int)FwTextPropVar.ktpvEnum'  					(int)SpellingModes.ksmDoNotCheck);  				vwenv.OpenParagraph();  				AddSegmentReference(vwenv' hvo);	// Calculate and display the segment reference.  				AddLabelPile(vwenv' m_cache' true' m_fShowMorphBundles);  				vwenv.AddObjVecItems(SegmentTags.kflidAnalyses' this' kfragBundle);  				// JohnT' 1 Feb 2008. Took this out as I can see no reason for it; AddObjVecItems handles  				// the dependency already. Adding it just means that any change to the forms list  				// regenerates a higher level than needed' which contributes to a great deal of scrolling  				// and flashing (LT-7470).  				// Originally added by Eric in revision 72 on the trunk as part of handling phrases.  				// Eric can't see any reason we need it now' either. If you find a need to re-insert it'  				// please document carefully the reasons it is needed and what bad consequences follow  				// from removing it.  				//vwenv.NoteDependency(new int[] { hvo }' new int[] { ktagSegmentForms }' 1);  				vwenv.CloseParagraph();  				// We'd get the same visual effect from just calling AddFreeformAnnotations here. But then a regenerate  				// such as happens when hiding or showing a prompt has to redisplay the whole segment. This initially  				// makes it lazy' then the lazy stuff gets expanded. In the process we may get undesired scrolling (LT-12248).  				// So we insert another layer of object' allowing just the freeforms to be regenerated.  				var flidSelf = Cache.MetaDataCacheAccessor.GetFieldId2(CmObjectTags.kClassId' "Self"' false);  				vwenv.AddObjProp(flidSelf' this' kfragFreeformBundle);  				vwenv.CloseDiv();  				break;  			case kfragFreeformBundle:  				AddFreeformAnnotations(vwenv' hvo);  				break;  			case kfragBundle: // One annotated word bundle; hvo is the IAnalysis object.  				// checking AllowLayout (especially in context of Undo/Redo make/break phrase)  				// helps prevent us from rebuilding the display until we've finished  				// reconstructing the data and cache. Otherwise we can crash.  				if (m_rootsite != null && !m_rootsite.AllowLayout)  					return;  				AddWordBundleInternal(hvo' vwenv);  				break;  			case kfragIsolatedAnalysis: // This one is used for an isolated HVO that is surely an analysis.  			{  				var wa = m_analRepository.GetObject(hvo);  				vwenv.AddObj(wa.Owner.Hvo' this' kfragWordformForm);  				if (m_fShowMorphBundles)  					vwenv.AddObj(hvo' this' kfragAnalysisMorphs);    				int chvoGlosses = wa.MeaningsOC.Count;  				for (int i = 0; i < m_WsList.AnalysisWsIds.Length; ++i)  				{  					SetColor(vwenv' LabelRGBFor(m_lineChoices.IndexOf(InterlinLineChoices.kflidWordGloss'  						m_WsList.AnalysisWsIds[i])));  					if (chvoGlosses == 0)  					{  						// There are no glosses' display something indicating it is missing.  						vwenv.AddProp(ktagAnalysisMissingGloss' this' kfragAnalysisMissingGloss);  					}  					else  					{  						vwenv.AddObjVec(WfiAnalysisTags.kflidMeanings' this' kfragWordGlossWs + i);  					}  				}  				AddAnalysisPos(vwenv' hvo' hvo' -1);  			}  				break;  			case kfragAnalysisMorphs:  				int cmorphs = 0;  				ICmObject co = m_coRepository.GetObject(hvo);  				if (co is IWfiAnalysis)  					cmorphs = (co as IWfiAnalysis).MorphBundlesOS.Count;  				// We really want a variable for this...there have been pathological cases where  				// m_fHaveOpenedParagraph changed during the construction of the paragraph' and we want to be  				// sure to close the paragraph if we opened it.  				var openedParagraph = !m_fHaveOpenedParagraph;  				if (openedParagraph)  					vwenv.OpenParagraph();  				if (cmorphs == 0)  				{  					DisplayMorphBundle(vwenv' 0);  				}  				else  				{  					vwenv.AddObjVecItems(WfiAnalysisTags.kflidMorphBundles' this' kfragMorphBundle);  				}  				if (openedParagraph)  					vwenv.CloseParagraph();  				break;  			case kfragMorphType: // for export only at present' display the  				vwenv.AddObjProp(MoFormTags.kflidMorphType' this' kfragPossibiltyAnalysisName);  				break;  			case kfragPossibiltyAnalysisName:  				vwenv.AddStringAltMember(CmPossibilityTags.kflidName' m_cache.DefaultAnalWs' this);  				break;    			case kfragMorphBundle: // the lines of morpheme information (hvo is a WfiMorphBundle)  				// Make an 'inner pile' to contain the bundle of morph information.  				// Give it 10 points of separation from whatever follows.  				DisplayMorphBundle(vwenv' hvo);  				break;  			case kfragSingleInterlinearAnalysisWithLabels:  				/*  				// This puts ten points between segments. There's always 5 points below each line of interlinear;  				// if there are no freeform annotations another 5 points makes 10 between segments.  				// If there are freeforms' we need the full 10 points after the last of them.  				int cfreeform = vwenv.get_DataAccess().get_VecSize(hvo' ktagSegFF);  				vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  					(int)FwTextPropVar.ktpvMilliPoint' cfreeform == 0 ? 5000 : 10000);  				*/  				vwenv.OpenDiv();  				DisplaySingleInterlinearAnalysisWithLabels(vwenv' hvo);  				vwenv.CloseDiv();  				break;  			// This frag is used to display a single interlin analysis that is always left-aligned' even for RTL languages  			case kfragSingleInterlinearAnalysisWithLabelsLeftAlign:  				vwenv.OpenDiv();  				vwenv.set_IntProperty((int)FwTextPropType.ktptPadLeading' (int)FwTextPropVar.ktpvMilliPoint' m_leftPadding);  				vwenv.OpenParagraph();  				vwenv.OpenInnerPile();  				DisplaySingleInterlinearAnalysisWithLabels(vwenv' hvo);  				vwenv.CloseInnerPile();  				vwenv.CloseParagraph();  				vwenv.CloseDiv();  				break;  			//case kfragDefaultSense: // Some default sense  			//	// NB: If the hvo is zero' then we need to go back to the normal missing sense display' after all.  			//	// (hvo isn't zero' even for cases where there isn't even a default value.)  			//	if (hvo > 0)  			//	{  			//		// Show default sense' in some other 'guess' color.  			//		SetGuessing(vwenv' false);  			//		foreach (int wsId in m_WsList.AnalysisWsIds)  			//			vwenv.AddStringAltMember(LexSenseTags.kflidGloss'  			//				wsId' this);  			//	}  			//	else  			//	{  			//		// Give up and show the missing sense row.  			//		vwenv.AddString(m_tssMissingSense);  			//	}  			//	break;  			case kfragWordformForm: // The form of a WviWordform.  				vwenv.AddStringAltMember(WfiWordformTags.kflidForm'  					m_wsVernForDisplay' this);  				break;  			case kfragPrefix:  				vwenv.AddUnicodeProp(MoMorphTypeTags.kflidPrefix' m_wsVernForDisplay' this);  				break;  			case kfragPostfix:  				vwenv.AddUnicodeProp(MoMorphTypeTags.kflidPostfix' m_wsVernForDisplay' this);  				break;  			case kfragSenseName: // The name (gloss) of a LexSense.  				foreach (int wsId in m_WsList.AnalysisWsIds)  					vwenv.AddStringAltMember(LexSenseTags.kflidGloss'  						wsId' this);  				break;  			case kfragCategory: // the category of a WfiAnalysis' a part of speech;  				// display the Abbreviation property inherited from CmPossibility.  				foreach(var wsId in m_WsList.AnalysisWsIds)  				{  					vwenv.AddStringAltMember(CmPossibilityTags.kflidAbbreviation' wsId' this);  				}  				break;  			default:  				if (frag >= kfragWordGlossWs && frag < kfragWordGlossWs + m_WsList.AnalysisWsIds.Length)  				{  					// Displaying one ws of the  form of a WfiGloss.  					int ws = m_WsList.AnalysisWsIds[frag - kfragWordGlossWs];  					vwenv.AddStringAltMember(WfiGlossTags.kflidForm' ws' this);  				}  				else if (frag >= kfragLineChoices && frag < kfragLineChoices + m_lineChoices.Count)  				{  					var spec = m_lineChoices[frag - kfragLineChoices];  					var ws = GetRealWsOrBestWsForContext(hvo' spec);  					vwenv.AddStringAltMember(spec.StringFlid' ws' this);  				}  				else if (frag >= kfragAnalysisCategoryChoices && frag < kfragAnalysisCategoryChoices + m_lineChoices.Count)  				{  					AddAnalysisPos(vwenv' hvo' hvo' frag - kfragAnalysisCategoryChoices);  				}  				else if (frag >= kfragMorphFormChoices && frag < kfragMorphFormChoices + m_lineChoices.Count)  				{  					InterlinLineSpec spec = m_lineChoices[frag - kfragMorphFormChoices];  					int wsActual = GetRealWsOrBestWsForContext(hvo' spec);  					DisplayMorphForm(vwenv' hvo' wsActual);  				}  				else if (frag >= kfragSegFfChoices && frag < kfragSegFfChoices + m_lineChoices.Count)  				{  					AddFreeformComment(vwenv' hvo' frag - kfragSegFfChoices);  				}  				else  				{  					throw new Exception("Bad fragment ID in InterlinVc.Display");  				}  				break;  		}
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,Display,The following statement contains a magic number: switch (frag)  			{  			case kfragStText:	// new root object for InterlinDocChild.  				SetupRealVernWsForDisplay(WritingSystemServices.ActualWs(m_cache' WritingSystemServices.kwsVernInParagraph'  					hvo' StTextTags.kflidParagraphs));  				vwenv.AddLazyVecItems(StTextTags.kflidParagraphs' this' kfragInterlinPara);  				break;  			case kfragInterlinPara: // Whole StTxtPara. This can be the root fragment in DE view.  				if (vwenv.DataAccess.get_VecSize(hvo' StTxtParaTags.kflidSegments) == 0)  				{  					vwenv.NoteDependency(new int[] { hvo }' new int[] { StTxtParaTags.kflidSegments }' 1);  					vwenv.AddString(m_tssEmptyPara);  				}  				else  				{  					PreferredVernWs = WritingSystemServices.ActualWs(m_cache' WritingSystemServices.kwsVernInParagraph' hvo' StTxtParaTags.kflidSegments);  					// Include the plain text version of the paragraph?  					vwenv.AddLazyVecItems(StTxtParaTags.kflidSegments' this' kfragParaSegment);  				}  				break;  			case kfragParaSegment:  				// Don't put anything in this segment if it is a 'label' segment (typically containing a verse  				// number for TE).  				var seg = m_segRepository.GetObject(hvo);  				if (seg.IsLabel)  					break;  				// This puts ten points between segments. There's always 5 points below each line of interlinear;  				// if there are no freeform annotations another 5 points makes 10 between segments.  				// If there are freeforms' we need the full 10 points after the last of them.  				var haveFreeform = seg.FreeTranslation != null || seg.LiteralTranslation != null || seg.NotesOS.Count > 0;  				vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  					(int)FwTextPropVar.ktpvMilliPoint' !haveFreeform ? 5000 : 10000);  				vwenv.OpenDiv();  				// Enhance JohnT: determine what the overall direction of the paragraph should  				// be and set it.  				if (m_mpBundleHeight == 0)  				{  					// First time...figure it out.  					int dmpx' dmpyAnal' dmpyVern;  					vwenv.get_StringWidth(m_tssEmptyAnalysis' null' out dmpx' out dmpyAnal);  					vwenv.get_StringWidth(m_tssEmptyVern' null' out dmpx' out dmpyVern);  					m_mpBundleHeight = dmpyAnal * 4 + dmpyVern * 3;  				}  				// The interlinear bundles are not editable.  				vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  					(int)FwTextPropVar.ktpvEnum' (int)TptEditable.ktptNotEditable);  				if (m_fRtl)  				{  					vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  						(int)FwTextPropVar.ktpvEnum' (int)FwTextToggleVal.kttvForceOn);  					vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  						(int)FwTextPropVar.ktpvEnum' (int) FwTextAlign.ktalRight);  				}  				vwenv.set_IntProperty((int)FwTextPropType.ktptSpellCheck' (int)FwTextPropVar.ktpvEnum'  					(int)SpellingModes.ksmDoNotCheck);  				vwenv.OpenParagraph();  				AddSegmentReference(vwenv' hvo);	// Calculate and display the segment reference.  				AddLabelPile(vwenv' m_cache' true' m_fShowMorphBundles);  				vwenv.AddObjVecItems(SegmentTags.kflidAnalyses' this' kfragBundle);  				// JohnT' 1 Feb 2008. Took this out as I can see no reason for it; AddObjVecItems handles  				// the dependency already. Adding it just means that any change to the forms list  				// regenerates a higher level than needed' which contributes to a great deal of scrolling  				// and flashing (LT-7470).  				// Originally added by Eric in revision 72 on the trunk as part of handling phrases.  				// Eric can't see any reason we need it now' either. If you find a need to re-insert it'  				// please document carefully the reasons it is needed and what bad consequences follow  				// from removing it.  				//vwenv.NoteDependency(new int[] { hvo }' new int[] { ktagSegmentForms }' 1);  				vwenv.CloseParagraph();  				// We'd get the same visual effect from just calling AddFreeformAnnotations here. But then a regenerate  				// such as happens when hiding or showing a prompt has to redisplay the whole segment. This initially  				// makes it lazy' then the lazy stuff gets expanded. In the process we may get undesired scrolling (LT-12248).  				// So we insert another layer of object' allowing just the freeforms to be regenerated.  				var flidSelf = Cache.MetaDataCacheAccessor.GetFieldId2(CmObjectTags.kClassId' "Self"' false);  				vwenv.AddObjProp(flidSelf' this' kfragFreeformBundle);  				vwenv.CloseDiv();  				break;  			case kfragFreeformBundle:  				AddFreeformAnnotations(vwenv' hvo);  				break;  			case kfragBundle: // One annotated word bundle; hvo is the IAnalysis object.  				// checking AllowLayout (especially in context of Undo/Redo make/break phrase)  				// helps prevent us from rebuilding the display until we've finished  				// reconstructing the data and cache. Otherwise we can crash.  				if (m_rootsite != null && !m_rootsite.AllowLayout)  					return;  				AddWordBundleInternal(hvo' vwenv);  				break;  			case kfragIsolatedAnalysis: // This one is used for an isolated HVO that is surely an analysis.  			{  				var wa = m_analRepository.GetObject(hvo);  				vwenv.AddObj(wa.Owner.Hvo' this' kfragWordformForm);  				if (m_fShowMorphBundles)  					vwenv.AddObj(hvo' this' kfragAnalysisMorphs);    				int chvoGlosses = wa.MeaningsOC.Count;  				for (int i = 0; i < m_WsList.AnalysisWsIds.Length; ++i)  				{  					SetColor(vwenv' LabelRGBFor(m_lineChoices.IndexOf(InterlinLineChoices.kflidWordGloss'  						m_WsList.AnalysisWsIds[i])));  					if (chvoGlosses == 0)  					{  						// There are no glosses' display something indicating it is missing.  						vwenv.AddProp(ktagAnalysisMissingGloss' this' kfragAnalysisMissingGloss);  					}  					else  					{  						vwenv.AddObjVec(WfiAnalysisTags.kflidMeanings' this' kfragWordGlossWs + i);  					}  				}  				AddAnalysisPos(vwenv' hvo' hvo' -1);  			}  				break;  			case kfragAnalysisMorphs:  				int cmorphs = 0;  				ICmObject co = m_coRepository.GetObject(hvo);  				if (co is IWfiAnalysis)  					cmorphs = (co as IWfiAnalysis).MorphBundlesOS.Count;  				// We really want a variable for this...there have been pathological cases where  				// m_fHaveOpenedParagraph changed during the construction of the paragraph' and we want to be  				// sure to close the paragraph if we opened it.  				var openedParagraph = !m_fHaveOpenedParagraph;  				if (openedParagraph)  					vwenv.OpenParagraph();  				if (cmorphs == 0)  				{  					DisplayMorphBundle(vwenv' 0);  				}  				else  				{  					vwenv.AddObjVecItems(WfiAnalysisTags.kflidMorphBundles' this' kfragMorphBundle);  				}  				if (openedParagraph)  					vwenv.CloseParagraph();  				break;  			case kfragMorphType: // for export only at present' display the  				vwenv.AddObjProp(MoFormTags.kflidMorphType' this' kfragPossibiltyAnalysisName);  				break;  			case kfragPossibiltyAnalysisName:  				vwenv.AddStringAltMember(CmPossibilityTags.kflidName' m_cache.DefaultAnalWs' this);  				break;    			case kfragMorphBundle: // the lines of morpheme information (hvo is a WfiMorphBundle)  				// Make an 'inner pile' to contain the bundle of morph information.  				// Give it 10 points of separation from whatever follows.  				DisplayMorphBundle(vwenv' hvo);  				break;  			case kfragSingleInterlinearAnalysisWithLabels:  				/*  				// This puts ten points between segments. There's always 5 points below each line of interlinear;  				// if there are no freeform annotations another 5 points makes 10 between segments.  				// If there are freeforms' we need the full 10 points after the last of them.  				int cfreeform = vwenv.get_DataAccess().get_VecSize(hvo' ktagSegFF);  				vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  					(int)FwTextPropVar.ktpvMilliPoint' cfreeform == 0 ? 5000 : 10000);  				*/  				vwenv.OpenDiv();  				DisplaySingleInterlinearAnalysisWithLabels(vwenv' hvo);  				vwenv.CloseDiv();  				break;  			// This frag is used to display a single interlin analysis that is always left-aligned' even for RTL languages  			case kfragSingleInterlinearAnalysisWithLabelsLeftAlign:  				vwenv.OpenDiv();  				vwenv.set_IntProperty((int)FwTextPropType.ktptPadLeading' (int)FwTextPropVar.ktpvMilliPoint' m_leftPadding);  				vwenv.OpenParagraph();  				vwenv.OpenInnerPile();  				DisplaySingleInterlinearAnalysisWithLabels(vwenv' hvo);  				vwenv.CloseInnerPile();  				vwenv.CloseParagraph();  				vwenv.CloseDiv();  				break;  			//case kfragDefaultSense: // Some default sense  			//	// NB: If the hvo is zero' then we need to go back to the normal missing sense display' after all.  			//	// (hvo isn't zero' even for cases where there isn't even a default value.)  			//	if (hvo > 0)  			//	{  			//		// Show default sense' in some other 'guess' color.  			//		SetGuessing(vwenv' false);  			//		foreach (int wsId in m_WsList.AnalysisWsIds)  			//			vwenv.AddStringAltMember(LexSenseTags.kflidGloss'  			//				wsId' this);  			//	}  			//	else  			//	{  			//		// Give up and show the missing sense row.  			//		vwenv.AddString(m_tssMissingSense);  			//	}  			//	break;  			case kfragWordformForm: // The form of a WviWordform.  				vwenv.AddStringAltMember(WfiWordformTags.kflidForm'  					m_wsVernForDisplay' this);  				break;  			case kfragPrefix:  				vwenv.AddUnicodeProp(MoMorphTypeTags.kflidPrefix' m_wsVernForDisplay' this);  				break;  			case kfragPostfix:  				vwenv.AddUnicodeProp(MoMorphTypeTags.kflidPostfix' m_wsVernForDisplay' this);  				break;  			case kfragSenseName: // The name (gloss) of a LexSense.  				foreach (int wsId in m_WsList.AnalysisWsIds)  					vwenv.AddStringAltMember(LexSenseTags.kflidGloss'  						wsId' this);  				break;  			case kfragCategory: // the category of a WfiAnalysis' a part of speech;  				// display the Abbreviation property inherited from CmPossibility.  				foreach(var wsId in m_WsList.AnalysisWsIds)  				{  					vwenv.AddStringAltMember(CmPossibilityTags.kflidAbbreviation' wsId' this);  				}  				break;  			default:  				if (frag >= kfragWordGlossWs && frag < kfragWordGlossWs + m_WsList.AnalysisWsIds.Length)  				{  					// Displaying one ws of the  form of a WfiGloss.  					int ws = m_WsList.AnalysisWsIds[frag - kfragWordGlossWs];  					vwenv.AddStringAltMember(WfiGlossTags.kflidForm' ws' this);  				}  				else if (frag >= kfragLineChoices && frag < kfragLineChoices + m_lineChoices.Count)  				{  					var spec = m_lineChoices[frag - kfragLineChoices];  					var ws = GetRealWsOrBestWsForContext(hvo' spec);  					vwenv.AddStringAltMember(spec.StringFlid' ws' this);  				}  				else if (frag >= kfragAnalysisCategoryChoices && frag < kfragAnalysisCategoryChoices + m_lineChoices.Count)  				{  					AddAnalysisPos(vwenv' hvo' hvo' frag - kfragAnalysisCategoryChoices);  				}  				else if (frag >= kfragMorphFormChoices && frag < kfragMorphFormChoices + m_lineChoices.Count)  				{  					InterlinLineSpec spec = m_lineChoices[frag - kfragMorphFormChoices];  					int wsActual = GetRealWsOrBestWsForContext(hvo' spec);  					DisplayMorphForm(vwenv' hvo' wsActual);  				}  				else if (frag >= kfragSegFfChoices && frag < kfragSegFfChoices + m_lineChoices.Count)  				{  					AddFreeformComment(vwenv' hvo' frag - kfragSegFfChoices);  				}  				else  				{  					throw new Exception("Bad fragment ID in InterlinVc.Display");  				}  				break;  		}
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,Display,The following statement contains a magic number: switch (frag)  			{  			case kfragStText:	// new root object for InterlinDocChild.  				SetupRealVernWsForDisplay(WritingSystemServices.ActualWs(m_cache' WritingSystemServices.kwsVernInParagraph'  					hvo' StTextTags.kflidParagraphs));  				vwenv.AddLazyVecItems(StTextTags.kflidParagraphs' this' kfragInterlinPara);  				break;  			case kfragInterlinPara: // Whole StTxtPara. This can be the root fragment in DE view.  				if (vwenv.DataAccess.get_VecSize(hvo' StTxtParaTags.kflidSegments) == 0)  				{  					vwenv.NoteDependency(new int[] { hvo }' new int[] { StTxtParaTags.kflidSegments }' 1);  					vwenv.AddString(m_tssEmptyPara);  				}  				else  				{  					PreferredVernWs = WritingSystemServices.ActualWs(m_cache' WritingSystemServices.kwsVernInParagraph' hvo' StTxtParaTags.kflidSegments);  					// Include the plain text version of the paragraph?  					vwenv.AddLazyVecItems(StTxtParaTags.kflidSegments' this' kfragParaSegment);  				}  				break;  			case kfragParaSegment:  				// Don't put anything in this segment if it is a 'label' segment (typically containing a verse  				// number for TE).  				var seg = m_segRepository.GetObject(hvo);  				if (seg.IsLabel)  					break;  				// This puts ten points between segments. There's always 5 points below each line of interlinear;  				// if there are no freeform annotations another 5 points makes 10 between segments.  				// If there are freeforms' we need the full 10 points after the last of them.  				var haveFreeform = seg.FreeTranslation != null || seg.LiteralTranslation != null || seg.NotesOS.Count > 0;  				vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  					(int)FwTextPropVar.ktpvMilliPoint' !haveFreeform ? 5000 : 10000);  				vwenv.OpenDiv();  				// Enhance JohnT: determine what the overall direction of the paragraph should  				// be and set it.  				if (m_mpBundleHeight == 0)  				{  					// First time...figure it out.  					int dmpx' dmpyAnal' dmpyVern;  					vwenv.get_StringWidth(m_tssEmptyAnalysis' null' out dmpx' out dmpyAnal);  					vwenv.get_StringWidth(m_tssEmptyVern' null' out dmpx' out dmpyVern);  					m_mpBundleHeight = dmpyAnal * 4 + dmpyVern * 3;  				}  				// The interlinear bundles are not editable.  				vwenv.set_IntProperty((int)FwTextPropType.ktptEditable'  					(int)FwTextPropVar.ktpvEnum' (int)TptEditable.ktptNotEditable);  				if (m_fRtl)  				{  					vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  						(int)FwTextPropVar.ktpvEnum' (int)FwTextToggleVal.kttvForceOn);  					vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  						(int)FwTextPropVar.ktpvEnum' (int) FwTextAlign.ktalRight);  				}  				vwenv.set_IntProperty((int)FwTextPropType.ktptSpellCheck' (int)FwTextPropVar.ktpvEnum'  					(int)SpellingModes.ksmDoNotCheck);  				vwenv.OpenParagraph();  				AddSegmentReference(vwenv' hvo);	// Calculate and display the segment reference.  				AddLabelPile(vwenv' m_cache' true' m_fShowMorphBundles);  				vwenv.AddObjVecItems(SegmentTags.kflidAnalyses' this' kfragBundle);  				// JohnT' 1 Feb 2008. Took this out as I can see no reason for it; AddObjVecItems handles  				// the dependency already. Adding it just means that any change to the forms list  				// regenerates a higher level than needed' which contributes to a great deal of scrolling  				// and flashing (LT-7470).  				// Originally added by Eric in revision 72 on the trunk as part of handling phrases.  				// Eric can't see any reason we need it now' either. If you find a need to re-insert it'  				// please document carefully the reasons it is needed and what bad consequences follow  				// from removing it.  				//vwenv.NoteDependency(new int[] { hvo }' new int[] { ktagSegmentForms }' 1);  				vwenv.CloseParagraph();  				// We'd get the same visual effect from just calling AddFreeformAnnotations here. But then a regenerate  				// such as happens when hiding or showing a prompt has to redisplay the whole segment. This initially  				// makes it lazy' then the lazy stuff gets expanded. In the process we may get undesired scrolling (LT-12248).  				// So we insert another layer of object' allowing just the freeforms to be regenerated.  				var flidSelf = Cache.MetaDataCacheAccessor.GetFieldId2(CmObjectTags.kClassId' "Self"' false);  				vwenv.AddObjProp(flidSelf' this' kfragFreeformBundle);  				vwenv.CloseDiv();  				break;  			case kfragFreeformBundle:  				AddFreeformAnnotations(vwenv' hvo);  				break;  			case kfragBundle: // One annotated word bundle; hvo is the IAnalysis object.  				// checking AllowLayout (especially in context of Undo/Redo make/break phrase)  				// helps prevent us from rebuilding the display until we've finished  				// reconstructing the data and cache. Otherwise we can crash.  				if (m_rootsite != null && !m_rootsite.AllowLayout)  					return;  				AddWordBundleInternal(hvo' vwenv);  				break;  			case kfragIsolatedAnalysis: // This one is used for an isolated HVO that is surely an analysis.  			{  				var wa = m_analRepository.GetObject(hvo);  				vwenv.AddObj(wa.Owner.Hvo' this' kfragWordformForm);  				if (m_fShowMorphBundles)  					vwenv.AddObj(hvo' this' kfragAnalysisMorphs);    				int chvoGlosses = wa.MeaningsOC.Count;  				for (int i = 0; i < m_WsList.AnalysisWsIds.Length; ++i)  				{  					SetColor(vwenv' LabelRGBFor(m_lineChoices.IndexOf(InterlinLineChoices.kflidWordGloss'  						m_WsList.AnalysisWsIds[i])));  					if (chvoGlosses == 0)  					{  						// There are no glosses' display something indicating it is missing.  						vwenv.AddProp(ktagAnalysisMissingGloss' this' kfragAnalysisMissingGloss);  					}  					else  					{  						vwenv.AddObjVec(WfiAnalysisTags.kflidMeanings' this' kfragWordGlossWs + i);  					}  				}  				AddAnalysisPos(vwenv' hvo' hvo' -1);  			}  				break;  			case kfragAnalysisMorphs:  				int cmorphs = 0;  				ICmObject co = m_coRepository.GetObject(hvo);  				if (co is IWfiAnalysis)  					cmorphs = (co as IWfiAnalysis).MorphBundlesOS.Count;  				// We really want a variable for this...there have been pathological cases where  				// m_fHaveOpenedParagraph changed during the construction of the paragraph' and we want to be  				// sure to close the paragraph if we opened it.  				var openedParagraph = !m_fHaveOpenedParagraph;  				if (openedParagraph)  					vwenv.OpenParagraph();  				if (cmorphs == 0)  				{  					DisplayMorphBundle(vwenv' 0);  				}  				else  				{  					vwenv.AddObjVecItems(WfiAnalysisTags.kflidMorphBundles' this' kfragMorphBundle);  				}  				if (openedParagraph)  					vwenv.CloseParagraph();  				break;  			case kfragMorphType: // for export only at present' display the  				vwenv.AddObjProp(MoFormTags.kflidMorphType' this' kfragPossibiltyAnalysisName);  				break;  			case kfragPossibiltyAnalysisName:  				vwenv.AddStringAltMember(CmPossibilityTags.kflidName' m_cache.DefaultAnalWs' this);  				break;    			case kfragMorphBundle: // the lines of morpheme information (hvo is a WfiMorphBundle)  				// Make an 'inner pile' to contain the bundle of morph information.  				// Give it 10 points of separation from whatever follows.  				DisplayMorphBundle(vwenv' hvo);  				break;  			case kfragSingleInterlinearAnalysisWithLabels:  				/*  				// This puts ten points between segments. There's always 5 points below each line of interlinear;  				// if there are no freeform annotations another 5 points makes 10 between segments.  				// If there are freeforms' we need the full 10 points after the last of them.  				int cfreeform = vwenv.get_DataAccess().get_VecSize(hvo' ktagSegFF);  				vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  					(int)FwTextPropVar.ktpvMilliPoint' cfreeform == 0 ? 5000 : 10000);  				*/  				vwenv.OpenDiv();  				DisplaySingleInterlinearAnalysisWithLabels(vwenv' hvo);  				vwenv.CloseDiv();  				break;  			// This frag is used to display a single interlin analysis that is always left-aligned' even for RTL languages  			case kfragSingleInterlinearAnalysisWithLabelsLeftAlign:  				vwenv.OpenDiv();  				vwenv.set_IntProperty((int)FwTextPropType.ktptPadLeading' (int)FwTextPropVar.ktpvMilliPoint' m_leftPadding);  				vwenv.OpenParagraph();  				vwenv.OpenInnerPile();  				DisplaySingleInterlinearAnalysisWithLabels(vwenv' hvo);  				vwenv.CloseInnerPile();  				vwenv.CloseParagraph();  				vwenv.CloseDiv();  				break;  			//case kfragDefaultSense: // Some default sense  			//	// NB: If the hvo is zero' then we need to go back to the normal missing sense display' after all.  			//	// (hvo isn't zero' even for cases where there isn't even a default value.)  			//	if (hvo > 0)  			//	{  			//		// Show default sense' in some other 'guess' color.  			//		SetGuessing(vwenv' false);  			//		foreach (int wsId in m_WsList.AnalysisWsIds)  			//			vwenv.AddStringAltMember(LexSenseTags.kflidGloss'  			//				wsId' this);  			//	}  			//	else  			//	{  			//		// Give up and show the missing sense row.  			//		vwenv.AddString(m_tssMissingSense);  			//	}  			//	break;  			case kfragWordformForm: // The form of a WviWordform.  				vwenv.AddStringAltMember(WfiWordformTags.kflidForm'  					m_wsVernForDisplay' this);  				break;  			case kfragPrefix:  				vwenv.AddUnicodeProp(MoMorphTypeTags.kflidPrefix' m_wsVernForDisplay' this);  				break;  			case kfragPostfix:  				vwenv.AddUnicodeProp(MoMorphTypeTags.kflidPostfix' m_wsVernForDisplay' this);  				break;  			case kfragSenseName: // The name (gloss) of a LexSense.  				foreach (int wsId in m_WsList.AnalysisWsIds)  					vwenv.AddStringAltMember(LexSenseTags.kflidGloss'  						wsId' this);  				break;  			case kfragCategory: // the category of a WfiAnalysis' a part of speech;  				// display the Abbreviation property inherited from CmPossibility.  				foreach(var wsId in m_WsList.AnalysisWsIds)  				{  					vwenv.AddStringAltMember(CmPossibilityTags.kflidAbbreviation' wsId' this);  				}  				break;  			default:  				if (frag >= kfragWordGlossWs && frag < kfragWordGlossWs + m_WsList.AnalysisWsIds.Length)  				{  					// Displaying one ws of the  form of a WfiGloss.  					int ws = m_WsList.AnalysisWsIds[frag - kfragWordGlossWs];  					vwenv.AddStringAltMember(WfiGlossTags.kflidForm' ws' this);  				}  				else if (frag >= kfragLineChoices && frag < kfragLineChoices + m_lineChoices.Count)  				{  					var spec = m_lineChoices[frag - kfragLineChoices];  					var ws = GetRealWsOrBestWsForContext(hvo' spec);  					vwenv.AddStringAltMember(spec.StringFlid' ws' this);  				}  				else if (frag >= kfragAnalysisCategoryChoices && frag < kfragAnalysisCategoryChoices + m_lineChoices.Count)  				{  					AddAnalysisPos(vwenv' hvo' hvo' frag - kfragAnalysisCategoryChoices);  				}  				else if (frag >= kfragMorphFormChoices && frag < kfragMorphFormChoices + m_lineChoices.Count)  				{  					InterlinLineSpec spec = m_lineChoices[frag - kfragMorphFormChoices];  					int wsActual = GetRealWsOrBestWsForContext(hvo' spec);  					DisplayMorphForm(vwenv' hvo' wsActual);  				}  				else if (frag >= kfragSegFfChoices && frag < kfragSegFfChoices + m_lineChoices.Count)  				{  					AddFreeformComment(vwenv' hvo' frag - kfragSegFfChoices);  				}  				else  				{  					throw new Exception("Bad fragment ID in InterlinVc.Display");  				}  				break;  		}
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,SetupAndOpenInnerPile,The following statement contains a magic number: vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  								  (int)FwTextPropVar.ktpvMilliPoint' 10000);
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,SetupAndOpenInnerPile,The following statement contains a magic number: vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  								  (int)FwTextPropVar.ktpvMilliPoint' 5000);
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,AddSegmentReference,The following statement contains a magic number: vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  				(int)FwTextPropVar.ktpvMilliPoint' 10000);
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,DisplayMorphBundle,The following statement contains a magic number: vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  				(int)FwTextPropVar.ktpvMilliPoint' 10000);
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,AddLabelPile,The following statement contains a magic number: vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  				(int)FwTextPropVar.ktpvMilliPoint' 10000);
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,AddLabelPile,The following statement contains a magic number: vwenv.set_IntProperty((int)FwTextPropType.ktptMarginBottom'  				(int)FwTextPropVar.ktpvMilliPoint'  				5000);
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,EstimateHeight,The following statement contains a magic number: switch (frag)  			{  					// If you change this' remember that an estimate that is too HIGH just means it takes a few iterations  					// to fill the screen' and the thumb on the scroll bar is a bit small. But if it is too SMALL'  					// we will expand more objects than we need' which is much more expensive.  					// Also remember: this gets called for EVERY paragraph and segment in  					// the text' it needs to run pretty fast.  				case kfragInterlinPara:  					var para = obj as IStTxtPara;  					if (para == null)  					{  						Debug.Assert(obj is IStTxtPara);  						return 1200;  					}  					return EstimateParaHeight(para' dxAvailWidth);  				case kfragTxtSection: // Is this even used??  					var section = obj as IScrSection;  					if (section == null)  					{  						Debug.Assert(obj is IScrSection);  						return 2000;  					}  					return EstimateStTextHeight(section.HeadingOA' dxAvailWidth) +  						EstimateStTextHeight(section.ContentOA' dxAvailWidth);  				case kfragParaSegment:  					var seg = obj as ISegment;  					if (seg == null)  					{  						Debug.Assert(obj is ISegment);  						return 400;  					}  					return EstimateSegmentHeight(seg' dxAvailWidth);  				default:  					return 500;  					// Not possible AFAIK; in case we missed one' large makes for over-long scroll bars but avoids excess layout work.  			}
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,EstimateHeight,The following statement contains a magic number: switch (frag)  			{  					// If you change this' remember that an estimate that is too HIGH just means it takes a few iterations  					// to fill the screen' and the thumb on the scroll bar is a bit small. But if it is too SMALL'  					// we will expand more objects than we need' which is much more expensive.  					// Also remember: this gets called for EVERY paragraph and segment in  					// the text' it needs to run pretty fast.  				case kfragInterlinPara:  					var para = obj as IStTxtPara;  					if (para == null)  					{  						Debug.Assert(obj is IStTxtPara);  						return 1200;  					}  					return EstimateParaHeight(para' dxAvailWidth);  				case kfragTxtSection: // Is this even used??  					var section = obj as IScrSection;  					if (section == null)  					{  						Debug.Assert(obj is IScrSection);  						return 2000;  					}  					return EstimateStTextHeight(section.HeadingOA' dxAvailWidth) +  						EstimateStTextHeight(section.ContentOA' dxAvailWidth);  				case kfragParaSegment:  					var seg = obj as ISegment;  					if (seg == null)  					{  						Debug.Assert(obj is ISegment);  						return 400;  					}  					return EstimateSegmentHeight(seg' dxAvailWidth);  				default:  					return 500;  					// Not possible AFAIK; in case we missed one' large makes for over-long scroll bars but avoids excess layout work.  			}
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,EstimateHeight,The following statement contains a magic number: switch (frag)  			{  					// If you change this' remember that an estimate that is too HIGH just means it takes a few iterations  					// to fill the screen' and the thumb on the scroll bar is a bit small. But if it is too SMALL'  					// we will expand more objects than we need' which is much more expensive.  					// Also remember: this gets called for EVERY paragraph and segment in  					// the text' it needs to run pretty fast.  				case kfragInterlinPara:  					var para = obj as IStTxtPara;  					if (para == null)  					{  						Debug.Assert(obj is IStTxtPara);  						return 1200;  					}  					return EstimateParaHeight(para' dxAvailWidth);  				case kfragTxtSection: // Is this even used??  					var section = obj as IScrSection;  					if (section == null)  					{  						Debug.Assert(obj is IScrSection);  						return 2000;  					}  					return EstimateStTextHeight(section.HeadingOA' dxAvailWidth) +  						EstimateStTextHeight(section.ContentOA' dxAvailWidth);  				case kfragParaSegment:  					var seg = obj as ISegment;  					if (seg == null)  					{  						Debug.Assert(obj is ISegment);  						return 400;  					}  					return EstimateSegmentHeight(seg' dxAvailWidth);  				default:  					return 500;  					// Not possible AFAIK; in case we missed one' large makes for over-long scroll bars but avoids excess layout work.  			}
Magic Number,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,EstimateHeight,The following statement contains a magic number: switch (frag)  			{  					// If you change this' remember that an estimate that is too HIGH just means it takes a few iterations  					// to fill the screen' and the thumb on the scroll bar is a bit small. But if it is too SMALL'  					// we will expand more objects than we need' which is much more expensive.  					// Also remember: this gets called for EVERY paragraph and segment in  					// the text' it needs to run pretty fast.  				case kfragInterlinPara:  					var para = obj as IStTxtPara;  					if (para == null)  					{  						Debug.Assert(obj is IStTxtPara);  						return 1200;  					}  					return EstimateParaHeight(para' dxAvailWidth);  				case kfragTxtSection: // Is this even used??  					var section = obj as IScrSection;  					if (section == null)  					{  						Debug.Assert(obj is IScrSection);  						return 2000;  					}  					return EstimateStTextHeight(section.HeadingOA' dxAvailWidth) +  						EstimateStTextHeight(section.ContentOA' dxAvailWidth);  				case kfragParaSegment:  					var seg = obj as ISegment;  					if (seg == null)  					{  						Debug.Assert(obj is ISegment);  						return 400;  					}  					return EstimateSegmentHeight(seg' dxAvailWidth);  				default:  					return 500;  					// Not possible AFAIK; in case we missed one' large makes for over-long scroll bars but avoids excess layout work.  			}
Magic Number,SIL.FieldWorks.IText,LanguageMapping,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,LanguageMapping,The following statement contains a magic number: Debug.Assert(subItems.Count == 5);
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,UpdateLanguageCodes,The following statement contains a magic number: if (m_sLastXmlFileName != m_LinguaLinksXmlFileName.Text)  			{  				m_sLastXmlFileName = m_LinguaLinksXmlFileName.Text;  				listViewMapping.Items.Clear();  				btnImport.Enabled = false;  				// default to not enabled now that there are no items  				m_nextInput = m_LinguaLinksXmlFileName.Text;  				if (!File.Exists(m_nextInput))  				{  					MessageBox.Show(  						String.Format(ITextStrings.ksLLFileNotFound' m_nextInput)'  						ITextStrings.ksLLImport'  						MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  					return;  				}    				m_startPhase = 1;  				string nameTest;  				if (m_nextInput.Length > 19)  				{  					nameTest = m_nextInput.Substring(m_nextInput.Length - 19' 19);  					if (nameTest == "\\LLPhase1Output.xml")  					{  						m_startPhase = 2;  					}  					else if (nameTest == "\\LLPhase2Output.xml")  					{  						m_startPhase = 3;  					}  					else if (nameTest == "\\LLPhase3Output.xml")  					{  						m_startPhase = 4;  					}  					else if (nameTest == "\\LLPhase4Output.xml")  					{  						m_startPhase = 5;  					}  					else if (nameTest == "\\LLPhase5Output.xml")  					{  						m_startPhase = 6;  					}  				}    				if (m_startPhase == 1)  				{  					using (StreamReader streamReader = File.OpenText(m_nextInput))  					{  						String input;    						bool inWritingSystem = false;  						bool inIcuLocale24 = false;  						bool inName24 = false;  						bool lineDone = false;  						bool formatOkay = false;  						int pos' pos1' pos2' pos3;  						string wsLLCode = "";  						string wsName = "";  						var wsInfo = new Dictionary<string' WsInfo>();    						//getting name for a writing system given the ICU code.  						foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystemManager.WritingSystems)  						{  							var wsi = new WsInfo(ws.DisplayLabel' ws.Id' string.IsNullOrEmpty(ws.LegacyMapping) ? "Windows1252<>Unicode" : ws.LegacyMapping);  							wsInfo.Add(wsi.KEY' wsi);  						}    						while ((input = streamReader.ReadLine()) != null)  						{  							lineDone = false;  							while (!lineDone)  							{  								if (!inWritingSystem)  								{  									pos = input.IndexOf("<LgWritingSystem");  									if (pos >= 0)  									{  										inWritingSystem = true;  										wsLLCode = "";  										wsName = "";  										if (input.Length >= pos + 21)  											input = input.Substring(pos + 21' input.Length - pos - 21);  										else  											input = input.Substring(pos + 16);  									}    								else  									{  										lineDone = true;  									}  								}  								if (inWritingSystem && !inIcuLocale24 && !inName24)  								{  									pos1 = input.IndexOf("</LgWritingSystem>");  									pos2 = input.IndexOf("<ICULocale24>");  									pos3 = input.IndexOf("<Name24>");  									if (pos1 < 0 && pos2 < 0 && pos3 < 0)  									{  										lineDone = true;  									}  									else if (pos1 >= 0 && (pos2 < 0 || pos2 > pos1) && (pos3 < 0 || pos3 > pos1))  									{  										input = input.Substring(pos1 + 18' input.Length - pos1 - 18);  										if (wsLLCode != "")  										{  											if (wsName == "")  											{  												wsName = "<" + wsLLCode + ">";  											}  											string wsFWName = "";  											string wsEC = "";  											string wsFWCode = "";    											foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  											{  												WsInfo wsi = kvp.Value;  												if (wsName == wsi.Name)  												{  													wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  													wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  													wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  												}  											}    											if (wsFWName == "")  											{  												foreach (KeyValuePair<string' WsInfo> kvp in wsInfo)  												{  													WsInfo wsi = kvp.Value;  													if (BaseName(wsName) == BaseName(wsi.Name))  													{  														wsFWName = TsStringUtils.NormalizeToNFC(wsi.Name);  														wsEC = TsStringUtils.NormalizeToNFC(wsi.Map);  														wsFWCode = TsStringUtils.NormalizeToNFC(wsi.Id);  													}  												}  											}    											var lvItem = new ListViewItem(new[] { TsStringUtils.NormalizeToNFC(wsName)' wsFWName' wsEC' TsStringUtils.NormalizeToNFC(wsLLCode)' wsFWCode });  											lvItem.Tag = wsName;  											listViewMapping.Items.Add(lvItem);  											formatOkay = true;  										}  										inWritingSystem = false;  									}  									else if (pos2 >= 0 && (pos3 < 0 || pos3 > pos2))  									{  										input = input.Substring(pos2 + 13' input.Length - pos2 - 13);  										inIcuLocale24 = true;  									}  									else  									{  										input = input.Substring(pos3 + 8' input.Length - pos3 - 8);  										inName24 = true;  									}  								}  								if (inIcuLocale24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsLLCode = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inIcuLocale24 = false;  									}  								}  								if (inName24)  								{  									pos = input.IndexOf(">");  									if (pos < 0)  									{  										lineDone = true;  									}  									else  									{  										input = input.Substring(pos + 1' input.Length - pos - 1);  										pos = input.IndexOf("<");  										wsName = input.Substring(0' pos);  										input = input.Substring(pos' input.Length - pos);  										inName24 = false;  									}  								}  							}  						}  						streamReader.Close();  						listViewMapping_SelectedIndexChanged();  						CheckImportEnabled();  						if (!formatOkay)  						{  							ShowFinishLabel();  							// update the button before showing the msg box just in case...  							MessageBox.Show(  							String.Format(ITextStrings.ksInvalidLLFile' m_nextInput)'  							ITextStrings.ksLLImport'  							MessageBoxButtons.OK' MessageBoxIcon.Asterisk);  							return;  						}  					}  				}  				else  				{  					btnImport.Enabled = true;  				}  				ShowFinishLabel();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,btnModifyMapping_Click,The following statement contains a magic number: using (LexImportWizardLanguage dlg = new LexImportWizardLanguage(m_cache'  				m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' app))  			{  				llName = lvItem.Text;  				fwName = lvItem.SubItems[1].Text;  				ec = lvItem.SubItems[2].Text;  				llCode = lvItem.SubItems[3].Text;  				dlg.LangToModify(llName' fwName' ec);    				if (dlg.ShowDialog(this) == DialogResult.OK)  				{  					// retrieve the new WS information from the dlg  					dlg.GetCurrentLangInfo(out llName' out fwName' out ec' out fwCode);    					// remove the one that was modified  					listViewMapping.Items.Remove(lvItem);    					// now add the modified one  					lvItem = new ListViewItem(new string[] { llName' fwName' ec' llCode' fwCode });  					lvItem.Tag = llName;  					listViewMapping.Items.Add(lvItem);  					int ii = listViewMapping.Items.IndexOf(lvItem);  					listViewMapping.Items[ii].Selected = true;  				}    				CheckImportEnabled();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,btnModifyMapping_Click,The following statement contains a magic number: using (LexImportWizardLanguage dlg = new LexImportWizardLanguage(m_cache'  				m_propertyTable.GetValue<IHelpTopicProvider>("HelpTopicProvider")' app))  			{  				llName = lvItem.Text;  				fwName = lvItem.SubItems[1].Text;  				ec = lvItem.SubItems[2].Text;  				llCode = lvItem.SubItems[3].Text;  				dlg.LangToModify(llName' fwName' ec);    				if (dlg.ShowDialog(this) == DialogResult.OK)  				{  					// retrieve the new WS information from the dlg  					dlg.GetCurrentLangInfo(out llName' out fwName' out ec' out fwCode);    					// remove the one that was modified  					listViewMapping.Items.Remove(lvItem);    					// now add the modified one  					lvItem = new ListViewItem(new string[] { llName' fwName' ec' llCode' fwCode });  					lvItem.Tag = llName;  					listViewMapping.Items.Add(lvItem);  					int ii = listViewMapping.Items.IndexOf(lvItem);  					listViewMapping.Items[ii].Selected = true;  				}    				CheckImportEnabled();  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,CheckImportEnabled,The following statement contains a magic number: foreach(ListViewItem lvItem2 in listViewMapping.Items)  			{  				if (lvItem2.SubItems[2].Text == "")  				{  					allSpecified = false;  				}  			}
Magic Number,SIL.FieldWorks.IText,LinguaLinksImportDlg,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,btnImport_Click,The following statement contains a magic number: using (var dlg = new ProgressDialogWithTask(this))  			{  				dlg.AllowCancel = true;    				LanguageMapping[] languageMappings = new LanguageMapping[listViewMapping.Items.Count];  				for (int i = 0; i < listViewMapping.Items.Count; i++)  					languageMappings[i] = new LanguageMapping(listViewMapping.Items[i].SubItems);    				dlg.Minimum = 0;  				dlg.Maximum = 500;    				using (new WaitCursor(this' true))  				{  					// This needs to be reset when cancel is pressed with out clicking the  					// browse button.  This resolves a noted issue in the code where an exception  					// is processed when run a second time...  					m_nextInput = m_LinguaLinksXmlFileName.Text;    					var import = new LinguaLinksImport(m_cache' m_sTempDir' m_sRootDir);  					import.NextInput = m_nextInput;  					import.Error += OnImportError;  					Debug.Assert(m_nextInput == m_LinguaLinksXmlFileName.Text);  					// Ensure the idle time processing for change record doesn't cause problems  					// because the import creates a record to change to.  See FWR-3700.  					var clerk = m_propertyTable.GetValue<RecordClerk>("ActiveClerk");  					var fSuppressedSave = false;  					try  					{  						if (clerk != null)  						{  							fSuppressedSave = clerk.SuppressSaveOnChangeRecord;  							clerk.SuppressSaveOnChangeRecord = true;  						}  						bool fSuccess = (bool)dlg.RunTask(true' import.Import'  							runToCompletion' languageMappings' m_startPhase);    						if (fSuccess)  						{  							MessageBox.Show(this'  								String.Format(ITextStrings.ksSuccessLoadingLL'  									Path.GetFileName(m_LinguaLinksXmlFileName.Text)'  									m_cache.ProjectId.Name' Environment.NewLine' import.LogFile)'  								ITextStrings.ksLLImportSucceeded'  								MessageBoxButtons.OK' MessageBoxIcon.Information);  							DialogResult = DialogResult.OK;	// only 'OK' if not exception  						}  						else  						{  							DialogResult = DialogResult.Abort; // unsuccessful import  						}    						Close();  						m_nextInput = import.NextInput;  					}  					catch (WorkerThreadException ex)  					{  						if (ex.InnerException is InvalidDataException)  						{  							// Special handling for this case...  							ShowFinishLabel();  							CheckImportEnabled();  						}  						else  						{  							Debug.WriteLine("Error: " + ex.InnerException.Message);    							MessageBox.Show(String.Format(import.ErrorMessage' ex.InnerException.Message)'  								ITextStrings.ksUnhandledError'  								MessageBoxButtons.OK' MessageBoxIcon.Error);  							DialogResult = DialogResult.Cancel;	// only 'OK' if not exception  							Close();  						}  					}  					finally  					{  						if (clerk != null)  							clerk.SuppressSaveOnChangeRecord = fSuppressedSave;  					}  				}  			}
Magic Number,SIL.FieldWorks.IText,ProgressReporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,Step,The following statement contains a magic number: if (nNewDone > 100)  					nNewDone = nNewDone % 100;
Magic Number,SIL.FieldWorks.IText,ProgressReporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\LinguaLinksImportDlg.cs,Step,The following statement contains a magic number: if (nNewDone > 100)  					nNewDone = nNewDone % 100;
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,LoadRealDataIntoSec1,The following statement contains a magic number: if (analysis != null) // Might still be' if no default is available.  			{  				var category = analysis.CategoryRA;  				if (category != null)  				{  					int hvoWordPos = CreateSecondaryAndCopyStrings(InterlinLineChoices.kflidWordPos' category.Hvo'  																   CmPossibilityTags.kflidAbbreviation' hvoSbWord' sdaMain' cda);  					cda.CacheObjProp(hvoSbWord' ktagSbWordPos' hvoWordPos);  					cda.CacheIntProp(hvoWordPos' ktagSbNamedObjGuess' fGuessing);  				}  				if (this.ShowMorphBundles)  				{  					var bldrError = new StringBuilder();  					foreach (var mb in analysis.MorphBundlesOS)  					{  						// Create the corresponding SbMorph.  						int hvoMbSec = m_caches.DataAccess.MakeNewObject(kclsidSbMorph' hvoSbWord'  																		 ktagSbWordMorphs' mb.IndexInOwner);  						m_caches.Map(hvoMbSec' mb.Hvo);    						// Get the real MoForm' if any.  						var mf = mb.MorphRA;  						// Get the text we will display on the first line of the morpheme bundle.  						// Taken from the MoForm if any' otherwise the form of the MB.  						int hvoMorphForm;  						string sPrefix = null;  						string sPostfix = null;  						if (mf == null)  						{  							// Create the secondary object corresponding to the MoForm. We create one  							// even though there isn't a real MoForm. It doesn't correspond to anything  							// in the real database.  							hvoMorphForm = m_caches.DataAccess.MakeNewObject(kclsidSbNamedObj' mb.Hvo'  																			 ktagSbMorphForm' -2); // -2 for atomic  							CopyStringsToSecondary(InterlinLineChoices.kflidMorphemes' sdaMain' mb.Hvo'  												   WfiMorphBundleTags.kflidForm' cda' hvoMorphForm' ktagSbNamedObjName);  							// We will slightly adjust the form we display in the default vernacular WS.  							InterlinLineSpec specMorphemes = m_choices.GetPrimarySpec(InterlinLineChoices.kflidMorphemes);  							int wsForm;  							if (specMorphemes == null || !mb.Form.TryWs(specMorphemes.WritingSystem' out wsForm))  								wsForm = RawWordformWs;  							ITsString tssForm = sdaMain.get_MultiStringAlt(mb.Hvo'  																		   WfiMorphBundleTags.kflidForm'  																		   wsForm);  							string realForm = tssForm.Text;  							// currently (unfortunately) Text returns 'null' from COM for empty strings.  							if (realForm == null)  								realForm = string.Empty;    							// if it's not an empty string' then we can find its form type' and separate the  							// morpheme markers into separate properties.  							if (realForm != string.Empty)  							{  								IMoMorphType mmt = null;  								try  								{  									int clsidForm;  									mmt = MorphServices.FindMorphType(m_caches.MainCache' ref realForm' out clsidForm);  									sPrefix = mmt.Prefix;  									sPostfix = mmt.Postfix;  								}  								catch (Exception e)  								{  									bldrError.AppendLine(e.Message);  								}  							}  							tssForm = TsStringUtils.MakeString(realForm' RawWordformWs);  							cda.CacheStringAlt(hvoMorphForm' ktagSbNamedObjName' wsVern' tssForm);  						}  						else  						{  							// Create the secondary object corresponding to the MoForm in the usual way from the form object.  							hvoMorphForm = CreateSecondaryAndCopyStrings(InterlinLineChoices.kflidMorphemes' mf.Hvo'  																		 MoFormTags.kflidForm' hvoSbWord' sdaMain' cda);  							// Store the prefix and postfix markers from the MoMorphType object.  							int hvoMorphType = sdaMain.get_ObjectProp(mf.Hvo'  																	  MoFormTags.kflidMorphType);  							if (hvoMorphType != 0)  							{  								sPrefix = sdaMain.get_UnicodeProp(hvoMorphType'  																  MoMorphTypeTags.kflidPrefix);  								sPostfix = sdaMain.get_UnicodeProp(hvoMorphType'  																   MoMorphTypeTags.kflidPostfix);  							}  						}  						if (!String.IsNullOrEmpty(sPrefix))  							cda.CacheStringProp(hvoMbSec' ktagSbMorphPrefix'  												TsStringUtils.MakeString(sPrefix' wsVern));  						if (!String.IsNullOrEmpty(sPostfix))  							cda.CacheStringProp(hvoMbSec' ktagSbMorphPostfix'  												TsStringUtils.MakeString(sPostfix' wsVern));    						// Link the SbMorph to its form object' noting if it is a guess.  						cda.CacheObjProp(hvoMbSec' ktagSbMorphForm' hvoMorphForm);  						cda.CacheIntProp(hvoMorphForm' ktagSbNamedObjGuess' fGuessing);    						// Get the real Sense that supplies the gloss' if any.  						var senseReal = mb.SenseRA;  						if (senseReal == null && fGuessing != 0)  						{  							// Guess a default  							senseReal = mb.DefaultSense;  						}  						if (senseReal != null) // either all-the-way real' or default.  						{  							// Create the corresponding dummy.  							int hvoLexSenseSec;  							// Add any irregularly inflected form type info to the LexGloss.  							ILexEntryRef lerTest;  							ILexEntry possibleVariant = null;  							if (mf != null)  								possibleVariant = mf.Owner as ILexEntry;  							if (possibleVariant != null && possibleVariant.IsVariantOfSenseOrOwnerEntry(senseReal' out lerTest))  							{  								hvoLexSenseSec = m_caches.FindOrCreateSec(senseReal.Hvo' kclsidSbNamedObj' hvoSbWord' ktagSbWordDummy);  								CacheLexGlossWithInflTypeForAllCurrentWs(possibleVariant' hvoLexSenseSec' wsVern' cda' mb.InflTypeRA);  							}  							else  							{  								// add normal LexGloss without variant info  								hvoLexSenseSec = CreateSecondaryAndCopyStrings(InterlinLineChoices.kflidLexGloss' senseReal.Hvo'  											 LexSenseTags.kflidGloss' hvoSbWord' sdaMain' cda);  							}  							cda.CacheObjProp(hvoMbSec' ktagSbMorphGloss' hvoLexSenseSec);  							cda.CacheIntProp(hvoLexSenseSec' ktagSbNamedObjGuess' fGuessing);    							int hvoInflType = 0;  							if (mb.InflTypeRA != null)  							{  								hvoInflType = m_caches.FindOrCreateSec(mb.InflTypeRA.Hvo'  														 kclsidSbNamedObj' hvoSbWord' ktagSbWordDummy);  							}  							cda.CacheObjProp(hvoMbSec' ktagSbNamedObjInflType' hvoInflType);  						}    						// Get the MSA' if any.  						var msaReal = mb.MsaRA;  						if (msaReal != null)  						{  							int hvoPos = m_caches.FindOrCreateSec(msaReal.Hvo'  																  kclsidSbNamedObj' hvoSbWord' ktagSbWordDummy);    							foreach (int ws in m_choices.WritingSystemsForFlid(InterlinLineChoices.kflidLexPos' true))  							{  								// Since ws maybe ksFirstAnal/ksFirstVern' we need to get what is actually  								// used in order to retrieve the data in Vc.Display().  See LT_7976.  								// Use InterlinAbbrTss to get an appropriate different name for each ws  								ITsString tssLexPos = msaReal.InterlinAbbrTSS(ws);  								int wsActual = TsStringUtils.GetWsAtOffset(tssLexPos' 0);  								cda.CacheStringAlt(hvoPos' ktagSbNamedObjName' wsActual' tssLexPos);  							}  							cda.CacheObjProp(hvoMbSec' ktagSbMorphPos' hvoPos);  							cda.CacheIntProp(hvoPos' ktagSbNamedObjGuess' fGuessing);  						}    						// If we have a form' we can get its owner and set the info for the Entry  						// line.  						// Enhance JohnT: attempt a guess if we have a form but no entry.  						if (mf != null)  						{  							var entryReal = mf.Owner as ILexEntry;  							// We can assume the owner is a LexEntry as that is the only type of object  							// that can own MoForms. We don't actually create the LexEntry' to  							// improve performance. All the relevant data should already have  							// been loaded while creating the main interlinear view.  							LoadSecDataForEntry(entryReal' senseReal' hvoSbWord' cda' wsVern' hvoMbSec' fGuessing' sdaMain);  						}  					}  					if (bldrError.Length > 0)  					{  						var msg = bldrError.ToString().Trim();  						var wnd = FindForm() ?? m_propertyTable.GetValue<IWin32Window>("window");  						MessageBox.Show(wnd' msg' ITextStrings.ksWarning' MessageBoxButtons.OK' MessageBoxIcon.Warning);  					}  				}  			}  			else  			{  				// No analysis' default or otherwise. We immediately' however' fill in a single  				// dummy morpheme' if showing morphology.  				fGuessing = 0;	// distinguish between a 'guess' (defaults) and courtesy filler info (cf. LT-5858).  				if (ShowMorphBundles)  				{  					int hvoMbSec = m_caches.DataAccess.MakeNewObject(kclsidSbMorph' hvoSbWord'  						ktagSbWordMorphs' 0);  					ITsString tssForm = m_caches.DataAccess.get_MultiStringAlt(hvoSbWord' ktagSbWordForm' this.RawWordformWs);  					// Possibly adjust case of tssForm.  					if (fAdjustCase && CaseStatus == StringCaseStatus.title &&  						tssForm != null && tssForm.Length > 0)  					{  						tssForm = TsStringUtils.MakeString(cf.ToLower(tssForm.Text)' this.RawWordformWs);  						m_tssWordform = tssForm; // need this to be set in case hvoWordformRef set to zero.  						// If we adjust the case of the form' we must adjust the hvo as well'  						// or any analyses created will go to the wrong WfiWordform.  						CurrentAnalysisTree.Analysis = GetWordform(tssForm);  						if (CurrentAnalysisTree.Wordform != null)  							m_fShowAnalysisCombo = CurrentAnalysisTree.Wordform.AnalysesOC.Count > 0;  					}  					else  					{  						// just use the wfi wordform form for our dummy morph form.  						tssForm = CurrentAnalysisTree.Wordform.Form.get_String(this.RawWordformWs);  					}  					int hvoMorphForm = m_caches.FindOrCreateSec(0' kclsidSbNamedObj'  						hvoSbWord' ktagSbWordDummy);  					cda.CacheStringAlt(hvoMorphForm' ktagSbNamedObjName' wsVern' tssForm);  					cda.CacheObjProp(hvoMbSec' ktagSbMorphForm' hvoMorphForm);  					cda.CacheIntProp(hvoMorphForm' ktagSbNamedObjGuess' fGuessing);  				}  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,ShowComboForSelection,The following statement contains a magic number: if (!fMouseDown)  			{  				// It's a mouse move.  				// If we've moved to somewhere outside any paragraph get rid of the combos.  				// But' allow somewhere close' since otherwise it's almost impossible to get  				// a combo on an empty string.  				Rect locExpanded = loc;  				locExpanded.right += 50;  				locExpanded.left -= 5;  				locExpanded.top -= 2;  				locExpanded.bottom += 2;  				if (!locExpanded.Contains(m_LastMouseMovePos))  				{  					HideCombos();  					return;  				}  				// Don't do anything if the current mouse position is in the same paragraph  				// as before. Things tend to flicker if we continually create and remove it.  				// But' if we've hidden all the combos' go ahead even if at the same position as before...  				// otherwise' when we drag off outside the text and return' we may not get any combo.  				if (loc.Equals(m_locLastShowCombo) && FirstLineHandler != null)  				{  					return;  				}  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,ShowComboForSelection,The following statement contains a magic number: if (!fMouseDown)  			{  				// It's a mouse move.  				// If we've moved to somewhere outside any paragraph get rid of the combos.  				// But' allow somewhere close' since otherwise it's almost impossible to get  				// a combo on an empty string.  				Rect locExpanded = loc;  				locExpanded.right += 50;  				locExpanded.left -= 5;  				locExpanded.top -= 2;  				locExpanded.bottom += 2;  				if (!locExpanded.Contains(m_LastMouseMovePos))  				{  					HideCombos();  					return;  				}  				// Don't do anything if the current mouse position is in the same paragraph  				// as before. Things tend to flicker if we continually create and remove it.  				// But' if we've hidden all the combos' go ahead even if at the same position as before...  				// otherwise' when we drag off outside the text and return' we may not get any combo.  				if (loc.Equals(m_locLastShowCombo) && FirstLineHandler != null)  				{  					return;  				}  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,ShowComboForSelection,The following statement contains a magic number: if (!fMouseDown)  			{  				// It's a mouse move.  				// If we've moved to somewhere outside any paragraph get rid of the combos.  				// But' allow somewhere close' since otherwise it's almost impossible to get  				// a combo on an empty string.  				Rect locExpanded = loc;  				locExpanded.right += 50;  				locExpanded.left -= 5;  				locExpanded.top -= 2;  				locExpanded.bottom += 2;  				if (!locExpanded.Contains(m_LastMouseMovePos))  				{  					HideCombos();  					return;  				}  				// Don't do anything if the current mouse position is in the same paragraph  				// as before. Things tend to flicker if we continually create and remove it.  				// But' if we've hidden all the combos' go ahead even if at the same position as before...  				// otherwise' when we drag off outside the text and return' we may not get any combo.  				if (loc.Equals(m_locLastShowCombo) && FirstLineHandler != null)  				{  					return;  				}  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,ShowComboForSelection,The following statement contains a magic number: if (!fMouseDown)  			{  				// It's a mouse move.  				// If we've moved to somewhere outside any paragraph get rid of the combos.  				// But' allow somewhere close' since otherwise it's almost impossible to get  				// a combo on an empty string.  				Rect locExpanded = loc;  				locExpanded.right += 50;  				locExpanded.left -= 5;  				locExpanded.top -= 2;  				locExpanded.bottom += 2;  				if (!locExpanded.Contains(m_LastMouseMovePos))  				{  					HideCombos();  					return;  				}  				// Don't do anything if the current mouse position is in the same paragraph  				// as before. Things tend to flicker if we continually create and remove it.  				// But' if we've hidden all the combos' go ahead even if at the same position as before...  				// otherwise' when we drag off outside the text and return' we may not get any combo.  				if (loc.Equals(m_locLastShowCombo) && FirstLineHandler != null)  				{  					return;  				}  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,ScanForIcon,The following statement contains a magic number: int dxPixelIncrement = 3;
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,ScanForIcon,The following statement contains a magic number: uint iconParagraphWidth = 10;
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,ScanForIcon,The following statement contains a magic number: if (m_vc.RightToLeft)  			{  				// Right to Left:  				selArrow = FindNearestSelectionType(selOrig' VwSelType.kstPicture'  					(uint)rect.right - iconParagraphWidth' iconParagraphWidth * 2' dxPixelIncrement);  				if (selArrow == null)  				{  					// we didn't find it next to our paragraph box. see if we can  					// find it at the beginning of the RootBox.  					selArrow = FindNearestSelectionType(selOrig' VwSelType.kstPicture'  						(uint)RootBox.Width - iconParagraphWidth' iconParagraphWidth' dxPixelIncrement);  				}  			}  			else  			{  				// Left to Right  				selArrow = FindNearestSelectionType(selOrig' VwSelType.kstPicture'  					(uint)rect.left + iconParagraphWidth' iconParagraphWidth * 2' -dxPixelIncrement);  				if (selArrow == null)  				{  					// we didn't find it next to our paragraph box. see if we can  					// find it at the beginning of the RootBox.  					selArrow = FindNearestSelectionType(selOrig' VwSelType.kstPicture'  						0' iconParagraphWidth' dxPixelIncrement);  				}  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,ScanForIcon,The following statement contains a magic number: if (m_vc.RightToLeft)  			{  				// Right to Left:  				selArrow = FindNearestSelectionType(selOrig' VwSelType.kstPicture'  					(uint)rect.right - iconParagraphWidth' iconParagraphWidth * 2' dxPixelIncrement);  				if (selArrow == null)  				{  					// we didn't find it next to our paragraph box. see if we can  					// find it at the beginning of the RootBox.  					selArrow = FindNearestSelectionType(selOrig' VwSelType.kstPicture'  						(uint)RootBox.Width - iconParagraphWidth' iconParagraphWidth' dxPixelIncrement);  				}  			}  			else  			{  				// Left to Right  				selArrow = FindNearestSelectionType(selOrig' VwSelType.kstPicture'  					(uint)rect.left + iconParagraphWidth' iconParagraphWidth * 2' -dxPixelIncrement);  				if (selArrow == null)  				{  					// we didn't find it next to our paragraph box. see if we can  					// find it at the beginning of the RootBox.  					selArrow = FindNearestSelectionType(selOrig' VwSelType.kstPicture'  						0' iconParagraphWidth' dxPixelIncrement);  				}  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,FindNearestSelectionType,The following statement contains a magic number: int y = rect.top + (rect.bottom - rect.top) / 2;
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectFirstAssociatedText,The following statement contains a magic number: int xMaxCountOfPixels = (widthIconPara) * 2;
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectAtStartOfMorph,The following statement contains a magic number: if (m_caches.DataAccess.get_StringProp(hvoMorph' ktagSbMorphPrefix).Length == 0 ||  				cprevOccurrences > 0)  			{  				// Select at the start of the name of the form  				SelLevInfo[] selectIndexMorph = new SelLevInfo[2];  				selectIndexMorph[0].tag = ktagSbMorphForm;  				selectIndexMorph[0].ihvo = 0;  				selectIndexMorph[0].cpropPrevious = cprevOccurrences;  				selectIndexMorph[1].tag = ktagSbWordMorphs;  				selectIndexMorph[1].ihvo = index;  				RootBox.MakeTextSelection(0' 2' selectIndexMorph' ktagSbNamedObjName' 0' 0' 0' this.RawWordformWs' false' -1' null' true);  			}  			else  			{  				// Select at the start of the prefix  				SelLevInfo[] selectIndexMorph = new SelLevInfo[1];  				selectIndexMorph[0].tag = ktagSbWordMorphs;  				selectIndexMorph[0].ihvo = index;  				RootBox.MakeTextSelection(0' 1' selectIndexMorph' ktagSbMorphPrefix' 0' 0' 0' 0' false' -1' null' true);  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectAtStartOfMorph,The following statement contains a magic number: if (m_caches.DataAccess.get_StringProp(hvoMorph' ktagSbMorphPrefix).Length == 0 ||  				cprevOccurrences > 0)  			{  				// Select at the start of the name of the form  				SelLevInfo[] selectIndexMorph = new SelLevInfo[2];  				selectIndexMorph[0].tag = ktagSbMorphForm;  				selectIndexMorph[0].ihvo = 0;  				selectIndexMorph[0].cpropPrevious = cprevOccurrences;  				selectIndexMorph[1].tag = ktagSbWordMorphs;  				selectIndexMorph[1].ihvo = index;  				RootBox.MakeTextSelection(0' 2' selectIndexMorph' ktagSbNamedObjName' 0' 0' 0' this.RawWordformWs' false' -1' null' true);  			}  			else  			{  				// Select at the start of the prefix  				SelLevInfo[] selectIndexMorph = new SelLevInfo[1];  				selectIndexMorph[0].tag = ktagSbWordMorphs;  				selectIndexMorph[0].ihvo = index;  				RootBox.MakeTextSelection(0' 1' selectIndexMorph' ktagSbMorphPrefix' 0' 0' 0' 0' false' -1' null' true);  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectAtEndOfMorph,The following statement contains a magic number: if (cchPostfix == 0 || cPrevOccurrences > 0)  			{  				// Select at the end of the name of the form  				SelLevInfo[] selectIndexMorph = new SelLevInfo[2];  				selectIndexMorph[0].tag = ktagSbMorphForm;  				selectIndexMorph[0].ihvo = 0;  				selectIndexMorph[0].cpropPrevious = cPrevOccurrences;  				selectIndexMorph[1].tag = ktagSbWordMorphs;  				selectIndexMorph[1].ihvo = index;  				int hvoNamedObj = sda.get_ObjectProp(hvoMorph' ktagSbMorphForm);  				List<InterlinLineSpec> matchingSpecs = m_choices.ItemsWithFlids(new int[] { InterlinLineChoices.kflidMorphemes });  				InterlinLineSpec specMorphemes = matchingSpecs[cPrevOccurrences];  				int ws = specMorphemes.WritingSystem;  				if (specMorphemes.IsMagicWritingSystem)  					ws = this.RawWordformWs;  				int cchName = sda.get_MultiStringAlt(hvoNamedObj' ktagSbNamedObjName' ws).Length;  				RootBox.MakeTextSelection(0' 2' selectIndexMorph' ktagSbNamedObjName' 0' cchName' cchName' this.RawWordformWs' false' -1' null' true);  			}  			else  			{  				// Select at the end of the postfix  				SelLevInfo[] selectIndexMorph = new SelLevInfo[1];  				selectIndexMorph[0].tag = ktagSbWordMorphs;  				selectIndexMorph[0].ihvo = index;  				RootBox.MakeTextSelection(0' 1' selectIndexMorph' ktagSbMorphPostfix' 0' cchPostfix' cchPostfix' 0' false' -1' null' true);  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectAtEndOfMorph,The following statement contains a magic number: if (cchPostfix == 0 || cPrevOccurrences > 0)  			{  				// Select at the end of the name of the form  				SelLevInfo[] selectIndexMorph = new SelLevInfo[2];  				selectIndexMorph[0].tag = ktagSbMorphForm;  				selectIndexMorph[0].ihvo = 0;  				selectIndexMorph[0].cpropPrevious = cPrevOccurrences;  				selectIndexMorph[1].tag = ktagSbWordMorphs;  				selectIndexMorph[1].ihvo = index;  				int hvoNamedObj = sda.get_ObjectProp(hvoMorph' ktagSbMorphForm);  				List<InterlinLineSpec> matchingSpecs = m_choices.ItemsWithFlids(new int[] { InterlinLineChoices.kflidMorphemes });  				InterlinLineSpec specMorphemes = matchingSpecs[cPrevOccurrences];  				int ws = specMorphemes.WritingSystem;  				if (specMorphemes.IsMagicWritingSystem)  					ws = this.RawWordformWs;  				int cchName = sda.get_MultiStringAlt(hvoNamedObj' ktagSbNamedObjName' ws).Length;  				RootBox.MakeTextSelection(0' 2' selectIndexMorph' ktagSbNamedObjName' 0' cchName' cchName' this.RawWordformWs' false' -1' null' true);  			}  			else  			{  				// Select at the end of the postfix  				SelLevInfo[] selectIndexMorph = new SelLevInfo[1];  				selectIndexMorph[0].tag = ktagSbWordMorphs;  				selectIndexMorph[0].ihvo = index;  				RootBox.MakeTextSelection(0' 1' selectIndexMorph' ktagSbMorphPostfix' 0' cchPostfix' cchPostfix' 0' false' -1' null' true);  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,MakeFirstMorph,The following statement contains a magic number: int hvoSbForm = sda.MakeNewObject(kclsidSbNamedObj' hvoSbMorph'  				ktagSbMorphForm' -2);
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,MakeRoot,The following statement contains a magic number: this.Margin = new Padding(3' 0' 3' 1);
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,MakeRoot,The following statement contains a magic number: this.Margin = new Padding(3' 0' 3' 1);
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetInfoForJumpToTool,The following statement contains a magic number: switch (tagRightClickTextProp)  			{  				case ktagSbMorphPrefix:  				case ktagSbMorphPostfix:  					m_hvoRightClickMorph = hvoRightClickObject;  					// Pretend we clicked on the morph form.  (See LT-7590.)  					hvoRightClickObject = Caches.DataAccess.get_ObjectProp(hvoRightClickObject' ktagSbMorphForm);  					break;  				case ktagSbNamedObjName:  					if (sel.CLevels(false) < 2)  						break;  					int hvoOuterObj' tagOuter' ihvoOuter' cpropPreviousOuter;  					IVwPropertyStore vpsDummy;  					sel.PropInfo(false' 1' out hvoOuterObj' out tagOuter' out ihvoOuter' out cpropPreviousOuter' out vpsDummy);  					if (tagOuter == ktagSbMorphGloss || tagOuter == ktagSbMorphPos || tagOuter == ktagSbMorphForm  						|| tagOuter == ktagSbMorphEntry)  					{  						m_hvoRightClickMorph = hvoOuterObj;  					}  					break;  				default:  					m_hvoRightClickMorph = 0;  					break;  			}
Magic Number,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetAvailWidth,The following statement contains a magic number: if (m_fSizeToContent)  				return 10000000;	// return Int32.MaxValue / 2;  			else  				return base.GetAvailWidth(prootb);
Magic Number,SIL.FieldWorks.IText,InterlinComboHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,Activate,The following statement contains a magic number: c.AdjustSize(500' 400);
Magic Number,SIL.FieldWorks.IText,InterlinComboHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,Activate,The following statement contains a magic number: c.AdjustSize(500' 400);
Magic Number,SIL.FieldWorks.IText,InterlinComboHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,AdjustListBoxSize,The following statement contains a magic number: if (m_comboList is ComboListBox)  				{  					ComboListBox clb = m_comboList as ComboListBox;  					using (var g = m_sandbox.CreateGraphics())  					{  						int nMaxWidth = 0;  						int nHeight = 0;  						IEnumerator ie = clb.Items.GetEnumerator();  						while (ie.MoveNext())  						{  							string s = null;  							if (ie.Current is ITsString)  							{  								ITsString tss = ie.Current as ITsString;  								s = tss.Text;  							}  							else if (ie.Current is String)  							{  								s = ie.Current as string;  							}  							if (s != null)  							{  								SizeF szf = g.MeasureString(s' clb.Font);  								int nWidth = (int)szf.Width + 2;  								if (nMaxWidth < nWidth)  									// 2 is not quite enough for height if you have homograph  									// subscripts.  									nMaxWidth = nWidth;  								nHeight += (int)szf.Height + 3;  							}  						}  						clb.Form.Width = Math.Max(clb.Form.Width' nMaxWidth);  						clb.Form.Height = Math.Max(clb.Form.Height' nHeight);  					}  				}
Magic Number,SIL.FieldWorks.IText,InterlinComboHandler,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,AdjustListBoxSize,The following statement contains a magic number: if (m_comboList is ComboListBox)  				{  					ComboListBox clb = m_comboList as ComboListBox;  					using (var g = m_sandbox.CreateGraphics())  					{  						int nMaxWidth = 0;  						int nHeight = 0;  						IEnumerator ie = clb.Items.GetEnumerator();  						while (ie.MoveNext())  						{  							string s = null;  							if (ie.Current is ITsString)  							{  								ITsString tss = ie.Current as ITsString;  								s = tss.Text;  							}  							else if (ie.Current is String)  							{  								s = ie.Current as string;  							}  							if (s != null)  							{  								SizeF szf = g.MeasureString(s' clb.Font);  								int nWidth = (int)szf.Width + 2;  								if (nMaxWidth < nWidth)  									// 2 is not quite enough for height if you have homograph  									// subscripts.  									nMaxWidth = nWidth;  								nHeight += (int)szf.Height + 3;  							}  						}  						clb.Form.Width = Math.Max(clb.Form.Width' nMaxWidth);  						clb.Form.Height = Math.Max(clb.Form.Height' nHeight);  					}  				}
Magic Number,SIL.FieldWorks.IText,IhSbWordForm,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,HandleSelect,The following statement contains a magic number: switch (index)  				{  					case 0: // Accept entire analysis  						// Todo: figure how to implement.  						break;  					case 1: // Edit this wordform.  						// Allows direct editing.  						ComboList.DropDownStyle = ComboBoxStyle.DropDown;  						// restore the combo to visibility so we can do the editing.  						m_sandbox.ShowCombo();  						break;  					case 2: // Delete this wordform.  						// Todo: figure implementation  						//					int ihvoTwfic = m_rgvsli[m_iRoot].ihvo;  						//					int [] itemsToInsert = new int[0];  						//					m_cache.ReplaceReferenceProperty(m_hvoSbWord'  						//						StTxtParaTags.kflidAnalyzedTextObjects'  						//						ihvoTwfic' ihvoTwfic + 1' ref itemsToInsert);  						// Enhance JohnT: consider removing the WfiWordform' if there are no  						// analyses and no other references.  						// Comment: RandyR: Please don't delete it.  						break;  				}
Magic Number,SIL.FieldWorks.IText,IhMissingEntry,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SetLexEntryToUnknown,The following statement contains a magic number: int hvoNewForm = sda.MakeNewObject(kclsidSbNamedObj' m_hvoMorph' ktagSbMorphForm' -2);
Magic Number,SIL.FieldWorks.IText,IhMissingWordPos,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SetupCombo,The following statement contains a magic number: m_tree.Size = new Size(180' 220);
Magic Number,SIL.FieldWorks.IText,IhMissingWordPos,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SetupCombo,The following statement contains a magic number: m_tree.Size = new Size(180' 220);
Magic Number,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,OnlyUsedThisOnce,The following statement contains a magic number: var segsUsingAnalysis = oldAnalysis.ReferringObjects.Where(obj => obj is ISegment).Take(2);
Magic Number,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,OnlyUsedThisOnce,The following statement contains a magic number: if (oldAnalysis.MeaningsOC.Count == 1)  				{  					var wfiGloss = oldAnalysis.MeaningsOC.ToArray()[0];  					var segsUsingGloss = wfiGloss.ReferringObjects.Where(obj => obj is ISegment).Take(2);  					if (segsUsingAnalysis.Count() + segsUsingGloss.Count() > 1)  						return false;  					if (seg == null)  					{  						seg = segsUsingGloss.FirstOrDefault() as ISegment;  						target = wfiGloss;  					}  				}
Magic Number,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,OnlyUsedThisOnce,The following statement contains a magic number: return seg.AnalysesRS.Where(a => a == target).Take(2).Count() <= 1;
Magic Number,SIL.FieldWorks.IText,GetRealAnalysisMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.GetRealyAnalysisMethod.cs,OnlyUsedThisOnce,The following statement contains a magic number: return sense.ReferringObjects.Where(obj => obj is IWfiMorphBundle).Take(2).Count() <= 1;
Magic Number,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,HandleMorpheme,The following statement contains a magic number: if (m_imorph < m_cOldMorphs)  				{  					// If there's existing analysis and any morphs match' keep the analysis of  					// the existing morph. It's probably the best guess.  					string sSbForm = GetExistingMorphForm(out hvoSbMorph' out hvoSbForm' m_imorph);  					if (sSbForm != realForm && maxSkip > 0)  					{  						// If we're deleting morph breaks' we may need to skip over a morph to  						// find the matching existing morph.  						int hvoSbFormT = 0;  						int hvoSbMorphT = 0;  						string sSbFormT = null;  						List<int> skippedMorphs = new List<int>();  						skippedMorphs.Add(hvoSbMorph);  						for (int skip = 1; skip <= maxSkip; ++skip)  						{  							sSbFormT = GetExistingMorphForm(out hvoSbMorphT' out hvoSbFormT' m_imorph + skip);  							if (sSbFormT == realForm)  							{  								hvoSbForm = hvoSbFormT;  								hvoSbMorph = hvoSbMorphT;  								sSbForm = sSbFormT;  								foreach (int hvo in skippedMorphs)  									m_sda.DeleteObjOwner(m_hvoSbWord' hvo' ktagSbWordMorphs' m_imorph);  								m_cOldMorphs -= skippedMorphs.Count;  								break;  							}  							skippedMorphs.Add(hvoSbMorphT);  						}  					}  					if (sSbForm != realForm)  					{  						// Clear out the old analysis. Can't be relevant to a different form.  						m_cda.CacheObjProp(hvoSbMorph' ktagSbMorphEntry' 0);  						m_cda.CacheObjProp(hvoSbMorph' ktagSbMorphGloss' 0);  						m_cda.CacheObjProp(hvoSbMorph' ktagSbMorphPos' 0);  					}  					else  					{  						fCanReuseOldMorphData = m_sda.get_StringProp(hvoSbMorph' ktagSbMorphPrefix).Text == mmt.Prefix  						&& m_sda.get_StringProp(hvoSbMorph' ktagSbMorphPostfix).Text == mmt.Postfix;  						//&& m_sda.get_IntProp(hvoSbMorph' ktagSbMorphClsid) == clsidForm  						//&& m_sda.get_IntProp(hvoSbMorph' ktagSbMorphRealType) == mmt.Hvo;  					}  				}  				else  				{  					// Make a new morph' and an SbNamedObj to go with it.  					hvoSbMorph = m_sda.MakeNewObject(kclsidSbMorph' m_hvoSbWord'  						ktagSbWordMorphs' m_imorph);  					hvoSbForm = m_sda.MakeNewObject(kclsidSbNamedObj' hvoSbMorph'  						ktagSbMorphForm' -2); // -2 for atomic  				}
Magic Number,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,DoBasicFinding,The following statement contains a magic number: if (cLongest == ccchSeg && cLongest > 2)  				{  					// All equal length' 3 or more segments.  					ieRoot = 1;		// Pure speculation at this point' based on lengths.  				}
Magic Number,SIL.FieldWorks.IText,MorphemeBreaker,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.MorphemeBreaker.cs,MakeSel,The following statement contains a magic number: int clev = 2;
Magic Number,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,ConvertPictureWidthToMillipoints,The following statement contains a magic number: const int kMillipointsPerInch = 72000 / 2540;
Magic Number,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,ConvertPictureWidthToMillipoints,The following statement contains a magic number: const int kMillipointsPerInch = 72000 / 2540;
Magic Number,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,AddPullDownIcon,The following statement contains a magic number: if (m_fIconsForAnalysisChoices)  				{  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  						(int)FwTextPropVar.ktpvMilliPoint' kmpIconMargin);  					vwenv.set_IntProperty((int)FwTextPropType.ktptOffset'  						(int)FwTextPropVar.ktpvMilliPoint' -2500);  					vwenv.AddPicture(m_PulldownArrowPic.Picture' tag' 0' 0);  				}
Magic Number,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,Display,The following statement contains a magic number: try  				{  					switch (frag)  					{  						case kfragBundle: // One annotated word bundle' in this case' the whole view.  							if (hvo == 0)  								return;  							vwenv.set_IntProperty((int)FwTextPropType.ktptSpellCheck' (int)FwTextPropVar.ktpvEnum'  								(int)SpellingModes.ksmDoNotCheck);  							vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  								(int)FwTextPropVar.ktpvDefault' krgbBackground);  							vwenv.OpenDiv();  							vwenv.OpenParagraph();  							// Since embedded in a pile with context' we need another layer of pile here'.  							// It's an overlay sandbox: draw a box around it.  							vwenv.OpenInnerPile();  							// Inside that division we need a paragraph which does not have any border  							// or background. This suppresses the 'infinite width' behavior for the  							// nested paragraphs that may have grey border.  							vwenv.OpenParagraph();    							// This makes a little separation between left border and arrows.  							vwenv.set_IntProperty((int)FwTextPropType.ktptPadLeading'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  							if (m_fRtl)  							{  								// This must not be on the outer paragraph or we get infinite width behavior.  								vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  									(int)FwTextPropVar.ktpvEnum' (int)FwTextToggleVal.kttvForceOn);  								vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  									(int)FwTextPropVar.ktpvEnum' (int)FwTextAlign.ktalRight);  							}  							vwenv.OpenInnerPile();  							for (int ispec = 0; ispec < m_choices.Count; )  							{  								InterlinLineSpec spec = m_choices[ispec];  								if (!spec.WordLevel)  									break;  								if (spec.MorphemeLevel)  								{  									DisplayMorphBundles(vwenv' hvo);  									ispec = m_choices.LastMorphemeIndex + 1;  									continue;  								}  								switch (spec.Flid)  								{  									case InterlinLineChoices.kflidWord:  										int ws = GetActualWs(hvo' spec.StringFlid' spec.WritingSystem);  										DisplayWordform(vwenv' ws' ispec);  										break;  									case InterlinLineChoices.kflidWordGloss:  										DisplayWordGloss(vwenv' hvo' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidWordPos:  										DisplayWordPOS(vwenv' hvo' spec.WritingSystem' ispec);  										break;  								}  								ispec++;  							}  							vwenv.CloseInnerPile();    							vwenv.CloseParagraph();  							vwenv.CloseInnerPile();    							vwenv.CloseParagraph();  							vwenv.CloseDiv();  							break;  						case kfragFirstMorph: // first morpheme in word  						case kfragMorph: // The bundle of 4 lines representing a morpheme.  							vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.OpenInnerPile();  							for (int ispec = m_choices.FirstMorphemeIndex; ispec <= m_choices.LastMorphemeIndex; ispec++)  							{  								int tagLexEntryIcon = 0;  								if (m_choices.FirstLexEntryIndex == ispec)  									tagLexEntryIcon = ktagMorphEntryIcon;  								InterlinLineSpec spec = m_choices[ispec];  								switch (spec.Flid)  								{  									case InterlinLineChoices.kflidMorphemes:  										DisplayMorphForm(vwenv' hvo' frag' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidLexEntries:  										AddOptionalNamedObj(vwenv' hvo' ktagSbMorphEntry' ktagMissingEntry'  											kfragMissingEntry' tagLexEntryIcon' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidLexGloss:  										AddOptionalNamedObj(vwenv' hvo' ktagSbMorphGloss' ktagMissingMorphGloss'  											kfragMissingMorphGloss' tagLexEntryIcon' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidLexPos:  										AddOptionalNamedObj(vwenv' hvo' ktagSbMorphPos' ktagMissingMorphPos'  											kfragMissingMorphPos' tagLexEntryIcon' spec.WritingSystem' ispec);  										break;  								}  							}  							vwenv.CloseInnerPile();    							break;  						default:  							if (frag >= kfragNamedObjectNameChoices && frag < kfragNamedObjectNameChoices + m_choices.Count)  							{  								InterlinLineSpec spec = m_choices[frag - kfragNamedObjectNameChoices];  								int wsActual = GetActualWs(hvo' ktagSbNamedObjName' spec.WritingSystem);  								vwenv.AddStringAltMember(ktagSbNamedObjName' wsActual' this);  							}  							else  							{  								throw new Exception("Bad fragment ID in SandboxVc.Display");  							}  							break;  					}  				}  				catch  				{  					Debug.Assert(false' "Exception thrown in the display of the SandboxVc (About to be eaten)");  				}
Magic Number,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,Display,The following statement contains a magic number: try  				{  					switch (frag)  					{  						case kfragBundle: // One annotated word bundle' in this case' the whole view.  							if (hvo == 0)  								return;  							vwenv.set_IntProperty((int)FwTextPropType.ktptSpellCheck' (int)FwTextPropVar.ktpvEnum'  								(int)SpellingModes.ksmDoNotCheck);  							vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  								(int)FwTextPropVar.ktpvDefault' krgbBackground);  							vwenv.OpenDiv();  							vwenv.OpenParagraph();  							// Since embedded in a pile with context' we need another layer of pile here'.  							// It's an overlay sandbox: draw a box around it.  							vwenv.OpenInnerPile();  							// Inside that division we need a paragraph which does not have any border  							// or background. This suppresses the 'infinite width' behavior for the  							// nested paragraphs that may have grey border.  							vwenv.OpenParagraph();    							// This makes a little separation between left border and arrows.  							vwenv.set_IntProperty((int)FwTextPropType.ktptPadLeading'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  							if (m_fRtl)  							{  								// This must not be on the outer paragraph or we get infinite width behavior.  								vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  									(int)FwTextPropVar.ktpvEnum' (int)FwTextToggleVal.kttvForceOn);  								vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  									(int)FwTextPropVar.ktpvEnum' (int)FwTextAlign.ktalRight);  							}  							vwenv.OpenInnerPile();  							for (int ispec = 0; ispec < m_choices.Count; )  							{  								InterlinLineSpec spec = m_choices[ispec];  								if (!spec.WordLevel)  									break;  								if (spec.MorphemeLevel)  								{  									DisplayMorphBundles(vwenv' hvo);  									ispec = m_choices.LastMorphemeIndex + 1;  									continue;  								}  								switch (spec.Flid)  								{  									case InterlinLineChoices.kflidWord:  										int ws = GetActualWs(hvo' spec.StringFlid' spec.WritingSystem);  										DisplayWordform(vwenv' ws' ispec);  										break;  									case InterlinLineChoices.kflidWordGloss:  										DisplayWordGloss(vwenv' hvo' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidWordPos:  										DisplayWordPOS(vwenv' hvo' spec.WritingSystem' ispec);  										break;  								}  								ispec++;  							}  							vwenv.CloseInnerPile();    							vwenv.CloseParagraph();  							vwenv.CloseInnerPile();    							vwenv.CloseParagraph();  							vwenv.CloseDiv();  							break;  						case kfragFirstMorph: // first morpheme in word  						case kfragMorph: // The bundle of 4 lines representing a morpheme.  							vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.OpenInnerPile();  							for (int ispec = m_choices.FirstMorphemeIndex; ispec <= m_choices.LastMorphemeIndex; ispec++)  							{  								int tagLexEntryIcon = 0;  								if (m_choices.FirstLexEntryIndex == ispec)  									tagLexEntryIcon = ktagMorphEntryIcon;  								InterlinLineSpec spec = m_choices[ispec];  								switch (spec.Flid)  								{  									case InterlinLineChoices.kflidMorphemes:  										DisplayMorphForm(vwenv' hvo' frag' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidLexEntries:  										AddOptionalNamedObj(vwenv' hvo' ktagSbMorphEntry' ktagMissingEntry'  											kfragMissingEntry' tagLexEntryIcon' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidLexGloss:  										AddOptionalNamedObj(vwenv' hvo' ktagSbMorphGloss' ktagMissingMorphGloss'  											kfragMissingMorphGloss' tagLexEntryIcon' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidLexPos:  										AddOptionalNamedObj(vwenv' hvo' ktagSbMorphPos' ktagMissingMorphPos'  											kfragMissingMorphPos' tagLexEntryIcon' spec.WritingSystem' ispec);  										break;  								}  							}  							vwenv.CloseInnerPile();    							break;  						default:  							if (frag >= kfragNamedObjectNameChoices && frag < kfragNamedObjectNameChoices + m_choices.Count)  							{  								InterlinLineSpec spec = m_choices[frag - kfragNamedObjectNameChoices];  								int wsActual = GetActualWs(hvo' ktagSbNamedObjName' spec.WritingSystem);  								vwenv.AddStringAltMember(ktagSbNamedObjName' wsActual' this);  							}  							else  							{  								throw new Exception("Bad fragment ID in SandboxVc.Display");  							}  							break;  					}  				}  				catch  				{  					Debug.Assert(false' "Exception thrown in the display of the SandboxVc (About to be eaten)");  				}
Magic Number,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,DisplayMorphForm,The following statement contains a magic number: if (fWantIcon) // Review JohnT: should we do the 'edit box' for all first columns?  				{  					AddPullDownIcon(vwenv' ktagMorphFormIcon);  					// Create an edit box that stays visible when the user deletes  					// the first morpheme (like the WordGloss box).  					// This is especially useful if the user wants to  					// delete the entire MorphForm line (cf. LT-1621).  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  						(int)FwTextPropVar.ktpvMilliPoint'  						kmpIconMargin);  					vwenv.set_IntProperty((int)FwTextPropType.ktptPadTrailing'  						(int)FwTextPropVar.ktpvMilliPoint'  						2000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptPadLeading'  						(int)FwTextPropVar.ktpvMilliPoint'  						2000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  						(int)FwTextPropVar.ktpvDefault' krgbEditable);  				}
Magic Number,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,DisplayMorphForm,The following statement contains a magic number: if (fWantIcon) // Review JohnT: should we do the 'edit box' for all first columns?  				{  					AddPullDownIcon(vwenv' ktagMorphFormIcon);  					// Create an edit box that stays visible when the user deletes  					// the first morpheme (like the WordGloss box).  					// This is especially useful if the user wants to  					// delete the entire MorphForm line (cf. LT-1621).  					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  						(int)FwTextPropVar.ktpvMilliPoint'  						kmpIconMargin);  					vwenv.set_IntProperty((int)FwTextPropType.ktptPadTrailing'  						(int)FwTextPropVar.ktpvMilliPoint'  						2000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptPadLeading'  						(int)FwTextPropVar.ktpvMilliPoint'  						2000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  						(int)FwTextPropVar.ktpvDefault' krgbEditable);  				}
Magic Number,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,DisplayWordGloss,The following statement contains a magic number: vwenv.set_IntProperty((int)FwTextPropType.ktptPadTrailing'  					(int)FwTextPropVar.ktpvMilliPoint'  					2000);
Magic Number,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,DisplayWordGloss,The following statement contains a magic number: vwenv.set_IntProperty((int)FwTextPropType.ktptPadLeading'  					(int)FwTextPropVar.ktpvMilliPoint'  					2000);
Magic Number,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,RebuildStatisticsTable,The following statement contains a magic number: statisticsBox.SelectionTabs = new int[] { 10' 300};
Magic Number,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,RebuildStatisticsTable,The following statement contains a magic number: statisticsBox.SelectionTabs = new int[] { 10' 300};
Magic Number,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,InitializeComponent,The following statement contains a magic number: this.statisticsBox.Size = new System.Drawing.Size(522' 478);
Magic Number,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,InitializeComponent,The following statement contains a magic number: this.statisticsBox.Size = new System.Drawing.Size(522' 478);
Magic Number,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(522' 478);
Magic Number,SIL.FieldWorks.IText,StatisticsView,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\StatisticsView.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(522' 478);
Magic Number,SIL.FieldWorks.IText,TitleContentsPane,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,AdjustHeight,The following statement contains a magic number: int desiredHeight = RootBox.Height + 8;
Magic Number,SIL.FieldWorks.IText,TitleContentsPane,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,AdjustHeight,The following statement contains a magic number: if (this.Parent != null)  				desiredHeight = Math.Min(desiredHeight' Parent.Height / 2);
Magic Number,SIL.FieldWorks.IText,TitleContentsPane,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,AdjustHeight,The following statement contains a magic number: desiredHeight = Math.Max(5' desiredHeight);
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,TitleContentsVc,The following statement contains a magic number: tpb.SetIntPropValues((int)FwTextPropType.ktptPadTop'  				(int) FwTextPropVar.ktpvMilliPoint' 1000);
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,TitleContentsVc,The following statement contains a magic number: tpb.SetIntPropValues((int)FwTextPropType.ktptPadBottom'  				(int) FwTextPropVar.ktpvMilliPoint' 1000);
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,TitleContentsVc,The following statement contains a magic number: tpb.SetIntPropValues((int)FwTextPropType.ktptPadLeading'  				(int) FwTextPropVar.ktpvMilliPoint' 3000);
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,TitleContentsVc,The following statement contains a magic number: tpb.SetIntPropValues((int)FwTextPropType.ktptPadTrailing'  				(int) FwTextPropVar.ktpvMilliPoint' 3000);
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,TitleContentsVc,The following statement contains a magic number: tpb.SetIntPropValues((int)FwTextPropType.ktptMarginTrailing'  				(int) FwTextPropVar.ktpvMilliPoint' 11000);
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,SetupWritingSystemsForTitle,The following statement contains a magic number: m_writingSystems = new CoreWritingSystemDefinition[2];
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,TitleContentsVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\TitleContentsPane.cs,Display,The following statement contains a magic number: switch(frag)  			{  				case kfragRoot:  					if (m_dxLabWidth == 0)  					{  						int dmpx1' dmpy;	//' dmpx2;  						vwenv.get_StringWidth(m_tssTitle' m_ttpBold' out dmpx1' out dmpy);  						//vwenv.get_StringWidth(m_tssComments' m_ttpBold' out dmpx2' out dmpy);  						//m_dxLabWidth = Math.Max(dmpx1' dmpx2) + 13000; // add 3 pt spacing to box' 10 to margin.  						m_dxLabWidth = dmpx1 + 13000; // add 3 pt spacing to box' 10 to margin.    						m_dxWsLabWidth = 0;  						foreach (ITsString tssLabel in m_WsLabels)  						{  							vwenv.get_StringWidth(tssLabel' m_ttpWsLabel' out dmpx1' out dmpy);  							m_dxWsLabWidth = Math.Max(m_dxWsLabWidth' dmpx1);  						}  						m_dxWsLabWidth += 18000; // 3 pts white space each side' 11 margin' 1 border' plus 1 for safety.  					}  					VwLength vlTable;  					vlTable.nVal = 10000;  					vlTable.unit = VwUnit.kunPercent100;    					VwLength vlColLabels; // 5-pt space plus max label width.  					vlColLabels.nVal = m_dxLabWidth;  					vlColLabels.unit = VwUnit.kunPoint1000;    					VwLength vlColWsLabels; // 5-pt space plus max ws label width.  					vlColWsLabels.nVal = m_dxWsLabWidth;  					vlColWsLabels.unit = VwUnit.kunPoint1000;    					// The Main column is relative and uses the rest of the space.  					VwLength vlColMain;  					vlColMain.nVal = 1;  					vlColMain.unit = VwUnit.kunRelative;    					// The Padding column allows for the the trailing margin and border.  					VwLength vlColPadding;  					vlColPadding.nVal = 10000;  					vlColPadding.unit = VwUnit.kunPoint1000;    					vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTop'  						(int) FwTextPropVar.ktpvMilliPoint' 5000);  					vwenv.OpenTable(4' // Four columns.  						vlTable' // Table uses 100% of available width.  						0' // Border thickness.  						VwAlignment.kvaLeft' // Default alignment.  						VwFramePosition.kvfpVoid' // No border.  						VwRule.kvrlNone' // No rules between cells.  						0' // No forced space between cells.  						0' // no padding inside cells.  						false);  					vwenv.MakeColumns(1' vlColLabels);  					vwenv.MakeColumns(1' vlColWsLabels);  					vwenv.MakeColumns(1' vlColMain);  					vwenv.MakeColumns(1' vlColPadding);    					vwenv.OpenTableBody();    					for (int i = 0; i < m_writingSystems.Length; i++)  					{  						vwenv.OpenTableRow();    						// First cell has 'Title' label in bold.  						vwenv.Props = m_ttpBold;  						vwenv.OpenTableCell(1'1);  						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  							(int) FwTextPropVar.ktpvMilliPoint' 10000);  						if (i == 0) // only on the first row  						{  							// We want this fixed at 10 point' since it's considered a UI component' not data.  							// See LT-4816  							vwenv.set_IntProperty((int)FwTextPropType.ktptFontSize'  								(int)FwTextPropVar.ktpvMilliPoint' 10000);  							vwenv.AddString(m_tssTitle);  						}  						vwenv.CloseTableCell();    						// Second cell has ws labels.  						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderLeading'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.Props = m_ttpDataCellProps;    						vwenv.Props = m_ttpWsLabel;  						vwenv.AddString(m_WsLabels[i]);  						vwenv.CloseTableCell();    						// Third cell has the Title property' in a box.    						vwenv.set_IntProperty((int)FwTextPropType.ktptBackColor'  							(int) FwTextPropVar.ktpvDefault' m_editBackColor);  						// Set the underlying directionality so that arrow keys work properly.  						bool fRTL = m_writingSystems[i].RightToLeftScript;  						vwenv.set_IntProperty((int)FwTextPropType.ktptRightToLeft'  							(int)FwTextPropVar.ktpvEnum' fRTL ? -1 : 0);  						vwenv.set_IntProperty((int)FwTextPropType.ktptAlign'  							(int)FwTextPropVar.ktpvEnum'  							fRTL ? (int)FwTextAlign.ktalRight : (int)FwTextAlign.ktalLeft);  						if (i == 0)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTop'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						if (i == m_writingSystems.Length - 1)  							vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  								(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1'1);  						vwenv.OpenParagraph();  						vwenv.Props = m_ttpDataCellProps;  						vwenv.set_IntProperty((int)FwTextPropType.ktptEditable' (int)FwTextPropVar.ktpvEnum'  								this.Editable ? (int)TptEditable.ktptIsEditable : (int)TptEditable.ktptNotEditable);  						if (IsScripture)  						{  							vwenv.AddStringAltMember(m_vtagStTextTitle' m_writingSystems[i].Handle' this);  						}  						else  						{  							vwenv.AddStringAltMember(CmMajorObjectTags.kflidName' m_writingSystems[i].Handle' this);  						}  						vwenv.CloseParagraph();  						vwenv.CloseTableCell();    						vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 10000);  						vwenv.set_IntProperty((int)FwTextPropType.ktptBorderTrailing'  							(int)FwTextPropVar.ktpvMilliPoint' 1000);  						vwenv.OpenTableCell(1' 1);  						vwenv.CloseTableCell();    						vwenv.CloseTableRow();  					}    					//// Second row.  					//vwenv.OpenTableRow();  					//  					//// First cell has 'Comments' label in bold.  					//vwenv.Props = m_ttpBold;  					//vwenv.OpenTableCell(1'1);  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginLeading'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.AddString(m_tssComments);  					//vwenv.CloseTableCell();  					//  					//// Second cell has the Description property' in a box.  					//vwenv.set_IntProperty((int)FwTextPropType.ktptMarginTrailing'  					//	(int)FwTextPropVar.ktpvMilliPoint' 10000);  					//vwenv.OpenTableCell(1'1);  					//vwenv.Props = m_ttpDataCellProps;  					//vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom'  					//	(int)FwTextPropVar.ktpvMilliPoint' 1000);  					//vwenv.AddStringAltMember(  					//	(int)CmMajorObject.CmMajorObjectTags.kflidDescription' m_wsAnalysis' this);  					//vwenv.CloseTableCell();  					//  					//vwenv.CloseTableRow();    					vwenv.CloseTableBody();    					vwenv.CloseTable();    					break;  				default:  					throw new Exception("Bad frag id in TitleContentsVc");  			}
Magic Number,SIL.FieldWorks.IText,WordsSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WordsSfmImportWizard.cs,DoStage2Conversion,The following statement contains a magic number: dlg.Position += 50;
Magic Number,SIL.FieldWorks.IText,WordsSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WordsSfmImportWizard.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(534' 354);
Magic Number,SIL.FieldWorks.IText,WordsSfmImportWizard,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WordsSfmImportWizard.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(534' 354);
Magic Number,SIL.FieldWorks.IText,WsListManager,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WsListManager.cs,LanguageCodeTextProps,The following statement contains a magic number: tpb.SetIntPropValues((int)FwTextPropType.ktptForeColor' (int)FwTextPropVar.ktpvDefault'  				BGR(47' 96' 255));
Magic Number,SIL.FieldWorks.IText,WsListManager,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WsListManager.cs,LanguageCodeTextProps,The following statement contains a magic number: tpb.SetIntPropValues((int)FwTextPropType.ktptForeColor' (int)FwTextPropVar.ktpvDefault'  				BGR(47' 96' 255));
Magic Number,SIL.FieldWorks.IText,WsListManager,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WsListManager.cs,LanguageCodeTextProps,The following statement contains a magic number: tpb.SetIntPropValues((int)FwTextPropType.ktptForeColor' (int)FwTextPropVar.ktpvDefault'  				BGR(47' 96' 255));
Magic Number,SIL.FieldWorks.IText,WsListManager,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WsListManager.cs,LanguageCodeTextProps,The following statement contains a magic number: tpb.SetIntPropValues((int)FwTextPropType.ktptFontSize' (int)FwTextPropVar.ktpvMilliPoint'  				8000);
Magic Number,SIL.FieldWorks.IText,WsListManager,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WsListManager.cs,BGR,The following statement contains a magic number: return red + (blue * 256 + green) * 256;
Magic Number,SIL.FieldWorks.IText,WsListManager,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\WsListManager.cs,BGR,The following statement contains a magic number: return red + (blue * 256 + green) * 256;
Missing Default,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,UpdatePhraseTextForWordItems,The following switch statement is missing a default case: switch (item.type)  				{  					case "txt": //intentional fallthrough  						isWord = true;  						goto case "punct";  					case "punct":  						ITsString wordString = TsStringUtils.MakeString(item.Value'  							GetWsEngine(wsFactory' item.lang).Handle);  						if (phraseText == null)  						{  							phraseText = wordString;  						}  						else  						{  							var phraseBldr = phraseText.GetBldr();  							if (lastWasWord && isWord) //two words next to each other deserve a space between  							{  								phraseBldr.ReplaceTsString(phraseText.Length' phraseText.Length'  								   TsStringUtils.MakeString("" + space' GetWsEngine(wsFactory' item.lang).Handle));  							}  							else if (!isWord) //handle punctuation  							{  								wordString = GetSpaceAdjustedPunctString(wsFactory'  									item' wordString' space' lastWasWord);  							}  							phraseBldr.ReplaceTsString(phraseBldr.Length' phraseBldr.Length' wordString);  							phraseText = phraseBldr.GetString();  						}  						lastWasWord = isWord;  						return; // only handle the baseline "txt" or "punct" once per "word" bundle' especially don't want extra writing system content in the baseline.  				}
Missing Default,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,CreateWordAnalysisStack,The following switch statement is missing a default case: switch (wordItem.type)  				{  					case "txt":  						wsMainVernWs = GetWsEngine(wsFact' wordItem.lang);  						wordForm = TsStringUtils.MakeString(wordItem.Value' wsMainVernWs.Handle);  						analysis = WfiWordformServices.FindOrCreateWordform(cache' wordForm);  						break;  					case "punct":  						wordForm = TsStringUtils.MakeString(wordItem.Value'  														 GetWsEngine(wsFact' wordItem.lang).Handle);  						analysis = WfiWordformServices.FindOrCreatePunctuationform(cache' wordForm);  						break;  				}
Missing Default,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,AddAlternativeWssToWordform,The following switch statement is missing a default case: switch (wordItem.type)  				{  					case "txt":  						var wsAlt = GetWsEngine(wsFact' wordItem.lang);  						if (wsAlt.Handle == wsMainVernWs.Handle)  							continue;  						ITsString wffAlt = TsStringUtils.MakeString(wordItem.Value' wsAlt.Handle);  						if (wffAlt.Length > 0)  							wf.Form.set_String(wsAlt.Handle' wffAlt);  						break;  				}
Missing Default,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,SetTextMetaAndMergeMedia,The following switch statement is missing a default case: switch (item.type)  					{  						case "title":  							newText.Name.set_String(GetWsEngine(wsFactory' item.lang).Handle' item.Value);  							break;  						case "title-abbreviation":  							newText.Abbreviation.set_String(GetWsEngine(wsFactory' item.lang).Handle' item.Value);  							break;  						case "source":  							newText.Source.set_String(GetWsEngine(wsFactory' item.lang).Handle' item.Value);  							break;  						case "comment":  							newText.Description.set_String(GetWsEngine(wsFactory' item.lang).Handle' item.Value);  							break;  					}
Missing Default,SIL.FieldWorks.IText,LinguaLinksImport,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\BIRDInterlinearImporter.cs,AdjustPunctStringForCharacter,The following switch statement is missing a default case: switch (charType)  			{  				case Icu.UCharCategory.U_END_PUNCTUATION:  				case Icu.UCharCategory.U_FINAL_PUNCTUATION:  					spaceAfter = true;  					break;  				case Icu.UCharCategory.U_START_PUNCTUATION:  				case Icu.UCharCategory.U_INITIAL_PUNCTUATION:  					spaceBefore = true;  					break;  				case Icu.UCharCategory.U_OTHER_PUNCTUATION: //handle special characters  					if(wordString.Text.LastIndexOfAny(new[] {'''''.''';''':'''?'''!''quote}) == wordString.Length - 1) //treat as ending characters  					{  						spaceAfter = punctChar != '"' || wordString.Length > 1; //quote characters are extra special' if we find them on their own  																				//it is near impossible to know what to do' but it's usually nothing.  					}  					if (punctChar == '\xA1' || punctChar == '\xBF')  					{  						spaceHere = true;  					}  					if (punctChar == quote && wordString.Length == 1)  					{  						spaceBefore = followsWord; //if we find a lonely quotation mark after a word' we'll put a space before it.  					}  					break;  			}
Missing Default,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,GetOptionString,The following switch statement is missing a default case: switch (type)  			{  				case ComplexConcordanceInsertType.Morph:  					return ITextStrings.ksComplexConcMorph;    				case ComplexConcordanceInsertType.Word:  					return ITextStrings.ksComplexConcWord;    				case ComplexConcordanceInsertType.TextTag:  					return ITextStrings.ksComplexConcTag;    				case ComplexConcordanceInsertType.Or:  					return "OR";    				case ComplexConcordanceInsertType.WordBoundary:  					return string.Format("{0} (#)"' ITextStrings.ksComplexConcWordBoundary);  			}
Missing Default,SIL.FieldWorks.IText,ComplexConcControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcControl.cs,m_insertControl_Insert,The following switch statement is missing a default case: switch (((InsertOption) e.Option).Type)  			{  				case ComplexConcordanceInsertType.Morph:  					using (ComplexConcMorphDlg dlg = new ComplexConcMorphDlg())  					{  						ComplexConcMorphNode morphNode = new ComplexConcMorphNode();  						dlg.SetDlgInfo(m_cache' m_mediator' m_propertyTable' morphNode);  						if (dlg.ShowDialog(m_propertyTable.GetValue<XWindow>("window")) == DialogResult.OK)  							node = morphNode;  					}  					break;    				case ComplexConcordanceInsertType.Word:  					using (ComplexConcWordDlg dlg = new ComplexConcWordDlg())  					{  						ComplexConcWordNode wordNode = new ComplexConcWordNode();  						dlg.SetDlgInfo(m_cache' m_mediator' m_propertyTable' wordNode);  						if (dlg.ShowDialog(m_propertyTable.GetValue<XWindow>("window")) == DialogResult.OK)  							node = wordNode;  					}  					break;    				case ComplexConcordanceInsertType.TextTag:  					using (ComplexConcTagDlg dlg = new ComplexConcTagDlg())  					{  						ComplexConcTagNode tagNode = new ComplexConcTagNode();  						dlg.SetDlgInfo(m_cache' m_mediator' m_propertyTable' tagNode);  						if (dlg.ShowDialog(m_propertyTable.GetValue<XWindow>("window")) == DialogResult.OK)  							node = tagNode;  					}  					break;    				case ComplexConcordanceInsertType.Or:  					node = new ComplexConcOrNode();  					break;    				case ComplexConcordanceInsertType.WordBoundary:  					node = new ComplexConcWordBdryNode();  					break;  			}
Missing Default,SIL.FieldWorks.IText,ComplexConcGroupNode,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcGroupNode.cs,ChildrenChanged,The following switch statement is missing a default case: switch (e.Action)  			{  				case NotifyCollectionChangedAction.Add:  					AddNodes(e.NewItems.Cast<ComplexConcPatternNode>());  					break;    				case NotifyCollectionChangedAction.Remove:  					RemoveNodes(e.OldItems.Cast<ComplexConcPatternNode>());  					break;    				case NotifyCollectionChangedAction.Replace:  					RemoveNodes(e.OldItems.Cast<ComplexConcPatternNode>());  					AddNodes(e.NewItems.Cast<ComplexConcPatternNode>());  					break;    				case NotifyCollectionChangedAction.Reset:  					break;  			}
Missing Default,SIL.FieldWorks.IText,ConcordanceControl,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ConcordanceControl.cs,FillWritingSystemCombo,The following switch statement is missing a default case: switch (wsMagic)  			{  				case WritingSystemServices.kwsVerns:  					foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystems.CurrentVernacularWritingSystems)  						m_cbWritingSystem.Items.Add(ws);  					wsSet = m_cache.DefaultVernWs;  					break;  				case WritingSystemServices.kwsAnals:  					foreach (CoreWritingSystemDefinition ws in m_cache.ServiceLocator.WritingSystems.CurrentAnalysisWritingSystems)  						m_cbWritingSystem.Items.Add(ws);  					wsSet = m_cache.DefaultAnalWs;  					break;  			}
Missing Default,SIL.FieldWorks.IText,ComplexConcPatternVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\ComplexConcPatternVc.cs,Display,The following switch statement is missing a default case: switch (frag)  			{  				case kfragPattern:  					VwLength tableLen;  					tableLen.nVal = 10000;  					tableLen.unit = VwUnit.kunPercent100;  					vwenv.OpenTable(1' tableLen' 0' VwAlignment.kvaCenter' VwFramePosition.kvfpVoid' VwRule.kvrlNone' 0' 0' false);  					VwLength patternLen;  					patternLen.nVal = 1;  					patternLen.unit = VwUnit.kunRelative;  					vwenv.MakeColumns(1' patternLen);  					vwenv.OpenTableBody();  					vwenv.OpenTableRow();    					vwenv.set_IntProperty((int)FwTextPropType.ktptBorderBottom' (int)FwTextPropVar.ktpvMilliPoint' 1000);  					vwenv.set_IntProperty((int)FwTextPropType.ktptBorderColor' (int)FwTextPropVar.ktpvDefault' (int)ColorUtil.ConvertColorToBGR(Color.Gray));  					vwenv.set_IntProperty((int)FwTextPropType.ktptAlign' (int)FwTextPropVar.ktpvEnum' (int)FwTextAlign.ktalCenter);  					vwenv.set_IntProperty((int)FwTextPropType.ktptPadBottom' (int)FwTextPropVar.ktpvMilliPoint' 2000);  					vwenv.OpenTableCell(1' 1);  					vwenv.OpenParagraph();  					if (((ComplexConcPatternSda) vwenv.DataAccess).Root.IsLeaf)  					{  						OpenSingleLinePile(vwenv' GetMaxNumLines(vwenv)' false);  						vwenv.Props = m_bracketProps;  						vwenv.AddProp(ComplexConcPatternSda.ktagChildren' this' kfragEmpty);  						CloseSingleLinePile(vwenv' false);  					}  					else  					{  						vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);  					}  					vwenv.CloseParagraph();  					vwenv.CloseTableCell();    					vwenv.CloseTableRow();  					vwenv.CloseTableBody();  					vwenv.CloseTable();  					break;    				case kfragNode:  					ComplexConcPatternNode node = ((ComplexConcPatternSda) vwenv.DataAccess).Nodes[hvo];  					int maxNumLines = GetMaxNumLines(vwenv);  					if (node is ComplexConcOrNode)  					{  						OpenSingleLinePile(vwenv' maxNumLines);  						vwenv.AddProp(ktagInnerNonBoundary' this' kfragOR);  						CloseSingleLinePile(vwenv' false);  					}  					else if (node is ComplexConcWordBdryNode)  					{  						OpenSingleLinePile(vwenv' maxNumLines);  						vwenv.AddProp(ktagInnerNonBoundary' this' kfragHash);  						CloseSingleLinePile(vwenv);  					}  					else if (node is ComplexConcGroupNode)  					{  						int numLines = GetNumLines(node);  						bool hasMinMax = node.Maximum != 1 || node.Minimum != 1;  						if (numLines == 1)  						{  							OpenSingleLinePile(vwenv' maxNumLines' false);  							// use normal parentheses for a single line group  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftParen);    							vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);    							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightParen);  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  							CloseSingleLinePile(vwenv' false);  						}  						else  						{  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginLeading' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagLeftNonBoundary' vwenv);  							vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftParenUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftParenExt);  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftParenLowHook);  							vwenv.CloseInnerPile();    							vwenv.AddObjVecItems(ComplexConcPatternSda.ktagChildren' this' kfragNode);    							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' vwenv);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightParenUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightParenExt);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightParenLowHook);  							vwenv.CloseInnerPile();  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  						}  					}  					else  					{  						bool hasMinMax = node.Maximum != 1 || node.Minimum != 1;  						int numLines = GetNumLines(node);  						if (numLines == 1)  						{  							OpenSingleLinePile(vwenv' maxNumLines' false);  							// use normal brackets for a single line constraint  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftBracket);    							DisplayFeatures(vwenv' node);    							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightBracket);  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  							CloseSingleLinePile(vwenv' false);  						}  						else  						{  							// left bracket pile  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginLeading' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagLeftNonBoundary' vwenv);  							vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftBracketUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(ktagLeftNonBoundary' this' kfragLeftBracketExt);  							vwenv.AddProp(ktagLeftBoundary' this' kfragLeftBracketLowHook);  							vwenv.CloseInnerPile();    							// feature pile  							vwenv.set_IntProperty((int) FwTextPropType.ktptAlign' (int) FwTextPropVar.ktpvEnum' (int) FwTextAlign.ktalLeft);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' ktagInnerNonBoundary' vwenv);  							DisplayFeatures(vwenv' node);  							vwenv.CloseInnerPile();    							// right bracket pile  							vwenv.Props = m_bracketProps;  							vwenv.set_IntProperty((int) FwTextPropType.ktptMarginTrailing' (int) FwTextPropVar.ktpvMilliPoint' PileMargin);  							vwenv.OpenInnerPile();  							AddExtraLines(maxNumLines - numLines' hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' vwenv);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightBracketUpHook);  							for (int i = 1; i < numLines - 1; i++)  								vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightNonBoundary' this' kfragRightBracketExt);  							vwenv.AddProp(hasMinMax ? ktagInnerNonBoundary : ktagRightBoundary' this' kfragRightBracketLowHook);  							vwenv.CloseInnerPile();  							if (hasMinMax)  								DisplayMinMax(numLines' vwenv);  						}  					}  					break;  			}
Missing Default,SIL.FieldWorks.IText,InterlinearExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,OpenTheObject,The following switch statement is missing a default case: switch(tag)  			{  				case StTextTags.kflidParagraphs:  					// The paragraph data may need to be loaded if the paragraph has not yet  					// appeared on the screen.  See LT-7071.  					m_vc.LoadDataFor(this' new int[1] { hvo }' 1' CurrentObject()' tag' -1' ihvo);  					WriteStartParagraph(hvo);  					break;  				case WfiAnalysisTags.kflidMorphBundles:  					WriteStartMorpheme(hvo);  					m_guidMorphType = Guid.Empty;	// reset morphtype before each morph bundle.  					break;  				case StTxtParaTags.kflidSegments:  					WriteStartPhrase(hvo);  					break;  				case SegmentTags.kflidAnalyses:  					WriteStartWord(hvo);  					break;  			}
Missing Default,SIL.FieldWorks.IText,InterlinearExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,CloseTheObject,The following switch statement is missing a default case: switch(CurrentPropTag)  			{  				case StTextTags.kflidParagraphs:  					m_writer.WriteEndElement();  					break;  				case WfiAnalysisTags.kflidMorphBundles:  					m_writer.WriteEndElement();  					m_guidMorphType = Guid.Empty;	// reset morphtype after each morph bundle.  					break;  				case StTxtParaTags.kflidSegments:  					m_writer.WriteEndElement();  					break;  				case SegmentTags.kflidAnalyses:  					m_writer.WriteEndElement();  					break;  			}
Missing Default,SIL.FieldWorks.IText,InterlinearExporter,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinearExporter.cs,AddUnicodeProp,The following switch statement is missing a default case: switch(tag)  			{  				case MoMorphTypeTags.kflidPrefix:  					m_sPendingPrefix = m_sda.get_UnicodeProp(m_hvoCurr' tag);  					break;  				case MoMorphTypeTags.kflidPostfix:  					m_writer.WriteString(m_sda.get_UnicodeProp(m_hvoCurr' tag));  					break;  			}
Missing Default,SIL.FieldWorks.IText,InterlinLineChoices,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinLineChoices.cs,DefaultChoices,The following switch statement is missing a default case: switch (mode)  			{  				case InterlinMode.Analyze:  					result.SetStandardState();  					break;  				case InterlinMode.Gloss:  				case InterlinMode.GlossAddWordsToLexicon:  					result.SetStandardGlossState();  					break;  			}
Missing Default,SIL.FieldWorks.IText,InterlinLineChoices,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinLineChoices.cs,GetCustomLineOptions,The following switch statement is missing a default case: switch (mode)  			{  				case InterlinMode.Analyze:  				case InterlinMode.Gloss:  					if (m_cache != null)  					{  						var classId = m_cache.MetaDataCacheAccessor.GetClassId("Segment");  						var mdc = (IFwMetaDataCacheManaged)m_cache.MetaDataCacheAccessor;  						foreach (int flid in mdc.GetFields(classId' false' (int)CellarPropertyTypeFilter.All))  						{  							if (!mdc.IsCustom(flid))  								continue;  							customLineOptions.Add(new LineOption(flid' mdc.GetFieldLabel(flid)));  						}  					}  					break;  			}
Missing Default,SIL.FieldWorks.IText,InterlinDocRootSiteBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinDocRootSiteBase.cs,PropChanged,The following switch statement is missing a default case: switch (tag)  			{  				case WfiAnalysisTags.kflidEvaluations:  					IWfiAnalysis analysis = m_cache.ServiceLocator.GetInstance<IWfiAnalysisRepository>().GetObject(hvo);  					if (analysis.HasWordform && RootStText.UniqueWordforms().Contains(analysis.Wordform))  					{  						m_wordformsToUpdate.Add(analysis.Wordform);  						m_mediator.IdleQueue.Add(IdleQueuePriority.High' PostponedUpdateWordforms);  					}  					break;  				case WfiWordformTags.kflidAnalyses:  					IWfiWordform wordform = m_cache.ServiceLocator.GetInstance<IWfiWordformRepository>().GetObject(hvo);  					if (RootStText.UniqueWordforms().Contains(wordform))  					{  						m_wordformsToUpdate.Add(wordform);  						m_mediator.IdleQueue.Add(IdleQueuePriority.High' PostponedUpdateWordforms);  					}  					break;  			}
Missing Default,SIL.FieldWorks.IText,InterlinMaster,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinMaster.cs,OnPropertyChanged,The following switch statement is missing a default case: switch (name)  			{  				case "InterlinearTab":  					if (m_tabCtrl.SelectedIndex != (int)InterlinearTab)  						ShowTabView();  					break;  				case "ShowMorphBundles":  					// This helps make sure the notification gets through even if the pane isn't  					// in focus (maybe the Sandbox or TC pane is) and so isn't an xCore target.  					break;  			}
Missing Default,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,IsVernWs,The following switch statement is missing a default case: switch (wsSpec)  			{  				case WritingSystemServices.kwsVern:  				case WritingSystemServices.kwsVerns:  				case WritingSystemServices.kwsFirstVern:  				case WritingSystemServices.kwsVernInParagraph:  					return true;  				case WritingSystemServices.kwsAnal:  				case WritingSystemServices.kwsAnals:  				case WritingSystemServices.kwsFirstAnal:  				case WritingSystemServices.kwsFirstPronunciation:  				case WritingSystemServices.kwsAllReversalIndex:  				case WritingSystemServices.kwsPronunciation:  				case WritingSystemServices.kwsPronunciations:  				case WritingSystemServices.kwsReversalIndex:  					return false;  			}
Missing Default,SIL.FieldWorks.IText,InterlinVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,DisplayMorphBundle,The following switch statement is missing a default case: switch (spec.Flid)  				{  					case InterlinLineChoices.kflidMorphemes:  						if (wmb == null)  						{  							vwenv.AddString(m_tssMissingMorph);  						}  						else if (mf == null)  						{  							// displaying morphemes should be  							int ws = 0;  							if (wmb.MorphRA != null)  							{  								Debug.Assert(spec.StringFlid == MoFormTags.kflidForm);  								ws = GetRealWsOrBestWsForContext(wmb.MorphRA.Hvo' spec);  							}  							// If no morph' use the form of the morph bundle (and the entry is of  							// course missing)  							if (ws == 0)  							{  								ws = WritingSystemServices.ActualWs(m_cache' spec.WritingSystem' wmb.Hvo'  									WfiMorphBundleTags.kflidForm);  							}  							vwenv.AddStringAltMember(  								WfiMorphBundleTags.kflidForm' ws' this);  						}  						else  						{  							// Got a morph' show it.  							vwenv.AddObjProp(WfiMorphBundleTags.kflidMorph'  								this' kfragMorphFormChoices + i);  							// And the LexEntry line.  						}  						break;  					case InterlinLineChoices.kflidLexEntries:  						if (mf == null)  						{  							if (hvo != 0)  								vwenv.NoteDependency(new int[] { hvo }' new int[] { WfiMorphBundleTags.kflidMorph }' 1);  							vwenv.AddString(m_tssMissingEntry);  						}  						else  						{  							int ws = GetRealWsOrBestWsForContext(mf.Hvo' spec);  							if (ws == 0)  								ws = spec.WritingSystem;  							LexEntryVc vcEntry = new LexEntryVc(m_cache);  							vcEntry.WritingSystemCode = ws;  							vwenv.AddObj(hvo' vcEntry' LexEntryVc.kfragEntryAndVariant);  						}  						break;  					case InterlinLineChoices.kflidLexGloss:  						int flid = 0;  						if (wmb != null)  						{  							vwenv.NoteDependency(new[] { wmb.Hvo }' new[] { WfiMorphBundleTags.kflidMorph }' 1);  							vwenv.NoteDependency(new[] { wmb.Hvo }' new[] { WfiMorphBundleTags.kflidInflType }' 1);  							vwenv.NoteDependency(new[] { hvo }' new[] { WfiMorphBundleTags.kflidSense }' 1);  							if (wmb.SenseRA == null)  							{  								if (ShowDefaultSense && wmb.DefaultSense != null && UsingGuess)  								{  									flid = wmb.Cache.MetaDataCacheAccessor.GetFieldId2(WfiMorphBundleTags.kClassId'  										"DefaultSense"' false);  								}  							}  							else  							{  								flid = WfiMorphBundleTags.kflidSense;  								if (wmb.MorphRA != null &&  									DisplayLexGlossWithInflType(vwenv' wmb.MorphRA.Owner as ILexEntry' wmb.SenseRA' spec' wmb.InflTypeRA))  								{  									break;  								}    							}  						}    						if (flid == 0)  							vwenv.AddString(m_tssMissingSense);  						else  							vwenv.AddObjProp(flid' this' kfragLineChoices + i);  						break;    					case InterlinLineChoices.kflidLexPos:  						// LexPOS line:  						int hvoMsa = 0;  						if (wmb != null && wmb.MsaRA != null)  							hvoMsa = wmb.MsaRA.Hvo;  						if (hvoMsa == 0)  						{  							if (hvo != 0)  								vwenv.NoteDependency(new int[] { hvo }' new int[] { WfiMorphBundleTags.kflidMsa }' 1);  							vwenv.AddString(m_tssMissingMsa);  						}  						else  						{  							// Use a special view constructor that knows how to display the  							// interlinear view of whatever kind of MSA it is.  							// Enhance JohnT: ideally we would have one of these VCs for each writing system'  							// perhaps stored in the InterlinLineSpec. Currently displaying multiple Wss of LexPos  							// is not useful' though it is possible.  							// Enhancement RickM: we set the m_msaVc.DefaultWs to the selected writing system  							//		of each LexPos line in interlinear. This is used extract the LexPos abbreviation  							//		for the specific writing system.  							m_msaVc.DefaultWs = spec.WritingSystem;  							vwenv.AddObjProp(WfiMorphBundleTags.kflidMsa'  								m_msaVc' (int)VcFrags.kfragInterlinearAbbr);  						}  						break;  				}
Missing Default,SIL.FieldWorks.IText,DisplayWordBundleMethod,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\InterlinVc.cs,Run,The following switch statement is missing a default case: switch(spec.Flid)  						{  						case InterlinLineChoices.kflidWord:  								DisplayWord(spec' i' wag);  								break;  						case InterlinLineChoices.kflidWordGloss:  								DisplayWordGloss(spec' i);  								break;  						case InterlinLineChoices.kflidWordPos:  								DisplayWordPOS(i);  								break;  						}
Missing Default,SIL.FieldWorks.IText,RawTextPane,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\RawTextPane.cs,OnProblemDeletion,The following switch statement is missing a default case: switch (dpt)  			{  			case VwDelProbType.kdptBsAtStartPara:  			case VwDelProbType.kdptDelAtEndPara:  			case VwDelProbType.kdptNone:  				return VwDelProbResponse.kdprDone;  			case VwDelProbType.kdptBsReadOnly:  			case VwDelProbType.kdptComplexRange:  			case VwDelProbType.kdptDelReadOnly:  			case VwDelProbType.kdptReadOnly:  				return VwDelProbResponse.kdprFail;  			}
Missing Default,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetDefaults,The following switch statement is missing a default case: switch (obj.ClassID)  				{  					case WfiAnalysisTags.kClassId:  						analysis = (IWfiAnalysis) obj;  						gloss = analysis.MeaningsOC.FirstOrDefault();  						return;  					case WfiGlossTags.kClassId:  						gloss = (IWfiGloss) obj;  						analysis = obj.OwnerOfClass<IWfiAnalysis>();  						return;  				}
Missing Default,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetLineOfCurrentSelectionAndNextTabStop,The following switch statement is missing a default case: switch (tagTextProp)  			{  				case ktagAnalysisIcon: // Wordform icon  					currentLineIndex = 0;  					break;  				case ktagSbWordForm: // Wordform  					currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidWord' ws);  					// try selecting the icon.  					if (increment < 0 && m_choices.IsFirstOccurrenceOfFlid(currentLineIndex))  						startLineIndex = currentLineIndex;  					break;  				case ktagMissingMorphs: // line 2' morpheme forms' no guess.  					// It's not supposed to be possible to get a selection into this line.  					// (Maybe the end-point' but not the anchor.)  					Debug.Assert(false);  					break;  				case ktagMorphFormIcon:  					currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidMorphemes);  					if (increment > 0 && !fOnNextLine)  					{  						iNextMorphIndex = 0;  						startLineIndex = currentLineIndex;  // try on the same line.  						fSkipIcon = true;  					}  					break;  				case ktagMissingMorphPos: // line 5' LexPos' missing.  				case ktagMissingMorphGloss: // line 4' LexGloss' missing.  				case ktagMissingEntry: // line 3' LexEntry' missing  					NextPositionForLexEntryText(increment' fOnNextLine' fIsPictureSel' out currentLineIndex' out startLineIndex' ref iNextMorphIndex);  					break;  				case ktagMorphEntryIcon:  					currentLineIndex = m_choices.FirstLexEntryIndex;  					if (!fOnNextLine)  						startLineIndex = currentLineIndex; 	// try on the same line.  					break;  				case ktagSbWordGloss:  					currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidWordGloss' ws);  					if (increment < 0 && m_vc.ShowWordGlossIcon &&  						m_choices.PreviousOccurrences(currentLineIndex) == 0)  					{  						startLineIndex = currentLineIndex;  					}  					break;  				case ktagWordGlossIcon: // line 6' word gloss.  					currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidWordGloss);  					if (increment > 0)  					{  						fSkipIcon = true;  						startLineIndex = currentLineIndex;  					}  					break;  				case ktagMissingWordPos: // line 7' word POS' missing  					currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidWordPos);  					if (increment < 0)  						startLineIndex = currentLineIndex;  					break;  				case ktagWordPosIcon:  					currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidWordPos);  					break;  				case ktagSbMorphPrefix:  				case ktagSbMorphPostfix:  					currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidMorphemes);  					if (!fOnNextLine)  						startLineIndex = currentLineIndex;  					break;  				case ktagSbNamedObjName:  					{  						// This could be any of several non-missing objects.  						// Need to further subdivide.  						int tagObjProp = rgvsli[0].tag;  						switch (tagObjProp)  						{  							case ktagSbMorphForm:  								currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidMorphemes' ws);  								if (fOnNextLine)  								{  									if (increment < 0 && m_choices.IsFirstOccurrenceOfFlid(currentLineIndex))  									{  										// try selecting the icon.  										iNextMorphIndex = -1;  										startLineIndex = currentLineIndex;  									}  								}  								else  								{  									startLineIndex = currentLineIndex;  								}  								break;  							case ktagSbMorphPos: // line 5' LexPos.  							case ktagSbMorphGloss: // line 4' LexGloss  							case ktagSbMorphEntry: // line 3' LexEntry  								NextPositionForLexEntryText(increment' fOnNextLine' fIsPictureSel' out currentLineIndex' out startLineIndex' ref iNextMorphIndex);  								break;  							case ktagSbWordPos: // line 7' WordPos.  								currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidWordPos);  								// try selecting the icon.  								if (increment < 0 && !fIsPictureSel)  									startLineIndex = currentLineIndex;  								break;  						}  					}  					break;  			}
Missing Default,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetLineOfCurrentSelectionAndNextTabStop,The following switch statement is missing a default case: switch (tagObjProp)  						{  							case ktagSbMorphForm:  								currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidMorphemes' ws);  								if (fOnNextLine)  								{  									if (increment < 0 && m_choices.IsFirstOccurrenceOfFlid(currentLineIndex))  									{  										// try selecting the icon.  										iNextMorphIndex = -1;  										startLineIndex = currentLineIndex;  									}  								}  								else  								{  									startLineIndex = currentLineIndex;  								}  								break;  							case ktagSbMorphPos: // line 5' LexPos.  							case ktagSbMorphGloss: // line 4' LexGloss  							case ktagSbMorphEntry: // line 3' LexEntry  								NextPositionForLexEntryText(increment' fOnNextLine' fIsPictureSel' out currentLineIndex' out startLineIndex' ref iNextMorphIndex);  								break;  							case ktagSbWordPos: // line 7' WordPos.  								currentLineIndex = m_choices.IndexOf(InterlinLineChoices.kflidWordPos);  								// try selecting the icon.  								if (increment < 0 && !fIsPictureSel)  									startLineIndex = currentLineIndex;  								break;  						}
Missing Default,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SelectOnOrBeyondLine,The following switch statement is missing a default case: switch (spec.Flid)  				{  					case InterlinLineChoices.kflidWord:  						if (!fSkipIconToTextField && m_choices.PreviousOccurrences(ispec) == 0)  						{  							if (ShowAnalysisCombo)  							{  								SelectIcon(ktagAnalysisIcon);  								return true;  							}  							else  								break; // can't do anything else on line 0.  						}  						else  						{  							// make a selection in an alternative writing system.  							MoveSelection(new SelLevInfo[0]' ktagSbWordForm'  								m_choices.PreviousOccurrences(ispec));  							return true;  						}  					case InterlinLineChoices.kflidMorphemes:  						int cMorphs = CheckMorphs();  						if (fSkipIconToTextField && iMorph < 0)  							iMorph = 0;  						if (iMorph >= 0 && iMorph < cMorphs)  							SelectAtStartOfMorph(iMorph' m_choices.PreviousOccurrences(ispec));  						else  							SelectIconOfMorph(0' ktagMorphFormIcon);  						return true;  					case InterlinLineChoices.kflidLexEntries:  					case InterlinLineChoices.kflidLexGloss:  					case InterlinLineChoices.kflidLexPos:  						if (ispec != m_choices.FirstLexEntryIndex)  							break;  						// Move to one of the lex entry icons.  						cMorphs = CheckMorphs();  						int iNextMorph = -1;  						if (iMorph >= 0 && iMorph < cMorphs)  							iNextMorph = iMorph;  						else  							iNextMorph = 0;  						IVwSelection selIcon = MakeSelectionIcon(AddMorphInfo(new SelLevInfo[0]' iNextMorph)'  							ktagMorphEntryIcon' !fSkipIconToTextField);  						if (fSkipIconToTextField)  						{  							// try to select the text next to the icon.  							SelectFirstAssociatedText(selIcon);  						}  						return true;  					case InterlinLineChoices.kflidWordGloss:  						if (!fSkipIconToTextField && m_vc.ShowWordGlossIcon && m_choices.PreviousOccurrences(ispec) == 0)  						{  							SelectIcon(ktagWordGlossIcon);  						}  						else if (IsInGlossMode())  						{  							// in gloss mode' we want to select the whole gloss' since the user may want to type over it.  							int glossLength;  							int cpropPrevious;  							GetWordGlossInfo(ispec' out glossLength' out cpropPrevious);  							return MoveSelection(new SelLevInfo[0]' ktagSbWordGloss' cpropPrevious' 0' glossLength);  						}  						else  						{  							SelectAtEndOfWordGloss(ispec);  						}  						return true;  					case InterlinLineChoices.kflidWordPos:  						if (m_choices.PreviousOccurrences(ispec) != 0)  							break;  						selIcon = MakeSelectionIcon(new SelLevInfo[0]'  							ktagWordPosIcon' !fSkipIconToTextField);  						if (fSkipIconToTextField)  						{  							// try to select the text next to the icon.  							SelectFirstAssociatedText(selIcon);  						}  						return true;  				}
Missing Default,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,Handle_AnalysisChosen,The following switch statement is missing a default case: switch (selectedItem.Tag)  			{  				case WfiWordformTags.kClassId:  					fMadeSelection = SelectAtStartOfMorph(0);  					break;  				case WfiGlossTags.kClassId:  					fMadeSelection = SelectAtEndOfWordGloss(-1);  					break;  			}
Missing Default,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.KeyCode)  			{  				case Keys.Up:  					if (e.Alt || IsIconSelected)  					{  						OnOpenCombo();  						e.Handled = true;  						return;  					}  					if (!e.Control && !e.Shift)  					{  						if (HandleUpKey())  							return;  					}  					break;  				case Keys.Down:  					if (e.Alt || IsIconSelected)  					{  						OnOpenCombo();  						e.Handled = true;  						return;  					}  					if (!e.Control && !e.Shift)  					{  						if (HandleDownKey())  							return;  					}  					break;  				case Keys.Space:  					if (IsIconSelected)  					{  						OnOpenCombo();  						e.Handled = true;  						return;  					}  					break;  				case Keys.Tab:  					if (!e.Control && !e.Alt)  					{  						HandleTab(e.Shift);  						// skip base.OnKeyDown' so RootSite will not try to move our cursor  						// to another field in addition to HandleTab causing Tab to advance  						// past the expected icon/field.  						return;  					}  					break;  				case Keys.Enter:  					if (e.Alt)  					{  						OnOpenCombo();  						e.Handled = true;  					}  					else  					{  						OnHandleEnter();  					}  					return;  				case Keys.End:  					if (HandleEndKey(e.Control))  						return;  					break;  				case Keys.Home:  					if (HandleHomeKey(e.Control))  						return;  					break;  				case Keys.Right:  					if (!e.Control && !e.Shift)  					{  						if (HandleRightKey())  							return;  					}  					break;  				case Keys.Left:  					if (!e.Control && !e.Shift)  					{  						if (HandleLeftKey())  							return;  					}  					break;  			}
Missing Default,SIL.FieldWorks.IText,SandboxBase,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,GetHvoForJumpToToolClass,The following switch statement is missing a default case: switch (className)  			{  				case "WfiWordform":  					return CurrentAnalysisTree.Wordform.Hvo;  				case "WfiAnalysis":  					{  						if (clid == WfiAnalysisTags.kClassId)  							return m_hvoAnalysisGuess;  						else if (clid == WfiGlossTags.kClassId)  							return CurrentGuess.OwnerOfClass(WfiAnalysisTags.kClassId).Hvo;  					}  					break;  				case "WfiGloss":  					{  						if (clid == WfiGlossTags.kClassId)  							return m_hvoAnalysisGuess;  					}  					break;  				case "MoForm":  					return GetObjectFromRightClickMorph(ktagSbMorphForm);  				case "LexEntry":  					int result = GetObjectFromRightClickMorph(ktagSbMorphEntry);  					if (result != 0)  						return result;  					return GetMostPromisingEntry();  				case "LexSense":  					return GetObjectFromRightClickMorph(ktagSbMorphGloss);  				case "PartOfSpeech":  					hvoMsa = GetObjectFromRightClickMorph(ktagSbMorphPos);  					if (hvoMsa == 0)  						return 0;  					// TODO: We really want the guid' and it's usually just as accessible as  					// the hvo' so methods like have been migrating to returning the guid.  					// This method should do likewise...  					using (CmObjectUi ui = CmObjectUi.MakeUi(m_caches.MainCache' hvoMsa))  					{  						ui.Mediator = Mediator;  						ui.PropTable = m_propertyTable;  						Guid guid = ui.GuidForJumping(null);  						if (guid == Guid.Empty)  							return 0;  						else  							return Cache.ServiceLocator.GetObject(guid).Hvo;  					}  				//LT-12195 Change Show Concordance of Category right click menu item for Lex Gram. Info. line of Interlinear.  				case "PartOfSpeechGramInfo":  					hvoMsa = GetObjectFromRightClickMorph(ktagSbMorphPos);  					return hvoMsa;  				case "WordPartOfSpeech":  					hvoMsa = GetObjectFromRightClickMorph(ktagSbWordPos);  					if (hvoMsa != 0)  						return hvoMsa;  					IWfiAnalysis realAnalysis = null;  					if (clid == WfiAnalysisTags.kClassId)  						realAnalysis = CurrentGuess as IWfiAnalysis;  					else if (clid == WfiGlossTags.kClassId)  						realAnalysis = CurrentGuess.OwnerOfClass(WfiAnalysisTags.kClassId) as IWfiAnalysis;  					if (realAnalysis != null && realAnalysis.CategoryRA != null)  						// JohnT: not sure it CAN be null' but play safe.  						return realAnalysis.CategoryRA.Hvo;  					break;  			}
Missing Default,SIL.FieldWorks.IText,IhSbWordForm,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,HandleSelect,The following switch statement is missing a default case: switch (index)  				{  					case 0: // Accept entire analysis  						// Todo: figure how to implement.  						break;  					case 1: // Edit this wordform.  						// Allows direct editing.  						ComboList.DropDownStyle = ComboBoxStyle.DropDown;  						// restore the combo to visibility so we can do the editing.  						m_sandbox.ShowCombo();  						break;  					case 2: // Delete this wordform.  						// Todo: figure implementation  						//					int ihvoTwfic = m_rgvsli[m_iRoot].ihvo;  						//					int [] itemsToInsert = new int[0];  						//					m_cache.ReplaceReferenceProperty(m_hvoSbWord'  						//						StTxtParaTags.kflidAnalyzedTextObjects'  						//						ihvoTwfic' ihvoTwfic + 1' ref itemsToInsert);  						// Enhance JohnT: consider removing the WfiWordform' if there are no  						// analyses and no other references.  						// Comment: RandyR: Please don't delete it.  						break;  				}
Missing Default,SIL.FieldWorks.IText,IhMorphForm,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SetupCombo,The following switch statement is missing a default case: switch (m_sandbox.CaseStatus)  				{  					case StringCaseStatus.allLower:  						break; // no more to add  					case StringCaseStatus.title:  						AddOtherCase(cf.SwitchTitleAndLower(form));  						break;  					case StringCaseStatus.mixed:  						switch (cf.StringCase(form))  						{  							case StringCaseStatus.allLower:  								AddOtherCase(cf.ToTitle(form));  								AddOtherCase(m_sandbox.RawWordform.Text);  								break;  							case StringCaseStatus.title:  								AddOtherCase(cf.ToLower(form));  								AddOtherCase(m_sandbox.RawWordform.Text);  								break;  							case StringCaseStatus.mixed:  								AddOtherCase(cf.ToLower(form));  								AddOtherCase(cf.ToTitle(form));  								break;  						}  						break;  				}
Missing Default,SIL.FieldWorks.IText,IhMorphForm,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.ComboHandlers.cs,SetupCombo,The following switch statement is missing a default case: switch (cf.StringCase(form))  						{  							case StringCaseStatus.allLower:  								AddOtherCase(cf.ToTitle(form));  								AddOtherCase(m_sandbox.RawWordform.Text);  								break;  							case StringCaseStatus.title:  								AddOtherCase(cf.ToLower(form));  								AddOtherCase(m_sandbox.RawWordform.Text);  								break;  							case StringCaseStatus.mixed:  								AddOtherCase(cf.ToLower(form));  								AddOtherCase(cf.ToTitle(form));  								break;  						}
Missing Default,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,Display,The following switch statement is missing a default case: switch (spec.Flid)  								{  									case InterlinLineChoices.kflidWord:  										int ws = GetActualWs(hvo' spec.StringFlid' spec.WritingSystem);  										DisplayWordform(vwenv' ws' ispec);  										break;  									case InterlinLineChoices.kflidWordGloss:  										DisplayWordGloss(vwenv' hvo' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidWordPos:  										DisplayWordPOS(vwenv' hvo' spec.WritingSystem' ispec);  										break;  								}
Missing Default,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,Display,The following switch statement is missing a default case: switch (spec.Flid)  								{  									case InterlinLineChoices.kflidMorphemes:  										DisplayMorphForm(vwenv' hvo' frag' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidLexEntries:  										AddOptionalNamedObj(vwenv' hvo' ktagSbMorphEntry' ktagMissingEntry'  											kfragMissingEntry' tagLexEntryIcon' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidLexGloss:  										AddOptionalNamedObj(vwenv' hvo' ktagSbMorphGloss' ktagMissingMorphGloss'  											kfragMissingMorphGloss' tagLexEntryIcon' spec.WritingSystem' ispec);  										break;  									case InterlinLineChoices.kflidLexPos:  										AddOptionalNamedObj(vwenv' hvo' ktagSbMorphPos' ktagMissingMorphPos'  											kfragMissingMorphPos' tagLexEntryIcon' spec.WritingSystem' ispec);  										break;  								}
Missing Default,SIL.FieldWorks.IText,SandboxVc,C:\repos\sillsdev_FieldWorks\Src\LexText\Interlinear\SandboxBase.SandboxVc.cs,DisplayVec,The following switch statement is missing a default case: switch (frag)  				{  					case kfragMorph: // The bundle of 4 lines representing a morpheme.  						ISilDataAccess sda = vwenv.DataAccess;  						int cmorph = sda.get_VecSize(hvo' tag);  						for (int i = 0; i < cmorph; ++i)  						{  							int hvoMorph = sda.get_VecItem(hvo' tag' i);  							vwenv.AddObj(hvoMorph' this' i == 0 ? kfragFirstMorph : kfragMorph);  						}  						break;  				}
