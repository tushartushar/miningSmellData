Implementation smell,Namespace,Class,File,Method,Description
Long Statement,LexEdDllTests,FlexBridgeListenerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\FlexBridgeListenerTests.cs,ConvertFlexNotesToLift_ConvertsRefs,The length of the statement  "		ref='silfw://localhost/link?app=flex&amp;database=current&amp;server=&amp;tool=default&amp;guid=6b466f54-f88a-42f6-b770-aca8fee5734c&amp;tag=&amp;id=6b466f54-f88a-42f6-b770-aca8fee5734c&amp;label=bother' " is 203.
Long Statement,LexEdDllTests,FlexBridgeListenerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\FlexBridgeListenerTests.cs,ConvertLiftNotesToFlex_ConvertsRefs,The length of the statement  "		ref='silfw://localhost/link?app=flex&amp;database=current&amp;server=&amp;tool=default&amp;guid=6b466f54-f88a-42f6-b770-aca8fee5734c&amp;tag=&amp;id=6b466f54-f88a-42f6-b770-aca8fee5734c&amp;label=bother' " is 203.
Long Statement,LexEdDllTests,LexEntryChangeHandlerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\LexEntryChangeHandlerTests.cs,FixupKeepDanglingLexEntryRefsWhenComplexEntryTypeExists,The length of the statement  "			Assert.AreEqual(1' complexEntryTypes.Count' "The remaining typeless ref should have been given Unspecified Complex Form Type"); " is 127.
Long Statement,LexEdDllTests,LexEntryChangeHandlerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\LexEntryChangeHandlerTests.cs,FixupKeepDanglingLexEntryRefsWhenComplexEntryTypeExists,The length of the statement  "			Assert.AreEqual(1' complexEntryTypes.Count' "The remaining componentless ref should still point to a Complex Entry Type"); " is 122.
Long Statement,LexEdDllTests,LexEntryChangeHandlerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\LexEntryChangeHandlerTests.cs,FixupKeepDanglingLexEntryRefsWhenComplexEntryTypeExists,The length of the statement  "			Assert.AreEqual(t' complexEntryTypes.First()' "The remaining componentles ref should still point to the same Complex Entry Type"); " is 130.
Long Statement,LexEdDllTests,ReversalEntryViewTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\ReversalEntryViewTests.cs,DummyReversalCreatedOnFocusLost,The length of the statement  "			// Creating the reversal index before the slice is fully initialized ensures the reversal index gets loaded into the dummy cache " is 128.
Long Statement,LexEdDllTests,ReversalEntryViewTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\ReversalEntryViewTests.cs,DummyReversalCreatedOnFocusLost,The length of the statement  "			// The reversal index entry control must maintain a dummy entry at the end to allow a place to click to add new entries. " is 120.
Long Statement,LexEdDllTests,CircularRefBreakerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\CircularRefBreakerTests.cs,BreakCircularEntryRefs,The length of the statement  "			Assert.DoesNotThrow(() => breaker.Process(Cache)' "The BreakCircularRefs.Process(cache) method does not throw an exception"); " is 125.
Long Statement,LexEdDllTests,CircularRefBreakerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\CircularRefBreakerTests.cs,BreakCircularEntryRefs,The length of the statement  "			Assert.DoesNotThrow(() => breaker.Process(Cache)' "The BreakCircularRefs.Process(cache) method still does not throw an exception"); " is 131.
Magic Number,LexEdDllTests,LexEntryChangeHandlerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\LexEntryChangeHandlerTests.cs,FixupKeepDanglingLexEntryRefsWhenComplexEntryTypeExists,The following statement contains a magic number: var t = Cache.LangProject.LexDbOA.ComplexEntryTypesOA.PossibilitiesOS.Cast<ILexEntryType>().ElementAt(2);
Magic Number,LexEdDllTests,LexEntryChangeHandlerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\LexEntryChangeHandlerTests.cs,FixupKeepDanglingLexEntryRefsWhenComplexEntryTypeExists,The following statement contains a magic number: Assert.AreEqual(2' remainingRefs.Count' "Dangling References should be removed");
Magic Number,LexEdDllTests,LexReferenceTreeRootLauncherTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\LexReferenceTreeRootLauncherTests.cs,SettingTargetToReplaceWholeInRelationWithOnlyOnePartDoesNotDeleteRelation,The following statement contains a magic number: UndoableUnitOfWorkHelper.Do("undo"' "redo"' m_actionHandler'  				() =>  				{    					// Set up a part-whole type lexical relation and two lexical entries indicating that "nose" is a part of "face".  					var lrt = Cache.ServiceLocator.GetInstance<ILexRefTypeFactory>().Create();  					if (Cache.LangProject.LexDbOA.ReferencesOA == null)  					{  						// default state of cache may not have the PL we need to own our lexical relation type...if not create it.  						Cache.LangProject.LexDbOA.ReferencesOA =  							Cache.ServiceLocator.GetInstance<ICmPossibilityListFactory>().Create();  					}  					Cache.LangProject.LexDbOA.ReferencesOA.PossibilitiesOS.Add(lrt);  					lrt.MappingType = (int)LexRefTypeTags.MappingTypes.kmtSenseAsymmetricPair; // e.g.' part/whole    					var face = MakeEntry("face"' "front of head");  					var nose = MakeEntry("nose"' "pointy bit on front");  					var rel = Cache.ServiceLocator.GetInstance<ILexReferenceFactory>().Create();  					lrt.MembersOC.Add(rel);  					rel.TargetsRS.Add(face);  					rel.TargetsRS.Add(nose);    					// Here is an alternative 'whole' to be the root that 'nose' belongs to.  					var head = MakeEntry("head"' "thing on top of body");    					// Now we want to configure the Lrtrl so that setting its target to 'head' will replace 'face' with 'head'.  					lrtrl.SetObject(rel);  					lrtrl.Child = nose; // the part for which we are changing the whole    					// This is the operation we want to test  					lrtrl.SetTarget(head);  					Assert.That(rel.IsValidObject);  					Assert.That(rel.TargetsRS' Has.Count.EqualTo(2));  					Assert.That(rel.TargetsRS[0]' Is.EqualTo(head));  					Assert.That(rel.TargetsRS[1]' Is.EqualTo(nose));  				});
Magic Number,LexEdDllTests,ReversalEntryViewTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\ReversalEntryViewTests.cs,DummyReversalCreatedOnFocusLost,The following statement contains a magic number: Assert.AreEqual(2' reversalView.GetIndexSize(ri.Hvo));
Magic Number,LexEdDllTests,ReversalEntryViewTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\ReversalEntryViewTests.cs,DummyReversalCreatedOnFocusLost,The following statement contains a magic number: Assert.AreEqual(2' reversalView.GetIndexSize(ri.Hvo));
Magic Number,LexEdDllTests,CircularRefBreakerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\CircularRefBreakerTests.cs,BreakCircularEntryRefs,The following statement contains a magic number: Assert.AreEqual(6' breaker.Count' "There should have been 6 LexEntryRef objects to process for this test");
Magic Number,LexEdDllTests,CircularRefBreakerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\CircularRefBreakerTests.cs,BreakCircularEntryRefs,The following statement contains a magic number: Assert.AreEqual(5' breaker.Circular' "There should have been 5 circular references fixed");
Magic Number,LexEdDllTests,CircularRefBreakerTests,D:\research\architectureSmells\repos1\sillsdev_FieldWorks\Src\LexText\Lexicon\LexEdDllTests\CircularRefBreakerTests.cs,BreakCircularEntryRefs,The following statement contains a magic number: Assert.AreEqual(3' breaker.Count' "There should have been 3 LexEntryRef objects to process for this test");
