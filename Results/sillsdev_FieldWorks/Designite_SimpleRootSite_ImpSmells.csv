Implementation smell,Namespace,Class,File,Method,Description
Long Method,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,RemoveRedundantHardFormatting,The method has 196 lines of code.
Long Method,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,MakeSelectionVisible,The method has 245 lines of code.
Long Method,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,GetExternalLinkSel,The method has 114 lines of code.
Long Method,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,ModifyOverlay,The method has 109 lines of code.
Complex Method,SIL.FieldWorks.Common.RootSites,RenderEngineFactory,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\RenderEngineFactory.cs,get_Renderer,Cyclomatic complexity of the method is 10
Complex Method,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,CollectTypedInput,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,RemoveCharFormatting,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,RemoveRedundantHardFormatting,Cyclomatic complexity of the method is 14
Complex Method,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,Dispose,Cyclomatic complexity of the method is 14
Complex Method,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,UpdateScrollRange,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,GetExternalLinkSel,Cyclomatic complexity of the method is 13
Complex Method,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,ModifyOverlay,Cyclomatic complexity of the method is 8
Long Parameter List,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,GetParagraphProps,The method has 7 parameters. Parameters: vwsel' hvoText' flidParaOwner' vqvps' ihvoFirst' ihvoLast' vqttp
Long Parameter List,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,GetAllParagraphProps,The method has 10 parameters. Parameters: vwsel' hvoText' tagText' vttp' vvps' ihvoFirst' ihvoLast' vttpHard' vvpsSoft' fRet
Long Parameter List,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,IsParagraphProps,The method has 6 parameters. Parameters: vwsel' hvoText' tagText' vqvps' ihvoAnchor' ihvoEnd
Long Parameter List,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,GetParagraphLevelInfoForSelection,The method has 5 parameters. Parameters: vwsel' fEnd' hvoText' tagText' ihvo
Long Parameter List,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,NarrowRangeOfTsTxtProps,The method has 9 parameters. Parameters: hvoText' tagText' vttp' vvpsSoft' fParagraphStyle' ihvoFirst' ihvoLast' ihvoFirstMod' ihvoLastMod
Long Parameter List,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,RemoveRedundantHardFormatting,The method has 5 parameters. Parameters: vpsSoft' ttpHard' fParaStyle' hvoPara' ttpRet
Long Parameter List,SIL.FieldWorks.Common.RootSites,OrientationManager,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\OrientationManager.cs,DrawTheRoot,The method has 7 parameters. Parameters: vdrb' rootb' hdc' drawRect' backColor' drawSel' clipRect
Long Parameter List,SIL.FieldWorks.Common.RootSites,VerticalOrientationManager,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\OrientationManager.cs,DrawTheRoot,The method has 7 parameters. Parameters: vdrb' rootb' hdc' drawRect' backColor' drawSel' clipRect
Long Parameter List,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,PrintRootSite,The method has 5 parameters. Parameters: sda' hvo' vc' frags' styleSheet
Long Parameter List,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,RequestSelectionAtEndOfUow,The method has 10 parameters. Parameters: _rootb' ihvoRoot' cvlsi' rgvsli' tagTextProp' cpropPrevious' ich' wsAlt' fAssocPrev' selProps
Long Parameter List,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,AdjustScrollRange,The method has 5 parameters. Parameters: prootb' dxdSize' dxdPosition' dydSize' dydPosition
Long Parameter List,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,InvalidateRect,The method has 5 parameters. Parameters: root' xdLeft' ydTop' xdWidth' ydHeight
Long Parameter List,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,OnInsertDiffParas,The method has 6 parameters. Parameters: prootb' ttpDest' cPara' ttpSrc' tssParas' tssTrailing
Long Parameter List,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,OnInsertDiffPara,The method has 5 parameters. Parameters: prootb' ttpDest' ttpSrc' tssParas' tssTrailing
Long Parameter List,SIL.FieldWorks.Common.RootSites,SelectionHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SelectionHelper.cs,InsertLevel,The method has 5 parameters. Parameters: iLev' tag' ihvo' ws' type
Long Parameter List,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,RequestSelectionAtEndOfUow,The method has 10 parameters. Parameters: rootb' ihvoRoot' cvlsi' rgvsli' tagTextProp' cpropPrevious' ich' wsAlt' fAssocPrev' selProps
Long Parameter List,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,AdjustScrollRange,The method has 5 parameters. Parameters: prootb' dxdSize' dxdPosition' dydSize' dydPosition
Long Parameter List,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,InvalidateRect,The method has 5 parameters. Parameters: root' xsLeft' ysTop' xsWidth' ysHeight
Long Parameter List,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnInsertDiffParas,The method has 6 parameters. Parameters: prootb' ttpDest' cPara' ttpSrc' tssParas' tssTrailing
Long Parameter List,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnInsertDiffPara,The method has 5 parameters. Parameters: prootb' ttpDest' ttpSrc' tssParas' tssTrailing
Long Parameter List,SIL.FieldWorks.Common.RootSites,VwBaseVc,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\VwBaseVc.cs,DisplayPicture,The method has 5 parameters. Parameters: vwenv' hvo' tag' val' frag
Long Parameter List,SIL.FieldWorks.Common.RootSites,VwBaseVc,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\VwBaseVc.cs,LoadDataFor,The method has 7 parameters. Parameters: vwenv' rghvo' chvo' hvoParent' tag' frag' ihvoMin
Long Parameter List,SIL.FieldWorks.Common.RootSites,VwBaseVc,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\VwBaseVc.cs,UpdateProp,The method has 5 parameters. Parameters: vwsel' hvo' tag' frag' tssVal
Long Identifier,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,,The length of the parameter m_fSuppressNextWritingSystemHvoChanged is 38.
Long Identifier,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,,The length of the parameter m_fSuppressNextBestStyleNameChanged is 35.
Long Identifier,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,,The length of the parameter m_haveCachedDrawForDisabledView is 31.
Long Identifier,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,,The length of the parameter m_fMakeRootWhenHandleIsCreated is 30.
Long Statement,SIL.FieldWorks.Common.RootSites,ActiveViewHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\ActiveViewHelper.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + " ******************"); " is 121.
Long Statement,SIL.FieldWorks.Common.RootSites,DataUpdateMonitor,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\DataUpdateMonitor.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + " ******************"); " is 121.
Long Statement,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + " ******************"); " is 121.
Long Statement,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,IsIgnoredKey,The length of the statement  "			// Ignore control characters (most can only be generated using control key' see above; but Escape otherwise gets through...) " is 124.
Long Statement,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,LostFocus,The length of the statement  "			//Debug.WriteLine(string.Format("EditingHelper.LostFocus:\n\t\t\tlost: {3} ({4})' Name={5}\n\t\t\tnew: {0} ({1})' Name={2}"' " is 124.
Long Statement,SIL.FieldWorks.Common.RootSites,SelectionHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SelectionHelper.cs,MakeRangeSelection,The length of the statement  "			// Don't make a selection if the property indicates not to: see comment about -2 in InterlinDocForAnalysis.HandleSelectionChange " is 128.
Long Statement,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + " ******************"); " is 121.
Long Statement,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,CheckDisposed,The length of the statement  "				throw new ObjectDisposedException(ToString()' "This object is being used after it has been disposed: this is an Error."); " is 121.
Long Statement,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,MakeSelectionVisible,The length of the statement  "							if (rcIdeal.Top < ydTop + extraSpacing || rcIdeal.Height > ydBottom - ydTop - extraSpacing * 2 || rcIdeal.Top > ydBottom) " is 121.
Long Statement,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnSetFocus,The length of the statement  "				//Debug.WriteLine(string.Format("SimpleRootSite.OnSetFocus:\n\t\t\tlost {0} ({1})' Name={2}\n\t\t\tnew {3} ({4})' Name={5}"' " is 124.
Long Statement,SIL.FieldWorks.Common.RootSites,SuspendDrawing,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,Dispose,The length of the statement  "			Debug.WriteLineIf(!disposing' "****************** Missing Dispose() call for " + GetType().Name + " ******************"); " is 121.
Long Statement,SIL.FieldWorks.Common.RootSites,SuspendDrawing,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,CheckDisposed,The length of the statement  "				throw new ObjectDisposedException("SuspendDrawing"' "This object is being used after it has been disposed: this is an Error."); " is 127.
Long Statement,SIL.FieldWorks.Common.RootSites,HoldGraphics,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\HoldGraphics.cs,CheckDisposed,The length of the statement  "				throw new ObjectDisposedException("HoldGraphics"' "This object is being used after it has been disposed: this is an Error."); " is 125.
Long Statement,SIL.FieldWorks.Common.RootSites,VwBaseVc,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\VwBaseVc.cs,DoHotLinkAction,The length of the statement  "				// We also need to deal with url's like the following ( http:// silfw:// http:\ silfw:\ which are considered Not rooted). " is 121.
Complex Conditional,SIL.FieldWorks.Common.RootSites,SelectionRestorer,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SelectionRestorer.cs,Dispose,The conditional expression  "!fDisposing || IsDisposed || m_savedSelection == null || m_rootSite.RootBox.Height <= 0"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,HandleKeyDown,The conditional expression  "MiscUtils.IsUnix && (e.KeyCode == Keys.Right || e.KeyCode == Keys.Left ||  				  e.KeyCode == Keys.F7 || e.KeyCode == Keys.F8) && ss == VwShiftStatus.kfssNone"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,GetCursor,The conditional expression  "fInObject && (objDataType == FwObjDataTypes.kodtNameGuidHot  				|| objDataType == FwObjDataTypes.kodtExternalPathName  				|| objDataType == FwObjDataTypes.kodtOwnNameGuidHot  				|| objDataType == FwObjDataTypes.kodtPictEvenHot  				|| objDataType == FwObjDataTypes.kodtPictOddHot)"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,SetWritingSystemPropertyFromSelection,The conditional expression  "rs != null && rs.Mediator != null && rs.PropTable != null && selection != null"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,BestStyleNameChanged,The conditional expression  "(styleName == String.Empty && charStyleName != String.Empty) ||  				(paraStyleName != styleName && charStyleName != styleName)"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,DeleteSelection,The conditional expression  "m_control == null || m_callbacks == null || m_callbacks.EditedRootBox == null ||  				!m_callbacks.GotCacheOrWs"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,IsSelectionInOneEditableProp,The conditional expression  "hvoObjE != hvoObjA || tagE != tagA || ihvoE != ihvoA || cPropPreviousA != cPropPreviousE"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,PasteClipboard,The conditional expression  "!CanPaste() || Callbacks == null || Callbacks.EditedRootBox == null ||  				!Callbacks.GotCacheOrWs  || CurrentSelection == null"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,CanCut,The conditional expression  "Callbacks != null && Callbacks.GotCacheOrWs && Callbacks.EditedRootBox != null && m_fEditable"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,CanPaste,The conditional expression  "m_callbacks != null && m_callbacks.EditedRootBox != null && m_fEditable &&  				CurrentSelection != null && m_control != null && m_control.Visible"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,SelectAll,The conditional expression  "m_callbacks == null || m_callbacks.EditedRootBox == null ||  				!m_callbacks.GotCacheOrWs || m_control == null"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,SelectionRectangle,The conditional expression  "(AutoScroll && VScroll && rcIdeal.Height > ClientHeight) ||  					(DoAutoHScroll && rcIdeal.Width > ClientRectangle.Width)"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnVisibleChanged,The conditional expression  "Visible && m_fRootboxMade && m_rootb != null && m_fRefreshPending"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,CheckForRecursivePaint,The conditional expression  "m_fInPaint || m_fInLayout || m_rootb != null && m_rootb.IsPropChangedInProgress"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnLayout,The conditional expression  "(!DesignMode || AllowPaintingInDesigner) && m_fRootboxMade && m_fAllowLayout &&  				IsHandleCreated && !m_fInLayout"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnMouseDown,The conditional expression  "pt.X >= rcPrimary.left && pt.X < rcPrimary.right  							&& pt.Y >= rcPrimary.top && pt.Y < rcPrimary.bottom"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnSizeChanged,The conditional expression  "m_fInPaint || m_fInLayout || m_rootb == null || (Size == m_sizeLast && m_dxdLayoutWidth >= 0)"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnSizeChanged,The conditional expression  "ScrollToSelectionOnSizeChanged &&  				!SizeChangedSuppression &&  				!m_fRefreshPending &&  				IsHandleCreated"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,Draw,The conditional expression  "m_rootb != null && m_dxdLayoutWidth > 0 &&  				(!DesignMode || AllowPaintingInDesigner)"  is complex.
Complex Conditional,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,GetNonFocusedSelectionState,The conditional expression  "(m_fIsTextBox || windowGainingFocus == null || windowGainingFocus is SimpleRootSite ||  				ParentForm == null || !ParentForm.Contains(windowGainingFocus)) &&  				!ShowRangeSelAfterLostFocus"  is complex.
Virtual Method Call from Constructor,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,SimpleRootSite,The constructor "SimpleRootSite" calls a virtual method "CreateGraphicsManager".
Virtual Method Call from Constructor,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,SimpleRootSite,The constructor "SimpleRootSite" calls a virtual method "CreateOrientationManager".
Empty Catch Block,SIL.FieldWorks.Common.RootSites,SelectionRestorer,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SelectionRestorer.cs,SelectionRestorer,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.RootSites,SelectionRestorer,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SelectionRestorer.cs,Dispose,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.RootSites,SelectionRestorer,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SelectionRestorer.cs,RestoreSelectionWhenReadOnly,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,SetCursor,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.RootSites,SelectionHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SelectionHelper.cs,UpdateScrollLocation,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,EnsureDefaultSelection,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnLoad,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnMouseDown,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnRightMouseUp,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,CallMouseDown,The method has an empty catch block.
Magic Number,SIL.FieldWorks.Common.RootSites,SelectionRestorer,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SelectionRestorer.cs,SelectionRestorer,The following statement contains a magic number: try  			{  				IVwSelection sel = rootSite.RootBox.MakeSelAt(5' 5' rcSrc' rcDst' false);  				m_topOfViewSelection = SelectionHelper.Create(sel' rootSite);  			}  			catch (COMException)  			{  				// Just ignore any errors  			}
Magic Number,SIL.FieldWorks.Common.RootSites,SelectionRestorer,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SelectionRestorer.cs,SelectionRestorer,The following statement contains a magic number: try  			{  				IVwSelection sel = rootSite.RootBox.MakeSelAt(5' 5' rcSrc' rcDst' false);  				m_topOfViewSelection = SelectionHelper.Create(sel' rootSite);  			}  			catch (COMException)  			{  				// Just ignore any errors  			}
Magic Number,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,CollectTypedInput,The following statement contains a magic number: while (true)  			{  				if (Win32.PeekMessage(ref msg' Control.Handle' (uint)Win32.WinMsgs.WM_KEYDOWN'  					(uint)Win32.WinMsgs.WM_KEYUP' (uint)Win32.PeekFlags.PM_NOREMOVE))  				{  					// If the key is the delete key' then process it normally because some  					// applications may use the DEL as a menu hotkey' which by this time has  					// already processed the keydown message. When that happens' the only  					// time we would get here for a DEL key is because we found the WM_KEYUP  					// message in the queue. In that case' TranslateMessage fails because  					// it only works when both the down and up are translated. The worst that  					// should happen with this special DEL key processing is that we don't  					// collect the delete keys and they happen one at a time.  					if ((int)msg.wParam == (int)Keys.Delete)  						break;    					// Now that we know we're going to translate the message' we need to  					// make sure it's removed from the message queue.  					Win32.PeekMessage(ref msg' Control.Handle' (uint)Win32.WinMsgs.WM_KEYDOWN'  						(uint)Win32.WinMsgs.WM_KEYUP' (uint)Win32.PeekFlags.PM_REMOVE);    					Win32.TranslateMessage(ref msg);  				}  				else if (Win32.PeekMessage(ref msg' Control.Handle' (uint)Win32.WinMsgs.WM_CHAR'  					(uint)Win32.WinMsgs.WM_CHAR' (uint)Win32.PeekFlags.PM_NOREMOVE))  				{  					char nextChar = (char)msg.wParam;  					if (!KeepCollectingInput(nextChar))  						break;    					// Since the previous peek didn't remove the message and by this point  					// we know we want to handle the message ourselves' we need to remove  					// the keypress from the message queue.  					Win32.PeekMessage(ref msg' Control.Handle' (uint)Win32.WinMsgs.WM_CHAR'  						(uint)Win32.WinMsgs.WM_CHAR' (uint)Win32.PeekFlags.PM_REMOVE);    					switch ((int)nextChar)  					{  						case (int)VwSpecialChars.kscBackspace:  							// handle backspace characters.  If there are are characters in  							// the buffer then remove the last one.  If not' then count  							// the backspace so it will be processed later.  							if (buffer.Length > 0)  							{  								if (buffer[0] == 8 || buffer[0] == 0x7f)  									throw new InvalidOperationException(  										"KeepCollectingInput should not allow more than one backspace");  								buffer.Remove(buffer.Length - 1' 1);  							}  							else  								buffer.Append(nextChar);  							return; // only one backspace currently allowed (except canceling earlier data)    						case (int)VwSpecialChars.kscDelForward:  						case '\r':  							if (buffer.Length > 0)  							{  								throw new InvalidOperationException(  									"KeepCollectingInput should not allow more than one delete or return");  							}  							buffer.Append(nextChar);  							return; // only one del currently allowed.  						default:  							// regular characters get added to the buffer  							buffer.Append(nextChar);  							break;  					}  				}  				else  					break;  			}
Magic Number,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,HandleKeyDown,The following statement contains a magic number: if (MiscUtils.IsUnix && (e.KeyCode == Keys.Right || e.KeyCode == Keys.Left ||  				  e.KeyCode == Keys.F7 || e.KeyCode == Keys.F8) && ss == VwShiftStatus.kfssNone)  			{  				// FWNX-456 fix for refreshing lines that cursor is not properly invalidating  				if(Control is SimpleRootSite)  				{  					Point ip = (Control as SimpleRootSite).IPLocation;  					Rect src' dst;  					(Control as SimpleRootSite).GetTransformAtDst(rootb' ip' out src' out dst);  					const int IPWidth = 2;  					const int LineHeightFudgeFactor = 3;  					Rectangle rect = new Rectangle(ip.X - dst.left' -dst.top' IPWidth'  						(Control as SimpleRootSite).LineHeight + LineHeightFudgeFactor);  					(Control as SimpleRootSite).InvalidateRect(rootb' rect.Left' rect.Top' rect.Width' rect.Height);  				}  			}
Magic Number,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,HandleKeyDown,The following statement contains a magic number: if (MiscUtils.IsUnix && (e.KeyCode == Keys.Right || e.KeyCode == Keys.Left ||  				  e.KeyCode == Keys.F7 || e.KeyCode == Keys.F8) && ss == VwShiftStatus.kfssNone)  			{  				// FWNX-456 fix for refreshing lines that cursor is not properly invalidating  				if(Control is SimpleRootSite)  				{  					Point ip = (Control as SimpleRootSite).IPLocation;  					Rect src' dst;  					(Control as SimpleRootSite).GetTransformAtDst(rootb' ip' out src' out dst);  					const int IPWidth = 2;  					const int LineHeightFudgeFactor = 3;  					Rectangle rect = new Rectangle(ip.X - dst.left' -dst.top' IPWidth'  						(Control as SimpleRootSite).LineHeight + LineHeightFudgeFactor);  					(Control as SimpleRootSite).InvalidateRect(rootb' rect.Left' rect.Top' rect.Width' rect.Height);  				}  			}
Magic Number,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,GetFontForNormalStyle,The following statement contains a magic number: return new Font(bldr.ToString()' (float)(dympHeight / 1000.0));
Magic Number,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,GetParagraphLevelInfoForSelection,The following statement contains a magic number: if (clev < 2)  				return false;
Magic Number,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,RemoveRedundantHardFormatting,The following statement contains a magic number: for (int itpt = 0; itpt < ctpt; itpt++)  			{  				int tpt;  				int nVarHard' nValHard;  				nValHard = ttpHard.GetIntProp(itpt' out tpt' out nVarHard);    				int nValSoft' nVarSoft;  				int nWeight' nRelHeight;  				switch ((FwTextPropType)tpt)  				{  				case FwTextPropType.ktptLineHeight:  					nValSoft = vpsSoft.get_IntProperty(tpt);  					nRelHeight = vpsSoft.get_IntProperty((int)VwStyleProperty.kspRelLineHeight);  					if (nRelHeight != 0)  					{  						nVarSoft = (int)FwTextPropVar.ktpvRelative;  						nValSoft = nRelHeight;  					}  						// By default' we have no min spacing; interpret this as single-space.  					else if (nValSoft == 0)  					{  						nVarSoft = (int)FwTextPropVar.ktpvRelative;  						nValSoft = (int)FwTextPropConstants.kdenTextPropRel;  					}  						// Otherwise interpret as absolute. Use the value we already.  					else  						nVarSoft = (int)FwTextPropVar.ktpvMilliPoint;  					break;  				case FwTextPropType.ktptBold:  					// For an inverting property' a value of invert is never redundant.  					if (nValHard == (int)FwTextToggleVal.kttvInvert)  						continue;  					nWeight = vpsSoft.get_IntProperty(tpt);  					nValSoft = (nWeight > 550) ? (int)FwTextToggleVal.kttvInvert :  						(int)FwTextToggleVal.kttvOff;  					nVarSoft = (int)FwTextPropVar.ktpvEnum;  					break;  				case FwTextPropType.ktptItalic:  					// For an inverting property' a value of invert is never redundant.  					if (nValHard == (int)FwTextToggleVal.kttvInvert)  						continue;  					nValSoft = vpsSoft.get_IntProperty(tpt);  					nVarSoft = (int)FwTextPropVar.ktpvEnum;  					break;  				case FwTextPropType.ktptUnderline:  				case FwTextPropType.ktptSuperscript:  				case FwTextPropType.ktptRightToLeft:  				case FwTextPropType.ktptKeepWithNext:  				case FwTextPropType.ktptKeepTogether:  				case FwTextPropType.ktptWidowOrphanControl:  				case FwTextPropType.ktptAlign:  				case FwTextPropType.ktptBulNumScheme:  					nValSoft = vpsSoft.get_IntProperty(tpt);  					nVarSoft = (int)FwTextPropVar.ktpvEnum;  					break;  				case FwTextPropType.ktptFontSize:  				case FwTextPropType.ktptOffset:  				case FwTextPropType.ktptLeadingIndent:		// == ktptMarginLeading  				case FwTextPropType.ktptTrailingIndent:	// == ktptMarginTrailing  				case FwTextPropType.ktptFirstIndent:  				case FwTextPropType.ktptSpaceBefore:		// == ktptMswMarginTop  				case FwTextPropType.ktptSpaceAfter:		// == ktptMarginBottom  				case FwTextPropType.ktptBorderTop:  				case FwTextPropType.ktptBorderBottom:  				case FwTextPropType.ktptBorderLeading:  				case FwTextPropType.ktptBorderTrailing:  				case FwTextPropType.ktptMarginTop:  				case FwTextPropType.ktptPadTop:  				case FwTextPropType.ktptPadBottom:  				case FwTextPropType.ktptPadLeading:  				case FwTextPropType.ktptPadTrailing:  					nValSoft = vpsSoft.get_IntProperty(tpt);  					nVarSoft = (int)FwTextPropVar.ktpvMilliPoint;  					break;  				case FwTextPropType.ktptForeColor:  				case FwTextPropType.ktptBackColor:  				case FwTextPropType.ktptUnderColor:  				case FwTextPropType.ktptBorderColor:  				case FwTextPropType.ktptBulNumStartAt:  					nValSoft = vpsSoft.get_IntProperty(tpt);  					nVarSoft = (int)FwTextPropVar.ktpvDefault;  					break;  				default:  					// Ignore.  					continue;  				}    				if (nValHard == nValSoft && nVarHard == nVarSoft)  				{  					// Clear.  					if (tpb == null)  						tpb = ttpHard.GetBldr();  					tpb.SetIntPropValues(tpt' -1' -1);  				}  			}
Magic Number,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,Init,The following statement contains a magic number: if (MiscUtils.IsUnix)  				dpix = 72;  			else  				dpix = (int)e.Graphics.DpiX;
Magic Number,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,Init,The following statement contains a magic number: m_vwPrintContext.SetPagePrintInfo(1' 1' 65535' 1' false);
Magic Number,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,PixelsFrom100ths,The following statement contains a magic number: return val * dpi / 100;
Magic Number,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,SetMargins,The following statement contains a magic number: if (MiscUtils.IsUnix)  			{  				dpiX = 72;  				dpiY = 72;  				if (landscape)  					page = new Rectangle(e.PageBounds.Y' e.PageBounds.X' e.PageBounds.Height' e.PageBounds.Width);  				relative = page;  			}  			else  				relative = printable;
Magic Number,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,SetMargins,The following statement contains a magic number: if (MiscUtils.IsUnix)  			{  				dpiX = 72;  				dpiY = 72;  				if (landscape)  					page = new Rectangle(e.PageBounds.Y' e.PageBounds.X' e.PageBounds.Height' e.PageBounds.Width);  				relative = page;  			}  			else  				relative = printable;
Magic Number,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,SetMargins,The following statement contains a magic number: m_vwPrintContext.SetMargins(  				PixelsFrom100ths(margins.Left - relative.Left' dpiX)'  				PixelsFrom100ths(relative.Right - margins.Right' dpiX)'  				PixelsFrom100ths((margins.Top - relative.Top) / 2' dpiY)'		// heading; get from smarter page setup?  				PixelsFrom100ths(margins.Top - relative.Top' dpiY)'				// top  				PixelsFrom100ths(relative.Bottom - margins.Bottom' dpiY)'		// bottom  				PixelsFrom100ths((relative.Bottom - margins.Bottom) / 2' dpiY));
Magic Number,SIL.FieldWorks.Common.RootSites,PrintRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\PrintRootSite.cs,SetMargins,The following statement contains a magic number: m_vwPrintContext.SetMargins(  				PixelsFrom100ths(margins.Left - relative.Left' dpiX)'  				PixelsFrom100ths(relative.Right - margins.Right' dpiX)'  				PixelsFrom100ths((margins.Top - relative.Top) / 2' dpiY)'		// heading; get from smarter page setup?  				PixelsFrom100ths(margins.Top - relative.Top' dpiY)'				// top  				PixelsFrom100ths(relative.Bottom - margins.Bottom' dpiY)'		// bottom  				PixelsFrom100ths((relative.Bottom - margins.Bottom) / 2' dpiY));
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,GetAvailWidth,The following statement contains a magic number: return m_orientationManager.GetAvailWidth() - HorizMargin * 2;
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,MakeSelectionVisible,The following statement contains a magic number: if (fWantOneLineSpace && ClientHeight < LineHeight * 3)  			{  				// The view is too short to have a line at the top and/or bottom of the line  				// we want to scroll into view. Since we can't possibly do a good job of  				// scrolling the selection into view in this circumstance' we just don't  				// even try.  				fWantOneLineSpace = false;  			}
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,MakeSelectionVisible,The following statement contains a magic number: using (new HoldGraphics(this))  			{  				bool fEndBeforeAnchor;  				Rectangle rcIdeal;  				SelectionRectangle(vwsel' out rcIdeal' out fEndBeforeAnchor);    				//rcIdeal.Inflate(0' 1); // for good measure  				// OK' we want rcIdeal to be visible.  				// dy gets added to the scroll offset. This means a positive dy causes there to be more  				// of the view hidden above the top of the screen. This is the same effect as clicking a  				// down arrow' which paradoxically causes the window contents to move up.  				int dy = 0;  				int dyRange = 0;  				int ydTop;    				#region DoAutoVScroll  				if (DoAutoVScroll)  				{  					// This loop repeats until we have figured out a scroll distance AND confirmed  					// that we can draw that location without messing things up.  					for (; ; )  					{  						// Get the amount to add to rdIdeal to make it comparable with the window  						// postion.  						ydTop = -ScrollPosition.Y; // Where the window thinks it is now.  						// Adjust for that and also the height of the (optional) header.  						rcIdeal.Offset(0' ydTop - m_dyHeader); // Was in drawing coords' adjusted by top.  						int ydBottom = ydTop + ClientHeight - m_dyHeader;    						// Is the end of the selection partly off the top of the screen?  						int extraSpacing = fWantOneLineSpace ? LineHeight : 0;  						if (!fWantBothEnds)  						{  							// For a range (that is not a picture) we scroll just far enough to show the end.  							if (fEndBeforeAnchor)  							{  								if (rcIdeal.Top < ydTop + extraSpacing)  									dy = rcIdeal.Top - (ydTop + extraSpacing);  								else if (rcIdeal.Top > ydBottom - extraSpacing)  									dy = rcIdeal.Top - (ydBottom - extraSpacing) + LineHeight;  							}  							else  							{  								if (rcIdeal.Bottom < ydTop + extraSpacing)  									dy = rcIdeal.Bottom - (ydTop + extraSpacing) - LineHeight;  								else if (rcIdeal.Bottom > ydBottom - extraSpacing)  									dy = rcIdeal.Bottom - (ydBottom - extraSpacing);  							}  						}  						else  						{  							// we want both ends to be visible if possible; if not' as much as possible at the top.  							// Also if it is completely off the bottom of the screen' a good default place to put it is near  							// the top.  							if (rcIdeal.Top < ydTop + extraSpacing || rcIdeal.Height > ydBottom - ydTop - extraSpacing * 2 || rcIdeal.Top > ydBottom)  							{  								// The top is not visible' or there isn't room to show it all: scroll till the  								// top is just visible' after the specified gap.  								dy = rcIdeal.Top - (ydTop + extraSpacing);  							}  							else if (rcIdeal.Bottom > ydBottom - extraSpacing)  							{  								// scroll down minimum to make bottom visible. This involves  								// hiding more text at the top: positive dy.  								dy = rcIdeal.Bottom - (ydBottom - extraSpacing);  							}  						}  						// Else the end of the selection is already visible' do nothing.  						// (But still make sure we can draw the requisite screen full  						// without messing stuff up. Just in case a previous lazy box  						// expansion looked like making it visible' but another makes it  						// invisible again...I'm not sure this can happen' but play safe.)    						// OK' we need to move by dy. But' if that puts the selection near the  						// bottom of the screen' we may have to expand a lazy box above it in  						// order to display a whole screen full. If the size estimate is off  						// (which it usually is)' that would affect the position' where the  						// selection gets moved to. To avoid this' we make the same PrepareToDraw  						// call that the rendering code will make before drawing after the scroll.  						Rectangle rcSrc' rcDst;  						GetCoordRects(out rcSrc' out rcDst);  						rcDst.Offset(0' -dy); // Want to draw at the position we plan to move to.    						// Get the whole range we are scrolling over. We use this later to see whether  						// PrepareToDraw messed anything up.  						dyRange = m_rootb.Height;    						if (m_rootb != null && m_dxdLayoutWidth > 0)  						{  							SaveSelectionInfo(rcIdeal' ydTop);  							VwPrepDrawResult xpdr = VwPrepDrawResult.kxpdrAdjust;  							// I'm not sure this loop is necessary because we repeat the outer loop until no  							// change in the root box height (therefore presumably no adjustment of scroll position)  							// happens. But it's harmless and makes it more obvious that the code is correct.  							while (xpdr == VwPrepDrawResult.kxpdrAdjust)  							{  								// In case the window contents aren't visible yet' it's important to do this as if it were.  								// When the window is invisible' the default clip rectangle is empty' and we don't  								// 'prepare to draw' very much. We want to be sure that we can draw everything in the window  								// without somehow affecting the position of this selection.  								Rect clipRect = new Rect(0' 0' ClientRectangle.Width' ClientHeight);  								((IVwGraphicsWin32)m_graphicsManager.VwGraphics).SetClipRect(ref clipRect);  								xpdr = PrepareToDraw(rcSrc' rcDst);  								GetCoordRects(out rcSrc' out rcDst);  							}  						}    						// If PrepareToDraw didn't change the scroll range' it didn't mess  						// anything up and we can use the dy we figured. Otherwise' loop and  						// figure it again with more complete information' because something at a  						// relevant point has been expanded to real boxes.  						if (m_rootb.Height == dyRange)  							break;    						// Otherwise we need another iteration' we need to recompute the  						// selection location in view of the changes to layout.  						SelectionRectangle(vwsel' out rcIdeal' out fEndBeforeAnchor);  						dy = 0; // Back to initial state.  					} // for loop  				}  				#endregion  				ydTop = -ScrollPosition.Y; // Where the window thinks it is now.  				SaveSelectionInfo(rcIdeal' ydTop);    				if (dy - ScrollPosition.Y < 0)  					dy = ScrollPosition.Y; // make offset 0 if it would have been less than that    				// dx gets added to the scroll offset. This means a positive dx causes there to  				// be moreof the view hidden left of the screen. This is the same effect as  				// clicking a right arrow' which paradoxically causes the window contents to  				// move left.  				int dx = 0;  				int xdLeft = -ScrollPosition.X; // Where the window thinks it is now.  				#region DoAutoHScroll  				if (DoAutoHScroll)  				{  					if (IsVertical)  					{  						// In all current vertical views we have no vertical scrolling' so only need  						// to consider horizontal. Also we have no laziness' so no need to mess with  						// possible effects of expanding lazy boxes that become visible.  						// In this case' rcPrimary's top is the distance from the right of the ClientRect to the  						// right of the selection' and the height of rcPrimary is a distance further left.  						int right = rcIdeal.Top; // distance to left of right edge of window  						int left = right + rcIdeal.Height;  						if (fWantOneLineSpace)  						{  							right -= LineHeight;  							left += LineHeight;  						}  						if (right < 0)  						{  							// selection is partly off the right of the window  							dx = -right; // positive dx to move window contents left.  						}  						else if (left > ClientRectangle.Width)  						{  							dx = ClientRectangle.Width - left; // negative to move window contents right  						}  					}  					else // not a vertical window' normal case  					{    						rcIdeal.Offset(xdLeft' 0); // Was in drawing coords' adjusted by left.  						// extra 4 pixels so Ip doesn't disappear at right.  						int xdRight = xdLeft + ClientRectangle.Width;    						// Is the selection right of the right side of the screen?  						if (rcIdeal.Right > xdRight)  							dx = rcIdeal.Right - xdRight;    						// Is the selection partly off the left of the screen?  						if (rcIdeal.Left < xdLeft)  						{  							// Is it bigger than the screen?  							if (rcIdeal.Width > ClientRectangle.Width && !fEndBeforeAnchor)  							{  								// Is it bigger than the screen?  								if (rcIdeal.Width > ClientRectangle.Width && !fEndBeforeAnchor)  								{  									// Left is off' and though it is too big to show entirely' we can show  									// more. Move the window contents right (negative dx).  									dx = rcIdeal.Right - xdRight;  								}  								else  								{  									// Partly off left' and fits: move window contents right (less is hidden'  									// neg dx).  									dx = rcIdeal.Left - xdLeft;  								}  							}  							else  							{  								// Left of selection is right of (or at) the left side of the screen.  								// Is right of selection right of the right side of the screen?  								if (rcIdeal.Right > xdRight)  								{  									if (rcIdeal.Width > ClientRectangle.Width && fEndBeforeAnchor)  									{  										// Left is visible' right isn't: move until lefts coincide to show as much  										// as possible. This is hiding more text left of the window: positive dx.  										dx = rcIdeal.Left - xdLeft;  									}  									else  									{  										// Fits entirely: scroll left minimum to make right visible. This involves  										// hiding more text at the left: positive dx.  										dx = rcIdeal.Right - xdRight;  									}  								}  								// Else it is already entirely visible' do nothing.  							}  							if (dx > Width - ClientRectangle.Width - 1 + ScrollPosition.X)  							{  								// This value makes it the maximum it can be' except this may make it negative  								dx = Width - ClientRectangle.Width - 1 + ScrollPosition.X;  							}  							if (dx - ScrollPosition.X < 0)  								dx = ScrollPosition.X; // make offset 0 if it would have been less than that  						}  					}  					int ScrollRangeX = ScrollRange.Width;  					if (dx > ScrollRangeX - ClientRectangle.Width - 1 + ScrollPosition.X)  					{  						// This value makes it the maximum it can be' except this may make it negative  						dx = ScrollRangeX - ClientRectangle.Width - 1 + ScrollPosition.X;  					}  					if (dx - ScrollPosition.X < 0)  						dx = ScrollPosition.X; // make offset 0 if it would have been less than that  				}  				#endregion  				if (dx != 0 || dy != 0)  				{  					// Update the scroll bar.  					ScrollPosition = new Point(xdLeft + dx' ydTop + dy);  				}  				Invalidate();  				//Update();  			}
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnHandleCreated,The following statement contains a magic number: m_Timer.Interval = 500;
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,ProcessCmdKey,The following statement contains a magic number: if (keyData == Keys.Apps || keyData == (Keys.F10 | Keys.Shift))  			{  				if (RootBox != null && RootBox.Selection != null)  				{  					Point pt;  					// Set point to somewhere around the middle of the selection in window coords.  					using (new HoldGraphics(this))  					{  						Rectangle rcSrcRoot' rcDstRoot;  						Rect rcSec' rcPrimary;  						bool fSplit' fEndBeforeAnchor;  						GetCoordRects(out rcSrcRoot' out rcDstRoot);  						RootBox.Selection.Location(m_graphicsManager.VwGraphics' rcSrcRoot' rcDstRoot' out rcPrimary'  							out rcSec' out fSplit' out fEndBeforeAnchor);    						pt = new Point((rcPrimary.right + rcPrimary.left)/2'  							(rcPrimary.top + rcPrimary.bottom)/2);  					}  					if (HandleContextMenuFromKeyboard(RootBox.Selection' pt))  						return true;  					// These two checks are copied from OnRightMouseUp; not sure why (or whether) they are needed.  					if (DataUpdateMonitor.IsUpdateInProgress())  						return true; //discard this event  					if (IsFollowLinkMsgPending)  					{  						return true; //discard this event  					}  					using (var hg = new HoldGraphics(this))  					{  						Rectangle rcSrcRoot' rcDstRoot;  						GetCoordRects(out rcSrcRoot' out rcDstRoot);  						return DoContextMenu(RootBox.Selection' pt' rcSrcRoot' rcDstRoot);  					}    				}  				return true;  			}
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,ProcessCmdKey,The following statement contains a magic number: if (keyData == Keys.Apps || keyData == (Keys.F10 | Keys.Shift))  			{  				if (RootBox != null && RootBox.Selection != null)  				{  					Point pt;  					// Set point to somewhere around the middle of the selection in window coords.  					using (new HoldGraphics(this))  					{  						Rectangle rcSrcRoot' rcDstRoot;  						Rect rcSec' rcPrimary;  						bool fSplit' fEndBeforeAnchor;  						GetCoordRects(out rcSrcRoot' out rcDstRoot);  						RootBox.Selection.Location(m_graphicsManager.VwGraphics' rcSrcRoot' rcDstRoot' out rcPrimary'  							out rcSec' out fSplit' out fEndBeforeAnchor);    						pt = new Point((rcPrimary.right + rcPrimary.left)/2'  							(rcPrimary.top + rcPrimary.bottom)/2);  					}  					if (HandleContextMenuFromKeyboard(RootBox.Selection' pt))  						return true;  					// These two checks are copied from OnRightMouseUp; not sure why (or whether) they are needed.  					if (DataUpdateMonitor.IsUpdateInProgress())  						return true; //discard this event  					if (IsFollowLinkMsgPending)  					{  						return true; //discard this event  					}  					using (var hg = new HoldGraphics(this))  					{  						Rectangle rcSrcRoot' rcDstRoot;  						GetCoordRects(out rcSrcRoot' out rcDstRoot);  						return DoContextMenu(RootBox.Selection' pt' rcSrcRoot' rcDstRoot);  					}    				}  				return true;  			}
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnSizeChanged,The following statement contains a magic number: if (ScrollToSelectionOnSizeChanged && !IsSelectionVisible(null) && AllowLayout)  			{  				using (new HoldGraphics(this))  				{  					Rectangle rcSrc;  					Rectangle rcDst;  					GetCoordRects(out rcSrc' out rcDst);  					m_fInLayout = true;  					try  					{  						using (new SuspendDrawing(this))  							selToScroll = m_rootb.MakeSelAt(5' 5' rcSrc' rcDst' false);  					}  					catch  					{  						// just ignore any errors we get...  						selToScroll = null;  					}  					finally  					{  						m_fInLayout = false;  					}  				}  			}
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OnSizeChanged,The following statement contains a magic number: if (ScrollToSelectionOnSizeChanged && !IsSelectionVisible(null) && AllowLayout)  			{  				using (new HoldGraphics(this))  				{  					Rectangle rcSrc;  					Rectangle rcDst;  					GetCoordRects(out rcSrc' out rcDst);  					m_fInLayout = true;  					try  					{  						using (new SuspendDrawing(this))  							selToScroll = m_rootb.MakeSelAt(5' 5' rcSrc' rcDst' false);  					}  					catch  					{  						// just ignore any errors we get...  						selToScroll = null;  					}  					finally  					{  						m_fInLayout = false;  					}  				}  			}
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,CallMouseMoveDrag,The following statement contains a magic number: if (m_rootb != null && m_fMouseInProcess == false)  			{  				// various scrolling speeds' i.e. 10 pixels per mousemovedrag event when  				// dragging beyond the top or bottom of of the rootbox  				const int LOSPEED = 10;  				const int HISPEED = 30;  				int speed;  				const int SLOW_BUFFER_ZONE = 30;    				m_fMouseInProcess = true;    				if (DoAutoVScroll && pt.Y < 0)  // if drag above the top of rootbox  				{  					// if mouse is within 30 pixels of top of rootbox  					if (pt.Y > -SLOW_BUFFER_ZONE)  						speed = LOSPEED;  					else  						speed = HISPEED;  					// regardless of where pt.Y is' select only to top minus "speed"'  					// then scroll up by "speed" number of pixels' so top of selection is  					// always at top of rootbox  					m_rootb.MouseMoveDrag(pt.X' -speed' rcSrcRoot' rcDstRoot);  					ScrollPosition = new Point(-ScrollPosition.X' -ScrollPosition.Y - speed);  					Refresh();  				}  				else if (DoAutoVScroll && pt.Y > Bottom)  // if drag below bottom of rootbox  				{  					// if mouse is within 30 pixels of bottom of rootbox  					if ((pt.Y - Bottom) < SLOW_BUFFER_ZONE)  						speed = LOSPEED;  					else  						speed = HISPEED;  					// regardless of where pt.Y is' select only to bottom plus "speed"'  					// then scroll down by "speed" number of pixels' so bottom of selection  					// is always at bottom of rootbox  					m_rootb.MouseMoveDrag(pt.X' Bottom + speed' rcSrcRoot' rcDstRoot);  					ScrollPosition = new Point(-ScrollPosition.X' -ScrollPosition.Y + speed);  					Refresh();  				}  				else  // selection and drag is occuring all within window boundaries  				{  					m_rootb.MouseMoveDrag(pt.X' pt.Y' rcSrcRoot' rcDstRoot);  				}  				m_fMouseInProcess = false;  			}
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,CallMouseMoveDrag,The following statement contains a magic number: if (m_rootb != null && m_fMouseInProcess == false)  			{  				// various scrolling speeds' i.e. 10 pixels per mousemovedrag event when  				// dragging beyond the top or bottom of of the rootbox  				const int LOSPEED = 10;  				const int HISPEED = 30;  				int speed;  				const int SLOW_BUFFER_ZONE = 30;    				m_fMouseInProcess = true;    				if (DoAutoVScroll && pt.Y < 0)  // if drag above the top of rootbox  				{  					// if mouse is within 30 pixels of top of rootbox  					if (pt.Y > -SLOW_BUFFER_ZONE)  						speed = LOSPEED;  					else  						speed = HISPEED;  					// regardless of where pt.Y is' select only to top minus "speed"'  					// then scroll up by "speed" number of pixels' so top of selection is  					// always at top of rootbox  					m_rootb.MouseMoveDrag(pt.X' -speed' rcSrcRoot' rcDstRoot);  					ScrollPosition = new Point(-ScrollPosition.X' -ScrollPosition.Y - speed);  					Refresh();  				}  				else if (DoAutoVScroll && pt.Y > Bottom)  // if drag below bottom of rootbox  				{  					// if mouse is within 30 pixels of bottom of rootbox  					if ((pt.Y - Bottom) < SLOW_BUFFER_ZONE)  						speed = LOSPEED;  					else  						speed = HISPEED;  					// regardless of where pt.Y is' select only to bottom plus "speed"'  					// then scroll down by "speed" number of pixels' so bottom of selection  					// is always at bottom of rootbox  					m_rootb.MouseMoveDrag(pt.X' Bottom + speed' rcSrcRoot' rcDstRoot);  					ScrollPosition = new Point(-ScrollPosition.X' -ScrollPosition.Y + speed);  					Refresh();  				}  				else  // selection and drag is occuring all within window boundaries  				{  					m_rootb.MouseMoveDrag(pt.X' pt.Y' rcSrcRoot' rcDstRoot);  				}  				m_fMouseInProcess = false;  			}
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,CallMouseMoveDrag,The following statement contains a magic number: if (m_rootb != null && m_fMouseInProcess == false)  			{  				// various scrolling speeds' i.e. 10 pixels per mousemovedrag event when  				// dragging beyond the top or bottom of of the rootbox  				const int LOSPEED = 10;  				const int HISPEED = 30;  				int speed;  				const int SLOW_BUFFER_ZONE = 30;    				m_fMouseInProcess = true;    				if (DoAutoVScroll && pt.Y < 0)  // if drag above the top of rootbox  				{  					// if mouse is within 30 pixels of top of rootbox  					if (pt.Y > -SLOW_BUFFER_ZONE)  						speed = LOSPEED;  					else  						speed = HISPEED;  					// regardless of where pt.Y is' select only to top minus "speed"'  					// then scroll up by "speed" number of pixels' so top of selection is  					// always at top of rootbox  					m_rootb.MouseMoveDrag(pt.X' -speed' rcSrcRoot' rcDstRoot);  					ScrollPosition = new Point(-ScrollPosition.X' -ScrollPosition.Y - speed);  					Refresh();  				}  				else if (DoAutoVScroll && pt.Y > Bottom)  // if drag below bottom of rootbox  				{  					// if mouse is within 30 pixels of bottom of rootbox  					if ((pt.Y - Bottom) < SLOW_BUFFER_ZONE)  						speed = LOSPEED;  					else  						speed = HISPEED;  					// regardless of where pt.Y is' select only to bottom plus "speed"'  					// then scroll down by "speed" number of pixels' so bottom of selection  					// is always at bottom of rootbox  					m_rootb.MouseMoveDrag(pt.X' Bottom + speed' rcSrcRoot' rcDstRoot);  					ScrollPosition = new Point(-ScrollPosition.X' -ScrollPosition.Y + speed);  					Refresh();  				}  				else  // selection and drag is occuring all within window boundaries  				{  					m_rootb.MouseMoveDrag(pt.X' pt.Y' rcSrcRoot' rcDstRoot);  				}  				m_fMouseInProcess = false;  			}
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,IsSelectionVisible,The following statement contains a magic number: int ydRight = ydLeft + ClientRectangle.Width - (HorizMargin * 2);
Magic Number,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OriginalWndProc,The following statement contains a magic number: switch (msg.Msg)  			{  #if !__MonoCS__ // Disable use of UIAutomationProvider.dll on Linux  				case 61: // WM_GETOBJECT  					{  						// FWR-2874' FWR-3045: This code was commented out to prevent a crash  						// that can happen when using the Windows 7 On-Screen Keyboard.  						//if (msg.LParam.ToInt32() == AutomationInteropProvider.RootObjectId)  						//{  						//    msg.Result = AutomationInteropProvider.ReturnRawElementProvider(  						//            this.Handle' msg.WParam' msg.LParam'  						//            UIAutomationServerProviderFactory());  						//    return;  						//}    						object obj = AccessibleRootObject;  						//IAccessible acc = (IAccessible)obj;  						if (obj == null)  						{  							// If for some reason the root site isn't sufficiently initialized  							// to have a root box' the best we can do is the default IAccessible.  							//MessageBox.Show("Null root in IAccessible");  							base.WndProc(ref msg);  						}  						else  						{  							Guid guidAcc = Marshal.GenerateGuidForType(typeof(IAccessible));  							msg.Result = LresultFromObject(ref guidAcc' msg.WParam' obj);  						}  						return;  					}  #endif  				case 0x286:	// WM_IME_CHAR  					{  						// We must handle this directly so that duplicate WM_CHAR messages don't get  						// posted' resulting in duplicated input.  (I suspect this may be a bug in the  						// .NET framework. - SMc)  						OnKeyPress(new KeyPressEventArgs((char)msg.WParam));  						return;  					}  				case (int)Win32.WinMsgs.WM_SETFOCUS:  					OnSetFocus(msg);  #if __MonoCS__  					// In Linux+Mono' if you .Focus() a SimpleRootSite' checking .Focused reports false unless  					// we comment out this case for intercepting WM_SETFOCUS' or call base.WndProc() to  					// presumably let Mono handle WM_SETFOCUS as well by successfully setting focus on the  					// base Control.  					// Affects six unit tests in FwCoreDlgsTests FwFindReplaceDlgTests: eg ApplyStyle_ToEmptyTextBox.  					//  					// Intercepting WM_SETFOCUS in Windows relates to focus switching with respect to Keyman.    					base.WndProc(ref msg);  #endif // __MonoCS__  					return;  				case (int)Win32.WinMsgs.WM_KILLFOCUS:  					base.WndProc(ref msg);  					OnKillFocus(Control.FromHandle(msg.WParam)'  						SIL.FieldWorks.Common.FwUtils.FwUtils.IsChildWindowOfForm(ParentForm' msg.WParam));  					return;  			}
Missing Default,SIL.FieldWorks.Common.RootSites,EditingHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\EditingHelper.cs,GetTsStringFromClipboard,The following switch statement is missing a default case: switch (pasteStatus)  			{  				case PasteStatus.PreserveWs:  					break;  				case PasteStatus.UseDestWs:  					Debug.Assert(destWs > 0);  					return wrapper.GetTsStringUsingWs(destWs' writingSystemFactory);  				case PasteStatus.CancelPaste:  					return null;  			}
Missing Default,SIL.FieldWorks.Common.RootSites,VerticalOrientationManager,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\OrientationManager.cs,ConvertKeyValue,The following switch statement is missing a default case: switch(keyValue)  			{  				case (int)Keys.Left:  					return (int)Keys.Down;  				case (int) Keys.Right:  					return (int)Keys.Up;  				case (int) Keys.Up:  					return (int)Keys.Left;  				case (int) Keys.Down:  					return (int)Keys.Right;  			}
Missing Default,SIL.FieldWorks.Common.RootSites,SelectionHelper,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SelectionHelper.cs,ContraryLimit,The following switch statement is missing a default case: switch(limit)  			{  				case SelLimitType.Anchor:  					return SelLimitType.End;  				case SelLimitType.End:  					return SelLimitType.Anchor;  				case SelLimitType.Top:  					return SelLimitType.Bottom;  				case SelLimitType.Bottom:  					return SelLimitType.Top;  			}
Missing Default,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,IsInputKey,The following switch statement is missing a default case: switch (keyData & Keys.KeyCode)  			{  					case Keys.Return:  						return m_acceptsReturn;    					case Keys.Escape:  						return false;    					case Keys.Tab:  						return m_acceptsTab && (keyData & Keys.Control) == Keys.None;  				}
Missing Default,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,OriginalWndProc,The following switch statement is missing a default case: switch (msg.Msg)  			{  #if !__MonoCS__ // Disable use of UIAutomationProvider.dll on Linux  				case 61: // WM_GETOBJECT  					{  						// FWR-2874' FWR-3045: This code was commented out to prevent a crash  						// that can happen when using the Windows 7 On-Screen Keyboard.  						//if (msg.LParam.ToInt32() == AutomationInteropProvider.RootObjectId)  						//{  						//    msg.Result = AutomationInteropProvider.ReturnRawElementProvider(  						//            this.Handle' msg.WParam' msg.LParam'  						//            UIAutomationServerProviderFactory());  						//    return;  						//}    						object obj = AccessibleRootObject;  						//IAccessible acc = (IAccessible)obj;  						if (obj == null)  						{  							// If for some reason the root site isn't sufficiently initialized  							// to have a root box' the best we can do is the default IAccessible.  							//MessageBox.Show("Null root in IAccessible");  							base.WndProc(ref msg);  						}  						else  						{  							Guid guidAcc = Marshal.GenerateGuidForType(typeof(IAccessible));  							msg.Result = LresultFromObject(ref guidAcc' msg.WParam' obj);  						}  						return;  					}  #endif  				case 0x286:	// WM_IME_CHAR  					{  						// We must handle this directly so that duplicate WM_CHAR messages don't get  						// posted' resulting in duplicated input.  (I suspect this may be a bug in the  						// .NET framework. - SMc)  						OnKeyPress(new KeyPressEventArgs((char)msg.WParam));  						return;  					}  				case (int)Win32.WinMsgs.WM_SETFOCUS:  					OnSetFocus(msg);  #if __MonoCS__  					// In Linux+Mono' if you .Focus() a SimpleRootSite' checking .Focused reports false unless  					// we comment out this case for intercepting WM_SETFOCUS' or call base.WndProc() to  					// presumably let Mono handle WM_SETFOCUS as well by successfully setting focus on the  					// base Control.  					// Affects six unit tests in FwCoreDlgsTests FwFindReplaceDlgTests: eg ApplyStyle_ToEmptyTextBox.  					//  					// Intercepting WM_SETFOCUS in Windows relates to focus switching with respect to Keyman.    					base.WndProc(ref msg);  #endif // __MonoCS__  					return;  				case (int)Win32.WinMsgs.WM_KILLFOCUS:  					base.WndProc(ref msg);  					OnKillFocus(Control.FromHandle(msg.WParam)'  						SIL.FieldWorks.Common.FwUtils.FwUtils.IsChildWindowOfForm(ParentForm' msg.WParam));  					return;  			}
Missing Default,SIL.FieldWorks.Common.RootSites,SimpleRootSite,C:\repos\sillsdev_FieldWorks\Src\Common\SimpleRootSite\SimpleRootSite.cs,PreFilterMessage,The following switch statement is missing a default case: switch (m.Msg)  			{  				case (int)Win32.WinMsgs.WM_KEYUP:  				case (int)Win32.WinMsgs.WM_LBUTTONUP:  				case (int)Win32.WinMsgs.WM_KEYDOWN:  					// If user-initiated messages come (or our spurious one' which we check  					// for below)' remove this filter.  					Application.RemoveMessageFilter(this);  					m_messageFilterInstalled = false;    					// Now check for the spurious CTRL-UP message  					if (m.Msg == (int)Win32.WinMsgs.WM_KEYUP &&  						m.WParam.ToInt32() == (int)Win32.VirtualKeycodes.VK_CONTROL)  					{  						return true; // discard this message  					}  					break;  			}
