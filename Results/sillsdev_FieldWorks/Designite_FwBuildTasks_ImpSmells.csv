Implementation smell,Namespace,Class,File,Method,Description
Long Method,FwBuildTasks,CollectTargets,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CollectTargets.cs,WriteTargetFiles,The method has 175 lines of code.
Long Method,FwBuildTasks,Unitpp,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Unitpp.cs,ProcessOutput,The method has 144 lines of code.
Long Method,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,Execute,The method has 104 lines of code.
Long Method,SIL.FieldWorks.Build.Tasks,RegFree,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\RegFree.cs,Execute,The method has 112 lines of code.
Complex Method,FwBuildTasks,DownloadFile,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFile.cs,ProcessDownloadFile,Cyclomatic complexity of the method is 8
Complex Method,FwBuildTasks,GenerateNUnitReports,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\GenerateNUnitReports.cs,GenerateReportFor,Cyclomatic complexity of the method is 8
Complex Method,FwBuildTasks,NUnit,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\NUnit.cs,ProgramArguments,Cyclomatic complexity of the method is 15
Complex Method,FwBuildTasks,NUnit,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\NUnit.cs,EnsureToolPath,Cyclomatic complexity of the method is 13
Complex Method,FwBuildTasks,XslTransformation,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\XslTransformation.cs,ValidateAttributes,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,ProcessFile,Cyclomatic complexity of the method is 8
Complex Method,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,CheckForPoFileProblems,Cyclomatic complexity of the method is 15
Complex Method,SIL.FieldWorks.Build.Tasks.Localization,PoMessageWriter,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Po2XmlConverter.PoMessageWriter.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,SIL.FieldWorks.Build.Tasks.Localization,PoString,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\PoString.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,SIL.FieldWorks.Build.Tasks.Localization,PoString,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\PoString.cs,StringListAsString,Cyclomatic complexity of the method is 8
Long Parameter List,FwBuildTasks,InstrumentedProjectLocalizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\InstrumentedProjectLocalizer.cs,RunAssemblyLinker,The method has 6 parameters. Parameters: outputDllPath' culture' fileversion' productVersion' version' resources
Long Parameter List,SIL.FieldWorks.Build.Tasks,RegFreeCreator,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\RegFreeCreator.cs,AddOrReplaceCoClass,The method has 6 parameters. Parameters: parent' clsId' threadingModel' description' tlbId' progId
Long Parameter List,SIL.FieldWorks.Build.Tasks,RegHelper,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\RegHelper.cs,ApiInvoke,The method has 5 parameters. Parameters: log' fileName' delegateSignatureType' methodName' args
Long Parameter List,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,StoreTranslatedThing,The method has 5 parameters. Parameters: xelRoot' enStrings' whatThing' skipCommentMethod' idMethod
Long Parameter List,SIL.FieldWorks.Build.Tasks.Localization,ProjectLocalizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\ProjectLocalizer.cs,RunAssemblyLinker,The method has 6 parameters. Parameters: outputDllPath' culture' fileversion' productVersion' version' resources
Long Parameter List,SIL.FieldWorks.Build.Tasks.Localization,ProjectLocalizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\ProjectLocalizer.cs,RunProcess,The method has 5 parameters. Parameters: fileName' arguments' stdOutput' timeout' workdir
Long Parameter List,SIL.FieldWorks.Build.Tasks.Localization,ProjectLocalizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\ProjectLocalizer.cs,BuildLinkerArgs,The method has 6 parameters. Parameters: outputDllPath' culture' fileversion' productVersion' version' resources
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,GetMethodPattern,The length of the statement  "			// All methods end with NOP' RET. On Windows' WriteLIneIf is always followed by NOP' but not on Linux' so remove it on Linux " is 124.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,GetDisposeBoolMethod,The length of the statement  "			return type.GetMethod(Dispose' BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly' Type.DefaultBinder' " is 126.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,Execute,The length of the statement  "				Log.LogError($"The assembly {assembly.GetName().Name} has types that do not call {MissingDisposeMsgCmd} and base.Dispose(disposing);" " is 133.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,InspectType,The length of the statement  "				Log.LogError($"The type {type.FullName} which implements IDisposable should dispose its members in Dispose(bool disposing)" " is 123.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,InspectType,The length of the statement  "			// Disposables' including Windows Forms' implement Dispose() { Dispose(true); GC.SuppressFinalize(this); } and ~Type() { Dispose(false); } " is 138.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,InspectType,The length of the statement  "				Log.LogError($"The type {type.FullName} which implements IDisposable should have a Finalizer that calls Dispose(false) {baseCategory}"); " is 136.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,GetCategory,The length of the statement  "			if (type.Namespace != null && (type.Namespace.StartsWith("System.Windows.Forms") || type.Namespace.StartsWith("System.ComponentModel"))) " is 136.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,IsAnonymousIEnumeratorImpl,The length of the statement  "			// REVIEW (Hasso) 2016.12: make more particular: FullName.IndexOf(FullName.IndexOf("+<")' ">"); substr(idx1' idx2); has method (who has?) " is 137.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,MethodCallsBaseDispose,The length of the statement  "			// We have to find base.Dispose(bool) on the Type that declares it' so that its ReflectedType matches that of the result of ResolveMethod " is 137.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,MethodCallsBaseDispose,The length of the statement  "			// Search the whole method' statrting at the end (the final two instructions are always NOP' RET--except on Unix' which may not have NOP) " is 137.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,MethodCallsBaseDispose,The length of the statement  "				if (testInstructions[i].opCode == OpCodes.Call && Equals(baseDispose' testModule.ResolveMethod((int) testInstructions[i].operand))) " is 131.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,MethodBeginningsMatch,The length of the statement  "					// OpCodes don't match. If the found OpCode is Callvirt' this is probably a `GetType().Name` where we expected a `GetType()`' " is 125.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,MethodBeginningsMatch,The length of the statement  "					// which is fine. Still return false' to force comparison against the second exemplar' but don't clutter the build log with " is 123.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,FinalizerCallsDisposeFalse,The length of the statement  "						// The call or callvirt looks like a proper Dispose(false) call (except for the failed ResolveMethod). It's good enough. " is 120.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,FinalizerCallsDisposeFalse,The length of the statement  "							Log.LogWarning($"Clouseau has found no problems with ~{finalizer.DeclaringType}() but cannot yet complete the inspection"); " is 123.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,IsDisposeBoolCall,The length of the statement  "				// On Unix' rather than throwing an ArgumentException for parameterized Types' Module.ResolveMethod returns a MethodBase with the " is 129.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,IsDisposeBoolCall,The length of the statement  "				// same signature' but which is somehow unequivalent. Compensate for this by checking for this case and throwing an ArgumentException. " is 134.
Long Statement,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,IsDisposeBoolCall,The length of the statement  "				var typeName = disposeBool.DeclaringType.ToString(); // ToString()' unlike FullName' includes the "[P'T]" in "ConsumerThread`2[P'T]" " is 132.
Long Statement,FwBuildTasks,ClouseauTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\ClouseauTests.cs,ImplIEnumerator_LogsOnlyWarnings,The length of the statement  "			_task.InspectType(Assembly.GetAssembly(typeof(ImplIEnumerator<Type>)).DefinedTypes.First(t => t.Name == "ImplIEnumerator`1")); " is 126.
Long Statement,FwBuildTasks,ClouseauTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\ClouseauTests.cs,NoBody_LogsError,The length of the statement  "			Assert.IsNotEmpty(_tbi.Errors' "abstract classes are not excused from implementing our boilerplate Disposable requirements"); " is 125.
Long Statement,FwBuildTasks,ClouseauTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\ClouseauTests.cs,DisposableWithoutMessageDerivedFromAbstract_LogsError,The length of the statement  "			Assert.IsEmpty(_tbi.Errors' "Derived classes should not be reprimanded for their base classes' errors. The base classes should be fixed"); " is 138.
Long Statement,FwBuildTasks,ProperlyImplementedIFWDisposable,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\ClouseauTests.cs,Dispose,The length of the statement  "				Debug.WriteLineIf(!disposing' "********* Missing Dispose() call for " + GetType() + " *********"); // kill two more birds: no `.Name`' extra *'s " is 144.
Long Statement,FwBuildTasks,DownloadFile,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFile.cs,ProcessDownloadFile,The length of the statement  "						Log.LogMessage(MessageImportance.High' "Could not retrieve latest {0}. No network connection. Trying {1} more times in {2}-minute intervals."' " is 142.
Long Statement,FwBuildTasks,DownloadFile,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFile.cs,DoDownloadFile,The length of the statement  "					Log.LogMessage(MessageImportance.Low' "{0} bytes written to {1} from {2}"' totalBytesRead' localFilename' remoteFilename); " is 122.
Long Statement,FwBuildTasks,DownloadFile,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFile.cs,DoDownloadFile,The length of the statement  "					Log.LogWarning("Unexpected Server Response[{0}] when downloading {1}"' response.StatusCode' Path.GetFileName(localFilename)); " is 125.
Long Statement,FwBuildTasks,DownloadFile,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFile.cs,DoDownloadFile,The length of the statement  "					return Result.FinalFailure; // The server responded' but did not return the requested resource. It probably won't next time' either' so give up now. " is 148.
Long Statement,FwBuildTasks,DownloadFilesFromTeamCity,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFilesFromTeamCity.cs,DownloadAllFiles,The length of the statement  "			Log.LogMessage("Downloading artifacts from {0}{1}"' addressBase' Query == null ? null : string.Format(" with Query {0}"' Query)); " is 129.
Long Statement,FwBuildTasks,DownloadFilesFromTeamCity,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFilesFromTeamCity.cs,QueryTeamCity,The length of the statement  "			// Didn't find a matching dependency in FLExBridge; check for the most-specific version-tagged build' if any (e.g. fw-8.2.8~beta2~nightly) " is 138.
Long Statement,FwBuildTasks,DownloadFilesFromTeamCity,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFilesFromTeamCity.cs,QueryTeamCity,The length of the statement  "				Log.LogError("Unable to retrieve dependencies for BuildType {0}. Check your connection and whether the BuildType exists"' BuildType); " is 133.
Long Statement,FwBuildTasks,DownloadFilesFromTeamCity,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFilesFromTeamCity.cs,GetTagsFromBuildElt,The length of the statement  "			return from tagElt in tagsElt.Elements("tag") select tagElt.Attribute("name") into nameAtt where nameAtt != null select nameAtt.Value; " is 134.
Long Statement,FwBuildTasks,GenerateTestCoverageReport,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\GenerateTestCoverageReport.cs,GenerateDotCoverAnalysisXml,The length of the statement  "				(assemblies.Length == 1 ? Path.GetFileNameWithoutExtension(firstAssembly.ItemSpec) : "MultipleFWProjects") + ".coversettings.xml"); " is 131.
Long Statement,FwBuildTasks,GenerateTestCoverageReport,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\GenerateTestCoverageReport.cs,GenerateDotCoverIncludeFilters,The length of the statement  "				var mainAssembly = testAssemblyName.IndexOf("Tests") > 0 ? testAssemblyName.Substring(0' testAssemblyName.IndexOf("Tests")) : testAssemblyName; " is 143.
Long Statement,FwBuildTasks,GenerateTestCoverageReport,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\GenerateTestCoverageReport.cs,GenerateDotCoverIncludeFilters,The length of the statement  "				includeFilters += string.Format("\t<FilterEntry>\n\t\t<ModuleMask>{0}</ModuleMask>\n\t</FilterEntry>"' Path.GetFileNameWithoutExtension(mainAssembly)); " is 151.
Long Statement,FwBuildTasks,LocalizeFieldWorks,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\LocalizeFieldWorks.cs,Execute,The length of the statement  "						buildFailed = true;  // an error was reported' e.g.' from Assembly Linker' that we didn't manage to make cause a return false. " is 126.
Long Statement,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,Setup,The length of the statement  "			CreateTestPoFile("es"' " first"' "A browse view {0}{0:F1}"' "Una vista examinar{0}{0:F1}"' " second"' "A category"' "Una categor√≠a"' " is 132.
Long Statement,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,Setup,The length of the statement  "				". /Language Explorer/Configuration/Lexicon/areaConfiguration.xml::/root/menuAddOn/menu/item/@label"' "A_llomorph"' "A_lomorfo"' " is 128.
Long Statement,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,Setup,The length of the statement  "				". /Language Explorer/Configuration/Parts/MorphologyParts.xml::/PartInventory/bin/part[@id=\"MoAlloAdhocProhib-Jt-Type\"]/lit"' "lit1"' "litTrans1"' " is 148.
Long Statement,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,Setup,The length of the statement  "				". /Language Explorer/Configuration/ContextHelp.xml::/strings/item[@id=\"AffixForm\"]"' "An allomorph of the affix."' "Un alomorfo del afijo."); " is 144.
Long Statement,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,CreateTestPoFile,The length of the statement  "			var poPath = Path.Combine(m_sut.PoFileDirectory' LocalizeFieldWorks.PoFileLeadIn + locale + LocalizeFieldWorks.PoFileExtension); " is 128.
Long Statement,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,DoIt,The length of the statement  "			// We should generate es.xml in the Output directory (a form of the PO file suitable for including in an XSLT transform). " is 121.
Long Statement,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,DoIt,The length of the statement  "				new EmbedInfo(Path.Combine(m_sut.OutputFolder' "es"' "Common"' "FieldWorks"' "SIL.FieldWorks.FieldWorks-strings.es.resources")' " is 127.
Long Statement,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,DoIt,The length of the statement  "				new EmbedInfo(Path.Combine(m_sut.OutputFolder' "es"' "Common"' "FieldWorks"' "Properties"' "SIL.FieldWorks.Properties.more strings.es.resources")' " is 146.
Long Statement,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,DoIt,The length of the statement  "				new EmbedInfo(Path.Combine(m_sut.OutputFolder' "es"' "xCore"' "xCoreInterfaces"' "SIL.xCoreInterfaces.xCoreInterfaces-strings.es.resources")' " is 141.
Long Statement,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,SelectsCorrectProjects,The length of the statement  "			Assert.That(projects.Contains(m_FieldWorksPropertiesFolder)' Is.False); // Review: we want to do the resx here' but it isn't a true project folder. " is 147.
Long Statement,FwBuildTasks,Substitute,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Substitute.cs,Execute,The length of the statement  "					fileContents = regex.Replace(fileContents' string.IsNullOrEmpty(strEnvValue) ? strDefault : strEnvValue' 1' match.Index); " is 121.
Long Statement,FwBuildTasks,Substitute,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Substitute.cs,Execute,The length of the statement  "						Log.LogMessage(MessageImportance.Low' "Skipping generating {0} from {1} because it hasn't changed."' Output' Path.GetFileName(template)); " is 137.
Long Statement,FwBuildTasks,Substitute,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Substitute.cs,ParseSymbolFile,The length of the statement  "					log.LogMessage(MessageImportance.High' "Invalid symbol file: '{0}' line {1} should be Name=Value"' symbolFile' lineNumber); " is 123.
Long Statement,FwBuildTasks,NUnit,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\NUnit.cs,ProcessOutput,The length of the statement  "					writer.WriteLine("<test-results name=\"{0}\" total=\"{1}\" errors=\"{2}\" failures=\"{3}\" not-run=\"{4}\" inconclusive=\"{5}\" ignored=\"{6}\" skipped=\"{7}\" invalid=\"{8}\" date=\"{9}\" time=\"{10}\">"' " is 205.
Long Statement,FwBuildTasks,NUnit,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\NUnit.cs,ProcessOutput,The length of the statement  "					writer.WriteLine("  <test-suite type=\"Assembly\" name=\"{0}\" executed=\"True\" result=\"Timeout\" success=\"False\" time=\"{1}\">"' " is 133.
Long Statement,FwBuildTasks,NUnit,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\NUnit.cs,ProcessOutput,The length of the statement  "					writer.WriteLine("          <test-case name=\"Timeout\" success=\"False\" time=\"{0}\" asserts=\"0\"/>"' ((double)Timeout / 1000.0).ToString("F3")); " is 148.
Long Statement,FwBuildTasks,CollectTargets,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CollectTargets.cs,WriteTargetFiles,The length of the statement  "						writer.WriteLine("\t\t\tProperties=\"$(msbuild-props);IntermediateOutputPath=$(dir-fwobj){0}{1}{0};DefineConstants=$({2}Defines);$(warningsAsErrors);WarningLevel=4;LcmArtifactsDir=$(LcmArtifactsDir)\""' " is 202.
Long Statement,FwBuildTasks,CollectTargets,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CollectTargets.cs,WriteTargetFiles,The length of the statement  "						writer.WriteLine("\t\t<Clouseau Condition=\"'$(Configuration)' == 'Debug'\" AssemblyPathname=\"$(dir-outputBase)/{0}\"/>"' AssemblyName); " is 137.
Long Statement,FwBuildTasks,CollectTargets,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CollectTargets.cs,WriteTargetFiles,The length of the statement  "							writer.WriteLine("\t\t<Message Text=\"Finished building {0} and running tests.\" Condition=\"'$(action)'=='test'\"/>"' project); " is 128.
Long Statement,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,Execute,The length of the statement  "				Log.LogMessage(MessageImportance.Normal' "Running {0} (timeout = {1} seconds)"' TestProgramName' ((double)Timeout/1000.0).ToString("F1")); " is 138.
Long Statement,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,Execute,The length of the statement  "							Log.LogMessage(MessageImportance.Normal' "Tests for {0} timed out' but appear to have finished. Giving 2 seconds for log to be written."' TestProgramName); " is 155.
Long Statement,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,Execute,The length of the statement  "							// If the tests completed' don't fail with a timeout; if missing Dispose calls caused NUnit to hang' that should be caught as a different failure. " is 146.
Long Statement,FwBuildTasks,XslTransformation,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\XslTransformation.cs,ValidateAttributes,The length of the statement  "				Log.LogError("XslTransformation: one of XslContent' XslInputPath' and XslCompiledDllPath must be specified' but not more than one."); " is 133.
Long Statement,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The length of the statement  "			var regex = new Regex(@"^\s*(MIDL_INTERFACE|class DECLSPEC_UUID)\(""(........)-(....)-(....)-(..)(..)-(..)(..)(..)(..)(..)(..)""\)\s*\n\s*(?<name>\w+)\s*(:|;)"' " is 160.
Long Statement,SIL.FieldWorks.Build.Tasks,RegFreeCreator,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\RegFreeCreator.cs,ProcessInterfaces,The length of the statement  "						Debug.WriteLine("Interface {0} is {1}: {2} methods' proxy: {3}"' interfaceIid' interfaceName' numMethods' proxyStubClsId); " is 122.
Long Statement,SIL.FieldWorks.Build.Tasks,RegFreeCreator,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\RegFreeCreator.cs,AddDependentAssembly,The length of the statement  "			var depAsmElem = (XmlElement) parent.SelectSingleNode(string.Format("asmv1:dependency/asmv1:dependentAssembly[@asmv2:codebase = '{0}']"' Path.GetFileName(fileName))' _nsManager); " is 178.
Long Statement,SIL.FieldWorks.Build.Tasks,RegFreeCreator,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\RegFreeCreator.cs,AddDependentAssembly,The length of the statement  "			var manifestAsmIdElem = (XmlElement) depAsmManifestDoc.SelectSingleNode("/asmv1:assembly/asmv1:assemblyIdentity"' depAsmNsManager); " is 131.
Long Statement,SIL.FieldWorks.Build.Tasks,RegFreeCreator,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\RegFreeCreator.cs,ProcessTypeInfo,The length of the statement  "						_log.LogMessage(MessageImportance.Low' string.Format(@"Coclass: clsid=""{0}""' threadingModel=""{1}""' tlbid=""{2}""' progid=""{3}"""' " is 134.
Long Statement,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,StoreTranslatedAttributes,The length of the statement  "				comment => comment == null || (!comment.StartsWith("/") && !comment.StartsWith("file:///")) || !IsFromXmlAttribute(comment)' " is 124.
Long Statement,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,CheckForPoFileProblems,The length of the statement  "					"{0} contains a suspicious string ({1}) that is probably a mis-typed string substitution marker using a letter in place of digit 0 or 1")) " is 138.
Long Statement,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,CheckForPoFileProblems,The length of the statement  "					"{0} contains a suspicious string ({1}) that is probably a mis-typed string substitution marker with braces messed up")) " is 120.
Long Statement,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,CheckForPoFileProblems,The length of the statement  "					"{0} contains a suspicious string ({1}) that is probably a mis-typed string substitution marker with braces messed up")) " is 120.
Long Statement,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,CheckForPoFileProblems,The length of the statement  "					"{0} contains a suspicious string in ({1}) that is probably a mis-typed string substitution marker with a missing opening brace")) " is 130.
Long Statement,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,CheckForPoFileProblems,The length of the statement  "					"{0} contains a suspicious string ({1}) that is probably a mis-typed string substitution marker with a missing closing brace")) " is 127.
Long Statement,SIL.FieldWorks.Build.Tasks.Localization,PoString,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\PoString.cs,CompareMsgIds,The length of the statement  "			return left.MsgIds.Count > right.MsgIds.Count ? 1 : string.Compare(left.MsgIds[0]' right.MsgIds[0]' StringComparison.Ordinal); " is 126.
Long Statement,SIL.FieldWorks.Build.Tasks.Localization,ProjectLocalizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\ProjectLocalizer.cs,RunAssemblyLinker,The length of the statement  "			Directory.CreateDirectory(Path.GetDirectoryName(outputDllPath)); // make sure the directory in which we want to make it exists. " is 127.
Long Statement,SIL.FieldWorks.Build.Tasks.Localization,ProjectLocalizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\ProjectLocalizer.cs,RunResGen,The length of the statement  "				// It needs to be able to reference the appropriate System.Drawing.dll and System.Windows.Forms.dll to make the conversion. " is 123.
Complex Conditional,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,IsDisposeBoolCall,The conditional expression  "disposeBool.Name == methodBase.Name && typeName.Contains("`") && typeName.Contains("[") && typeName.Contains("]")"  is complex.
Complex Conditional,FwBuildTasks,CollectTargets,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CollectTargets.cs,ProcessCsProjFile,The conditional expression  "project == "ICSharpCode.SharpZLib" ||  				project == "VwGraphicsReplayer" ||  				project == "SfmStats" ||  				project == "ConvertSFM""  is complex.
Empty Catch Block,FwBuildTasks,ForceDelete,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ForceDelete.cs,Execute,The method has an empty catch block.
Empty Catch Block,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,Execute,The method has an empty catch block.
Empty Catch Block,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,Execute,The method has an empty catch block.
Empty Catch Block,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,StreamReaderThread_Output,The method has an empty catch block.
Empty Catch Block,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,StreamReaderThread_Error,The method has an empty catch block.
Empty Catch Block,SIL.FieldWorks.Build.Tasks,RegFree,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\RegFree.cs,Execute,The method has an empty catch block.
Magic Number,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,MethodCallsBaseDispose,The following statement contains a magic number: for(var i = testInstructions.Count - 2; i > 1; i--)  			{  				if (testInstructions[i].opCode == OpCodes.Call && Equals(baseDispose' testModule.ResolveMethod((int) testInstructions[i].operand)))  					// Found the call; make sure we pass `disposing`  					return testInstructions[i - 2].opCode == OpCodes.Ldarg_0  						&& testInstructions[i - 1].opCode == OpCodes.Ldarg_1  						&& (IsUnix || testInstructions[i + 1].opCode == OpCodes.Nop);  			}
Magic Number,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,MethodCallsBaseDispose,The following statement contains a magic number: for(var i = testInstructions.Count - 2; i > 1; i--)  			{  				if (testInstructions[i].opCode == OpCodes.Call && Equals(baseDispose' testModule.ResolveMethod((int) testInstructions[i].operand)))  					// Found the call; make sure we pass `disposing`  					return testInstructions[i - 2].opCode == OpCodes.Ldarg_0  						&& testInstructions[i - 1].opCode == OpCodes.Ldarg_1  						&& (IsUnix || testInstructions[i + 1].opCode == OpCodes.Nop);  			}
Magic Number,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,FinalizerCallsDisposeFalse,The following statement contains a magic number: for (var i = IsUnix ? 2 : 3; i < instructions.Length - 2; i++)  			{  				try  				{  					if ((instructions[i].opCode == OpCodes.Callvirt || instructions[i].opCode == OpCodes.Call)  						&& IsDisposeBoolCall(module' (int) instructions[i].operand' disposeBool))  						// found the call; make sure we pass `false`  						return PassesFalse(instructions' i);  				}  				catch (ArgumentException) // Probably failed to ResolveMethod for a parameterizable type  				{  					if (PassesFalse(instructions' i))  					{  						// The call or callvirt looks like a proper Dispose(false) call (except for the failed ResolveMethod). It's good enough.  						// On Windows' since we're slightly less sure' also log a warning.  						if (!IsUnix)  						{  							Log.LogWarning($"Clouseau has found no problems with ~{finalizer.DeclaringType}() but cannot yet complete the inspection");  							PrintMethodComparison(GetMethodPattern(GetFinalizer(typeof(ExemplarDisposable)))' instructions);  						}  						return true;  					}  					// else' this may be some other call; keep looking  				}  			}
Magic Number,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,FinalizerCallsDisposeFalse,The following statement contains a magic number: for (var i = IsUnix ? 2 : 3; i < instructions.Length - 2; i++)  			{  				try  				{  					if ((instructions[i].opCode == OpCodes.Callvirt || instructions[i].opCode == OpCodes.Call)  						&& IsDisposeBoolCall(module' (int) instructions[i].operand' disposeBool))  						// found the call; make sure we pass `false`  						return PassesFalse(instructions' i);  				}  				catch (ArgumentException) // Probably failed to ResolveMethod for a parameterizable type  				{  					if (PassesFalse(instructions' i))  					{  						// The call or callvirt looks like a proper Dispose(false) call (except for the failed ResolveMethod). It's good enough.  						// On Windows' since we're slightly less sure' also log a warning.  						if (!IsUnix)  						{  							Log.LogWarning($"Clouseau has found no problems with ~{finalizer.DeclaringType}() but cannot yet complete the inspection");  							PrintMethodComparison(GetMethodPattern(GetFinalizer(typeof(ExemplarDisposable)))' instructions);  						}  						return true;  					}  					// else' this may be some other call; keep looking  				}  			}
Magic Number,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,FinalizerCallsDisposeFalse,The following statement contains a magic number: for (var i = IsUnix ? 2 : 3; i < instructions.Length - 2; i++)  			{  				try  				{  					if ((instructions[i].opCode == OpCodes.Callvirt || instructions[i].opCode == OpCodes.Call)  						&& IsDisposeBoolCall(module' (int) instructions[i].operand' disposeBool))  						// found the call; make sure we pass `false`  						return PassesFalse(instructions' i);  				}  				catch (ArgumentException) // Probably failed to ResolveMethod for a parameterizable type  				{  					if (PassesFalse(instructions' i))  					{  						// The call or callvirt looks like a proper Dispose(false) call (except for the failed ResolveMethod). It's good enough.  						// On Windows' since we're slightly less sure' also log a warning.  						if (!IsUnix)  						{  							Log.LogWarning($"Clouseau has found no problems with ~{finalizer.DeclaringType}() but cannot yet complete the inspection");  							PrintMethodComparison(GetMethodPattern(GetFinalizer(typeof(ExemplarDisposable)))' instructions);  						}  						return true;  					}  					// else' this may be some other call; keep looking  				}  			}
Magic Number,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,PassesFalse,The following statement contains a magic number: return (IsUnix || instructions[callIdx - 3].opCode == OpCodes.Nop)  				&& instructions[callIdx - 2].opCode == OpCodes.Ldarg_0  				&& instructions[callIdx - 1].opCode == OpCodes.Ldc_I4_0 // ldc.i4.0 is literal false  				&& (IsUnix || instructions[callIdx + 1].opCode == OpCodes.Nop);
Magic Number,FwBuildTasks,Clouseau,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Clouseau.cs,PassesFalse,The following statement contains a magic number: return (IsUnix || instructions[callIdx - 3].opCode == OpCodes.Nop)  				&& instructions[callIdx - 2].opCode == OpCodes.Ldarg_0  				&& instructions[callIdx - 1].opCode == OpCodes.Ldc_I4_0 // ldc.i4.0 is literal false  				&& (IsUnix || instructions[callIdx + 1].opCode == OpCodes.Nop);
Magic Number,FwBuildTasks,ILReader,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CodeReader\ILReader.cs,ReadUInt16,The following statement contains a magic number: _position += 2;
Magic Number,FwBuildTasks,ILReader,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CodeReader\ILReader.cs,ReadUInt16,The following statement contains a magic number: return BitConverter.ToUInt16(_byteArray' _position - 2);
Magic Number,FwBuildTasks,ILReader,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CodeReader\ILReader.cs,ReadInt32,The following statement contains a magic number: _position += 4;
Magic Number,FwBuildTasks,ILReader,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CodeReader\ILReader.cs,ReadInt32,The following statement contains a magic number: return BitConverter.ToInt32(_byteArray' _position - 4);
Magic Number,FwBuildTasks,ILReader,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CodeReader\ILReader.cs,ReadInt64,The following statement contains a magic number: _position += 8;
Magic Number,FwBuildTasks,ILReader,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CodeReader\ILReader.cs,ReadInt64,The following statement contains a magic number: return BitConverter.ToInt64(_byteArray' _position - 8);
Magic Number,FwBuildTasks,ILReader,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CodeReader\ILReader.cs,ReadSingle,The following statement contains a magic number: _position += 4;
Magic Number,FwBuildTasks,ILReader,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CodeReader\ILReader.cs,ReadSingle,The following statement contains a magic number: return BitConverter.ToSingle(_byteArray' _position - 4);
Magic Number,FwBuildTasks,ILReader,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CodeReader\ILReader.cs,ReadDouble,The following statement contains a magic number: _position += 8;
Magic Number,FwBuildTasks,ILReader,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CodeReader\ILReader.cs,ReadDouble,The following statement contains a magic number: return BitConverter.ToDouble(_byteArray' _position - 8);
Magic Number,FwBuildTasks,DownloadFile,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFile.cs,DoDownloadFile,The following statement contains a magic number: try  			{  				// Create a request for the specified remote file name  				var request = WebRequest.Create(remoteFilename);  				// If a username or password have been given' use them  				if (!string.IsNullOrEmpty(httpUsername) || !string.IsNullOrEmpty(httpPassword))  				{  					var username = httpUsername;  					var password = httpPassword;  					request.Credentials = new NetworkCredential(username' password);  				}    				// Prevent caching of requests so that we always download latest  				request.Headers[HttpRequestHeader.CacheControl] = "no-cache";    				// Send the request to the server and retrieve the WebResponse object  				response = (HttpWebResponse) request.GetResponse();  				if (response.StatusCode == HttpStatusCode.OK)  				{  					lastModified = response.LastModified;  					if (File.Exists(localFilename) && lastModified == File.GetLastWriteTime(localFilename))  						return Result.UpToDate;    					// Once the WebResponse object has been retrieved' get the stream object associated with the response's data  					remoteStream = response.GetResponseStream();  					if (remoteStream == null)  						return Result.NoResponse;    					// Create the local file  					localStream = File.Create(localFilename);    					// Allocate a 1k buffer  					var buffer = new byte[1024];  					int bytesRead' totalBytesRead = 0;  					// Simple do/while loop to read from stream until no bytes are returned  					do  					{  						// Read data (up to 1k) from the stream  						bytesRead = remoteStream.Read(buffer' 0' buffer.Length);    						// Write the data to the local file  						localStream.Write(buffer' 0' bytesRead);    						// Increment total bytes processed  						totalBytesRead += bytesRead;  					} while (bytesRead > 0);  					Log.LogMessage(MessageImportance.Low' "{0} bytes written to {1} from {2}"' totalBytesRead' localFilename' remoteFilename);  					return Result.Downloaded;  				}  				else  				{  					Log.LogWarning("Unexpected Server Response[{0}] when downloading {1}"' response.StatusCode' Path.GetFileName(localFilename));  				}  			}  			catch (WebException wex)  			{  				if (wex.Status == WebExceptionStatus.ConnectFailure || wex.Status == WebExceptionStatus.NameResolutionFailure)  				{  					// We probably don't have a network connection (despite the check in the caller).  					Log.LogWarning("Could not retrieve latest {0}. No network connection."' remoteFilename);  					return Result.NoResponse;  				}  				string html = null;  				if (wex.Response != null)  					using (var errStream = wex.Response.GetResponseStream())  						if(errStream != null)  							using (var sr = new StreamReader(errStream))  								html = sr.ReadToEnd();  				if (html != null)  				{  					Log.LogWarning("Could not download from {0}. Server responds {1}"' remoteFilename' html);  					return Result.FinalFailure; // The server responded' but did not return the requested resource. It probably won't next time' either' so give up now.  				}  				Log.LogWarning("Could not download from {0}. Exception {1}. Status {2}"' remoteFilename' wex.Message' wex.Status);  				return Result.NoResponse;  			}  			catch (Exception e)  			{  				Log.LogError(e.Message);  				Log.LogMessage(MessageImportance.Normal' e.StackTrace);  			}  			finally  			{  				// Close the response and streams objects here to make sure they're closed even if an exception is thrown at some point  				if (response != null) response.Close();  				if (remoteStream != null) remoteStream.Close();  				if (localStream != null)  				{  					localStream.Close();  					// ReSharper disable once ObjectCreationAsStatement  					// Justification: all we need to do with the new FileInfo is set LastWriteTime' which is saved immediately  					new FileInfo(localFilename) { LastWriteTime = lastModified };  				}  			}
Magic Number,FwBuildTasks,GenerateTestCoverageReport,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\GenerateTestCoverageReport.cs,RunDotCover,The following statement contains a magic number: try  			{  				msg = string.Format("Starting program: {1} ({2}) in {0}"'  					process.StartInfo.WorkingDirectory'  					process.StartInfo.FileName'  					process.StartInfo.Arguments);    				Log.LogMessage(MessageImportance.Low' msg);    				process.Start();  				process.WaitForExit(30 * 60 * 1000);  			}  			catch (Exception ex)  			{  				throw new Exception(String.Format("Got exception starting {0}"' process.StartInfo.FileName)' ex);  			}
Magic Number,FwBuildTasks,GenerateTestCoverageReport,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\GenerateTestCoverageReport.cs,RunDotCover,The following statement contains a magic number: try  			{  				msg = string.Format("Starting program: {1} ({2}) in {0}"'  					process.StartInfo.WorkingDirectory'  					process.StartInfo.FileName'  					process.StartInfo.Arguments);    				Log.LogMessage(MessageImportance.Low' msg);    				process.Start();  				process.WaitForExit(30 * 60 * 1000);  			}  			catch (Exception ex)  			{  				throw new Exception(String.Format("Got exception starting {0}"' process.StartInfo.FileName)' ex);  			}
Magic Number,FwBuildTasks,GenerateTestCoverageReport,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\GenerateTestCoverageReport.cs,RunDotCover,The following statement contains a magic number: try  			{  				msg = string.Format("Starting program: {1} ({2}) in {0}"'  					process.StartInfo.WorkingDirectory'  					process.StartInfo.FileName'  					process.StartInfo.Arguments);    				Log.LogMessage(MessageImportance.Low' msg);    				process.Start();  				process.WaitForExit(30 * 60 * 1000);  			}  			catch (Exception ex)  			{  				throw new Exception(String.Format("Got exception starting {0}"' process.StartInfo.FileName)' ex);  			}
Magic Number,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,CreateTestPoFile,The following statement contains a magic number: Assert.That(data.Length % 3' Is.EqualTo(0));
Magic Number,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,CreateTestPoFile,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 3 )  			{  				writer.WriteLine("#" + data[i]);  				writer.WriteLine("msgid \"" + data[i + 1] + "\"");  				writer.WriteLine("msgstr \"" + data[i + 2] + "\"");  				writer.WriteLine();    			}
Magic Number,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,CreateTestPoFile,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 3 )  			{  				writer.WriteLine("#" + data[i]);  				writer.WriteLine("msgid \"" + data[i + 1] + "\"");  				writer.WriteLine("msgstr \"" + data[i + 2] + "\"");  				writer.WriteLine();    			}
Magic Number,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,DoIt,The following statement contains a magic number: Assert.That(InstrumentedProjectLocalizer.LinkerPath.Count' Is.EqualTo(4));
Magic Number,FwBuildTasks,LocalizeFieldWorksTests,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\FwBuildTasksTests\LocalizeFieldWorksTests.cs,DoIt_BinaryOnly,The following statement contains a magic number: Assert.That(InstrumentedProjectLocalizer.LinkerPath.Count' Is.EqualTo(4));
Magic Number,FwBuildTasks,Substitute,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Substitute.cs,ParseSymbolFile,The following statement contains a magic number: while (!reader.EndOfStream)  			{  				var line = reader.ReadLine();  				lineNumber++;  				// Ignore empty lines' comments' or if we somehow get a null at the end.  				if (string.IsNullOrWhiteSpace(line) || line.StartsWith("//"))  					continue;  				var items = line.Split('=');  				if (items.Length != 2 || items[0].Trim().Length == 0)  				{  					log.LogMessage(MessageImportance.High' "Invalid symbol file: '{0}' line {1} should be Name=Value"' symbolFile' lineNumber);  					return false;  				}  				substitutions[items[0].Trim()] = items[1].Trim();  			}
Magic Number,FwBuildTasks,NUnit,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\NUnit.cs,ProcessOutput,The following statement contains a magic number: if (fTimedOut)  			{  				if (File.Exists(OutputXmlFile))  				{  					FileInfo fi = new FileInfo(OutputXmlFile);  					if (fi.Length > 0)  						File.Move(OutputXmlFile' OutputXmlFile + "-partial");  					else  						File.Delete(OutputXmlFile);  				}  				using (StreamWriter writer = new StreamWriter(OutputXmlFile))  				{  					var num = lines.Count;  					writer.WriteLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");  					writer.WriteLine("<test-results name=\"{0}\" total=\"{1}\" errors=\"{2}\" failures=\"{3}\" not-run=\"{4}\" inconclusive=\"{5}\" ignored=\"{6}\" skipped=\"{7}\" invalid=\"{8}\" date=\"{9}\" time=\"{10}\">"'  										FixturePath' num + 1' 0' 1' 0' num' 0' 0' 0'  										DateTime.Now.ToShortDateString()' DateTime.Now.ToString("HH:mm:ss"));  					writer.WriteLine("  <test-suite type=\"Assembly\" name=\"{0}\" executed=\"True\" result=\"Timeout\" success=\"False\" time=\"{1}\">"'  										FixturePath' delta.TotalSeconds.ToString("F3"));  					writer.WriteLine("    <results>");  					writer.WriteLine("      <test-suite name=\"Timeout\">");  					writer.WriteLine("        <results>");  					writer.WriteLine("          <test-case name=\"Timeout\" success=\"False\" time=\"{0}\" asserts=\"0\"/>"' ((double)Timeout / 1000.0).ToString("F3"));  					writer.WriteLine("        </results>");  					writer.WriteLine("      </test-suite>");  					writer.WriteLine("    </results>");  					writer.WriteLine("  </test-suite>");  					writer.WriteLine("<!-- tests tried before time ran out:");  					foreach (var line in lines)  						writer.WriteLine(line.Substring(6));  					writer.WriteLine("-->");  					writer.WriteLine("</test-results>");  				}  			}
Magic Number,FwBuildTasks,NUnit,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\NUnit.cs,ProcessOutput,The following statement contains a magic number: if (fTimedOut)  			{  				if (File.Exists(OutputXmlFile))  				{  					FileInfo fi = new FileInfo(OutputXmlFile);  					if (fi.Length > 0)  						File.Move(OutputXmlFile' OutputXmlFile + "-partial");  					else  						File.Delete(OutputXmlFile);  				}  				using (StreamWriter writer = new StreamWriter(OutputXmlFile))  				{  					var num = lines.Count;  					writer.WriteLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");  					writer.WriteLine("<test-results name=\"{0}\" total=\"{1}\" errors=\"{2}\" failures=\"{3}\" not-run=\"{4}\" inconclusive=\"{5}\" ignored=\"{6}\" skipped=\"{7}\" invalid=\"{8}\" date=\"{9}\" time=\"{10}\">"'  										FixturePath' num + 1' 0' 1' 0' num' 0' 0' 0'  										DateTime.Now.ToShortDateString()' DateTime.Now.ToString("HH:mm:ss"));  					writer.WriteLine("  <test-suite type=\"Assembly\" name=\"{0}\" executed=\"True\" result=\"Timeout\" success=\"False\" time=\"{1}\">"'  										FixturePath' delta.TotalSeconds.ToString("F3"));  					writer.WriteLine("    <results>");  					writer.WriteLine("      <test-suite name=\"Timeout\">");  					writer.WriteLine("        <results>");  					writer.WriteLine("          <test-case name=\"Timeout\" success=\"False\" time=\"{0}\" asserts=\"0\"/>"' ((double)Timeout / 1000.0).ToString("F3"));  					writer.WriteLine("        </results>");  					writer.WriteLine("      </test-suite>");  					writer.WriteLine("    </results>");  					writer.WriteLine("  </test-suite>");  					writer.WriteLine("<!-- tests tried before time ran out:");  					foreach (var line in lines)  						writer.WriteLine(line.Substring(6));  					writer.WriteLine("-->");  					writer.WriteLine("</test-results>");  				}  			}
Magic Number,FwBuildTasks,CollectTargets,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CollectTargets.cs,GetProjectSubDir,The following statement contains a magic number: if (projectSubDir.StartsWith("/Src/"))  				projectSubDir = projectSubDir.Substring(5);  			else if (projectSubDir.StartsWith("/Lib/src/"))  				projectSubDir = projectSubDir.Substring(9);  			else if (projectSubDir.StartsWith("/"))  				projectSubDir = projectSubDir.Substring(1);
Magic Number,FwBuildTasks,CollectTargets,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CollectTargets.cs,GetProjectSubDir,The following statement contains a magic number: if (projectSubDir.StartsWith("/Src/"))  				projectSubDir = projectSubDir.Substring(5);  			else if (projectSubDir.StartsWith("/Lib/src/"))  				projectSubDir = projectSubDir.Substring(9);  			else if (projectSubDir.StartsWith("/"))  				projectSubDir = projectSubDir.Substring(1);
Magic Number,FwBuildTasks,CollectTargets,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CollectTargets.cs,WriteTargetFiles,The following statement contains a magic number: try  			{  				// Write all the C# targets and their dependencies.  				using (var writer = new StreamWriter(targetsFile))  				{  					writer.WriteLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");  					writer.WriteLine("<!-- This file is automatically generated by the Setup target.  DO NOT EDIT! -->");  					writer.WriteLine("<!-- Unfortunately' the new one is generated after the old one has been read. -->");  					writer.WriteLine("<!-- 'msbuild /t:refreshTargets' generates this file and does nothing else. -->");  					writer.WriteLine("<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" ToolsVersion=\"14.0\">");  					writer.WriteLine();  					foreach (var project in m_mapProjFile.Keys)  					{  						LoadProjectFile(m_mapProjFile[project]);    						var isTestProject = project.EndsWith("Tests") || project == "TestManager" || project == "ProjectUnpacker";    						// <Choose> to define DefineConstants  						writer.WriteLine("\t<Choose>");  						var otherwiseBldr = new StringBuilder();  						var otherwiseAdded = false;  						var configs = new Dictionary<string' string>();  						foreach (XmlNode node in ConfigNodes)  						{  							var condition = node.Attributes["Condition"].InnerText;  							var tmp = condition.Substring(condition.IndexOf("==") + 2).Trim().Trim('\'');  							var configuration = tmp.Substring(0' tmp.IndexOf("|"));    							// Add configuration only once even if same configuration is contained  							// for multiple platforms' e.g. for AnyCpu and x64.  							if (configs.ContainsKey(configuration))  							{  								if (configs[configuration] != node.SelectSingleNode("c:DefineConstants"' m_namespaceMgr).InnerText.Replace(";"' " "))  								{  									Log.LogError("Configuration {0} for project {1} is defined several times " +  										"but contains differing values for DefineConstants."' configuration' project);  								}  								continue;  							}  							configs.Add(configuration' node.SelectSingleNode("c:DefineConstants"' m_namespaceMgr).InnerText.Replace(";"' " "));    							writer.WriteLine("\t\t<When Condition=\" '$(config-capital)' == '{0}' \">"' configuration);  							writer.WriteLine("\t\t\t<PropertyGroup>");  							writer.WriteLine("\t\t\t\t<{0}Defines>{1} CODE_ANALYSIS</{0}Defines>"'  								project' configs[configuration]);  							writer.WriteLine("\t\t\t</PropertyGroup>");  							writer.WriteLine("\t\t</When>");  							if (condition.Contains("Debug") && !otherwiseAdded)  							{  								otherwiseBldr.AppendLine("\t\t<Otherwise>");  								otherwiseBldr.AppendLine("\t\t\t<PropertyGroup>");  								otherwiseBldr.AppendLine(string.Format("\t\t\t\t<{0}Defines>{1} CODE_ANALYSIS</{0}Defines>"' project'  									node.SelectSingleNode("c:DefineConstants"' m_namespaceMgr).InnerText.Replace(";"' " ")));  								otherwiseBldr.AppendLine("\t\t\t</PropertyGroup>");  								otherwiseBldr.AppendLine("\t\t</Otherwise>");  								otherwiseAdded = true;  							}  						}  						writer.Write(otherwiseBldr.ToString());  						writer.WriteLine("\t</Choose>");  						writer.WriteLine();    						writer.Write("\t<Target Name=\"{0}\""' project);  						var bldr = new StringBuilder();  						bldr.Append("Initialize"); // ensure the output directories and version files exist.  						if (project == "ParatextImportTests" || project == "FwCoreDlgsTests")  						{  							// The ParatextImportTests and FwCoreDlgsTests require that the ScrChecks.dll be in DistFiles/Editorial Checks.  							// We don't discover that dependency because it's not a reference (LT-13777).  							bldr.Append(";ScrChecks");  						}  						var dependencies = m_mapProjDepends[project];  						dependencies.Sort();  						foreach (var dep in dependencies)  						{  							if (m_mapProjFile.ContainsKey(dep))  								bldr.AppendFormat(";{0}"' dep);  						}  						writer.Write(" DependsOnTargets=\"{0}\""' bldr);    						if (project == "MigrateSqlDbs")  						{  							writer.Write(" Condition=\"'$(OS)'=='Windows_NT'\"");  						}  						if (project.StartsWith("ManagedVwWindow"))  						{  							writer.Write(" Condition=\"'$(OS)'=='Unix'\"");  						}  						writer.WriteLine(">");    						// <MsBuild> task  						writer.WriteLine("\t\t<MSBuild Projects=\"{0}\""' m_mapProjFile[project].Replace(m_fwroot' "$(fwrt)"));  						writer.WriteLine("\t\t\tTargets=\"$(msbuild-target)\"");  						writer.WriteLine("\t\t\tProperties=\"$(msbuild-props);IntermediateOutputPath=$(dir-fwobj){0}{1}{0};DefineConstants=$({2}Defines);$(warningsAsErrors);WarningLevel=4;LcmArtifactsDir=$(LcmArtifactsDir)\""'  							Path.DirectorySeparatorChar' GetProjectSubDir(project)' project);  						writer.WriteLine("\t\t\tToolsVersion=\"14.0\"/>");    						// <Clouseau> verification task  						writer.WriteLine("\t\t<Clouseau Condition=\"'$(Configuration)' == 'Debug'\" AssemblyPathname=\"$(dir-outputBase)/{0}\"/>"' AssemblyName);    						if (isTestProject)  						{  							// <NUnit> task  							writer.WriteLine("\t\t<Message Text=\"Running unit tests for {0}\" />"' project);  							writer.WriteLine("\t\t<NUnit Condition=\"'$(action)'=='test'\"");  							writer.WriteLine("\t\t\tAssemblies=\"$(dir-outputBase)/{0}.dll\""' project);  							writer.WriteLine("\t\t\tToolPath=\"$(fwrt)/Bin/NUnit/bin\"");  							writer.WriteLine("\t\t\tWorkingDirectory=\"$(dir-outputBase)\"");  							writer.WriteLine("\t\t\tOutputXmlFile=\"$(dir-outputBase)/{0}.dll-nunit-output.xml\""' project);  							writer.WriteLine("\t\t\tForce32Bit=\"$(useNUnit-x86)\"");  							writer.WriteLine("\t\t\tExcludeCategory=\"$(excludedCategories)\"");  							// Don't continue on error. NUnit returns 0 even if there are failed tests.  							// A non-zero return code means a configuration error or that NUnit crashed  							// - we shouldn't ignore those.  							//writer.WriteLine("\t\t\tContinueOnError=\"true\"");  							writer.WriteLine("\t\t\tFudgeFactor=\"$(timeoutFudgeFactor)\"");  							writer.WriteLine("\t\t\tTimeout=\"{0}\">"' TimeoutForProject(project));  							writer.WriteLine("\t\t\t<Output TaskParameter=\"FailedSuites\" ItemName=\"FailedSuites\"/>");  							writer.WriteLine("\t\t</NUnit>");  							writer.WriteLine("\t\t<Message Text=\"Finished building {0}.\" Condition=\"'$(action)'!='test'\"/>"' project);  							writer.WriteLine("\t\t<Message Text=\"Finished building {0} and running tests.\" Condition=\"'$(action)'=='test'\"/>"' project);  							// Generate dotCover task  							GenerateDotCoverTask(writer' new[] {project}' $"{project}.coverage.xml");  						}  						else  						{  							writer.WriteLine("\t\t<Message Text=\"Finished building {0}.\"/>"' project);  						}  						writer.WriteLine("\t</Target>");  						writer.WriteLine();  					}  					writer.Write("\t<Target Name=\"allCsharp\" DependsOnTargets=\"");  					bool first = true;  					foreach (var project in m_mapProjFile.Keys)  					{  						// These projects are experimental.  						// These projects weren't built by nant normally.  						if (project == "FxtExe")  						{  							continue;  						}  						if (first)  							writer.Write(project);  						else  							writer.Write(";{0}"' project);  						first = false;  					}  					writer.WriteLine("\"/>");  					writer.WriteLine();  					writer.Write("\t<Target Name=\"allCsharpNoTests\" DependsOnTargets=\"");  					first = true;  					foreach (var project in m_mapProjFile.Keys)  					{  						// These projects are experimental.  						// These projects weren't built by nant normally.  						if (project == "FxtExe" ||  							project.EndsWith("Tests") || // These are tests.  							project == "ProjectUnpacker") // This is only used in tests.  						{  							continue;  						}  						if (first)  							writer.Write(project);  						else  							writer.Write(";{0}"' project);  						first = false;  					}  					writer.WriteLine("\"/>");    					writer.WriteLine("</Project>");  					writer.Flush();  					writer.Close();  				}  				Console.WriteLine("Created {0}"' targetsFile);  			}  			catch (Exception e)  			{  				var badFile = targetsFile + ".bad";  				File.Move(targetsFile' badFile);  				Console.WriteLine("Failed to Create FieldWorks.targets bad result stored in {0}"' badFile);  				throw new StopTaskException(e);  			}
Magic Number,FwBuildTasks,CollectTargets,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\CollectTargets.cs,TimeoutForProject,The following statement contains a magic number: return (m_timeoutMap.ContainsKey(project) ? m_timeoutMap[project] : m_timeoutMap["default"])*1000;
Magic Number,FwBuildTasks,BuildUtils,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\BuildUtils.cs,GetAssemblyFolder,The following statement contains a magic number: if (codebase.StartsWith("file:///"))  				path = codebase.Substring(7);  			else  				path = codebase;
Magic Number,FwBuildTasks,BuildUtils,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\BuildUtils.cs,ApplyLinuxXslt,The following statement contains a magic number: try  			{  				xmlInitParser();  				xmlSubstituteEntitiesDefault(1);  				xsltSetXIncludeDefault(1);  				exsltRegisterAll();  				var doc = xmlParseFile(inputFile);  				if (doc == IntPtr.Zero)  					throw new Exception($"ApplyLinuxXslt: Cannot parse XML file \"{inputFile}\"");  				var parameters = new string[2 * xparams.Count + 1];  				var i = 0;  				foreach (var xparam in xparams)  				{  					parameters[i++] = xparam.Name;  					parameters[i++] = $"'{xparam.Value}'";  				}  				parameters[i] = null;  				var res = xsltApplyStylesheet(xsl' doc' parameters);  				xmlFreeDoc(doc);  				if (res == IntPtr.Zero)  					throw new Exception($"ApplyLinuxXslt: Applying stylesheet to \"{inputFile}\" failed.");  				var ok = xsltSaveResultToFilename(outputFile' res' xsl' 0);  				xmlFreeDoc(res);  				if (ok < 0)  					throw new Exception($"ApplyLinuxXslt: Cannot save result file \"{outputFile}\"");  			}  			finally  			{  				xsltFreeStylesheet(xsl);  			}
Magic Number,FwBuildTasks,Unitpp,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Unitpp.cs,ProcessOutput,The following statement contains a magic number: var notRun = 99999;
Magic Number,FwBuildTasks,Unitpp,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Unitpp.cs,ProcessOutput,The following statement contains a magic number: foreach (var line in m_TestLog)  			{  				var logLine = false; // whether to output line on Console  				if (line.StartsWith("****** top"))  				{  					// This is the first line' just ignore  				}  				else if (line.StartsWith("****** "))  				{  					// Name of the suite  					var regex = new Regex(@"^\*+ (?<name>[^*]+)");  					var match = regex.Match(line);    					FinishTestCase();  					var suite = m_Doc.CreateElement("test-suite");  					suite.SetAttribute("name"' match.Groups["name"].Value.TrimEnd());  					outerResults.AppendChild(suite);  					results = m_Doc.CreateElement("results");  					suite.AppendChild(results);  				}  				else if (line.StartsWith("OK:"))  				{  					// Successful test - grab and report name  					FinishTestCase();  					var name = line.Substring(4); // skip "OK: "  					CreateTestCaseNode(m_Doc' results' name' true);  					++ok;  				}  				else if (line.StartsWith("FAIL:"))  				{  					// Failed test - grab and report name  					FinishTestCase();  					logLine = true;  					var name = line.Substring(6); // skip "FAIL: "  					ReportFailedTestCase(results' name);  					++fail;  				}  				else if (line.Contains(":FAIL:"))  				{  					// Failed test reported with filename and line  					FinishTestCase();  					logLine = true;  					var regex = new Regex("(?<filename>([A-Za-z]:)?[^:]+):(?<lineno>[0-9]+):FAIL: (?<name>[^:]+):(?<message>.+)");  					var match = regex.Match(line);  					var failureNode = ReportFailedTestCase(results' match.Groups["name"].Value.TrimEnd());  					++fail;  // ReSharper disable PossibleNullReferenceException  					m_MsgBldr.AppendLine(match.Groups["message"].Value.TrimEnd());  // ReSharper restore PossibleNullReferenceException  					m_MsgBldr.AppendLine();  					FinishTestCase();  					AppendStackTrace(match' failureNode);  				}  				else if (line.StartsWith("ERROR:"))  				{  					// Failed test - grab and report name  					FinishTestCase();  					logLine = true;  					var name = line.Substring(7); // skip "ERROR: "  					ReportFailedTestCase(results' name);  					++error;  				}  				else if (line.Contains(":ERROR:"))  				{  					// Failed test reported with filename and line  					FinishTestCase();  					logLine = true;  					var regex = new Regex("(?<filename>([A-Za-z]:)?[^:]+):(?<lineno>[0-9]+):ERROR: (?<name>[^:]+):(?<message>.+)");  					var match = regex.Match(line);  					var errorNode = ReportFailedTestCase(results' match.Groups["name"].Value.TrimEnd());  					++error;  // ReSharper disable PossibleNullReferenceException  					m_MsgBldr.AppendLine(match.Groups["message"].Value.TrimEnd());  // ReSharper restore PossibleNullReferenceException  					m_MsgBldr.AppendLine();  					FinishTestCase();  					AppendStackTrace(match' errorNode);  				}  				else if (line.StartsWith("Tests [Ok-Fail-Error]:"))  				{  					// Last line  					FinishTestCase();  					var regex = new Regex(@"Tests \[Ok-Fail-Error\]: \[(?<ok>\d+)-(?<fail>\d+)-(?<error>\d+)\]");  					var match = regex.Match(line);  					ok = Int32.Parse(match.Groups["ok"].Value);  					fail = Int32.Parse(match.Groups["fail"].Value);  					error = Int32.Parse(match.Groups["error"].Value);  					notRun = 0; // we don't keep track of ignored tests  					Log.LogMessage(MessageImportance.Normal' line);  					break;  				}  				else  				{  					logLine = true;  					if (m_MsgBldr != null)  						m_MsgBldr.AppendLine(line);  				}  				if (logLine)  					Log.LogMessage(MessageImportance.Normal' line);  				else  					Log.LogMessage(MessageImportance.Low' line);  			}
Magic Number,FwBuildTasks,Unitpp,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Unitpp.cs,ProcessOutput,The following statement contains a magic number: foreach (var line in m_TestLog)  			{  				var logLine = false; // whether to output line on Console  				if (line.StartsWith("****** top"))  				{  					// This is the first line' just ignore  				}  				else if (line.StartsWith("****** "))  				{  					// Name of the suite  					var regex = new Regex(@"^\*+ (?<name>[^*]+)");  					var match = regex.Match(line);    					FinishTestCase();  					var suite = m_Doc.CreateElement("test-suite");  					suite.SetAttribute("name"' match.Groups["name"].Value.TrimEnd());  					outerResults.AppendChild(suite);  					results = m_Doc.CreateElement("results");  					suite.AppendChild(results);  				}  				else if (line.StartsWith("OK:"))  				{  					// Successful test - grab and report name  					FinishTestCase();  					var name = line.Substring(4); // skip "OK: "  					CreateTestCaseNode(m_Doc' results' name' true);  					++ok;  				}  				else if (line.StartsWith("FAIL:"))  				{  					// Failed test - grab and report name  					FinishTestCase();  					logLine = true;  					var name = line.Substring(6); // skip "FAIL: "  					ReportFailedTestCase(results' name);  					++fail;  				}  				else if (line.Contains(":FAIL:"))  				{  					// Failed test reported with filename and line  					FinishTestCase();  					logLine = true;  					var regex = new Regex("(?<filename>([A-Za-z]:)?[^:]+):(?<lineno>[0-9]+):FAIL: (?<name>[^:]+):(?<message>.+)");  					var match = regex.Match(line);  					var failureNode = ReportFailedTestCase(results' match.Groups["name"].Value.TrimEnd());  					++fail;  // ReSharper disable PossibleNullReferenceException  					m_MsgBldr.AppendLine(match.Groups["message"].Value.TrimEnd());  // ReSharper restore PossibleNullReferenceException  					m_MsgBldr.AppendLine();  					FinishTestCase();  					AppendStackTrace(match' failureNode);  				}  				else if (line.StartsWith("ERROR:"))  				{  					// Failed test - grab and report name  					FinishTestCase();  					logLine = true;  					var name = line.Substring(7); // skip "ERROR: "  					ReportFailedTestCase(results' name);  					++error;  				}  				else if (line.Contains(":ERROR:"))  				{  					// Failed test reported with filename and line  					FinishTestCase();  					logLine = true;  					var regex = new Regex("(?<filename>([A-Za-z]:)?[^:]+):(?<lineno>[0-9]+):ERROR: (?<name>[^:]+):(?<message>.+)");  					var match = regex.Match(line);  					var errorNode = ReportFailedTestCase(results' match.Groups["name"].Value.TrimEnd());  					++error;  // ReSharper disable PossibleNullReferenceException  					m_MsgBldr.AppendLine(match.Groups["message"].Value.TrimEnd());  // ReSharper restore PossibleNullReferenceException  					m_MsgBldr.AppendLine();  					FinishTestCase();  					AppendStackTrace(match' errorNode);  				}  				else if (line.StartsWith("Tests [Ok-Fail-Error]:"))  				{  					// Last line  					FinishTestCase();  					var regex = new Regex(@"Tests \[Ok-Fail-Error\]: \[(?<ok>\d+)-(?<fail>\d+)-(?<error>\d+)\]");  					var match = regex.Match(line);  					ok = Int32.Parse(match.Groups["ok"].Value);  					fail = Int32.Parse(match.Groups["fail"].Value);  					error = Int32.Parse(match.Groups["error"].Value);  					notRun = 0; // we don't keep track of ignored tests  					Log.LogMessage(MessageImportance.Normal' line);  					break;  				}  				else  				{  					logLine = true;  					if (m_MsgBldr != null)  						m_MsgBldr.AppendLine(line);  				}  				if (logLine)  					Log.LogMessage(MessageImportance.Normal' line);  				else  					Log.LogMessage(MessageImportance.Low' line);  			}
Magic Number,FwBuildTasks,Unitpp,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Unitpp.cs,ProcessOutput,The following statement contains a magic number: foreach (var line in m_TestLog)  			{  				var logLine = false; // whether to output line on Console  				if (line.StartsWith("****** top"))  				{  					// This is the first line' just ignore  				}  				else if (line.StartsWith("****** "))  				{  					// Name of the suite  					var regex = new Regex(@"^\*+ (?<name>[^*]+)");  					var match = regex.Match(line);    					FinishTestCase();  					var suite = m_Doc.CreateElement("test-suite");  					suite.SetAttribute("name"' match.Groups["name"].Value.TrimEnd());  					outerResults.AppendChild(suite);  					results = m_Doc.CreateElement("results");  					suite.AppendChild(results);  				}  				else if (line.StartsWith("OK:"))  				{  					// Successful test - grab and report name  					FinishTestCase();  					var name = line.Substring(4); // skip "OK: "  					CreateTestCaseNode(m_Doc' results' name' true);  					++ok;  				}  				else if (line.StartsWith("FAIL:"))  				{  					// Failed test - grab and report name  					FinishTestCase();  					logLine = true;  					var name = line.Substring(6); // skip "FAIL: "  					ReportFailedTestCase(results' name);  					++fail;  				}  				else if (line.Contains(":FAIL:"))  				{  					// Failed test reported with filename and line  					FinishTestCase();  					logLine = true;  					var regex = new Regex("(?<filename>([A-Za-z]:)?[^:]+):(?<lineno>[0-9]+):FAIL: (?<name>[^:]+):(?<message>.+)");  					var match = regex.Match(line);  					var failureNode = ReportFailedTestCase(results' match.Groups["name"].Value.TrimEnd());  					++fail;  // ReSharper disable PossibleNullReferenceException  					m_MsgBldr.AppendLine(match.Groups["message"].Value.TrimEnd());  // ReSharper restore PossibleNullReferenceException  					m_MsgBldr.AppendLine();  					FinishTestCase();  					AppendStackTrace(match' failureNode);  				}  				else if (line.StartsWith("ERROR:"))  				{  					// Failed test - grab and report name  					FinishTestCase();  					logLine = true;  					var name = line.Substring(7); // skip "ERROR: "  					ReportFailedTestCase(results' name);  					++error;  				}  				else if (line.Contains(":ERROR:"))  				{  					// Failed test reported with filename and line  					FinishTestCase();  					logLine = true;  					var regex = new Regex("(?<filename>([A-Za-z]:)?[^:]+):(?<lineno>[0-9]+):ERROR: (?<name>[^:]+):(?<message>.+)");  					var match = regex.Match(line);  					var errorNode = ReportFailedTestCase(results' match.Groups["name"].Value.TrimEnd());  					++error;  // ReSharper disable PossibleNullReferenceException  					m_MsgBldr.AppendLine(match.Groups["message"].Value.TrimEnd());  // ReSharper restore PossibleNullReferenceException  					m_MsgBldr.AppendLine();  					FinishTestCase();  					AppendStackTrace(match' errorNode);  				}  				else if (line.StartsWith("Tests [Ok-Fail-Error]:"))  				{  					// Last line  					FinishTestCase();  					var regex = new Regex(@"Tests \[Ok-Fail-Error\]: \[(?<ok>\d+)-(?<fail>\d+)-(?<error>\d+)\]");  					var match = regex.Match(line);  					ok = Int32.Parse(match.Groups["ok"].Value);  					fail = Int32.Parse(match.Groups["fail"].Value);  					error = Int32.Parse(match.Groups["error"].Value);  					notRun = 0; // we don't keep track of ignored tests  					Log.LogMessage(MessageImportance.Normal' line);  					break;  				}  				else  				{  					logLine = true;  					if (m_MsgBldr != null)  						m_MsgBldr.AppendLine(line);  				}  				if (logLine)  					Log.LogMessage(MessageImportance.Normal' line);  				else  					Log.LogMessage(MessageImportance.Low' line);  			}
Magic Number,FwBuildTasks,Unitpp,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Unitpp.cs,ProcessOutput,The following statement contains a magic number: if (fTimedOut)  			{  				var fakeSuite = m_Doc.CreateElement("test-suite");  				outerResults.AppendChild(fakeSuite);  				fakeSuite.SetAttribute("name"' "Timeout");  				var fakeResults = m_Doc.CreateElement("results");  				fakeSuite.AppendChild(fakeResults);  				var fakeTestCase = m_Doc.CreateElement("test-case");  				fakeResults.AppendChild(fakeTestCase);  				fakeTestCase.SetAttribute("name"' "Timeout");  				fakeTestCase.SetAttribute("success"' "False");  				fakeTestCase.SetAttribute("time"' ((double)Timeout/1000.0).ToString("F3"));  				fakeTestCase.SetAttribute("asserts"' "0");  				notRun = 0;  				++fail;  			}
Magic Number,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,Execute,The following statement contains a magic number: if (Timeout == Int32.MaxValue)  				Log.LogMessage(MessageImportance.Normal' "Running {0}"' TestProgramName);  			else  				Log.LogMessage(MessageImportance.Normal' "Running {0} (timeout = {1} seconds)"' TestProgramName' ((double)Timeout/1000.0).ToString("F1"));
Magic Number,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,Execute,The following statement contains a magic number: try  			{  				// Start the external process  				var process = StartProcess();  				outputThread = new Thread(StreamReaderThread_Output);  				errorThread = new Thread(StreamReaderThread_Error);    				m_StdOut = process.StandardOutput;  				m_StdError = process.StandardError;    				outputThread.Start();  				errorThread.Start();    				// Wait for the process to terminate  				process.WaitForExit(Timeout);    				// Wait for the threads to terminate  				outputThread.Join(2000);  				errorThread.Join(2000);    				bool fTimedOut = !process.WaitForExit(0);	// returns false immediately if still running.  				if (fTimedOut)  				{  					try  					{  						bool testLooksToHaveFinished;  						lock(LockObject)  						{  							testLooksToHaveFinished = !string.IsNullOrEmpty(m_TestLog.FindLast(line => line.Contains(GetTestsCompletedString())));  						}  						if(testLooksToHaveFinished)  						{  							Log.LogMessage(MessageImportance.Normal' "Tests for {0} timed out' but appear to have finished. Giving 2 seconds for log to be written."' TestProgramName);  							Thread.Sleep(2000);  							// If the tests completed' don't fail with a timeout; if missing Dispose calls caused NUnit to hang' that should be caught as a different failure.  							fTimedOut = false;  						}  						if(!process.HasExited) // If the tests looked to have finished the process might have exited normally by now  							process.Kill(); // This will set the exit code to -1 and the suite will be added as a failed suite below  					}  					catch  					{  						// ignore possible exceptions that are thrown when the  						// process is terminated  					}  				}    				TimeSpan delta = DateTime.Now - dtStart;  				Log.LogMessage(MessageImportance.Normal' "Total time for running {0} = {1}"' TestProgramName' delta);    				try  				{  					ProcessOutput(fTimedOut' delta);  				}  				catch //(Exception e)  				{  					//Console.WriteLine("CAUGHT EXCEPTION: {0}"' e.Message);  					//Console.WriteLine("STACK: {0}"' e.StackTrace);  				}    				// If the test timed out' it was killed and its ExitCode is not available.  				// So check for a timeout first.  				if (fTimedOut)  				{  					Log.LogError("The tests in {0} did not finish in {1} milliseconds."'  						TestProgramName' Timeout);  					FailedSuites = FailedSuiteNames;  					retVal = false;  				}  				else if (process.ExitCode != 0)  				{  					Log.LogWarning("{0} returned with exit code {1}"' TestProgramName'  						process.ExitCode);  					FailedSuites = FailedSuiteNames;  					// Return true in this case - at least NUnit returns non-zero exit code when  					// a test fails' but we don't want to stop the build.  				}  			}  			catch (Exception e)  			{  				Log.LogErrorFromException(e' true);  				retVal = false;  			}  			finally  			{  				// ensure outputThread is always aborted  				if (outputThread != null && outputThread.IsAlive)  				{  					outputThread.Abort();  				}  				// ensure errorThread is always aborted  				if (errorThread != null && errorThread.IsAlive)  				{  					errorThread.Abort();  				}  			}
Magic Number,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,Execute,The following statement contains a magic number: try  			{  				// Start the external process  				var process = StartProcess();  				outputThread = new Thread(StreamReaderThread_Output);  				errorThread = new Thread(StreamReaderThread_Error);    				m_StdOut = process.StandardOutput;  				m_StdError = process.StandardError;    				outputThread.Start();  				errorThread.Start();    				// Wait for the process to terminate  				process.WaitForExit(Timeout);    				// Wait for the threads to terminate  				outputThread.Join(2000);  				errorThread.Join(2000);    				bool fTimedOut = !process.WaitForExit(0);	// returns false immediately if still running.  				if (fTimedOut)  				{  					try  					{  						bool testLooksToHaveFinished;  						lock(LockObject)  						{  							testLooksToHaveFinished = !string.IsNullOrEmpty(m_TestLog.FindLast(line => line.Contains(GetTestsCompletedString())));  						}  						if(testLooksToHaveFinished)  						{  							Log.LogMessage(MessageImportance.Normal' "Tests for {0} timed out' but appear to have finished. Giving 2 seconds for log to be written."' TestProgramName);  							Thread.Sleep(2000);  							// If the tests completed' don't fail with a timeout; if missing Dispose calls caused NUnit to hang' that should be caught as a different failure.  							fTimedOut = false;  						}  						if(!process.HasExited) // If the tests looked to have finished the process might have exited normally by now  							process.Kill(); // This will set the exit code to -1 and the suite will be added as a failed suite below  					}  					catch  					{  						// ignore possible exceptions that are thrown when the  						// process is terminated  					}  				}    				TimeSpan delta = DateTime.Now - dtStart;  				Log.LogMessage(MessageImportance.Normal' "Total time for running {0} = {1}"' TestProgramName' delta);    				try  				{  					ProcessOutput(fTimedOut' delta);  				}  				catch //(Exception e)  				{  					//Console.WriteLine("CAUGHT EXCEPTION: {0}"' e.Message);  					//Console.WriteLine("STACK: {0}"' e.StackTrace);  				}    				// If the test timed out' it was killed and its ExitCode is not available.  				// So check for a timeout first.  				if (fTimedOut)  				{  					Log.LogError("The tests in {0} did not finish in {1} milliseconds."'  						TestProgramName' Timeout);  					FailedSuites = FailedSuiteNames;  					retVal = false;  				}  				else if (process.ExitCode != 0)  				{  					Log.LogWarning("{0} returned with exit code {1}"' TestProgramName'  						process.ExitCode);  					FailedSuites = FailedSuiteNames;  					// Return true in this case - at least NUnit returns non-zero exit code when  					// a test fails' but we don't want to stop the build.  				}  			}  			catch (Exception e)  			{  				Log.LogErrorFromException(e' true);  				retVal = false;  			}  			finally  			{  				// ensure outputThread is always aborted  				if (outputThread != null && outputThread.IsAlive)  				{  					outputThread.Abort();  				}  				// ensure errorThread is always aborted  				if (errorThread != null && errorThread.IsAlive)  				{  					errorThread.Abort();  				}  			}
Magic Number,FwBuildTasks,TestTask,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\TestTask.cs,Execute,The following statement contains a magic number: try  			{  				// Start the external process  				var process = StartProcess();  				outputThread = new Thread(StreamReaderThread_Output);  				errorThread = new Thread(StreamReaderThread_Error);    				m_StdOut = process.StandardOutput;  				m_StdError = process.StandardError;    				outputThread.Start();  				errorThread.Start();    				// Wait for the process to terminate  				process.WaitForExit(Timeout);    				// Wait for the threads to terminate  				outputThread.Join(2000);  				errorThread.Join(2000);    				bool fTimedOut = !process.WaitForExit(0);	// returns false immediately if still running.  				if (fTimedOut)  				{  					try  					{  						bool testLooksToHaveFinished;  						lock(LockObject)  						{  							testLooksToHaveFinished = !string.IsNullOrEmpty(m_TestLog.FindLast(line => line.Contains(GetTestsCompletedString())));  						}  						if(testLooksToHaveFinished)  						{  							Log.LogMessage(MessageImportance.Normal' "Tests for {0} timed out' but appear to have finished. Giving 2 seconds for log to be written."' TestProgramName);  							Thread.Sleep(2000);  							// If the tests completed' don't fail with a timeout; if missing Dispose calls caused NUnit to hang' that should be caught as a different failure.  							fTimedOut = false;  						}  						if(!process.HasExited) // If the tests looked to have finished the process might have exited normally by now  							process.Kill(); // This will set the exit code to -1 and the suite will be added as a failed suite below  					}  					catch  					{  						// ignore possible exceptions that are thrown when the  						// process is terminated  					}  				}    				TimeSpan delta = DateTime.Now - dtStart;  				Log.LogMessage(MessageImportance.Normal' "Total time for running {0} = {1}"' TestProgramName' delta);    				try  				{  					ProcessOutput(fTimedOut' delta);  				}  				catch //(Exception e)  				{  					//Console.WriteLine("CAUGHT EXCEPTION: {0}"' e.Message);  					//Console.WriteLine("STACK: {0}"' e.StackTrace);  				}    				// If the test timed out' it was killed and its ExitCode is not available.  				// So check for a timeout first.  				if (fTimedOut)  				{  					Log.LogError("The tests in {0} did not finish in {1} milliseconds."'  						TestProgramName' Timeout);  					FailedSuites = FailedSuiteNames;  					retVal = false;  				}  				else if (process.ExitCode != 0)  				{  					Log.LogWarning("{0} returned with exit code {1}"' TestProgramName'  						process.ExitCode);  					FailedSuites = FailedSuiteNames;  					// Return true in this case - at least NUnit returns non-zero exit code when  					// a test fails' but we don't want to stop the build.  				}  			}  			catch (Exception e)  			{  				Log.LogErrorFromException(e' true);  				retVal = false;  			}  			finally  			{  				// ensure outputThread is always aborted  				if (outputThread != null && outputThread.IsAlive)  				{  					outputThread.Abort();  				}  				// ensure errorThread is always aborted  				if (errorThread != null && errorThread.IsAlive)  				{  					errorThread.Abort();  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,ExtractIIDs,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\ExtractIIDsTask.cs,Execute,The following statement contains a magic number: using (var outfile = new StreamWriter(Output))  			{  				if (UseUnixNewlines)  					outfile.NewLine = "\n";    				outfile.WriteLine("// Automatically generated from {0} by ExtractIIDs task"'  					Path.GetFileName(Input));    				if (LinesToInsertAtTop != null)  				{  					foreach (var line in LinesToInsertAtTop)  						outfile.WriteLine(line.ItemSpec);  				}    				outfile.WriteLine("#include \"{0}\""' Path.GetFileName(Input));  				outfile.WriteLine();    				foreach (Match matchedInterface in regex.Matches(inputContents))  				{  					outfile.WriteLine(  						"DEFINE_UUIDOF({0}' 0x{1}' 0x{2}' 0x{3}' 0x{4}' 0x{5}' 0x{6}' 0x{7}' 0x{8}' 0x{9}' 0x{10}' 0x{11});"'  						matchedInterface.Groups["name"]' matchedInterface.Groups[2]' matchedInterface.Groups[3]'  						matchedInterface.Groups[4]' matchedInterface.Groups[5]' matchedInterface.Groups[6]'  						matchedInterface.Groups[7]' matchedInterface.Groups[8]' matchedInterface.Groups[9]'  						matchedInterface.Groups[10]' matchedInterface.Groups[11]' matchedInterface.Groups[12]);  				}  			}
Magic Number,SIL.FieldWorks.Build.Tasks,RegFreeCreator,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\RegFreeCreator.cs,ProcessTypeInfo,The following statement contains a magic number: try  			{  				IntPtr pTypeAttr;  				typeInfo.GetTypeAttr(out pTypeAttr);  				var typeAttr = (TYPEATTR)Marshal.PtrToStructure(pTypeAttr' typeof(TYPEATTR));  				typeInfo.ReleaseTypeAttr(pTypeAttr);  				if (typeAttr.typekind == TYPEKIND.TKIND_COCLASS)  				{  					var clsId = typeAttr.guid.ToString("B");  					string keyString = string.Format(@"CLSID\{0}"' clsId);  					RegistryKey typeKey = Registry.ClassesRoot.OpenSubKey(keyString);  					if (typeKey == null)  						return;    					RegistryKey inprocServer = typeKey.OpenSubKey("InprocServer32");  					if (inprocServer == null)  						return;    					// Try to get the file element for the server  					var bldr = new StringBuilder(255);  					RegHelper.GetLongPathName((string)inprocServer.GetValue(null)' bldr' 255);  					string serverFullPath = bldr.ToString();  					string server = Path.GetFileName(serverFullPath);  					if (!File.Exists(serverFullPath) &&  						!File.Exists(Path.Combine(_baseDirectory' server)))  					{  						if (!_nonExistingServers.Contains(server))  						{  							_log.LogMessage(MessageImportance.Low' "{0} is referenced in the TLB but is not in current directory"' server);  							_nonExistingServers.Add(server);  						}  						return;  					}    					XmlElement file = GetOrCreateFileNode(parent' server);  					//// Check to see that the DLL we're processing is really the DLL that can  					//// create this class. Otherwise we better not claim that we know how to do it!  					//if (keyString == null || keyString == string.Empty ||  					//    server.ToLower() != Path.GetFileName(m_FileName))  					//{  					//    return;  					//}    					if (!_coClasses.ContainsKey(clsId))  					{  						var description = (string)typeKey.GetValue(string.Empty);  						var threadingModel = (string)inprocServer.GetValue("ThreadingModel");  						var progId = GetDefaultValueForKey(typeKey' "ProgID");  						AddOrReplaceCoClass(file' clsId' threadingModel' description' tlbGuid.ToString("B")' progId);  						_log.LogMessage(MessageImportance.Low' string.Format(@"Coclass: clsid=""{0}""' threadingModel=""{1}""' tlbid=""{2}""' progid=""{3}"""'  							clsId' threadingModel' tlbGuid' progId));  					}  				}  			}  			catch(Exception e)  			{  				_log.LogMessage(MessageImportance.High' "Failed to process the type info for {0}"' tlbGuid);  				_log.LogMessage(MessageImportance.High' e.StackTrace);  			}
Magic Number,SIL.FieldWorks.Build.Tasks,RegFreeCreator,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\RegFreeCreator.cs,ProcessTypeInfo,The following statement contains a magic number: try  			{  				IntPtr pTypeAttr;  				typeInfo.GetTypeAttr(out pTypeAttr);  				var typeAttr = (TYPEATTR)Marshal.PtrToStructure(pTypeAttr' typeof(TYPEATTR));  				typeInfo.ReleaseTypeAttr(pTypeAttr);  				if (typeAttr.typekind == TYPEKIND.TKIND_COCLASS)  				{  					var clsId = typeAttr.guid.ToString("B");  					string keyString = string.Format(@"CLSID\{0}"' clsId);  					RegistryKey typeKey = Registry.ClassesRoot.OpenSubKey(keyString);  					if (typeKey == null)  						return;    					RegistryKey inprocServer = typeKey.OpenSubKey("InprocServer32");  					if (inprocServer == null)  						return;    					// Try to get the file element for the server  					var bldr = new StringBuilder(255);  					RegHelper.GetLongPathName((string)inprocServer.GetValue(null)' bldr' 255);  					string serverFullPath = bldr.ToString();  					string server = Path.GetFileName(serverFullPath);  					if (!File.Exists(serverFullPath) &&  						!File.Exists(Path.Combine(_baseDirectory' server)))  					{  						if (!_nonExistingServers.Contains(server))  						{  							_log.LogMessage(MessageImportance.Low' "{0} is referenced in the TLB but is not in current directory"' server);  							_nonExistingServers.Add(server);  						}  						return;  					}    					XmlElement file = GetOrCreateFileNode(parent' server);  					//// Check to see that the DLL we're processing is really the DLL that can  					//// create this class. Otherwise we better not claim that we know how to do it!  					//if (keyString == null || keyString == string.Empty ||  					//    server.ToLower() != Path.GetFileName(m_FileName))  					//{  					//    return;  					//}    					if (!_coClasses.ContainsKey(clsId))  					{  						var description = (string)typeKey.GetValue(string.Empty);  						var threadingModel = (string)inprocServer.GetValue("ThreadingModel");  						var progId = GetDefaultValueForKey(typeKey' "ProgID");  						AddOrReplaceCoClass(file' clsId' threadingModel' description' tlbGuid.ToString("B")' progId);  						_log.LogMessage(MessageImportance.Low' string.Format(@"Coclass: clsid=""{0}""' threadingModel=""{1}""' tlbid=""{2}""' progid=""{3}"""'  							clsId' threadingModel' tlbGuid' progId));  					}  				}  			}  			catch(Exception e)  			{  				_log.LogMessage(MessageImportance.High' "Failed to process the type info for {0}"' tlbGuid);  				_log.LogMessage(MessageImportance.High' e.StackTrace);  			}
Magic Number,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,IsFromXmlAttribute,The following statement contains a magic number: return sComment.Length > idx + 2;
Magic Number,SIL.FieldWorks.Build.Tasks.Localization,Po2XmlConverter,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Po2XmlConverter.cs,UnescapeBackslashes,The following statement contains a magic number: for (var idx = result.IndexOf('\\'' 0); idx >= 0 && idx < result.Length; idx = result.IndexOf('\\'' idx))  			{  				switch (result[idx + 1])  				{  					case 'n':  						result = result.Remove(idx' 2);  						result = result.Insert(idx' "\n");  						break;  					case 'r':  						result = result.Remove(idx' 2);  						result = result.Insert(idx' "\r");  						break;  					case 't':  						result = result.Remove(idx' 2);  						result = result.Insert(idx' "\t");  						break;  					default:  						result = result.Remove(idx' 1);  						break;  				}  				++idx;		// Move past the remaining character (might be \).  			}
Magic Number,SIL.FieldWorks.Build.Tasks.Localization,Po2XmlConverter,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Po2XmlConverter.cs,UnescapeBackslashes,The following statement contains a magic number: for (var idx = result.IndexOf('\\'' 0); idx >= 0 && idx < result.Length; idx = result.IndexOf('\\'' idx))  			{  				switch (result[idx + 1])  				{  					case 'n':  						result = result.Remove(idx' 2);  						result = result.Insert(idx' "\n");  						break;  					case 'r':  						result = result.Remove(idx' 2);  						result = result.Insert(idx' "\r");  						break;  					case 't':  						result = result.Remove(idx' 2);  						result = result.Insert(idx' "\t");  						break;  					default:  						result = result.Remove(idx' 1);  						break;  				}  				++idx;		// Move past the remaining character (might be \).  			}
Magic Number,SIL.FieldWorks.Build.Tasks.Localization,Po2XmlConverter,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Po2XmlConverter.cs,UnescapeBackslashes,The following statement contains a magic number: for (var idx = result.IndexOf('\\'' 0); idx >= 0 && idx < result.Length; idx = result.IndexOf('\\'' idx))  			{  				switch (result[idx + 1])  				{  					case 'n':  						result = result.Remove(idx' 2);  						result = result.Insert(idx' "\n");  						break;  					case 'r':  						result = result.Remove(idx' 2);  						result = result.Insert(idx' "\r");  						break;  					case 't':  						result = result.Remove(idx' 2);  						result = result.Insert(idx' "\t");  						break;  					default:  						result = result.Remove(idx' 1);  						break;  				}  				++idx;		// Move past the remaining character (might be \).  			}
Magic Number,SIL.FieldWorks.Build.Tasks.Localization,PoString,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\PoString.cs,ReadFromFile,The following statement contains a magic number: do  			{  				if (s == "#")  				{  					pos.AddUserComment("");  				}  				else if (s.StartsWith("# "))  				{  					pos.AddUserComment(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#."))  				{  					pos.AddAutoComment(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#:"))  				{  					pos.AddReference(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#'"))  				{  					pos.AddFlags(s.Substring(2).TrimStart());  				}  				else if (s.ToLower().StartsWith("msgid"))  				{  					fMsgId = true;  					if (fMsgStr)  						fError = true;  					pos.AddMsgIdLine(s);  				}  				else if (s.ToLower().StartsWith("msgstr"))  				{  					if (!fMsgId)  						fError = true;  					fMsgId = false;  					fMsgStr = true;  					pos.AddMsgStrLine(s);  				}  				else if (s.StartsWith("\""))  				{  					if (fMsgId)  						pos.AddMsgIdLine(s);  					else if (fMsgStr)  						pos.AddMsgStrLine(s);  					else  						fError = true;  				}  				else if (s.StartsWith("#~"))  				{  					pos.IsObsolete = true;  					pos.UserComments?.Clear();  					pos.AutoComments?.Clear();  					pos.Reference?.Clear();  					pos.Flags?.Clear();  					pos.MsgIds?.Clear();  					pos.MsgStrings?.Clear();  				}  				else  				{  					fError = true;  				}  				if (fError)  				{  					Console.WriteLine("INVALID PO FILE: ERROR ON LINE " + s_NumberOfLines);  					throw new Exception("BAD PO FILE");  				}  				if (inputStream.EndOfStream)  					break;  				s = inputStream.ReadLine();  				++s_NumberOfLines;  				s = s?.Trim();  			} while (!string.IsNullOrEmpty(s));
Magic Number,SIL.FieldWorks.Build.Tasks.Localization,PoString,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\PoString.cs,ReadFromFile,The following statement contains a magic number: do  			{  				if (s == "#")  				{  					pos.AddUserComment("");  				}  				else if (s.StartsWith("# "))  				{  					pos.AddUserComment(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#."))  				{  					pos.AddAutoComment(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#:"))  				{  					pos.AddReference(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#'"))  				{  					pos.AddFlags(s.Substring(2).TrimStart());  				}  				else if (s.ToLower().StartsWith("msgid"))  				{  					fMsgId = true;  					if (fMsgStr)  						fError = true;  					pos.AddMsgIdLine(s);  				}  				else if (s.ToLower().StartsWith("msgstr"))  				{  					if (!fMsgId)  						fError = true;  					fMsgId = false;  					fMsgStr = true;  					pos.AddMsgStrLine(s);  				}  				else if (s.StartsWith("\""))  				{  					if (fMsgId)  						pos.AddMsgIdLine(s);  					else if (fMsgStr)  						pos.AddMsgStrLine(s);  					else  						fError = true;  				}  				else if (s.StartsWith("#~"))  				{  					pos.IsObsolete = true;  					pos.UserComments?.Clear();  					pos.AutoComments?.Clear();  					pos.Reference?.Clear();  					pos.Flags?.Clear();  					pos.MsgIds?.Clear();  					pos.MsgStrings?.Clear();  				}  				else  				{  					fError = true;  				}  				if (fError)  				{  					Console.WriteLine("INVALID PO FILE: ERROR ON LINE " + s_NumberOfLines);  					throw new Exception("BAD PO FILE");  				}  				if (inputStream.EndOfStream)  					break;  				s = inputStream.ReadLine();  				++s_NumberOfLines;  				s = s?.Trim();  			} while (!string.IsNullOrEmpty(s));
Magic Number,SIL.FieldWorks.Build.Tasks.Localization,PoString,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\PoString.cs,ReadFromFile,The following statement contains a magic number: do  			{  				if (s == "#")  				{  					pos.AddUserComment("");  				}  				else if (s.StartsWith("# "))  				{  					pos.AddUserComment(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#."))  				{  					pos.AddAutoComment(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#:"))  				{  					pos.AddReference(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#'"))  				{  					pos.AddFlags(s.Substring(2).TrimStart());  				}  				else if (s.ToLower().StartsWith("msgid"))  				{  					fMsgId = true;  					if (fMsgStr)  						fError = true;  					pos.AddMsgIdLine(s);  				}  				else if (s.ToLower().StartsWith("msgstr"))  				{  					if (!fMsgId)  						fError = true;  					fMsgId = false;  					fMsgStr = true;  					pos.AddMsgStrLine(s);  				}  				else if (s.StartsWith("\""))  				{  					if (fMsgId)  						pos.AddMsgIdLine(s);  					else if (fMsgStr)  						pos.AddMsgStrLine(s);  					else  						fError = true;  				}  				else if (s.StartsWith("#~"))  				{  					pos.IsObsolete = true;  					pos.UserComments?.Clear();  					pos.AutoComments?.Clear();  					pos.Reference?.Clear();  					pos.Flags?.Clear();  					pos.MsgIds?.Clear();  					pos.MsgStrings?.Clear();  				}  				else  				{  					fError = true;  				}  				if (fError)  				{  					Console.WriteLine("INVALID PO FILE: ERROR ON LINE " + s_NumberOfLines);  					throw new Exception("BAD PO FILE");  				}  				if (inputStream.EndOfStream)  					break;  				s = inputStream.ReadLine();  				++s_NumberOfLines;  				s = s?.Trim();  			} while (!string.IsNullOrEmpty(s));
Magic Number,SIL.FieldWorks.Build.Tasks.Localization,PoString,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\PoString.cs,ReadFromFile,The following statement contains a magic number: do  			{  				if (s == "#")  				{  					pos.AddUserComment("");  				}  				else if (s.StartsWith("# "))  				{  					pos.AddUserComment(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#."))  				{  					pos.AddAutoComment(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#:"))  				{  					pos.AddReference(s.Substring(2).TrimStart());  				}  				else if (s.StartsWith("#'"))  				{  					pos.AddFlags(s.Substring(2).TrimStart());  				}  				else if (s.ToLower().StartsWith("msgid"))  				{  					fMsgId = true;  					if (fMsgStr)  						fError = true;  					pos.AddMsgIdLine(s);  				}  				else if (s.ToLower().StartsWith("msgstr"))  				{  					if (!fMsgId)  						fError = true;  					fMsgId = false;  					fMsgStr = true;  					pos.AddMsgStrLine(s);  				}  				else if (s.StartsWith("\""))  				{  					if (fMsgId)  						pos.AddMsgIdLine(s);  					else if (fMsgStr)  						pos.AddMsgStrLine(s);  					else  						fError = true;  				}  				else if (s.StartsWith("#~"))  				{  					pos.IsObsolete = true;  					pos.UserComments?.Clear();  					pos.AutoComments?.Clear();  					pos.Reference?.Clear();  					pos.Flags?.Clear();  					pos.MsgIds?.Clear();  					pos.MsgStrings?.Clear();  				}  				else  				{  					fError = true;  				}  				if (fError)  				{  					Console.WriteLine("INVALID PO FILE: ERROR ON LINE " + s_NumberOfLines);  					throw new Exception("BAD PO FILE");  				}  				if (inputStream.EndOfStream)  					break;  				s = inputStream.ReadLine();  				++s_NumberOfLines;  				s = s?.Trim();  			} while (!string.IsNullOrEmpty(s));
Magic Number,SIL.FieldWorks.Build.Tasks.Localization,PoString,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\PoString.cs,WriteMsgBundle,The following statement contains a magic number: if (strings.Count != 1 && !(strings.Count == 2 && string.IsNullOrEmpty(strings[1])))  				WriteQuotedLine(""' false' outputStream);
Missing Default,FwBuildTasks,DownloadFile,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\DownloadFile.cs,ProcessDownloadFile,The following switch statement is missing a default case: switch (success)  				{  					case Result.UpToDate:  						Log.LogMessage(MessageImportance.Normal' "The local file {0} is up-to-date with {1}."' localPathname' remoteUrl);  						return true;  					case Result.Downloaded:  						return true;  				}
Missing Default,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,CollectInterestingProjects,The following switch statement is missing a default case: switch (Path.GetFileName(root))  			{  				case "SidebarLibrary":  				case "obj":  				case "bin":  					return true;  			}
Missing Default,SIL.FieldWorks.Build.Tasks.Localization,Localizer,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\Localizer.cs,CheckForPoFileProblems,The following switch statement is missing a default case: switch (state)  					{  						case PoState.MsgId:  							var id = ExtractMsgValue(line);  							if (!string.IsNullOrEmpty(id))  								currentId = currentId + id;  							break;  						case PoState.MsgStr:  							var val = ExtractMsgValue(line);  							if (!string.IsNullOrEmpty(val))  								currentValue = currentValue + val;  							break;  					}
Missing Default,SIL.FieldWorks.Build.Tasks.Localization,PoString,C:\repos\sillsdev_FieldWorks\Build\Src\FwBuildTasks\Localization\PoString.cs,StringListAsString,The following switch statement is missing a default case: switch (s[iBackslash])  						{  							case 'n':  								s = s.Remove(iBackslash' 1);  								s = s.Insert(iBackslash' "\n");  								break;  							case 't':  								s = s.Remove(iBackslash' 1);  								s = s.Insert(iBackslash' "\t");  								break;  						}
