Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The method has 66 lines of code.
Long Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,HandleTextChange,The method has 80 lines of code.
Long Method,ICSharpCode.AvalonEdit.Editing,Caret,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The method has 62 lines of code.
Long Method,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretUpDown,The method has 62 lines of code.
Long Method,ICSharpCode.AvalonEdit.Editing,RectangleSelection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,The method has 60 lines of code.
Long Method,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The method has 63 lines of code.
Long Method,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightLineInternal,The method has 60 lines of code.
Long Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRegex,The method has 63 lines of code.
Long Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The method has 260 lines of code.
Long Method,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The method has 82 lines of code.
Complex Method,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,HandleKey,Cyclomatic complexity of the method is 44
Complex Method,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,SelectItemWithStart,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OnKeyDown,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FindOverlappingSegments,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateAugmentedData,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnInsert,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,HandleTextChange,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FindNode,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnInsert,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnInsert,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Document,TextDocument,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,FireChangeEvents,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Document,TextDocument,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.AvalonEdit.Editing,Caret,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\Caret.cs,ValidatePosition,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Editing,Caret,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaret,Cyclomatic complexity of the method is 32
Complex Method,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretUpDown,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,TransformSelectedLines,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,TransformSelectedSegments,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnTab,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnPaste,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Editing,RectangleSelection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.AvalonEdit.Editing,Selection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\Selection.cs,GetText,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,StartDrag,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.AvalonEdit.Editing,SimpleSelection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,ReplaceSelectionWithText,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Editing,TextAreaInputHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextAreaInputHandler.cs,Detach,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingManager.cs,UpdateFoldings,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,CalculateFoldLinesForFoldingsActiveAtStart,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,CalculateFoldLinesForMarkers,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateNewFoldings,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightLineInternal,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightNonSpans,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,ToHtml,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,CreateHtmlFragment,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,EscapeHtml,Cyclomatic complexity of the method is 24
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,VisitSpan,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRuleSet,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportSpan,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRegex,Cyclomatic complexity of the method is 23
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,ParseElements,Cyclomatic complexity of the method is 21
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,ParseSpan,Cyclomatic complexity of the method is 24
Complex Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,Cyclomatic complexity of the method is 107
Complex Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,IsSingleStatementKeyword,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,GetRectsForSegmentImpl,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Rendering,ColorizingTransformer,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\ColorizingTransformer.cs,ChangeVisualElements,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,InsertAfter,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,MergeCollapsedSectionsIfPossible,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,CheckProperties,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnInsert,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AddRemoveCollapsedSection,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AddRemoveCollapsedSectionDown,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,GetFirstInterestedOffset,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CreateAndMeasureVisualLines,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ArrangeOverride,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,PerformVisualElementConstruction,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,GetTextRun,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Snippets,InsertionContext,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Snippets\InsertionContext.cs,RaiseInsertionCompleted,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,InsertRange,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,RemoveRange,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnInsert,Cyclomatic complexity of the method is 7
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Utils,Deque,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,GetEnumerator,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.AvalonEdit.Utils,Rope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,FindNodeUsingCache,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Utils,TextFormatterFactory,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\TextFormatterFactory.cs,CreateFormattedText,Cyclomatic complexity of the method is 7
Long Parameter List,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindowBase,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindowBase.cs,RaiseEventPair,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.CodeCompletion,CollapseIfSingleOverloadConverter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\OverloadViewer.cs,Convert,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.CodeCompletion,CollapseIfSingleOverloadConverter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\OverloadViewer.cs,ConvertBack,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FindOverlappingSegments,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CheckNodeProperties,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,CheckNodeProperties,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,DocumentChangeEventArgs,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentChangeEventArgs.cs,DocumentChangeEventArgs,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,BuildTree,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,CheckNodeProperties,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextDocument,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextDocument,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextDocument,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,DoReplace,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,AddBinding,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretRight,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretLeft,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretUpDown,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,SetCaretPosition,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,AddBinding,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,TransformSelectedLines,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,TransformSelectedSegments,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,RectangleSelection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,PerformRectangularPaste,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Editing,TextAreaInputHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextAreaInputHandler.cs,AddBinding,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateElementFold,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Highlighting,HighlightingDefinitionTypeConverter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightingDefinitionTypeConverter.cs,ConvertTo,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,BuildHeader,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,CreateHtmlFragment,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,AddRectangle,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,FormattedTextRun,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\FormattedTextElement.cs,Draw,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,BuildTree,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,CheckNodeProperties,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AddRemoveCollapsedSectionDown,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,InlineObjectRun,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\InlineObjectRun.cs,Draw,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The method has 6 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Snippets,BoundActiveElement,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Snippets\SnippetBoundElement.cs,BoundActiveElement,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CharRope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CharRope.cs,WriteTo,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CharRope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CharRope.cs,WriteTo,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,CheckNodeProperties,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,Rope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,Rope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,SetRange,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,Rope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,CopyTo,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,RopeNode,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,StoreElements,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,RopeNode,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,CopyTo,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,RopeNode,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,Insert,The method has 4 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,TextFormatterFactory,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\TextFormatterFactory.cs,CreateFormattedText,The method has 5 parameters.
Long Parameter List,ICSharpCode.AvalonEdit.Utils,ThrowUtil,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\ThrowUtil.cs,CheckInRangeInclusive,The method has 4 parameters.
Long Identifier,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The length of the parameter removalNeverCausesAnchorDeletion is 32.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,Redraw,The length of the parameter changedSomethingBeforeOrInLine is 30.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the parameter relativeSplitRelativeTextOffset is 31.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The length of the statement  "		Point p = textArea.TextView.GetVisualPosition (new TextViewPosition (line' Math.Max (1' column))' VisualYPosition.LineMiddle); " is 126.
Long Statement,ICSharpCode.AvalonEdit,TextViewPosition,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextViewPosition.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "[TextViewPosition Line={0} Column={1} VisualColumn={2}]"' this.line' this.column' this.visualColumn); " is 154.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,SelectItemFiltering,The length of the statement  "	var listToFilter = (this.currentList != null && (!string.IsNullOrEmpty (this.currentText)) && (!string.IsNullOrEmpty (text)) && text.StartsWith (this.currentText)) ? this.currentList : this.completionData; " is 205.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,completionList_InsertionRequested,The length of the statement  "		item.Complete (this.TextArea' new AnchorSegment (this.TextArea.Document' this.StartOffset' this.EndOffset - this.StartOffset)' e); " is 130.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,textArea_PreviewTextInput,The length of the statement  "	e.Handled = RaiseEventPair (this' PreviewTextInputEvent' TextInputEvent' new TextCompositionEventArgs (e.Device' e.TextComposition)); " is 133.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,textArea_MouseWheel,The length of the statement  "	e.Handled = RaiseEventPair (GetScrollEventTarget ()' PreviewMouseWheelEvent' MouseWheelEvent' new MouseWheelEventArgs (e.MouseDevice' e.Timestamp' e.Delta)); " is 157.
Long Statement,ICSharpCode.AvalonEdit.Document,SimpleSegment,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\ISegment.cs,ToString,The length of the statement  "	return "[Offset=" + Offset.ToString (CultureInfo.InvariantCulture) + "' Length=" + Length.ToString (CultureInfo.InvariantCulture) + "]"; " is 136.
Long Statement,ICSharpCode.AvalonEdit.Document,AnchorSegment,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\ISegment.cs,ToString,The length of the statement  "	return "[Offset=" + Offset.ToString (CultureInfo.InvariantCulture) + "' EndOffset=" + EndOffset.ToString (CultureInfo.InvariantCulture) + "]"; " is 142.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineNode.cs,ToString,The length of the statement  "		return string.Format (CultureInfo.InvariantCulture' "[DocumentLine Number={0} Offset={1} Length={2}]"' LineNumber' Offset' Length); " is 131.
Long Statement,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The length of the statement  "	if (mode != CaretPositioningMode.Normal && mode != CaretPositioningMode.WordBorder && mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordBorderOrSymbol && mode != CaretPositioningMode.WordStartOrSymbol) { " is 228.
Long Statement,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The length of the statement  "				if (charBefore == CharacterClass.Other && (mode == CaretPositioningMode.WordBorderOrSymbol || mode == CaretPositioningMode.WordStartOrSymbol)) { " is 144.
Long Statement,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The length of the statement  "				if (!((mode == CaretPositioningMode.WordStart || mode == CaretPositioningMode.WordStartOrSymbol) && (charAfter == CharacterClass.Whitespace || charAfter == CharacterClass.LineTerminator))) { " is 190.
Long Statement,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,Equals,The length of the statement  "	return offset == other.offset && insertionLength == other.insertionLength && removalLengthWithDeletionFlag == other.removalLengthWithDeletionFlag; " is 146.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsets,The length of the statement  "		throw new InvalidOperationException ("This TextSegmentCollection will automatically update offsets; do not call UpdateOffsets manually!"); " is 138.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsets,The length of the statement  "		throw new InvalidOperationException ("This TextSegmentCollection will automatically update offsets; do not call UpdateOffsets manually!"); " is 138.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsetsInternal,The length of the statement  "	// Special case pure insertions' because they don't always cause a text segment to increase in size when the replaced region " is 124.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CheckProperties,The length of the statement  "		distanceToMaxEnd = Math.Max (distanceToMaxEnd' node.right.distanceToMaxEnd + node.right.StartOffset - node.StartOffset); " is 120.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 131.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The length of the statement  "	if (node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The length of the statement  "	} else if (node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK) { " is 135.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CopyTo,The length of the statement  "		throw new ArgumentOutOfRangeException ("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - count)); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 131.
Long Statement,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The length of the statement  "	if (node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The length of the statement  "	} else if (node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK) { " is 135.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegment,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegment.cs,ToDebugString,The length of the statement  "	return "[nodeLength=" + nodeLength + " totalNodeLength=" + totalNodeLength + " distanceToMaxEnd=" + distanceToMaxEnd + " MaxEndOffset=" + (StartOffset + distanceToMaxEnd) + "]"; " is 177.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 131.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The length of the statement  "	if (node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The length of the statement  "	} else if (node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK) { " is 135.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,CopyTo,The length of the statement  "		throw new ArgumentOutOfRangeException ("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - LineCount)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,ThrowIfRangeInvalid,The length of the statement  "		throw new ArgumentOutOfRangeException ("offset"' offset' "0 <= offset <= " + rope.Length.ToString (CultureInfo.InvariantCulture)); " is 130.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,ThrowIfRangeInvalid,The length of the statement  "		throw new ArgumentOutOfRangeException ("length"' length' "0 <= length' offset(" + offset + ")+length <= " + rope.Length.ToString (CultureInfo.InvariantCulture)); " is 161.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,CreateAnchor,The length of the statement  "		throw new ArgumentOutOfRangeException ("offset"' offset' "0 <= offset <= " + rope.Length.ToString (CultureInfo.InvariantCulture)); " is 130.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The length of the statement  "	int newVisualColumnForwards = visualLine.GetNextCaretPosition (position.VisualColumn - 1' LogicalDirection.Forward' CaretPositioningMode.Normal); " is 145.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The length of the statement  "		int newVisualColumnBackwards = visualLine.GetNextCaretPosition (position.VisualColumn + 1' LogicalDirection.Backward' CaretPositioningMode.Normal); " is 147.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretLayer,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretLayer.cs,OnRender,The length of the statement  "		Rect r = new Rect (caretRectangle.X - textView.HorizontalOffset' caretRectangle.Y - textView.VerticalOffset' caretRectangle.Width' caretRectangle.Height); " is 154.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretRight,The length of the statement  "			Debug.Assert (visualLine.LastDocumentLine.Offset + visualLine.LastDocumentLine.TotalLength == textArea.Document.TextLength); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,CopyWholeLine,The length of the statement  "	HtmlClipboard.SetHtml (data' HtmlClipboard.CreateHtmlFragment (textArea.Document' highlighter' wholeLine' new HtmlOptions (textArea.Options))); " is 143.
Long Statement,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,MeasureOverride,The length of the statement  "	FormattedText text = TextFormatterFactory.CreateFormattedText (this' new string ('9'' maxLineNumberLength)' typeface' emSize' (Brush)GetValue (Control.ForegroundProperty)); " is 172.
Long Statement,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnRender,The length of the statement  "			FormattedText text = TextFormatterFactory.CreateFormattedText (this' lineNumber.ToString (CultureInfo.CurrentCulture)' typeface' emSize' foreground); " is 149.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,UpdateOnDocumentChange,The length of the statement  "	return new RectangleSelection (document' e.GetNewOffset (StartOffset' AnchorMovementType.AfterInsertion)' e.GetNewOffset (EndOffset' AnchorMovementType.BeforeInsertion)); " is 170.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionLayer,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionLayer.cs,ReceiveWeakEvent,The length of the statement  "	if (managerType == typeof(TextViewWeakEventManager.VisualLinesChanged) || managerType == typeof(TextViewWeakEventManager.ScrollOffsetChanged)) { " is 144.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetEffect,The length of the statement  "				if ((e.AllowedEffects & DragDropEffects.Move) == DragDropEffects.Move && (e.KeyStates & DragDropKeyStates.ControlKey) != DragDropKeyStates.ControlKey) { " is 152.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,StartDrag,The length of the statement  "	if (deleteOnMove != null && resultEffect == DragDropEffects.Move && (allowedEffects & DragDropEffects.Move) == DragDropEffects.Move) { " is 134.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetWordAtMousePosition,The length of the statement  "		int wordStartVC = line.GetNextCaretPosition (visualColumn + 1' LogicalDirection.Backward' CaretPositioningMode.WordStartOrSymbol); " is 130.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetWordAtMousePosition,The length of the statement  "		int wordEndVC = line.GetNextCaretPosition (wordStartVC' LogicalDirection.Forward' CaretPositioningMode.WordBorderOrSymbol); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The length of the statement  "	if (mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular) { " is 142.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The length of the statement  "		if (Math.Abs (mouseMovement.X) > SystemParameters.MinimumHorizontalDragDistance || Math.Abs (mouseMovement.Y) > SystemParameters.MinimumVerticalDragDistance) { " is 159.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,ExtendSelectionToMouse,The length of the statement  "			textArea.Selection = new SimpleSelection (Math.Min (newWord.Offset' startWord.Offset)' Math.Max (newWord.EndOffset' startWord.EndOffset)); " is 138.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonUp,The length of the statement  "	} else if (mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular) { " is 149.
Long Statement,ICSharpCode.AvalonEdit.Editing,SimpleSelection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,UpdateOnDocumentChange,The length of the statement  "	return new SimpleSelection (e.GetNewOffset (startOffset' AnchorMovementType.AfterInsertion)' e.GetNewOffset (endOffset' AnchorMovementType.AfterInsertion)); " is 156.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnTextInput,The length of the statement  "	//Debug.WriteLine("TextInput: Text='" + e.Text + "' SystemText='" + e.SystemText + "' ControlText='" + e.ControlText + "'"); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextArea.cs,GetDeletableSegments,The length of the statement  "			throw new InvalidOperationException ("ReadOnlySectionProvider returned incorrect segments (outside of input segment / wrong order)"); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextArea.cs,GetDeletableSegments,The length of the statement  "		throw new InvalidOperationException ("ReadOnlySectionProvider returned incorrect segments (outside of input segment / wrong order)"); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnPropertyChanged,The length of the statement  "	if (e.Property == SelectionBrushProperty || e.Property == SelectionBorderProperty || e.Property == SelectionForegroundProperty || e.Property == SelectionCornerRadiusProperty) { " is 176.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingElementGenerator,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingElementGenerator.cs,ConstructElement,The length of the statement  "		FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' title' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize' Brushes.Gray); " is 218.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "				drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos)); " is 145.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "					drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2)); " is 150.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "		drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' RenderSize.Height)); " is 135.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The length of the statement  "	Rect rect = new Rect (pixelSize.Width / 2' pixelSize.Height / 2' this.RenderSize.Width - pixelSize.Width' this.RenderSize.Height - pixelSize.Height); " is 149.
Long Statement,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateElementFoldStart,The length of the statement  "	//XmlFoldStart newFoldStart = new XmlFoldStart(reader.Prefix' reader.LocalName' reader.LineNumber - 1' reader.LinePosition - 2); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightLineAndUpdateTreeList,The length of the statement  "		//Debug.WriteLine("Span stack in line " + lineNumber + " changed from " + storedSpanStacks[lineNumber] + " to " + spanStack); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightLineInternal,The length of the statement  "					throw new InvalidOperationException ("A highlighting span matched 0 characters' which would cause an endless loop.\n" + "Change the highlighting definition so that either the start or the end regex matches at least one character.\n" + "Start regex: " + poppedSpan.StartExpression + "\n" + "End regex: " + poppedSpan.EndExpression); " is 331.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightNonSpans,The length of the statement  "				throw new InvalidOperationException ("A highlighting rule matched 0 characters' which would cause an endless loop.\n" + "Change the highlighting definition so that the rule matches at least one character.\n" + "Regex: " + rules [ruleIndex].Regex); " is 247.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,PushColor,The length of the statement  "	} else if (lastPoppedSection != null && lastPoppedSection.Color == color && lastPoppedSection.Offset + lastPoppedSection.Length == position + lineStartOffset) { " is 160.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,ToHtml,The length of the statement  "		throw new ArgumentOutOfRangeException ("startOffset"' startOffset' "Value must be between " + documentLineStartOffset + " and " + documentLineEndOffset); " is 153.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,ToHtml,The length of the statement  "		throw new ArgumentOutOfRangeException ("endOffset"' endOffset' "Value must be between startOffset and " + documentLineEndOffset); " is 129.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,textView_VisualLineConstructionStarting,The length of the statement  "		// This is necessary in case the document gets modified above the FirstLineInView so that the highlighting state changes. " is 121.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,ColorizeLine,The length of the statement  "			ChangeLinePart (section.Offset' section.Offset + section.Length' visualLineElement => ApplyColorToElement (visualLineElement' section.Color)); " is 142.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,ApplyColorToElement,The length of the statement  "		element.TextRunProperties.SetTypeface (new Typeface (tf.FontFamily' color.FontStyle ?? tf.Style' color.FontWeight ?? tf.Weight' tf.Stretch)); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,SetHtml,The length of the statement  "	string htmlStart = @"<!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.0 Transitional//EN"">" + Environment.NewLine + "<HTML>" + Environment.NewLine + "<BODY>" + Environment.NewLine + "<!--StartFragment-->" + Environment.NewLine; " is 222.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,SetHtml,The length of the statement  "	string htmlEnd = "<!--EndFragment-->" + Environment.NewLine + "</BODY>" + Environment.NewLine + "</HTML>" + Environment.NewLine; " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,Resources,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Resources\Resources.cs,RegisterBuiltInHighlightings,The length of the statement  "	hlm.RegisterHighlighting ("XML"' (".xml;.xsl;.xslt;.xsd;.manifest;.config;.addin;" + ".xshd;.wxs;.wxi;.wxl;.proj;.csproj;.vbproj;.ilproj;" + ".booproj;.build;.xfrm;.targets;.xaml;.xpt;" + ".xft;.map;.wsdl;.disco").Split (';')' "XML-Mode.xshd"); " is 244.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteRuleSetReference,The length of the statement  "			writer.WriteAttributeString ("ruleSet"' ruleSetReference.ReferencedDefinition + "/" + ruleSetReference.ReferencedElement); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteColorAttributes,The length of the statement  "		writer.WriteAttributeString ("fontWeight"' V2Loader.FontWeightConverter.ConvertToInvariantString (color.FontWeight.Value).ToLowerInvariant ()); " is 143.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteColorAttributes,The length of the statement  "		writer.WriteAttributeString ("fontStyle"' V2Loader.FontStyleConverter.ConvertToInvariantString (color.FontStyle.Value).ToLowerInvariant ()); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseDefinition,The length of the statement  "				Regex = @"\b0[xX][0-9a-fA-F]+" + @"|\b" + @"(\d+(" + floatingPoint + ")?" + @"|" + floatingPoint + ")" + optionalExponent " is 121.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,GetColorFromElement,The length of the statement  "	if (!element.HasAttribute ("bold") && !element.HasAttribute ("italic") && !element.HasAttribute ("color") && !element.HasAttribute ("bgcolor")) " is 143.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportSpan,The length of the statement  "	span.BeginRegex = ImportRegex (element ["Begin"].InnerText' element ["Begin"].GetBoolAttribute ("singleword") ?? false' element ["Begin"].GetBoolAttribute ("startofline")); " is 172.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,Error,The length of the statement  "		return new HighlightingDefinitionInvalidException (HighlightingLoader.FormatExceptionMessage (message' lineInfo.LineNumber' lineInfo.LinePosition)); " is 148.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,XshdReference,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\XshdReference.cs,Equals,The length of the statement  "	return this.referencedDefinition == other.referencedDefinition && this.referencedElement == other.referencedElement && this.inlineElement == other.inlineElement; " is 161.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "			block.Indent (Repeat (set.IndentString' oldBlock.OneLineBlock) + (oldBlock.Continuation ? set.IndentString : "") + (i == line.Length - 1 ? set.IndentString : new String (' '' i + 1))); " is 184.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "			if (block.LastWord == "case" || line.StartsWith ("case "' StringComparison.Ordinal) || line.StartsWith (block.LastWord + ":"' StringComparison.Ordinal)) { " is 154.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "		if (block.LastWord == "case" || line.StartsWith ("case "' StringComparison.Ordinal) || line.StartsWith (block.LastWord + ":"' StringComparison.Ordinal)) " is 152.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "		if (!oldBlock.Continuation && oldBlock.OneLineBlock == 0 && oldBlock.StartLine == block.StartLine && block.StartLine < doc.LineNumber && lastRealChar != ':') { " is 159.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "	if (indent.Length != (doc.Text.Length - line.Length) || !doc.Text.StartsWith (indent.ToString ()' StringComparison.Ordinal) || Char.IsWhiteSpace (doc.Text [indent.Length])) { " is 174.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,AddSegment,The length of the statement  "			AddRectangle (PixelSnapHelpers.Round (r.Left' pixelSize.Width)' PixelSnapHelpers.Round (r.Top' pixelSize.Height)' PixelSnapHelpers.Round (r.Right' pixelSize.Width)' PixelSnapHelpers.Round (r.Bottom' pixelSize.Height)); " is 218.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,AddSegment,The length of the statement  "			AddRectangle (PixelSnapHelpers.PixelAlign (r.Left' pixelSize.Width)' PixelSnapHelpers.PixelAlign (r.Top' pixelSize.Height)' PixelSnapHelpers.PixelAlign (r.Right' pixelSize.Width)' PixelSnapHelpers.PixelAlign (r.Bottom' pixelSize.Height)); " is 238.
Long Statement,ICSharpCode.AvalonEdit.Rendering,CollapsedLineSection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\CollapsedLineSection.cs,ToString,The length of the statement  "	return "[CollapsedSection " + ID + " Start=" + (start != null ? start.LineNumber.ToString () : "null") + " End=" + (end != null ? end.LineNumber.ToString () : "null") + " IsCollapsed=" + isCollapsed + "]"; " is 205.
Long Statement,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,ChangeLinePart,The length of the statement  "		throw new ArgumentOutOfRangeException ("startOffset"' startOffset' "Value must be between " + currentDocumentLineStartOffset + " and " + currentDocumentLineEndOffset); " is 167.
Long Statement,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,ChangeLinePart,The length of the statement  "		throw new ArgumentOutOfRangeException ("endOffset"' endOffset' "Value must be between " + startOffset + " and " + currentDocumentLineEndOffset); " is 144.
Long Statement,ICSharpCode.AvalonEdit.Rendering,FormattedTextRun,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\FormattedTextElement.cs,Format,The length of the statement  "	return new TextEmbeddedObjectMetrics (element.Text.WidthIncludingTrailingWhitespace' element.Text.Height' element.Text.Baseline); " is 129.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,UpdateAugmentedData,The length of the statement  "	if (totalCount != node.totalCount || !totalHeight.IsClose (node.totalHeight) || mode == UpdateAfterChildrenChangeRecursionMode.WholeBranch) { " is 141.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,GetAllCollapsedSections,The length of the statement  "	return System.Linq.Enumerable.Distinct (System.Linq.Enumerable.SelectMany (AllNodes' node => System.Linq.Enumerable.Concat (node.lineNode.collapsedSections ?? emptyCSList' node.collapsedSections ?? emptyCSList))); " is 213.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 131.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The length of the statement  "	if (node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The length of the statement  "	} else if (node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK) { " is 135.
Long Statement,ICSharpCode.AvalonEdit.Rendering,HeightTreeNode,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTreeNode.cs,ToString,The length of the statement  "	return "[HeightTreeNode " + documentLine.LineNumber + " CS=" + GetCollapsedSections (collapsedSections) + " Line.CS=" + GetCollapsedSections (lineNode.collapsedSections) + " Line.Height=" + lineNode.height + " TotalHeight=" + totalHeight + "]"; " is 244.
Long Statement,ICSharpCode.AvalonEdit.Rendering,NewLineElementGenerator,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\NewLineElementGenerator.cs,ConstructElement,The length of the statement  "	FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' newlineText' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize' Brushes.LightGray); " is 229.
Long Statement,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The length of the statement  "		FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' "\u00B7"' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize' Brushes.LightGray); " is 226.
Long Statement,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The length of the statement  "		FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' "\u00BB"' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize' Brushes.LightGray); " is 226.
Long Statement,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The length of the statement  "		FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' TextUtilities.GetControlCharacterName (c)' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize * 0.9' Brushes.White); " is 261.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ReceiveWeakEvent,The length of the statement  "		// Unfortunately the "easy" approach (just use DispatcherPriority.Background) here makes the editor twice as slow because " is 121.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ReceiveWeakEvent,The length of the statement  "		// When fixing this' make sure performance on the SharpDevelop "type text in C# comment" stress test doesn't get significantly worse. " is 133.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,UpdateBuiltinElementGeneratorsFromOptions,The length of the statement  "	AddRemoveDefaultElementGeneratorOnDemand (ref singleCharacterElementGenerator' options.ShowBoxForControlCharacters || options.ShowSpaces || options.ShowTabs); " is 158.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,The length of the statement  "			} else if (p.KnownLayer == referencedLayer && p.Position == LayerInsertionPosition.Above || p.KnownLayer > referencedLayer) { " is 125.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,GetOrConstructVisualLine,The length of the statement  "		l = BuildVisualLine (documentLine' globalTextRunProperties' paragraphProperties' elementGenerators.ToArray ()' lineTransformers.ToArray ()' lastAvailableSize); " is 159.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,EnsureVisualLines,The length of the statement  "		throw new InvalidOperationException ("The visual line build process is already running! Cannot EnsureVisualLines() during Measure!"); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The length of the statement  "		heightTreeHeight = Math.Max (heightTreeHeight' Math.Min (heightTreeHeight - 50' scrollOffset.Y) + scrollViewport.Height); " is 121.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The length of the statement  "	return new Size (canHorizontallyScroll ? Math.Min (availableSize.Width' maxWidth) : maxWidth' canVerticallyScroll ? Math.Min (availableSize.Height' heightTreeHeight) : heightTreeHeight); " is 186.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CreateAndMeasureVisualLines,The length of the statement  "			visualLine = BuildVisualLine (nextLine' globalTextRunProperties' paragraphProperties' elementGeneratorsArray' lineTransformersArray' availableSize); " is 148.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CreateAndMeasureVisualLines,The length of the statement  "		throw new InvalidOperationException ("A visual line was disposed even though it is still in use.\n" + "This can happen when Redraw() is called during measure for lines " + "that are already constructed."); " is 205.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The length of the statement  "			throw new InvalidOperationException ("Line " + i + " was skipped by a VisualLineElementGenerator' but it is not collapsed."); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The length of the statement  "		TextLine textLine = formatter.FormatLine (textSource' textOffset' availableSize.Width' paragraphProperties' lastLineBreak); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,SetScrollData,The length of the statement  "	if (!(viewport.IsClose (this.scrollViewport) && extent.IsClose (this.scrollExtent) && offset.IsClose (this.scrollOffset))) { " is 124.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnMouseMove,The length of the statement  "	if (Math.Abs (mouseMovement.X) > SystemParameters.MouseHoverWidth || Math.Abs (mouseMovement.Y) > SystemParameters.MouseHoverHeight) { " is 134.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnMouseMove,The length of the statement  "		mouseHoverTimer = new DispatcherTimer (SystemParameters.MouseHoverTime' DispatcherPriority.Background' OnMouseHoverTimerElapsed' this.Dispatcher); " is 146.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The length of the statement  "	if (e.Property == Control.ForegroundProperty || e.Property == Control.FontFamilyProperty || e.Property == Control.FontSizeProperty || e.Property == Control.FontStretchProperty || e.Property == Control.FontStyleProperty || e.Property == Control.FontWeightProperty) { " is 265.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,PerformVisualElementConstruction,The length of the statement  "					throw new ArgumentOutOfRangeException (g.GetType ().Name + ".GetFirstInterestedOffset"' g.cachedInterest' "GetFirstInterestedOffset must not return an offset less than startOffset. Return -1 to signal no interest."); " is 216.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetVisualColumn,The length of the statement  "		if (element.RelativeTextOffset <= relativeTextOffset && element.RelativeTextOffset + element.DocumentLength >= relativeTextOffset) { " is 132.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,The length of the statement  "		if (visualColumn > this.VisualLength && !elements [elements.Count - 1].HandlesLineBorders && HasImplicitStopAtLineEnd (mode)) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,The length of the statement  "			int pos = elements [i].GetNextCaretPosition (Math.Min (visualColumn' elements [i].VisualColumn + elements [i].VisualLength + 1)' direction' mode); " is 146.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,The length of the statement  "		if (visualColumn < this.VisualLength && !elements [elements.Count - 1].HandlesLineBorders && HasImplicitStopAtLineEnd (mode)) " is 125.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the statement  "		throw new ArgumentOutOfRangeException ("splitVisualColumn"' splitVisualColumn' "Value must be between " + (VisualColumn + 1) + " and " + (VisualColumn + VisualLength - 1)); " is 172.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the statement  "		throw new ArgumentOutOfRangeException ("splitRelativeTextOffset"' splitRelativeTextOffset' "Value must be between " + (RelativeTextOffset) + " and " + (RelativeTextOffset + DocumentLength)); " is 190.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,GetNextCaretPosition,The length of the statement  "		else if (visualColumn < stop2 && mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) " is 122.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,CreateTextRun,The length of the statement  "	string text = context.Document.GetText (context.VisualLine.FirstDocumentLine.Offset + RelativeTextOffset + relativeOffset' DocumentLength - relativeOffset); " is 156.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,Split,The length of the statement  "		throw new ArgumentOutOfRangeException ("splitVisualColumn"' splitVisualColumn' "Value must be between " + (VisualColumn + 1) + " and " + (VisualColumn + VisualLength - 1)); " is 172.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,GetNextCaretPosition,The length of the statement  "	int pos = TextUtilities.GetNextCaretPosition (parentVisualLine.Document' textOffset + visualColumn - this.VisualColumn' direction' mode); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,GetTextRun,The length of the statement  "			if (textSourceCharacterIndex >= element.VisualColumn && textSourceCharacterIndex < element.VisualColumn + element.VisualLength) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Snippets,InsertionContext,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Snippets\InsertionContext.cs,InsertText,The length of the statement  "			string insertString = text.Substring (textOffset' segment.Offset - textOffset) + this.LineTerminator + this.Indentation; " is 120.
Long Statement,ICSharpCode.AvalonEdit.Utils,CharRope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CharRope.cs,InsertText,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + rope.Length.ToString(CultureInfo.InvariantCulture));" is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,CopyTo,The length of the statement  "		throw new ArgumentOutOfRangeException ("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - this.Count)); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 131.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The length of the statement  "	if (parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK) { " is 129.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The length of the statement  "	if (node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK) { " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The length of the statement  "	} else if (node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK) { " is 135.
Long Statement,ICSharpCode.AvalonEdit.Utils,ExtensionMethods,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\ExtensionMethods.cs,CreateTypeface,The length of the statement  "	return new Typeface ((FontFamily)fe.GetValue (TextBlock.FontFamilyProperty)' (FontStyle)fe.GetValue (TextBlock.FontStyleProperty)' (FontWeight)fe.GetValue (TextBlock.FontWeightProperty)' (FontStretch)fe.GetValue (TextBlock.FontStretchProperty)); " is 245.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("index"' index' "0 <= index <= " + this.Length.ToString (CultureInfo.InvariantCulture)); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("index"' index' "0 <= index <= " + this.Length.ToString (CultureInfo.InvariantCulture)); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("startIndex"' startIndex' "0 <= startIndex <= " + this.Length.ToString (CultureInfo.InvariantCulture)); " is 142.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("length"' length' "0 <= length' startIndex(" + startIndex + ")+length <= " + this.Length.ToString (CultureInfo.InvariantCulture)); " is 169.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyArrayWithRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("startIndex"' arrayIndex' "0 <= arrayIndex <= " + array.Length.ToString (CultureInfo.InvariantCulture)); " is 143.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyArrayWithRange,The length of the statement  "		throw new ArgumentOutOfRangeException ("count"' count' "0 <= length' arrayIndex(" + arrayIndex + ")+count <= " + array.Length.ToString (CultureInfo.InvariantCulture)); " is 167.
Long Statement,ICSharpCode.AvalonEdit.Utils,RopeNode,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,ToString,The length of the statement  "			return "[Leaf length=" + length + "' isShared=" + isShared + "' text=\"" + new string (charContents' 0' length) + "\"]"; " is 120.
Long Statement,ICSharpCode.AvalonEdit.Utils,RopeNode,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,ToString,The length of the statement  "		return "[Concat length=" + length + "' isShared=" + isShared + "' height=" + height + "' Balance=" + this.Balance + "]"; " is 120.
Long Statement,ICSharpCode.AvalonEdit.Utils,FunctionNode,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,GetContentNode,The length of the statement  "				throw new InvalidOperationException ("Trying to load this node recursively; or: a previous call to a rope initializer failed."); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Utils,TextFormatterFactory,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\TextFormatterFactory.cs,Create,The length of the statement  "		return (TextFormatter)typeof(TextFormatter).InvokeMember ("Create"' BindingFlags.InvokeMethod | BindingFlags.Public | BindingFlags.Static' null' null' new object[] { " is 165.
Long Statement,ICSharpCode.AvalonEdit.Utils,TextFormatterFactory,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\TextFormatterFactory.cs,CreateFormattedText,The length of the statement  "		return (FormattedText)Activator.CreateInstance (typeof(FormattedText)' text' CultureInfo.CurrentCulture' FlowDirection.LeftToRight' typeface' emSize' foreground' null' formattingMode); " is 184.
Long Statement,ICSharpCode.AvalonEdit.Utils,TextFormatterFactory,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\TextFormatterFactory.cs,CreateFormattedText,The length of the statement  "		return new FormattedText (text' CultureInfo.CurrentCulture' FlowDirection.LeftToRight' typeface' emSize.Value' foreground); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,Round,The length of the statement  "	return new Rect (Round (rect.X' pixelSize.Width)' Round (rect.Y' pixelSize.Height)' Round (rect.Width' pixelSize.Width)' Round (rect.Height' pixelSize.Height)); " is 160.
Long Statement,ICSharpCode.AvalonEdit.Utils,ThrowUtil,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\ThrowUtil.cs,CheckInRangeInclusive,The length of the statement  "		throw new ArgumentOutOfRangeException (parameterName' val' "Expected: " + lower.ToString (CultureInfo.InvariantCulture) + " <= " + parameterName + " <= " + upper.ToString (CultureInfo.InvariantCulture)); " is 203.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The conditional expression  "mode != CaretPositioningMode.Normal && mode != CaretPositioningMode.WordBorder && mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordBorderOrSymbol && mode != CaretPositioningMode.WordStartOrSymbol"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The conditional expression  "!((mode == CaretPositioningMode.WordStart || mode == CaretPositioningMode.WordStartOrSymbol) && (charAfter == CharacterClass.Whitespace || charAfter == CharacterClass.LineTerminator))"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_QueryCursor,The conditional expression  "p.X >= 0 && p.Y >= 0 && p.X <= textArea.TextView.ActualWidth && p.Y <= textArea.TextView.ActualHeight"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The conditional expression  "mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonUp,The conditional expression  "mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,TextArea,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnPropertyChanged,The conditional expression  "e.Property == SelectionBrushProperty || e.Property == SelectionBorderProperty || e.Property == SelectionForegroundProperty || e.Property == SelectionCornerRadiusProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,Minimum,The conditional expression  "endSpanMatch != null && endSpanMatch.Success && (min == null || endSpanMatch.Index < min.Index)"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,GetColorFromElement,The conditional expression  "!element.HasAttribute ("bold") && !element.HasAttribute ("italic") && !element.HasAttribute ("color") && !element.HasAttribute ("bgcolor")"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The conditional expression  "lineComment || blockComment || inString || inChar"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The conditional expression  "!oldBlock.Continuation && oldBlock.OneLineBlock == 0 && oldBlock.StartLine == block.StartLine && block.StartLine < doc.LineNumber && lastRealChar != ':'"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The conditional expression  "rectangle.IsEmpty || visual == null || visual == this || !this.IsAncestorOf (visual)"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The conditional expression  "e.Property == Control.ForegroundProperty || e.Property == Control.FontFamilyProperty || e.Property == Control.FontSizeProperty || e.Property == Control.FontStretchProperty || e.Property == Control.FontStyleProperty || e.Property == Control.FontWeightProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED && sibling.color == BLACK && GetColor (sibling.left) == BLACK && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && sibling.color == BLACK && GetColor (sibling.left) == RED && GetColor (sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && sibling.color == BLACK && GetColor (sibling.right) == RED && GetColor (sibling.left) == BLACK"  is complex.
Virtual Method Call from Constructor,ICSharpCode.AvalonEdit.Snippets,InsertionContext,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Snippets\InsertionContext.cs,InsertionContext,The constructor "InsertionContext" calls a virtual method "GetText".
Empty Catch Block,ICSharpCode.AvalonEdit.Rendering,VisualLineLinkText,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineLinkText.cs,OnMouseDown,The method has an empty catch block.
Magic Number,ICSharpCode.AvalonEdit,TextEditor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null) {  	Point p = textArea.TextView.GetVisualPosition (new TextViewPosition (line' Math.Max (1' column))' VisualYPosition.LineMiddle);  	double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  	if (Math.Abs (verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  		scrollViewer.ScrollToVerticalOffset (Math.Max (0' verticalPos));  	}  	if (column > 0) {  		if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  			double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  			if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  				scrollViewer.ScrollToHorizontalOffset (horizontalPos);  			}  		} else {  			scrollViewer.ScrollToHorizontalOffset (0);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null) {  	Point p = textArea.TextView.GetVisualPosition (new TextViewPosition (line' Math.Max (1' column))' VisualYPosition.LineMiddle);  	double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  	if (Math.Abs (verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  		scrollViewer.ScrollToVerticalOffset (Math.Max (0' verticalPos));  	}  	if (column > 0) {  		if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  			double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  			if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  				scrollViewer.ScrollToHorizontalOffset (horizontalPos);  			}  		} else {  			scrollViewer.ScrollToHorizontalOffset (0);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null) {  	Point p = textArea.TextView.GetVisualPosition (new TextViewPosition (line' Math.Max (1' column))' VisualYPosition.LineMiddle);  	double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  	if (Math.Abs (verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  		scrollViewer.ScrollToVerticalOffset (Math.Max (0' verticalPos));  	}  	if (column > 0) {  		if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  			double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  			if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  				scrollViewer.ScrollToHorizontalOffset (horizontalPos);  			}  		} else {  			scrollViewer.ScrollToHorizontalOffset (0);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (column > 0) {  	if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  		double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  		if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  			scrollViewer.ScrollToHorizontalOffset (horizontalPos);  		}  	} else {  		scrollViewer.ScrollToHorizontalOffset (0);  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (column > 0) {  	if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  		double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  		if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  			scrollViewer.ScrollToHorizontalOffset (horizontalPos);  		}  	} else {  		scrollViewer.ScrollToHorizontalOffset (0);  	}  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  	double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  	if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  		scrollViewer.ScrollToHorizontalOffset (horizontalPos);  	}  } else {  	scrollViewer.ScrollToHorizontalOffset (0);  }  
Magic Number,ICSharpCode.AvalonEdit,TextEditor,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  	double horizontalPos = Math.Max (0' p.X - scrollViewer.ViewportWidth / 2);  	if (Math.Abs (horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  		scrollViewer.ScrollToHorizontalOffset (horizontalPos);  	}  } else {  	scrollViewer.ScrollToHorizontalOffset (0);  }  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  	hashCode += 1000000007 * Line.GetHashCode ();  	hashCode += 1000000009 * Column.GetHashCode ();  	hashCode += 1000000021 * VisualColumn.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  	hashCode += 1000000007 * Line.GetHashCode ();  	hashCode += 1000000009 * Column.GetHashCode ();  	hashCode += 1000000021 * VisualColumn.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  	hashCode += 1000000007 * Line.GetHashCode ();  	hashCode += 1000000009 * Column.GetHashCode ();  	hashCode += 1000000021 * VisualColumn.GetHashCode ();  }  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000007 * Line.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000009 * Column.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000021 * VisualColumn.GetHashCode ();  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionListBox,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionListBox.cs,CenterViewOn,The following statement contains a magic number: this.FirstVisibleItem = index - VisibleItemCount / 2;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query == itemText)  	return 8;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 8;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (string.Equals (itemText' query' StringComparison.OrdinalIgnoreCase))  	return 7;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 7;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.StartsWith (query))  	return 6;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 6;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.StartsWith (query' StringComparison.OrdinalIgnoreCase))  	return 5;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 5;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query.Length <= 2) {  	camelCaseMatch = CamelCaseMatch (itemText' query);  	if (camelCaseMatch.GetValueOrDefault (false))  		return 4;  }  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query.Length <= 2) {  	camelCaseMatch = CamelCaseMatch (itemText' query);  	if (camelCaseMatch.GetValueOrDefault (false))  		return 4;  }  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (camelCaseMatch.GetValueOrDefault (false))  	return 4;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 4;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (IsFiltering && itemText.Contains (query))  	return 3;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 3;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (IsFiltering && itemText.IndexOf (query' StringComparison.OrdinalIgnoreCase) >= 0)  	return 2;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: return 2;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MaxHeight = 300;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.Width = 175;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MinHeight = 15;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MinWidth = 30;  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OverloadInsightWindow,The following statement contains a magic number: overloadViewer.Margin = new Thickness (2' 0' 0' 0);  
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CollapseIfSingleOverloadConverter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\OverloadViewer.cs,Convert,The following statement contains a magic number: return ((int)value < 2) ? Visibility.Collapsed : Visibility.Visible;  
Magic Number,ICSharpCode.AvalonEdit.Document,SimpleSegment,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\ISegment.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return Offset + 10301 * Length;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,SimpleSegment,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\ISegment.cs,GetHashCode,The following statement contains a magic number: return Offset + 10301 * Length;  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: for (int i = offset; i < text.Length; i++) {  	switch (text [i]) {  	case '\r':  		if (i + 1 < text.Length) {  			if (text [i + 1] == '\n') {  				return new SimpleSegment (i' 2);  			}  		}  		goto case '\n';  	case '\n':  		return new SimpleSegment (i' 1);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: switch (text [i]) {  case '\r':  	if (i + 1 < text.Length) {  		if (text [i + 1] == '\n') {  			return new SimpleSegment (i' 2);  		}  	}  	goto case '\n';  case '\n':  	return new SimpleSegment (i' 1);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (i + 1 < text.Length) {  	if (text [i + 1] == '\n') {  		return new SimpleSegment (i' 2);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (text [i + 1] == '\n') {  	return new SimpleSegment (i' 2);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: return new SimpleSegment (i' 2);  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: for (int i = offset; i < textLength; i++) {  	switch (text.GetCharAt (i)) {  	case '\r':  		if (i + 1 < textLength) {  			if (text.GetCharAt (i + 1) == '\n') {  				return new SimpleSegment (i' 2);  			}  		}  		goto case '\n';  	case '\n':  		return new SimpleSegment (i' 1);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: switch (text.GetCharAt (i)) {  case '\r':  	if (i + 1 < textLength) {  		if (text.GetCharAt (i + 1) == '\n') {  			return new SimpleSegment (i' 2);  		}  	}  	goto case '\n';  case '\n':  	return new SimpleSegment (i' 1);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (i + 1 < textLength) {  	if (text.GetCharAt (i + 1) == '\n') {  		return new SimpleSegment (i' 2);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (text.GetCharAt (i + 1) == '\n') {  	return new SimpleSegment (i' 2);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: return new SimpleSegment (i' 2);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,FindNextNewLine,The following statement contains a magic number: if (s == SimpleSegment.Invalid) {  	newLineType = null;  	return -1;  } else {  	if (s.Length == 2) {  		newLineType = "\r\n";  	} else if (text.GetCharAt (s.Offset) == '\n') {  		newLineType = "\n";  	} else {  		newLineType = "\r";  	}  	return s.Offset;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,FindNextNewLine,The following statement contains a magic number: if (s.Length == 2) {  	newLineType = "\r\n";  } else if (text.GetCharAt (s.Offset) == '\n') {  	newLineType = "\n";  } else {  	newLineType = "\r";  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  	return c0Table [num];  else if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  	return c0Table [num];  else if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  	return c0Table [num];  else if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num >= 127 && num <= 159)  	return delAndC1Table [num - 127];  else  	return num.ToString ("x4"' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: return delAndC1Table [num - 127];  
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return offset + 3559 * insertionLength + 3571 * (int)removalLengthWithDeletionFlag;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return offset + 3559 * insertionLength + 3571 * (int)removalLengthWithDeletionFlag;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: return offset + 3559 * insertionLength + 3571 * (int)removalLengthWithDeletionFlag;  
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: return offset + 3559 * insertionLength + 3571 * (int)removalLengthWithDeletionFlag;  
Magic Number,ICSharpCode.AvalonEdit.Document,TextSegmentCollection,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Document,TextAnchorTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Document,TextLocation,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked(87 * x.GetHashCode () ^ y.GetHashCode ());  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,Remove,The following statement contains a magic number: if (offset > startLineOffset + startLine.Length) {  	Debug.Assert (startLine.DelimiterLength == 2);  	// we are deleting starting in the middle of a delimiter  	// remove last delimiter part  	SetLineLength (startLine' startLine.TotalLength - 1);  	// remove remaining text  	Remove (offset' length - 1);  	return;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,Remove,The following statement contains a magic number: Debug.Assert (startLine.DelimiterLength == 2);  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,Insert,The following statement contains a magic number: if (offset > lineOffset + line.Length) {  	Debug.Assert (line.DelimiterLength == 2);  	// we are inserting in the middle of a delimiter  	// shorten line  	SetLineLength (line' line.TotalLength - 1);  	// add new line  	line = InsertLineAfter (line' 1);  	line = SetLineLength (line' 1);  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,Insert,The following statement contains a magic number: Debug.Assert (line.DelimiterLength == 2);  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  	line.DelimiterLength = 0;  } else {  	int lineOffset = line.Offset;  	char lastChar = document.GetCharAt (lineOffset + newTotalLength - 1);  	if (lastChar == '\r') {  		line.DelimiterLength = 1;  	} else if (lastChar == '\n') {  		if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  			line.DelimiterLength = 2;  		} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  			// we need to join this line with the previous line  			DocumentLine previousLine = line.PreviousLine;  			RemoveLine (line);  			return SetLineLength (previousLine' previousLine.TotalLength + 1);  		} else {  			line.DelimiterLength = 1;  		}  	} else {  		line.DelimiterLength = 0;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  	line.DelimiterLength = 0;  } else {  	int lineOffset = line.Offset;  	char lastChar = document.GetCharAt (lineOffset + newTotalLength - 1);  	if (lastChar == '\r') {  		line.DelimiterLength = 1;  	} else if (lastChar == '\n') {  		if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  			line.DelimiterLength = 2;  		} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  			// we need to join this line with the previous line  			DocumentLine previousLine = line.PreviousLine;  			RemoveLine (line);  			return SetLineLength (previousLine' previousLine.TotalLength + 1);  		} else {  			line.DelimiterLength = 1;  		}  	} else {  		line.DelimiterLength = 0;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  	line.DelimiterLength = 0;  } else {  	int lineOffset = line.Offset;  	char lastChar = document.GetCharAt (lineOffset + newTotalLength - 1);  	if (lastChar == '\r') {  		line.DelimiterLength = 1;  	} else if (lastChar == '\n') {  		if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  			line.DelimiterLength = 2;  		} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  			// we need to join this line with the previous line  			DocumentLine previousLine = line.PreviousLine;  			RemoveLine (line);  			return SetLineLength (previousLine' previousLine.TotalLength + 1);  		} else {  			line.DelimiterLength = 1;  		}  	} else {  		line.DelimiterLength = 0;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\r') {  	line.DelimiterLength = 1;  } else if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\r') {  	line.DelimiterLength = 1;  } else if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\r') {  	line.DelimiterLength = 1;  } else if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (lastChar == '\n') {  	if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  		line.DelimiterLength = 2;  	} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  		// we need to join this line with the previous line  		DocumentLine previousLine = line.PreviousLine;  		RemoveLine (line);  		return SetLineLength (previousLine' previousLine.TotalLength + 1);  	} else {  		line.DelimiterLength = 1;  	}  } else {  	line.DelimiterLength = 0;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  	line.DelimiterLength = 2;  } else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  	// we need to join this line with the previous line  	DocumentLine previousLine = line.PreviousLine;  	RemoveLine (line);  	return SetLineLength (previousLine' previousLine.TotalLength + 1);  } else {  	line.DelimiterLength = 1;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  	line.DelimiterLength = 2;  } else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  	// we need to join this line with the previous line  	DocumentLine previousLine = line.PreviousLine;  	RemoveLine (line);  	return SetLineLength (previousLine' previousLine.TotalLength + 1);  } else {  	line.DelimiterLength = 1;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength >= 2 && document.GetCharAt (lineOffset + newTotalLength - 2) == '\r') {  	line.DelimiterLength = 2;  } else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt (lineOffset - 1) == '\r') {  	// we need to join this line with the previous line  	DocumentLine previousLine = line.PreviousLine;  	RemoveLine (line);  	return SetLineLength (previousLine' previousLine.TotalLength + 1);  } else {  	line.DelimiterLength = 1;  }  
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: line.DelimiterLength = 2;  
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,GetTreeHeight,The following statement contains a magic number: if (size == 0)  	return 0;  else  	return GetTreeHeight (size / 2) + 1;  
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,GetTreeHeight,The following statement contains a magic number: return GetTreeHeight (size / 2) + 1;  
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Document,TextDocument,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The following statement contains a magic number: switch (offsetChangeMappingType) {  case OffsetChangeMappingType.Normal:  	Replace (offset' length' text' null);  	break;  case OffsetChangeMappingType.RemoveAndInsert:  	if (length == 0 || text.Length == 0) {  		// only insertion or only removal?  		// OffsetChangeMappingType doesn't matter' just use Normal.  		Replace (offset' length' text' null);  	} else {  		OffsetChangeMap map = new OffsetChangeMap (2);  		map.Add (new OffsetChangeMapEntry (offset' length' 0));  		map.Add (new OffsetChangeMapEntry (offset' 0' text.Length));  		map.Freeze ();  		Replace (offset' length' text' map);  	}  	break;  case OffsetChangeMappingType.CharacterReplace:  	if (length == 0 || text.Length == 0) {  		// only insertion or only removal?  		// OffsetChangeMappingType doesn't matter' just use Normal.  		Replace (offset' length' text' null);  	} else if (text.Length > length) {  		// look at OffsetChangeMappingType.CharacterReplace XML comments on why we need to replace  		// the last character  		OffsetChangeMapEntry entry = new OffsetChangeMapEntry (offset + length - 1' 1' 1 + text.Length - length);  		Replace (offset' length' text' OffsetChangeMap.FromSingleElement (entry));  	} else if (text.Length < length) {  		OffsetChangeMapEntry entry = new OffsetChangeMapEntry (offset + text.Length' length - text.Length' 0' true);  		Replace (offset' length' text' OffsetChangeMap.FromSingleElement (entry));  	} else {  		Replace (offset' length' text' OffsetChangeMap.Empty);  	}  	break;  default:  	throw new ArgumentOutOfRangeException ("offsetChangeMappingType"' offsetChangeMappingType' "Invalid enum value");  }  
Magic Number,ICSharpCode.AvalonEdit.Document,TextDocument,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The following statement contains a magic number: if (length == 0 || text.Length == 0) {  	// only insertion or only removal?  	// OffsetChangeMappingType doesn't matter' just use Normal.  	Replace (offset' length' text' null);  } else {  	OffsetChangeMap map = new OffsetChangeMap (2);  	map.Add (new OffsetChangeMapEntry (offset' length' 0));  	map.Add (new OffsetChangeMapEntry (offset' 0' text.Length));  	map.Freeze ();  	Replace (offset' length' text' map);  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: return new Line {  	X1 = 0'  	Y1 = 0'  	X2 = 0'  	Y2 = 1'  	StrokeDashArray =  {  		0'  		2  	}'  	Stretch = Stretch.Fill'  	Stroke = Brushes.Gray'  	StrokeThickness = 1'  	StrokeDashCap = PenLineCap.Round'  	Margin = new Thickness (2' 0' 2' 0)'  	Tag = tag  };  
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: return new Line {  	X1 = 0'  	Y1 = 0'  	X2 = 0'  	Y2 = 1'  	StrokeDashArray =  {  		0'  		2  	}'  	Stretch = Stretch.Fill'  	Stroke = Brushes.Gray'  	StrokeThickness = 1'  	StrokeDashCap = PenLineCap.Round'  	Margin = new Thickness (2' 0' 2' 0)'  	Tag = tag  };  
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: return new Line {  	X1 = 0'  	Y1 = 0'  	X2 = 0'  	Y2 = 1'  	StrokeDashArray =  {  		0'  		2  	}'  	Stretch = Stretch.Fill'  	Stroke = Brushes.Gray'  	StrokeThickness = 1'  	StrokeDashCap = PenLineCap.Round'  	Margin = new Thickness (2' 0' 2' 0)'  	Tag = tag  };  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: if (newLength < 2)  	newLength = 2;  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: if (newLength < 2)  	newLength = 2;  
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: newLength = 2;  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (!e.Handled && e.ChangedButton == MouseButton.Left) {  	ModifierKeys modifiers = Keyboard.Modifiers;  	bool shift = (modifiers & ModifierKeys.Shift) == ModifierKeys.Shift;  	if (AllowTextDragDrop && e.ClickCount == 1 && !shift) {  		int visualColumn;  		int offset = GetOffsetFromMousePosition (e' out visualColumn);  		if (textArea.Selection.Contains (offset)) {  			if (textArea.CaptureMouse ()) {  				mode = SelectionMode.PossibleDragStart;  				possibleDragStartMousePos = e.GetPosition (textArea);  			}  			e.Handled = true;  			return;  		}  	}  	int oldOffset = textArea.Caret.Offset;  	SetCaretOffsetToMousePosition (e);  	if (!shift) {  		textArea.Selection = Selection.Empty;  	}  	if (textArea.CaptureMouse ()) {  		if ((modifiers & ModifierKeys.Alt) == ModifierKeys.Alt) {  			mode = SelectionMode.Rectangular;  			if (shift && textArea.Selection is RectangleSelection) {  				textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldOffset' textArea.Caret.Offset);  			}  		} else if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  			mode = SelectionMode.Normal;  			if (shift && !(textArea.Selection is RectangleSelection)) {  				textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldOffset' textArea.Caret.Offset);  			}  		} else {  			SimpleSegment startWord;  			if (e.ClickCount == 3) {  				mode = SelectionMode.WholeLine;  				startWord = GetLineAtMousePosition (e);  			} else {  				mode = SelectionMode.WholeWord;  				startWord = GetWordAtMousePosition (e);  			}  			if (startWord == SimpleSegment.Invalid) {  				mode = SelectionMode.None;  				textArea.ReleaseMouseCapture ();  				return;  			}  			if (shift && !textArea.Selection.IsEmpty) {  				if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  					textArea.Selection = textArea.Selection.SetEndpoint (startWord.Offset);  				} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  					textArea.Selection = textArea.Selection.SetEndpoint (startWord.EndOffset);  				}  				this.startWord = new AnchorSegment (textArea.Document' textArea.Selection.SurroundingSegment);  			} else {  				textArea.Selection = new SimpleSelection (startWord.Offset' startWord.EndOffset);  				this.startWord = new AnchorSegment (textArea.Document' startWord.Offset' startWord.Length);  			}  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (textArea.CaptureMouse ()) {  	if ((modifiers & ModifierKeys.Alt) == ModifierKeys.Alt) {  		mode = SelectionMode.Rectangular;  		if (shift && textArea.Selection is RectangleSelection) {  			textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldOffset' textArea.Caret.Offset);  		}  	} else if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  		mode = SelectionMode.Normal;  		if (shift && !(textArea.Selection is RectangleSelection)) {  			textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldOffset' textArea.Caret.Offset);  		}  	} else {  		SimpleSegment startWord;  		if (e.ClickCount == 3) {  			mode = SelectionMode.WholeLine;  			startWord = GetLineAtMousePosition (e);  		} else {  			mode = SelectionMode.WholeWord;  			startWord = GetWordAtMousePosition (e);  		}  		if (startWord == SimpleSegment.Invalid) {  			mode = SelectionMode.None;  			textArea.ReleaseMouseCapture ();  			return;  		}  		if (shift && !textArea.Selection.IsEmpty) {  			if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  				textArea.Selection = textArea.Selection.SetEndpoint (startWord.Offset);  			} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  				textArea.Selection = textArea.Selection.SetEndpoint (startWord.EndOffset);  			}  			this.startWord = new AnchorSegment (textArea.Document' textArea.Selection.SurroundingSegment);  		} else {  			textArea.Selection = new SimpleSelection (startWord.Offset' startWord.EndOffset);  			this.startWord = new AnchorSegment (textArea.Document' startWord.Offset' startWord.Length);  		}  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if ((modifiers & ModifierKeys.Alt) == ModifierKeys.Alt) {  	mode = SelectionMode.Rectangular;  	if (shift && textArea.Selection is RectangleSelection) {  		textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldOffset' textArea.Caret.Offset);  	}  } else if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  	mode = SelectionMode.Normal;  	if (shift && !(textArea.Selection is RectangleSelection)) {  		textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldOffset' textArea.Caret.Offset);  	}  } else {  	SimpleSegment startWord;  	if (e.ClickCount == 3) {  		mode = SelectionMode.WholeLine;  		startWord = GetLineAtMousePosition (e);  	} else {  		mode = SelectionMode.WholeWord;  		startWord = GetWordAtMousePosition (e);  	}  	if (startWord == SimpleSegment.Invalid) {  		mode = SelectionMode.None;  		textArea.ReleaseMouseCapture ();  		return;  	}  	if (shift && !textArea.Selection.IsEmpty) {  		if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  			textArea.Selection = textArea.Selection.SetEndpoint (startWord.Offset);  		} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  			textArea.Selection = textArea.Selection.SetEndpoint (startWord.EndOffset);  		}  		this.startWord = new AnchorSegment (textArea.Document' textArea.Selection.SurroundingSegment);  	} else {  		textArea.Selection = new SimpleSelection (startWord.Offset' startWord.EndOffset);  		this.startWord = new AnchorSegment (textArea.Document' startWord.Offset' startWord.Length);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  	mode = SelectionMode.Normal;  	if (shift && !(textArea.Selection is RectangleSelection)) {  		textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint (oldOffset' textArea.Caret.Offset);  	}  } else {  	SimpleSegment startWord;  	if (e.ClickCount == 3) {  		mode = SelectionMode.WholeLine;  		startWord = GetLineAtMousePosition (e);  	} else {  		mode = SelectionMode.WholeWord;  		startWord = GetWordAtMousePosition (e);  	}  	if (startWord == SimpleSegment.Invalid) {  		mode = SelectionMode.None;  		textArea.ReleaseMouseCapture ();  		return;  	}  	if (shift && !textArea.Selection.IsEmpty) {  		if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  			textArea.Selection = textArea.Selection.SetEndpoint (startWord.Offset);  		} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  			textArea.Selection = textArea.Selection.SetEndpoint (startWord.EndOffset);  		}  		this.startWord = new AnchorSegment (textArea.Document' textArea.Selection.SurroundingSegment);  	} else {  		textArea.Selection = new SimpleSelection (startWord.Offset' startWord.EndOffset);  		this.startWord = new AnchorSegment (textArea.Document' startWord.Offset' startWord.Length);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (e.ClickCount == 3) {  	mode = SelectionMode.WholeLine;  	startWord = GetLineAtMousePosition (e);  } else {  	mode = SelectionMode.WholeWord;  	startWord = GetWordAtMousePosition (e);  }  
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,ExtendSelectionToMouse,The following statement contains a magic number: textArea.Caret.BringCaretToView (5.0);  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: foreach (FoldingMarginMarker m in markers) {  	int visualColumn = m.VisualLine.GetVisualColumn (m.FoldingSection.StartOffset - m.VisualLine.FirstDocumentLine.Offset);  	TextLine textLine = m.VisualLine.GetTextLine (visualColumn);  	double yPos = m.VisualLine.GetTextLineVisualYPosition (textLine' VisualYPosition.LineTop) - TextView.VerticalOffset;  	yPos += (textLine.Height - m.DesiredSize.Height) / 2;  	double xPos = (finalSize.Width - m.DesiredSize.Width) / 2;  	m.Arrange (new Rect (PixelSnapHelpers.Round (new Point (xPos' yPos)' pixelSize)' m.DesiredSize));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: foreach (FoldingMarginMarker m in markers) {  	int visualColumn = m.VisualLine.GetVisualColumn (m.FoldingSection.StartOffset - m.VisualLine.FirstDocumentLine.Offset);  	TextLine textLine = m.VisualLine.GetTextLine (visualColumn);  	double yPos = m.VisualLine.GetTextLineVisualYPosition (textLine' VisualYPosition.LineTop) - TextView.VerticalOffset;  	yPos += (textLine.Height - m.DesiredSize.Height) / 2;  	double xPos = (finalSize.Width - m.DesiredSize.Width) / 2;  	m.Arrange (new Rect (PixelSnapHelpers.Round (new Point (xPos' yPos)' pixelSize)' m.DesiredSize));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: yPos += (textLine.Height - m.DesiredSize.Height) / 2;  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  	foreach (TextLine tl in vl.TextLines) {  		if (endMarker [tlNumber] != null) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  		}  		if (colors [tlNumber + 1] != currentPen) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			if (currentPen != null) {  				drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  			}  			currentPen = colors [tlNumber + 1];  			startY = visualPos;  		}  		tlNumber++;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  	foreach (TextLine tl in vl.TextLines) {  		if (endMarker [tlNumber] != null) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  		}  		if (colors [tlNumber + 1] != currentPen) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			if (currentPen != null) {  				drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  			}  			currentPen = colors [tlNumber + 1];  			startY = visualPos;  		}  		tlNumber++;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  	foreach (TextLine tl in vl.TextLines) {  		if (endMarker [tlNumber] != null) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  		}  		if (colors [tlNumber + 1] != currentPen) {  			double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  			if (currentPen != null) {  				drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  			}  			currentPen = colors [tlNumber + 1];  			startY = visualPos;  		}  		tlNumber++;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (TextLine tl in vl.TextLines) {  	if (endMarker [tlNumber] != null) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  	}  	if (colors [tlNumber + 1] != currentPen) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		if (currentPen != null) {  			drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  		}  		currentPen = colors [tlNumber + 1];  		startY = visualPos;  	}  	tlNumber++;  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (TextLine tl in vl.TextLines) {  	if (endMarker [tlNumber] != null) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  	}  	if (colors [tlNumber + 1] != currentPen) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		if (currentPen != null) {  			drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  		}  		currentPen = colors [tlNumber + 1];  		startY = visualPos;  	}  	tlNumber++;  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (TextLine tl in vl.TextLines) {  	if (endMarker [tlNumber] != null) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  	}  	if (colors [tlNumber + 1] != currentPen) {  		double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  		if (currentPen != null) {  			drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  		}  		currentPen = colors [tlNumber + 1];  		startY = visualPos;  	}  	tlNumber++;  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (endMarker [tlNumber] != null) {  	double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  	drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: drawingContext.DrawLine (endMarker [tlNumber]' new Point (markerXPos - pixelSize.Width / 2' visualPos)' new Point (RenderSize.Width' visualPos));  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (colors [tlNumber + 1] != currentPen) {  	double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  	if (currentPen != null) {  		drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  	}  	currentPen = colors [tlNumber + 1];  	startY = visualPos;  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (colors [tlNumber + 1] != currentPen) {  	double visualPos = GetVisualPos (vl' tl' pixelSize.Height);  	if (currentPen != null) {  		drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  	}  	currentPen = colors [tlNumber + 1];  	startY = visualPos;  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (currentPen != null) {  	drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (currentPen != null) {  	drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' visualPos - pixelSize.Height / 2));  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (currentPen != null) {  	drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' RenderSize.Height));  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: drawingContext.DrawLine (currentPen' new Point (markerXPos' startY + pixelSize.Height / 2)' new Point (markerXPos' RenderSize.Height));  
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (comment != null) {  	int firstNewLine = comment.IndexOf ('\n');  	if (firstNewLine >= 0) {  		// Take off 4 chars to get the actual comment start (takes  		// into account the <!-- chars.  		int startOffset = GetOffset (document' reader) - 4;  		int endOffset = startOffset + comment.Length + 3;  		string foldText = String.Concat ("<!--"' comment.Substring (0' firstNewLine).TrimEnd ('\r')' "-->");  		foldMarkers.Add (new NewFolding (startOffset' endOffset) {  			Name = foldText  		});  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (comment != null) {  	int firstNewLine = comment.IndexOf ('\n');  	if (firstNewLine >= 0) {  		// Take off 4 chars to get the actual comment start (takes  		// into account the <!-- chars.  		int startOffset = GetOffset (document' reader) - 4;  		int endOffset = startOffset + comment.Length + 3;  		string foldText = String.Concat ("<!--"' comment.Substring (0' firstNewLine).TrimEnd ('\r')' "-->");  		foldMarkers.Add (new NewFolding (startOffset' endOffset) {  			Name = foldText  		});  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (firstNewLine >= 0) {  	// Take off 4 chars to get the actual comment start (takes  	// into account the <!-- chars.  	int startOffset = GetOffset (document' reader) - 4;  	int endOffset = startOffset + comment.Length + 3;  	string foldText = String.Concat ("<!--"' comment.Substring (0' firstNewLine).TrimEnd ('\r')' "-->");  	foldMarkers.Add (new NewFolding (startOffset' endOffset) {  		Name = foldText  	});  }  
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (firstNewLine >= 0) {  	// Take off 4 chars to get the actual comment start (takes  	// into account the <!-- chars.  	int startOffset = GetOffset (document' reader) - 4;  	int endOffset = startOffset + comment.Length + 3;  	string foldText = String.Concat ("<!--"' comment.Substring (0' firstNewLine).TrimEnd ('\r')' "-->");  	foldMarkers.Add (new NewFolding (startOffset' endOffset) {  		Name = foldText  	});  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HtmlOptions,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,HtmlOptions,The following statement contains a magic number: this.TabSize = 4;  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith ("#"' StringComparison.Ordinal)) {  	int a = 255;  	int offset = 0;  	if (c.Length > 7) {  		offset = 2;  		a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	}  	int r = Int32.Parse (c.Substring (1 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int g = Int32.Parse (c.Substring (3 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	int b = Int32.Parse (c.Substring (5 + offset' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	return new SimpleHighlightingBrush (Color.FromArgb ((byte)a' (byte)r' (byte)g' (byte)b));  } else if (c.StartsWith ("SystemColors."' StringComparison.Ordinal)) {  	return V2Loader.GetSystemColorBrush (null' c);  } else {  	return new SimpleHighlightingBrush ((Color)V2Loader.ColorConverter.ConvertFromInvariantString (c));  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.Length > 7) {  	offset = 2;  	a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.Length > 7) {  	offset = 2;  	a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.Length > 7) {  	offset = 2;  	a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  }  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: offset = 2;  
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: a = Int32.Parse (c.Substring (1' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  
Magic Number,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,RebuildDocument,The following statement contains a magic number: dict = new Dictionary<DocumentLine' HeightTreeNode> ((int)(document.LineCount / 0.7));  
Magic Number,ICSharpCode.AvalonEdit.Rendering,HeightTree,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,NewLineElementGenerator,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\NewLineElementGenerator.cs,ConstructElement,The following statement contains a magic number: if (lastDocumentLine.DelimiterLength == 2) {  	newlineText = "\u00B6";  } else if (lastDocumentLine.DelimiterLength == 1) {  	char newlineChar = CurrentContext.Document.GetCharAt (lastDocumentLine.Offset + lastDocumentLine.Length);  	if (newlineChar == '\r')  		newlineText = "\\r";  	else if (newlineChar == '\n')  		newlineText = "\\n";  	else  		newlineText = "?";  } else {  	return null;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The following statement contains a magic number: if (ShowSpaces && c == ' ') {  	FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' "\u00B7"' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize' Brushes.LightGray);  	return new SpaceTextElement (text);  } else if (ShowTabs && c == '\t') {  	FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' "\u00BB"' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize' Brushes.LightGray);  	return new TabTextElement (text);  } else if (ShowBoxForControlCharacters && char.IsControl (c)) {  	FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' TextUtilities.GetControlCharacterName (c)' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize * 0.9' Brushes.White);  	return new SpecialCharacterBoxElement (text);  } else {  	return null;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The following statement contains a magic number: if (ShowTabs && c == '\t') {  	FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' "\u00BB"' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize' Brushes.LightGray);  	return new TabTextElement (text);  } else if (ShowBoxForControlCharacters && char.IsControl (c)) {  	FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' TextUtilities.GetControlCharacterName (c)' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize * 0.9' Brushes.White);  	return new SpecialCharacterBoxElement (text);  } else {  	return null;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The following statement contains a magic number: if (ShowBoxForControlCharacters && char.IsControl (c)) {  	FormattedText text = TextFormatterFactory.CreateFormattedText (CurrentContext.TextView' TextUtilities.GetControlCharacterName (c)' CurrentContext.GlobalTextRunProperties.Typeface' CurrentContext.GlobalTextRunProperties.FontRenderingEmSize * 0.9' Brushes.White);  	return new SpecialCharacterBoxElement (text);  } else {  	return null;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnDocumentChanged,The following statement contains a magic number: if (newValue != null) {  	TextDocumentWeakEventManager.Changing.AddListener (newValue' this);  	heightTree = new HeightTree (newValue' FontSize + 3);  	formatter = TextFormatterFactory.Create (this);  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnDocumentChanged,The following statement contains a magic number: heightTree = new HeightTree (newValue' FontSize + 3);  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width > 32000)  	availableSize.Width = 32000;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width > 32000)  	availableSize.Width = 32000;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: availableSize.Width = 32000;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (options.AllowScrollBelowDocument) {  	heightTreeHeight = Math.Max (heightTreeHeight' Math.Min (heightTreeHeight - 50' scrollOffset.Y) + scrollViewport.Height);  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: heightTreeHeight = Math.Max (heightTreeHeight' Math.Min (heightTreeHeight - 50' scrollOffset.Y) + scrollViewport.Height);  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Left < visibleRectangle.Left) {  	if (rectangle.Right > visibleRectangle.Right) {  		newScrollOffset.X = rectangle.Left + rectangle.Width / 2;  	} else {  		newScrollOffset.X = rectangle.Left;  	}  } else if (rectangle.Right > visibleRectangle.Right) {  	newScrollOffset.X = rectangle.Right - scrollViewport.Width;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Right > visibleRectangle.Right) {  	newScrollOffset.X = rectangle.Left + rectangle.Width / 2;  } else {  	newScrollOffset.X = rectangle.Left;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: newScrollOffset.X = rectangle.Left + rectangle.Width / 2;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Top < visibleRectangle.Top) {  	if (rectangle.Bottom > visibleRectangle.Bottom) {  		newScrollOffset.Y = rectangle.Top + rectangle.Height / 2;  	} else {  		newScrollOffset.Y = rectangle.Top;  	}  } else if (rectangle.Bottom > visibleRectangle.Bottom) {  	newScrollOffset.Y = rectangle.Bottom - scrollViewport.Height;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Bottom > visibleRectangle.Bottom) {  	newScrollOffset.Y = rectangle.Top + rectangle.Height / 2;  } else {  	newScrollOffset.Y = rectangle.Top;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: newScrollOffset.Y = rectangle.Top + rectangle.Height / 2;  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: foreach (TextLine tl in TextLines) {  	if (tl == textLine) {  		switch (yPositionMode) {  		case VisualYPosition.LineTop:  			return pos;  		case VisualYPosition.LineMiddle:  			return pos + tl.Height / 2;  		case VisualYPosition.LineBottom:  			return pos + tl.Height;  		case VisualYPosition.TextTop:  			return pos + tl.Height - textView.FontSize;  		default:  			throw new ArgumentException ("Invalid yPositionMode:" + yPositionMode);  		}  	} else {  		pos += tl.Height;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: if (tl == textLine) {  	switch (yPositionMode) {  	case VisualYPosition.LineTop:  		return pos;  	case VisualYPosition.LineMiddle:  		return pos + tl.Height / 2;  	case VisualYPosition.LineBottom:  		return pos + tl.Height;  	case VisualYPosition.TextTop:  		return pos + tl.Height - textView.FontSize;  	default:  		throw new ArgumentException ("Invalid yPositionMode:" + yPositionMode);  	}  } else {  	pos += tl.Height;  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: switch (yPositionMode) {  case VisualYPosition.LineTop:  	return pos;  case VisualYPosition.LineMiddle:  	return pos + tl.Height / 2;  case VisualYPosition.LineBottom:  	return pos + tl.Height;  case VisualYPosition.TextTop:  	return pos + tl.Height - textView.FontSize;  default:  	throw new ArgumentException ("Invalid yPositionMode:" + yPositionMode);  }  
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: return pos + tl.Height / 2;  
Magic Number,ICSharpCode.AvalonEdit.Utils,CompressingTreeList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: if (size == arr.Length)  	SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: if (size == arr.Length)  	SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: if (size == arr.Length)  	SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: if (size == arr.Length)  	SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: SetCapacity (Math.Max (4' arr.Length * 2));  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  case 65000:  // UTF-7  case 65001:  // UTF-8  case 1200:  // UTF-16 LE  case 1201:  // UTF-16 BE  case 12000:  // UTF-32 LE  case 12001:  	// UTF-32 BE  	return true;  default:  	return false;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: if (stream.Length >= 2) {  	// the autodetection of StreamReader is not capable of detecting the difference  	// between ISO-8859-1 and UTF-8 without BOM.  	int firstByte = stream.ReadByte ();  	int secondByte = stream.ReadByte ();  	switch ((firstByte << 8) | secondByte) {  	case 0x0000:  	// either UTF-32 Big Endian or a binary file; use StreamReader  	case 0xfffe:  	// Unicode BOM (UTF-16 LE or UTF-32 LE)  	case 0xfeff:  	// UTF-16 BE BOM  	case 0xefbb:  		// start of UTF-8 BOM  		// StreamReader autodetection works  		stream.Position = 0;  		return new StreamReader (stream);  	default:  		return AutoDetect (stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  	}  } else {  	if (defaultEncoding != null) {  		return new StreamReader (stream' defaultEncoding);  	} else {  		return new StreamReader (stream);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: if (stream.Length >= 2) {  	// the autodetection of StreamReader is not capable of detecting the difference  	// between ISO-8859-1 and UTF-8 without BOM.  	int firstByte = stream.ReadByte ();  	int secondByte = stream.ReadByte ();  	switch ((firstByte << 8) | secondByte) {  	case 0x0000:  	// either UTF-32 Big Endian or a binary file; use StreamReader  	case 0xfffe:  	// Unicode BOM (UTF-16 LE or UTF-32 LE)  	case 0xfeff:  	// UTF-16 BE BOM  	case 0xefbb:  		// start of UTF-8 BOM  		// StreamReader autodetection works  		stream.Position = 0;  		return new StreamReader (stream);  	default:  		return AutoDetect (stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  	}  } else {  	if (defaultEncoding != null) {  		return new StreamReader (stream' defaultEncoding);  	} else {  		return new StreamReader (stream);  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: switch ((firstByte << 8) | secondByte) {  case 0x0000:  // either UTF-32 Big Endian or a binary file; use StreamReader  case 0xfffe:  // Unicode BOM (UTF-16 LE or UTF-32 LE)  case 0xfeff:  // UTF-16 BE BOM  case 0xefbb:  	// start of UTF-8 BOM  	// StreamReader autodetection works  	stream.Position = 0;  	return new StreamReader (stream);  default:  	return AutoDetect (stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) {  	if (i == 0) {  		b = firstByte;  	} else if (i == 1) {  		b = secondByte;  	} else {  		b = (byte)fs.ReadByte ();  	}  	if (b < 0x80) {  		// normal ASCII character  		if (state == UTF8Sequence) {  			state = Error;  			break;  		}  	} else if (b < 0xc0) {  		// 10xxxxxx : continues UTF8 byte sequence  		if (state == UTF8Sequence) {  			--sequenceLength;  			if (sequenceLength < 0) {  				state = Error;  				break;  			} else if (sequenceLength == 0) {  				state = UTF8;  			}  		} else {  			state = Error;  			break;  		}  	} else if (b >= 0xc2 && b < 0xf5) {  		// beginning of byte sequence  		if (state == UTF8 || state == ASCII) {  			state = UTF8Sequence;  			if (b < 0xe0) {  				sequenceLength = 1;  				// one more byte following  			} else if (b < 0xf0) {  				sequenceLength = 2;  				// two more bytes following  			} else {  				sequenceLength = 3;  				// three more bytes following  			}  		} else {  			state = Error;  			break;  		}  	} else {  		// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  		state = Error;  		break;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) {  	if (i == 0) {  		b = firstByte;  	} else if (i == 1) {  		b = secondByte;  	} else {  		b = (byte)fs.ReadByte ();  	}  	if (b < 0x80) {  		// normal ASCII character  		if (state == UTF8Sequence) {  			state = Error;  			break;  		}  	} else if (b < 0xc0) {  		// 10xxxxxx : continues UTF8 byte sequence  		if (state == UTF8Sequence) {  			--sequenceLength;  			if (sequenceLength < 0) {  				state = Error;  				break;  			} else if (sequenceLength == 0) {  				state = UTF8;  			}  		} else {  			state = Error;  			break;  		}  	} else if (b >= 0xc2 && b < 0xf5) {  		// beginning of byte sequence  		if (state == UTF8 || state == ASCII) {  			state = UTF8Sequence;  			if (b < 0xe0) {  				sequenceLength = 1;  				// one more byte following  			} else if (b < 0xf0) {  				sequenceLength = 2;  				// two more bytes following  			} else {  				sequenceLength = 3;  				// three more bytes following  			}  		} else {  			state = Error;  			break;  		}  	} else {  		// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  		state = Error;  		break;  	}  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0x80) {  	// normal ASCII character  	if (state == UTF8Sequence) {  		state = Error;  		break;  	}  } else if (b < 0xc0) {  	// 10xxxxxx : continues UTF8 byte sequence  	if (state == UTF8Sequence) {  		--sequenceLength;  		if (sequenceLength < 0) {  			state = Error;  			break;  		} else if (sequenceLength == 0) {  			state = UTF8;  		}  	} else {  		state = Error;  		break;  	}  } else if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0x80) {  	// normal ASCII character  	if (state == UTF8Sequence) {  		state = Error;  		break;  	}  } else if (b < 0xc0) {  	// 10xxxxxx : continues UTF8 byte sequence  	if (state == UTF8Sequence) {  		--sequenceLength;  		if (sequenceLength < 0) {  			state = Error;  			break;  		} else if (sequenceLength == 0) {  			state = UTF8;  		}  	} else {  		state = Error;  		break;  	}  } else if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xc0) {  	// 10xxxxxx : continues UTF8 byte sequence  	if (state == UTF8Sequence) {  		--sequenceLength;  		if (sequenceLength < 0) {  			state = Error;  			break;  		} else if (sequenceLength == 0) {  			state = UTF8;  		}  	} else {  		state = Error;  		break;  	}  } else if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xc0) {  	// 10xxxxxx : continues UTF8 byte sequence  	if (state == UTF8Sequence) {  		--sequenceLength;  		if (sequenceLength < 0) {  			state = Error;  			break;  		} else if (sequenceLength == 0) {  			state = UTF8;  		}  	} else {  		state = Error;  		break;  	}  } else if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b >= 0xc2 && b < 0xf5) {  	// beginning of byte sequence  	if (state == UTF8 || state == ASCII) {  		state = UTF8Sequence;  		if (b < 0xe0) {  			sequenceLength = 1;  			// one more byte following  		} else if (b < 0xf0) {  			sequenceLength = 2;  			// two more bytes following  		} else {  			sequenceLength = 3;  			// three more bytes following  		}  	} else {  		state = Error;  		break;  	}  } else {  	// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (state == UTF8 || state == ASCII) {  	state = UTF8Sequence;  	if (b < 0xe0) {  		sequenceLength = 1;  		// one more byte following  	} else if (b < 0xf0) {  		sequenceLength = 2;  		// two more bytes following  	} else {  		sequenceLength = 3;  		// three more bytes following  	}  } else {  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (state == UTF8 || state == ASCII) {  	state = UTF8Sequence;  	if (b < 0xe0) {  		sequenceLength = 1;  		// one more byte following  	} else if (b < 0xf0) {  		sequenceLength = 2;  		// two more bytes following  	} else {  		sequenceLength = 3;  		// three more bytes following  	}  } else {  	state = Error;  	break;  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xe0) {  	sequenceLength = 1;  	// one more byte following  } else if (b < 0xf0) {  	sequenceLength = 2;  	// two more bytes following  } else {  	sequenceLength = 3;  	// three more bytes following  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xe0) {  	sequenceLength = 1;  	// one more byte following  } else if (b < 0xf0) {  	sequenceLength = 2;  	// two more bytes following  } else {  	sequenceLength = 3;  	// three more bytes following  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xf0) {  	sequenceLength = 2;  	// two more bytes following  } else {  	sequenceLength = 3;  	// three more bytes following  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: if (b < 0xf0) {  	sequenceLength = 2;  	// two more bytes following  } else {  	sequenceLength = 3;  	// three more bytes following  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: sequenceLength = 2;  
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: sequenceLength = 3;  
Magic Number,ICSharpCode.AvalonEdit.Utils,RopeNode,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,CreateNodes,The following statement contains a magic number: if (leafCount == 1) {  	result.contents = new T[NodeSize];  } else {  	int rightSide = leafCount / 2;  	int leftSide = leafCount - rightSide;  	int leftLength = leftSide * NodeSize;  	result.left = CreateNodes (leftSide' leftLength);  	result.right = CreateNodes (rightSide' totalLength - leftLength);  	result.height = (byte)(1 + Math.Max (result.left.height' result.right.height));  }  
Magic Number,ICSharpCode.AvalonEdit.Utils,RopeNode,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Utils,FunctionNode,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;  
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,PixelAlign,The following statement contains a magic number: return pixelSize * (Math.Round ((value / pixelSize) + 0.5) - 0.5);  
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,PixelAlign,The following statement contains a magic number: return pixelSize * (Math.Round ((value / pixelSize) + 0.5) - 0.5);  
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,RoundToOdd,The following statement contains a magic number: return Round (value - pixelSize' pixelSize * 2) + pixelSize;  
Missing Default,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,HandleKey,The following switch statement is missing a default case: switch (e.Key) {  case Key.Down:  	e.Handled = true;  	index = listBox.SelectedIndex + 1;  	if (index > listBox.Items.Count - 1) {  		index = 0;  	}  	listBox.SelectIndex (index);  	break;  case Key.Up:  	e.Handled = true;  	index = listBox.SelectedIndex - 1;  	if (0 == listBox.SelectedIndex) {  		index = listBox.Items.Count - 1;  	}  	listBox.SelectIndex (index);  	break;  case Key.PageDown:  	e.Handled = true;  	listBox.SelectIndex (listBox.SelectedIndex + listBox.VisibleItemCount);  	break;  case Key.PageUp:  	e.Handled = true;  	listBox.SelectIndex (listBox.SelectedIndex - listBox.VisibleItemCount);  	break;  case Key.Home:  	e.Handled = true;  	listBox.SelectIndex (0);  	break;  case Key.End:  	e.Handled = true;  	listBox.SelectIndex (listBox.Items.Count - 1);  	break;  case Key.Tab:  	e.Handled = true;  	index = listBox.SelectedIndex + 1;  	if (index > listBox.Items.Count - 1) {  		index = 0;  	}  	listBox.SelectIndex (index);  	break;  case Key.Enter:  	e.Handled = true;  	RequestInsertion (e);  	break;  case Key.Oem5:  	RequestInsertion (e);  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.Up:  	e.Handled = true;  	overloadViewer.ChangeIndex (-1);  	break;  case Key.Down:  	e.Handled = true;  	overloadViewer.ChangeIndex (+1);  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following switch statement is missing a default case: switch (text [i]) {  case '\r':  	if (i + 1 < text.Length) {  		if (text [i + 1] == '\n') {  			return new SimpleSegment (i' 2);  		}  	}  	goto case '\n';  case '\n':  	return new SimpleSegment (i' 1);  }  
Missing Default,ICSharpCode.AvalonEdit.Document,NewLineFinder,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following switch statement is missing a default case: switch (text.GetCharAt (i)) {  case '\r':  	if (i + 1 < textLength) {  		if (text.GetCharAt (i + 1) == '\n') {  			return new SimpleSegment (i' 2);  		}  	}  	goto case '\n';  case '\n':  	return new SimpleSegment (i' 1);  }  
Missing Default,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateNewFoldings,The following switch statement is missing a default case: switch (reader.NodeType) {  case XmlNodeType.Element:  	if (!reader.IsEmptyElement) {  		XmlFoldStart newFoldStart = CreateElementFoldStart (document' reader);  		stack.Push (newFoldStart);  	}  	break;  case XmlNodeType.EndElement:  	XmlFoldStart foldStart = stack.Pop ();  	CreateElementFold (document' foldMarkers' reader' foldStart);  	break;  case XmlNodeType.Comment:  	CreateCommentFold (document' foldMarkers' reader);  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The following switch statement is missing a default case: switch (c) {  case '/':  	if (blockComment && lastchar == '*')  		blockComment = false;  	if (!inString && !inChar) {  		if (!blockComment && nextchar == '/')  			lineComment = true;  		if (!lineComment && nextchar == '*')  			blockComment = true;  	}  	break;  case '#':  	if (!(inChar || blockComment || inString))  		lineComment = true;  	break;  case '"':  	if (!(inChar || lineComment || blockComment)) {  		inString = !inString;  		if (!inString && verbatim) {  			if (nextchar == '"') {  				escape = true;  				// skip escaped quote  				inString = true;  			} else {  				verbatim = false;  			}  		} else if (inString && lastchar == '@') {  			verbatim = true;  		}  	}  	break;  case '\'':  	if (!(inString || lineComment || blockComment)) {  		inChar = !inChar;  	}  	break;  case '\\':  	if ((inString && !verbatim) || inChar)  		escape = true;  	// skip next character  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The following switch statement is missing a default case: switch (c) {  case '{':  	block.ResetOneLineBlock ();  	blocks.Push (block);  	block.StartLine = doc.LineNumber;  	if (block.LastWord == "switch") {  		block.Indent (set.IndentString + set.IndentString);  		/* oldBlock refers to the previous line' not the previous block 							 * The block we want is not available anymore because it was never pushed. 							 * } else if (oldBlock.OneLineBlock) { 							// Inside a one-line-block is another statement 							// with a full block: indent the inner full block 							// by one additional level 							block.Indent(set' set.IndentString + set.IndentString); 							block.OuterIndent += set.IndentString; 							// Indent current line if it starts with the '{' character 							if (i == 0) { 								oldBlock.InnerIndent += set.IndentString; 							}*/} else {  		block.Indent (set);  	}  	block.Bracket = '{';  	break;  case '}':  	while (block.Bracket != '{') {  		if (blocks.Count == 0)  			break;  		block = blocks.Pop ();  	}  	if (blocks.Count == 0)  		break;  	block = blocks.Pop ();  	block.Continuation = false;  	block.ResetOneLineBlock ();  	break;  case '(':  case '[':  	blocks.Push (block);  	if (block.StartLine == doc.LineNumber)  		block.InnerIndent = block.OuterIndent;  	else  		block.StartLine = doc.LineNumber;  	block.Indent (Repeat (set.IndentString' oldBlock.OneLineBlock) + (oldBlock.Continuation ? set.IndentString : "") + (i == line.Length - 1 ? set.IndentString : new String (' '' i + 1)));  	block.Bracket = c;  	break;  case ')':  	if (blocks.Count == 0)  		break;  	if (block.Bracket == '(') {  		block = blocks.Pop ();  		if (IsSingleStatementKeyword (block.LastWord))  			block.Continuation = false;  	}  	break;  case ']':  	if (blocks.Count == 0)  		break;  	if (block.Bracket == '[')  		block = blocks.Pop ();  	break;  case ';':  case ''':  	block.Continuation = false;  	block.ResetOneLineBlock ();  	break;  case ':':  	if (block.LastWord == "case" || line.StartsWith ("case "' StringComparison.Ordinal) || line.StartsWith (block.LastWord + ":"' StringComparison.Ordinal)) {  		block.Continuation = false;  		block.ResetOneLineBlock ();  	}  	break;  }  
Missing Default,ICSharpCode.AvalonEdit.Rendering,TextView,D:\newReposJune17\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,The following switch statement is missing a default case: switch (position) {  case LayerInsertionPosition.Below:  	layers.Insert (i' layer);  	return;  case LayerInsertionPosition.Above:  	layers.Insert (i + 1' layer);  	return;  case LayerInsertionPosition.Replace:  	layers [i] = layer;  	return;  }  
