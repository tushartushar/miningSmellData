Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The method has 281 lines of code.
Complex Method,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FindOverlappingSegments,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateAugmentedData,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,HandleTextChange,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingManager,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingManager.cs,UpdateFoldings,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,CalculateFoldLinesForFoldingsActiveAtStart,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightLineInternal,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightNonSpans,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,ToHtml,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,CreateHtmlFragment,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRuleSet,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRegex,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,Cyclomatic complexity of the method is 36
Complex Method,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,GetRectsForSegmentImpl,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,ColorizingTransformer,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\ColorizingTransformer.cs,ChangeVisualElements,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,MergeCollapsedSectionsIfPossible,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AddRemoveCollapsedSection,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CreateAndMeasureVisualLines,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ArrangeOverride,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,PerformVisualElementConstruction,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,FindNodeUsingCache,Cyclomatic complexity of the method is 9
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretUpDown,The method has 5 parameters. Parameters: textArea' direction' visualLine' textLine' caretVisualColumn
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,SetCaretPosition,The method has 5 parameters. Parameters: textArea' targetVisualLine' targetLine' ch' allowWrapToNextLine
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The method has 6 parameters. Parameters: documentLine' globalTextRunProperties' paragraphProperties' elementGeneratorsArray' lineTransformersArray' availableSize
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Utils,TextFormatterFactory,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\TextFormatterFactory.cs,CreateFormattedText,The method has 5 parameters. Parameters: element' text' typeface' emSize' foreground
Long Identifier,ICSharpCode.AvalonEdit,TextEditorOptions,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditorOptions.cs,,The length of the parameter requireControlModifierForHyperlinkClick is 39.
Long Identifier,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The length of the parameter removalNeverCausesAnchorDeletion is 32.
Long Identifier,ICSharpCode.AvalonEdit.Document,UndoStack,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\UndoStack.cs,,The length of the parameter elementsOnUndoUntilOriginalFile is 31.
Long Identifier,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\Caret.cs,,The length of the parameter raisePositionChangedOnUpdateFinished is 36.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,,The length of the parameter currentDocumentLineStartOffset is 30.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextLayer,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextLayer.cs,,The length of the parameter visualLinesWithOutstandingInlineObjects is 39.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,Redraw,The length of the parameter changedSomethingBeforeOrInLine is 30.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter singleCharacterElementGenerator is 31.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter AdditionalHorizontalScrollAmount is 32.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the parameter relativeSplitRelativeTextOffset is 31.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,Load,The length of the statement  "				this.Encoding = reader.CurrentEncoding; // assign encoding after ReadToEnd() so that the StreamReader can autodetect the encoding " is 129.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The length of the statement  "				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle); " is 123.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,SelectItemFiltering,The length of the statement  "			var listToFilter = (this.currentList != null && (!string.IsNullOrEmpty(this.currentText)) && (!string.IsNullOrEmpty(text)) && " is 125.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,completionList_InsertionRequested,The length of the statement  "				item.Complete(this.TextArea' new AnchorSegment(this.TextArea.Document' this.StartOffset' this.EndOffset - this.StartOffset)' e); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Document,SimpleSegment,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\ISegment.cs,ToString,The length of the statement  "			return "[Offset=" + Offset.ToString(CultureInfo.InvariantCulture) + "' Length=" + Length.ToString(CultureInfo.InvariantCulture) + "]"; " is 134.
Long Statement,ICSharpCode.AvalonEdit.Document,AnchorSegment,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\ISegment.cs,ToString,The length of the statement  "			return "[Offset=" + Offset.ToString(CultureInfo.InvariantCulture) + "' EndOffset=" + EndOffset.ToString(CultureInfo.InvariantCulture) + "]"; " is 140.
Long Statement,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,Equals,The length of the statement  "			return offset == other.offset && insertionLength == other.insertionLength && removalLengthWithDeletionFlag == other.removalLengthWithDeletionFlag; " is 146.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsets,The length of the statement  "				throw new InvalidOperationException("This TextSegmentCollection will automatically update offsets; do not call UpdateOffsets manually!"); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsets,The length of the statement  "				throw new InvalidOperationException("This TextSegmentCollection will automatically update offsets; do not call UpdateOffsets manually!"); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsetsInternal,The length of the statement  "			// Special case pure insertions' because they don't always cause a text segment to increase in size when the replaced region " is 124.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CopyTo,The length of the statement  "				throw new ArgumentOutOfRangeException("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - count)); " is 121.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,CopyTo,The length of the statement  "				throw new ArgumentOutOfRangeException("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - LineCount)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,ThrowIfRangeInvalid,The length of the statement  "				throw new ArgumentOutOfRangeException("offset"' offset' "0 <= offset <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,ThrowIfRangeInvalid,The length of the statement  "				throw new ArgumentOutOfRangeException("length"' length' "0 <= length' offset(" + offset + ")+length <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 159.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,CreateAnchor,The length of the statement  "				throw new ArgumentOutOfRangeException("offset"' offset' "0 <= offset <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The length of the statement  "			int newVisualColumnForwards = visualLine.GetNextCaretPosition(position.VisualColumn - 1' LogicalDirection.Forward' CaretPositioningMode.Normal); " is 144.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The length of the statement  "				int newVisualColumnBackwards = visualLine.GetNextCaretPosition(position.VisualColumn + 1' LogicalDirection.Backward' CaretPositioningMode.Normal); " is 146.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretRight,The length of the statement  "					Debug.Assert(visualLine.LastDocumentLine.Offset + visualLine.LastDocumentLine.TotalLength == textArea.Document.TextLength); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,CopyWholeLine,The length of the statement  "			HtmlClipboard.SetHtml(data' HtmlClipboard.CreateHtmlFragment(textArea.Document' highlighter' wholeLine' new HtmlOptions(textArea.Options))); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,StartDrag,The length of the statement  "			if (deleteOnMove != null && resultEffect == DragDropEffects.Move && (allowedEffects & DragDropEffects.Move) == DragDropEffects.Move) { " is 134.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetWordAtMousePosition,The length of the statement  "				int wordStartVC = line.GetNextCaretPosition(visualColumn + 1' LogicalDirection.Backward' CaretPositioningMode.WordStartOrSymbol); " is 129.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetWordAtMousePosition,The length of the statement  "				int wordEndVC = line.GetNextCaretPosition(wordStartVC' LogicalDirection.Forward' CaretPositioningMode.WordBorderOrSymbol); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The length of the statement  "			if (mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular) { " is 142.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonUp,The length of the statement  "			} else if (mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular) { " is 149.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnTextInput,The length of the statement  "			//Debug.WriteLine("TextInput: Text='" + e.Text + "' SystemText='" + e.SystemText + "' ControlText='" + e.ControlText + "'"); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextArea.cs,GetDeletableSegments,The length of the statement  "					throw new InvalidOperationException("ReadOnlySectionProvider returned incorrect segments (outside of input segment / wrong order)"); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextArea.cs,GetDeletableSegments,The length of the statement  "				throw new InvalidOperationException("ReadOnlySectionProvider returned incorrect segments (outside of input segment / wrong order)"); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos)); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2)); " is 147.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "				drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' RenderSize.Height)); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateElementFoldStart,The length of the statement  "			//XmlFoldStart newFoldStart = new XmlFoldStart(reader.Prefix' reader.LocalName' reader.LineNumber - 1' reader.LinePosition - 2); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightLineAndUpdateTreeList,The length of the statement  "				//Debug.WriteLine("Span stack in line " + lineNumber + " changed from " + storedSpanStacks[lineNumber] + " to " + spanStack); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,ToHtml,The length of the statement  "				throw new ArgumentOutOfRangeException("startOffset"' startOffset' "Value must be between " + documentLineStartOffset + " and " + documentLineEndOffset); " is 152.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,ToHtml,The length of the statement  "				throw new ArgumentOutOfRangeException("endOffset"' endOffset' "Value must be between startOffset and " + documentLineEndOffset); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,textView_VisualLineConstructionStarting,The length of the statement  "				// This is necessary in case the document gets modified above the FirstLineInView so that the highlighting state changes. " is 121.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,TextViewDocumentHighlighter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,OnHighlightStateChanged,The length of the statement  "				 * But doing it too early means it doesn't have the information necessary to re-highlight and redraw only the desired parts. " is 123.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DelayLoadedHighlightingDefinition,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightingManager.cs,GetDefinition,The length of the statement  "							throw new InvalidOperationException("Tried to create delay-loaded highlighting definition recursively. Make sure the are no cyclic references between the highlighting definitions."); " is 182.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DefaultHighlightingManager,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HighlightingManager.cs,RegisterHighlighting,The length of the statement  "//						new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter().Serialize(fs' Xshd.HighlightingLoader.Load(xshd' this)); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,SetHtml,The length of the statement  "			string htmlEnd = "<!--EndFragment-->" + Environment.NewLine + "</BODY>" + Environment.NewLine + "</HTML>" + Environment.NewLine; " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteRuleSetReference,The length of the statement  "					writer.WriteAttributeString("ruleSet"' ruleSetReference.ReferencedDefinition + "/" + ruleSetReference.ReferencedElement); " is 121.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteColorAttributes,The length of the statement  "				writer.WriteAttributeString("fontWeight"' V2Loader.FontWeightConverter.ConvertToInvariantString(color.FontWeight.Value).ToLowerInvariant()); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteColorAttributes,The length of the statement  "				writer.WriteAttributeString("fontStyle"' V2Loader.FontStyleConverter.ConvertToInvariantString(color.FontStyle.Value).ToLowerInvariant()); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,GetColorFromElement,The length of the statement  "			if (!element.HasAttribute("bold") && !element.HasAttribute("italic") && !element.HasAttribute("color") && !element.HasAttribute("bgcolor")) " is 139.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,Error,The length of the statement  "				return new HighlightingDefinitionInvalidException(HighlightingLoader.FormatExceptionMessage(message' lineInfo.LineNumber' lineInfo.LinePosition)); " is 146.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,TranslateElementVisitor,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\XmlHighlightingDefinition.cs,GetDefinition,The length of the statement  "					throw Error(position' "Resolving references to other syntax definitions is not possible because the IHighlightingDefinitionReferenceResolver is null."); " is 152.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "				if (block.LastWord == "case" || line.StartsWith("case "' StringComparison.Ordinal) || line.StartsWith(block.LastWord + ":"' StringComparison.Ordinal)) " is 150.
Long Statement,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,ChangeLinePart,The length of the statement  "				throw new ArgumentOutOfRangeException("startOffset"' startOffset' "Value must be between " + currentDocumentLineStartOffset + " and " + currentDocumentLineEndOffset); " is 166.
Long Statement,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,ChangeLinePart,The length of the statement  "				throw new ArgumentOutOfRangeException("endOffset"' endOffset' "Value must be between " + startOffset + " and " + currentDocumentLineEndOffset); " is 143.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ReceiveWeakEvent,The length of the statement  "				// Unfortunately the "easy" approach (just use DispatcherPriority.Background) here makes the editor twice as slow because " is 121.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ReceiveWeakEvent,The length of the statement  "				// When fixing this' make sure performance on the SharpDevelop "type text in C# comment" stress test doesn't get significantly worse. " is 133.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,UpdateBuiltinElementGeneratorsFromOptions,The length of the statement  "			AddRemoveDefaultElementGeneratorOnDemand(ref singleCharacterElementGenerator' options.ShowBoxForControlCharacters || options.ShowSpaces || options.ShowTabs); " is 157.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,EnsureVisualLines,The length of the statement  "				throw new InvalidOperationException("The visual line build process is already running! Cannot EnsureVisualLines() during Measure!"); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The length of the statement  "					throw new InvalidOperationException("Line " + i + " was skipped by a VisualLineElementGenerator' but it is not collapsed."); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,The length of the statement  "				if (visualColumn > this.VisualLength && !elements[elements.Count-1].HandlesLineBorders && HasImplicitStopAtLineEnd(mode)) { " is 123.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,The length of the statement  "				if (visualColumn < this.VisualLength && !elements[elements.Count-1].HandlesLineBorders && HasImplicitStopAtLineEnd(mode)) " is 121.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the statement  "				throw new ArgumentOutOfRangeException("splitVisualColumn"' splitVisualColumn' "Value must be between " + (VisualColumn + 1) + " and " + (VisualColumn + VisualLength - 1)); " is 171.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the statement  "				throw new ArgumentOutOfRangeException("splitRelativeTextOffset"' splitRelativeTextOffset' "Value must be between " + (RelativeTextOffset) + " and " + (RelativeTextOffset + DocumentLength)); " is 189.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,GetNextCaretPosition,The length of the statement  "				else if (visualColumn < stop2 && mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) " is 122.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,CreateTextRun,The length of the statement  "			string text = context.Document.GetText(context.VisualLine.FirstDocumentLine.Offset + RelativeTextOffset + relativeOffset' DocumentLength - relativeOffset); " is 155.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,Split,The length of the statement  "				throw new ArgumentOutOfRangeException("splitVisualColumn"' splitVisualColumn' "Value must be between " + (VisualColumn + 1) + " and " + (VisualColumn + VisualLength - 1)); " is 171.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,GetNextCaretPosition,The length of the statement  "			int pos = TextUtilities.GetNextCaretPosition(parentVisualLine.Document' textOffset + visualColumn - this.VisualColumn' direction' mode); " is 136.
Long Statement,ICSharpCode.AvalonEdit.Utils,CharRope,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CharRope.cs,InsertText,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,CopyTo,The length of the statement  "				throw new ArgumentOutOfRangeException("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - this.Count)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyRange,The length of the statement  "				throw new ArgumentOutOfRangeException("startIndex"' startIndex' "0 <= startIndex <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyRange,The length of the statement  "				throw new ArgumentOutOfRangeException("length"' length' "0 <= length' startIndex(" + startIndex + ")+length <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 167.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyArrayWithRange,The length of the statement  "				throw new ArgumentOutOfRangeException("startIndex"' arrayIndex' "0 <= arrayIndex <= " + array.Length.ToString(CultureInfo.InvariantCulture)); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyArrayWithRange,The length of the statement  "				throw new ArgumentOutOfRangeException("count"' count' "0 <= length' arrayIndex(" + arrayIndex + ")+count <= " + array.Length.ToString(CultureInfo.InvariantCulture)); " is 165.
Long Statement,ICSharpCode.AvalonEdit.Utils,RopeNode<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,ToString,The length of the statement  "				return "[Concat length=" + length + "' isShared=" + isShared + "' height=" + height + "' Balance=" + this.Balance + "]"; " is 120.
Long Statement,ICSharpCode.AvalonEdit.Utils,FunctionNode<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,GetContentNode,The length of the statement  "						throw new InvalidOperationException("Trying to load this node recursively; or: a previous call to a rope initializer failed."); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,ThrowUtil,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\ThrowUtil.cs,CheckInRangeInclusive,The length of the statement  "				throw new ArgumentOutOfRangeException(parameterName' val' "Expected: " + lower.ToString(CultureInfo.InvariantCulture) + " <= " + parameterName + " <= " + upper.ToString(CultureInfo.InvariantCulture)); " is 200.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\obj\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The conditional expression  "mode != CaretPositioningMode.Normal  			    && mode != CaretPositioningMode.WordBorder  			    && mode != CaretPositioningMode.WordStart  			    && mode != CaretPositioningMode.WordBorderOrSymbol  			    && mode != CaretPositioningMode.WordStartOrSymbol"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The conditional expression  "!((mode == CaretPositioningMode.WordStart || mode == CaretPositioningMode.WordStartOrSymbol)  						      && (charAfter == CharacterClass.Whitespace || charAfter == CharacterClass.LineTerminator))"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_QueryCursor,The conditional expression  "p.X >= 0 && p.Y >= 0 && p.X <= textArea.TextView.ActualWidth && p.Y <= textArea.TextView.ActualHeight"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The conditional expression  "mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonUp,The conditional expression  "mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnPropertyChanged,The conditional expression  "e.Property == SelectionBrushProperty  			    || e.Property == SelectionBorderProperty  			    || e.Property == SelectionForegroundProperty  			    || e.Property == SelectionCornerRadiusProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,Minimum,The conditional expression  "endSpanMatch != null && endSpanMatch.Success && (min == null || endSpanMatch.Index < min.Index)"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,GetColorFromElement,The conditional expression  "!element.HasAttribute("bold") && !element.HasAttribute("italic") && !element.HasAttribute("color") && !element.HasAttribute("bgcolor")"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The conditional expression  "lineComment || blockComment || inString || inChar"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The conditional expression  "!oldBlock.Continuation && oldBlock.OneLineBlock == 0 &&  				    oldBlock.StartLine == block.StartLine &&  				    block.StartLine < doc.LineNumber && lastRealChar != ':'"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,NewLineTextElement,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\NewLineElementGenerator.cs,GetNextCaretPosition,The conditional expression  "visualColumn > this.VisualColumn && direction == LogicalDirection.Backward ||  				    visualColumn < this.VisualColumn && direction == LogicalDirection.Forward"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The conditional expression  "rectangle.IsEmpty || visual == null || visual == this || !this.IsAncestorOf(visual)"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The conditional expression  "e.Property == Control.ForegroundProperty  			    || e.Property == Control.FontFamilyProperty  			    || e.Property == Control.FontSizeProperty  			    || e.Property == Control.FontStretchProperty  			    || e.Property == Control.FontStyleProperty  			    || e.Property == Control.FontWeightProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Virtual Method Call from Constructor,ICSharpCode.AvalonEdit.Snippets,InsertionContext,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Snippets\InsertionContext.cs,InsertionContext,The constructor "InsertionContext" calls a virtual method "GetText".
Empty Catch Block,ICSharpCode.AvalonEdit.Rendering,VisualLineLinkText,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLineLinkText.cs,OnMouseDown,The method has an empty catch block.
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: const double MinimumScrollPercentage = 0.3;
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null) {  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null) {  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null) {  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * Line.GetHashCode();  				hashCode += 1000000009 * Column.GetHashCode();  				hashCode += 1000000021 * VisualColumn.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * Line.GetHashCode();  				hashCode += 1000000009 * Column.GetHashCode();  				hashCode += 1000000021 * VisualColumn.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * Line.GetHashCode();  				hashCode += 1000000009 * Column.GetHashCode();  				hashCode += 1000000021 * VisualColumn.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionListBox,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionListBox.cs,CenterViewOn,The following statement contains a magic number: this.FirstVisibleItem = index - VisibleItemCount / 2;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query == itemText)  				return 8;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (string.Equals(itemText' query' StringComparison.OrdinalIgnoreCase))  				return 7;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.StartsWith(query))  				return 6;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.StartsWith(query' StringComparison.OrdinalIgnoreCase))  				return 5;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query.Length <= 2) {  				camelCaseMatch = CamelCaseMatch(itemText' query);  				if (camelCaseMatch.GetValueOrDefault(false)) return 4;  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query.Length <= 2) {  				camelCaseMatch = CamelCaseMatch(itemText' query);  				if (camelCaseMatch.GetValueOrDefault(false)) return 4;  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (IsFiltering && itemText.Contains(query))  				return 3;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (IsFiltering && itemText.IndexOf(query' StringComparison.OrdinalIgnoreCase) >= 0)  				return 2;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MaxHeight = 300;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.Width = 175;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MinHeight = 15;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MinWidth = 30;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OverloadInsightWindow,The following statement contains a magic number: overloadViewer.Margin = new Thickness(2'0'0'0);
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CollapseIfSingleOverloadConverter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\OverloadViewer.cs,Convert,The following statement contains a magic number: return ((int)value < 2) ? Visibility.Collapsed : Visibility.Visible;
Magic Number,ICSharpCode.AvalonEdit.Document,SimpleSegment,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\ISegment.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return Offset + 10301 * Length;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: for (int i = offset; i < text.Length; i++) {  				switch (text[i]) {  					case '\r':  						if (i + 1 < text.Length) {  							if (text[i + 1] == '\n') {  								return new SimpleSegment(i' 2);  							}  						}  						goto case '\n';  					case '\n':  						return new SimpleSegment(i' 1);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: for (int i = offset; i < textLength; i++) {  				switch (text.GetCharAt(i)) {  					case '\r':  						if (i + 1 < textLength) {  							if (text.GetCharAt(i + 1) == '\n') {  								return new SimpleSegment(i' 2);  							}  						}  						goto case '\n';  					case '\n':  						return new SimpleSegment(i' 1);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,FindNextNewLine,The following statement contains a magic number: if (s == SimpleSegment.Invalid) {  				newLineType = null;  				return -1;  			} else {  				if (s.Length == 2) {  					newLineType = "\r\n";  				} else if (text.GetCharAt(s.Offset) == '\n') {  					newLineType = "\n";  				} else {  					newLineType = "\r";  				}  				return s.Offset;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  				return c0Table[num];  			else if (num >= 127 && num <= 159)  				return delAndC1Table[num - 127];  			else  				return num.ToString("x4"' CultureInfo.InvariantCulture);
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  				return c0Table[num];  			else if (num >= 127 && num <= 159)  				return delAndC1Table[num - 127];  			else  				return num.ToString("x4"' CultureInfo.InvariantCulture);
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  				return c0Table[num];  			else if (num >= 127 && num <= 159)  				return delAndC1Table[num - 127];  			else  				return num.ToString("x4"' CultureInfo.InvariantCulture);
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return offset + 3559 * insertionLength + 3571 * (int)removalLengthWithDeletionFlag;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return offset + 3559 * insertionLength + 3571 * (int)removalLengthWithDeletionFlag;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Document,TextLocation,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked (87 * x.GetHashCode() ^ y.GetHashCode());
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,Remove,The following statement contains a magic number: if (offset > startLineOffset + startLine.Length) {  				Debug.Assert(startLine.DelimiterLength == 2);  				// we are deleting starting in the middle of a delimiter  				  				// remove last delimiter part  				SetLineLength(startLine' startLine.TotalLength - 1);  				// remove remaining text  				Remove(offset' length - 1);  				return;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,Insert,The following statement contains a magic number: if (offset > lineOffset + line.Length) {  				Debug.Assert(line.DelimiterLength == 2);  				// we are inserting in the middle of a delimiter  				  				// shorten line  				SetLineLength(line' line.TotalLength - 1);  				// add new line  				line = InsertLineAfter(line' 1);  				line = SetLineLength(line' 1);  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  				line.DelimiterLength = 0;  			} else {  				int lineOffset = line.Offset;  				char lastChar = document.GetCharAt(lineOffset + newTotalLength - 1);  				if (lastChar == '\r') {  					line.DelimiterLength = 1;  				} else if (lastChar == '\n') {  					if (newTotalLength >= 2 && document.GetCharAt(lineOffset + newTotalLength - 2) == '\r') {  						line.DelimiterLength = 2;  					} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt(lineOffset - 1) == '\r') {  						// we need to join this line with the previous line  						DocumentLine previousLine = line.PreviousLine;  						RemoveLine(line);  						return SetLineLength(previousLine' previousLine.TotalLength + 1);  					} else {  						line.DelimiterLength = 1;  					}  				} else {  					line.DelimiterLength = 0;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  				line.DelimiterLength = 0;  			} else {  				int lineOffset = line.Offset;  				char lastChar = document.GetCharAt(lineOffset + newTotalLength - 1);  				if (lastChar == '\r') {  					line.DelimiterLength = 1;  				} else if (lastChar == '\n') {  					if (newTotalLength >= 2 && document.GetCharAt(lineOffset + newTotalLength - 2) == '\r') {  						line.DelimiterLength = 2;  					} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt(lineOffset - 1) == '\r') {  						// we need to join this line with the previous line  						DocumentLine previousLine = line.PreviousLine;  						RemoveLine(line);  						return SetLineLength(previousLine' previousLine.TotalLength + 1);  					} else {  						line.DelimiterLength = 1;  					}  				} else {  					line.DelimiterLength = 0;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  				line.DelimiterLength = 0;  			} else {  				int lineOffset = line.Offset;  				char lastChar = document.GetCharAt(lineOffset + newTotalLength - 1);  				if (lastChar == '\r') {  					line.DelimiterLength = 1;  				} else if (lastChar == '\n') {  					if (newTotalLength >= 2 && document.GetCharAt(lineOffset + newTotalLength - 2) == '\r') {  						line.DelimiterLength = 2;  					} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt(lineOffset - 1) == '\r') {  						// we need to join this line with the previous line  						DocumentLine previousLine = line.PreviousLine;  						RemoveLine(line);  						return SetLineLength(previousLine' previousLine.TotalLength + 1);  					} else {  						line.DelimiterLength = 1;  					}  				} else {  					line.DelimiterLength = 0;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,GetTreeHeight,The following statement contains a magic number: if (size == 0)  				return 0;  			else  				return GetTreeHeight(size / 2) + 1;
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,BuildTree,The following statement contains a magic number: int middle = (start + end) / 2;
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The following statement contains a magic number: switch (offsetChangeMappingType) {  				case OffsetChangeMappingType.Normal:  					Replace(offset' length' text' null);  					break;  				case OffsetChangeMappingType.RemoveAndInsert:  					if (length == 0 || text.Length == 0) {  						// only insertion or only removal?  						// OffsetChangeMappingType doesn't matter' just use Normal.  						Replace(offset' length' text' null);  					} else {  						OffsetChangeMap map = new OffsetChangeMap(2);  						map.Add(new OffsetChangeMapEntry(offset' length' 0));  						map.Add(new OffsetChangeMapEntry(offset' 0' text.Length));  						map.Freeze();  						Replace(offset' length' text' map);  					}  					break;  				case OffsetChangeMappingType.CharacterReplace:  					if (length == 0 || text.Length == 0) {  						// only insertion or only removal?  						// OffsetChangeMappingType doesn't matter' just use Normal.  						Replace(offset' length' text' null);  					} else if (text.Length > length) {  						// look at OffsetChangeMappingType.CharacterReplace XML comments on why we need to replace  						// the last character  						OffsetChangeMapEntry entry = new OffsetChangeMapEntry(offset + length - 1' 1' 1 + text.Length - length);  						Replace(offset' length' text' OffsetChangeMap.FromSingleElement(entry));  					} else if (text.Length < length) {  						OffsetChangeMapEntry entry = new OffsetChangeMapEntry(offset + text.Length' length - text.Length' 0' true);  						Replace(offset' length' text' OffsetChangeMap.FromSingleElement(entry));  					} else {  						Replace(offset' length' text' OffsetChangeMap.Empty);  					}  					break;  				default:  					throw new ArgumentOutOfRangeException("offsetChangeMappingType"' offsetChangeMappingType' "Invalid enum value");  			}
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: return new Line {  				X1 = 0' Y1 = 0' X2 = 0' Y2 = 1'  				StrokeDashArray = { 0' 2 }'  				Stretch = Stretch.Fill'  				Stroke = Brushes.Gray'  				StrokeThickness = 1'  				StrokeDashCap = PenLineCap.Round'  				Margin = new Thickness(2' 0' 2' 0)'  				Tag = tag  			};
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: return new Line {  				X1 = 0' Y1 = 0' X2 = 0' Y2 = 1'  				StrokeDashArray = { 0' 2 }'  				Stretch = Stretch.Fill'  				Stroke = Brushes.Gray'  				StrokeThickness = 1'  				StrokeDashCap = PenLineCap.Round'  				Margin = new Thickness(2' 0' 2' 0)'  				Tag = tag  			};
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: return new Line {  				X1 = 0' Y1 = 0' X2 = 0' Y2 = 1'  				StrokeDashArray = { 0' 2 }'  				Stretch = Stretch.Fill'  				Stroke = Brushes.Gray'  				StrokeThickness = 1'  				StrokeDashCap = PenLineCap.Round'  				Margin = new Thickness(2' 0' 2' 0)'  				Tag = tag  			};
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: if (newLength < 2)  				newLength = 2;
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: if (newLength < 2)  				newLength = 2;
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (!e.Handled && e.ChangedButton == MouseButton.Left) {  				ModifierKeys modifiers = Keyboard.Modifiers;  				bool shift = (modifiers & ModifierKeys.Shift) == ModifierKeys.Shift;  				if (AllowTextDragDrop && e.ClickCount == 1 && !shift) {  					int visualColumn;  					int offset = GetOffsetFromMousePosition(e' out visualColumn);  					if (textArea.Selection.Contains(offset)) {  						if (textArea.CaptureMouse()) {  							mode = SelectionMode.PossibleDragStart;  							possibleDragStartMousePos = e.GetPosition(textArea);  						}  						e.Handled = true;  						return;  					}  				}  				  				int oldOffset = textArea.Caret.Offset;  				SetCaretOffsetToMousePosition(e);  				  				  				if (!shift) {  					textArea.Selection = Selection.Empty;  				}  				if (textArea.CaptureMouse()) {  					if ((modifiers & ModifierKeys.Alt) == ModifierKeys.Alt) {  						mode = SelectionMode.Rectangular;  						if (shift && textArea.Selection is RectangleSelection) {  							textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint(oldOffset' textArea.Caret.Offset);  						}  					} else if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  						mode = SelectionMode.Normal;  						if (shift && !(textArea.Selection is RectangleSelection)) {  							textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint(oldOffset' textArea.Caret.Offset);  						}  					} else {  						SimpleSegment startWord;  						if (e.ClickCount == 3) {  							mode = SelectionMode.WholeLine;  							startWord = GetLineAtMousePosition(e);  						} else {  							mode = SelectionMode.WholeWord;  							startWord = GetWordAtMousePosition(e);  						}  						if (startWord == SimpleSegment.Invalid) {  							mode = SelectionMode.None;  							textArea.ReleaseMouseCapture();  							return;  						}  						if (shift && !textArea.Selection.IsEmpty) {  							if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  								textArea.Selection = textArea.Selection.SetEndpoint(startWord.Offset);  							} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  								textArea.Selection = textArea.Selection.SetEndpoint(startWord.EndOffset);  							}  							this.startWord = new AnchorSegment(textArea.Document' textArea.Selection.SurroundingSegment);  						} else {  							textArea.Selection = new SimpleSelection(startWord.Offset' startWord.EndOffset);  							this.startWord = new AnchorSegment(textArea.Document' startWord.Offset' startWord.Length);  						}  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,ExtendSelectionToMouse,The following statement contains a magic number: textArea.Caret.BringCaretToView(5.0);
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: foreach (FoldingMarginMarker m in markers) {  				int visualColumn = m.VisualLine.GetVisualColumn(m.FoldingSection.StartOffset - m.VisualLine.FirstDocumentLine.Offset);  				TextLine textLine = m.VisualLine.GetTextLine(visualColumn);  				double yPos = m.VisualLine.GetTextLineVisualYPosition(textLine' VisualYPosition.LineTop) - TextView.VerticalOffset;  				yPos += (textLine.Height - m.DesiredSize.Height) / 2;  				double xPos = (finalSize.Width - m.DesiredSize.Width) / 2;  				m.Arrange(new Rect(PixelSnapHelpers.Round(new Point(xPos' yPos)' pixelSize)' m.DesiredSize));  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: foreach (FoldingMarginMarker m in markers) {  				int visualColumn = m.VisualLine.GetVisualColumn(m.FoldingSection.StartOffset - m.VisualLine.FirstDocumentLine.Offset);  				TextLine textLine = m.VisualLine.GetTextLine(visualColumn);  				double yPos = m.VisualLine.GetTextLineVisualYPosition(textLine' VisualYPosition.LineTop) - TextView.VerticalOffset;  				yPos += (textLine.Height - m.DesiredSize.Height) / 2;  				double xPos = (finalSize.Width - m.DesiredSize.Width) / 2;  				m.Arrange(new Rect(PixelSnapHelpers.Round(new Point(xPos' yPos)' pixelSize)' m.DesiredSize));  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: double markerXPos = PixelSnapHelpers.PixelAlign(RenderSize.Width / 2' pixelSize.Width);
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  				foreach (TextLine tl in vl.TextLines) {  					if (endMarker[tlNumber] != null) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos));  					}  					if (colors[tlNumber + 1] != currentPen) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						if (currentPen != null) {  							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2));  						}  						currentPen = colors[tlNumber + 1];  						startY = visualPos;  					}  					tlNumber++;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  				foreach (TextLine tl in vl.TextLines) {  					if (endMarker[tlNumber] != null) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos));  					}  					if (colors[tlNumber + 1] != currentPen) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						if (currentPen != null) {  							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2));  						}  						currentPen = colors[tlNumber + 1];  						startY = visualPos;  					}  					tlNumber++;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  				foreach (TextLine tl in vl.TextLines) {  					if (endMarker[tlNumber] != null) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos));  					}  					if (colors[tlNumber + 1] != currentPen) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						if (currentPen != null) {  							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2));  						}  						currentPen = colors[tlNumber + 1];  						startY = visualPos;  					}  					tlNumber++;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (currentPen != null) {  				drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' RenderSize.Height));  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,GetVisualPos,The following statement contains a magic number: double pos = vl.GetTextLineVisualYPosition(tl' VisualYPosition.LineTop) + tl.Height / 2 - TextView.VerticalOffset;
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: Rect rect = new Rect(pixelSize.Width / 2'  			                     pixelSize.Height / 2'  			                     this.RenderSize.Width - pixelSize.Width'  			                     this.RenderSize.Height - pixelSize.Height);
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: Rect rect = new Rect(pixelSize.Width / 2'  			                     pixelSize.Height / 2'  			                     this.RenderSize.Width - pixelSize.Width'  			                     this.RenderSize.Height - pixelSize.Height);
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: double middleX = rect.Left + rect.Width / 2;
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: double middleY = rect.Top + rect.Height / 2;
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: double space = PixelSnapHelpers.Round(rect.Width / 8' pixelSize.Width) + pixelSize.Width;
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (comment != null) {  				int firstNewLine = comment.IndexOf('\n');  				if (firstNewLine >= 0) {  					  					// Take off 4 chars to get the actual comment start (takes  					// into account the <!-- chars.  					  					int startOffset = GetOffset(document' reader) - 4;  					int endOffset = startOffset + comment.Length + 3;  					  					string foldText = String.Concat("<!--"' comment.Substring(0' firstNewLine).TrimEnd('\r') ' "-->");  					foldMarkers.Add(new NewFolding(startOffset' endOffset) { Name = foldText } );  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (comment != null) {  				int firstNewLine = comment.IndexOf('\n');  				if (firstNewLine >= 0) {  					  					// Take off 4 chars to get the actual comment start (takes  					// into account the <!-- chars.  					  					int startOffset = GetOffset(document' reader) - 4;  					int endOffset = startOffset + comment.Length + 3;  					  					string foldText = String.Concat("<!--"' comment.Substring(0' firstNewLine).TrimEnd('\r') ' "-->");  					foldMarkers.Add(new NewFolding(startOffset' endOffset) { Name = foldText } );  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HtmlOptions,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,HtmlOptions,The following statement contains a magic number: this.TabSize = 4;
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,GetSystemColorBrush,The following statement contains a magic number: string shortName = name.Substring(13);
Magic Number,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,RebuildDocument,The following statement contains a magic number: dict = new Dictionary<DocumentLine' HeightTreeNode>((int)(document.LineCount / 0.7));
Magic Number,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,BuildTree,The following statement contains a magic number: int middle = (start + end) / 2;
Magic Number,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Rendering,NewLineElementGenerator,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\NewLineElementGenerator.cs,ConstructElement,The following statement contains a magic number: if (lastDocumentLine.DelimiterLength == 2) {  				newlineText = "\u00B6";  			} else if (lastDocumentLine.DelimiterLength == 1) {  				char newlineChar = CurrentContext.Document.GetCharAt(lastDocumentLine.Offset + lastDocumentLine.Length);  				if (newlineChar == '\r')  					newlineText = "\\r";  				else if (newlineChar == '\n')  					newlineText = "\\n";  				else  					newlineText = "?";  			} else {  				return null;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The following statement contains a magic number: if (ShowSpaces && c == ' ') {  				FormattedText text = TextFormatterFactory.CreateFormattedText(  					CurrentContext.TextView'  					"\u00B7"'  					CurrentContext.GlobalTextRunProperties.Typeface'  					CurrentContext.GlobalTextRunProperties.FontRenderingEmSize'  					Brushes.LightGray  				);  				return new SpaceTextElement(text);  			} else if (ShowTabs && c == '\t') {  				FormattedText text = TextFormatterFactory.CreateFormattedText(  					CurrentContext.TextView'  					"\u00BB"'  					CurrentContext.GlobalTextRunProperties.Typeface'  					CurrentContext.GlobalTextRunProperties.FontRenderingEmSize'  					Brushes.LightGray  				);  				return new TabTextElement(text);  			} else if (ShowBoxForControlCharacters && char.IsControl(c)) {  				FormattedText text = TextFormatterFactory.CreateFormattedText(  					CurrentContext.TextView'  					TextUtilities.GetControlCharacterName(c)'  					CurrentContext.GlobalTextRunProperties.Typeface'  					CurrentContext.GlobalTextRunProperties.FontRenderingEmSize * 0.9'  					Brushes.White  				);  				return new SpecialCharacterBoxElement(text);  			} else {  				return null;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: drawingContext.DrawRoundedRectangle(Brushes.DarkGray' null' r' 2.5' 2.5);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: drawingContext.DrawRoundedRectangle(Brushes.DarkGray' null' r' 2.5' 2.5);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Format,The following statement contains a magic number: return new TextEmbeddedObjectMetrics(metrics.Width + 3'  				                                     metrics.Height' metrics.Baseline);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ComputeBoundingBox,The following statement contains a magic number: r.Width += 3;
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnDocumentChanged,The following statement contains a magic number: if (newValue != null) {  				TextDocumentWeakEventManager.Changing.AddListener(newValue' this);  				heightTree = new HeightTree(newValue' FontSize + 3);  				formatter = TextFormatterFactory.Create(this);  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width > 32000)  				availableSize.Width = 32000;
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width > 32000)  				availableSize.Width = 32000;
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (options.AllowScrollBelowDocument) {  				heightTreeHeight = Math.Max(heightTreeHeight' Math.Min(heightTreeHeight - 50' scrollOffset.Y) + scrollViewport.Height);  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Left < visibleRectangle.Left) {  				if (rectangle.Right > visibleRectangle.Right) {  					newScrollOffset.X = rectangle.Left + rectangle.Width / 2;  				} else {  					newScrollOffset.X = rectangle.Left;  				}  			} else if (rectangle.Right > visibleRectangle.Right) {  				newScrollOffset.X = rectangle.Right - scrollViewport.Width;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Top < visibleRectangle.Top) {  				if (rectangle.Bottom > visibleRectangle.Bottom) {  					newScrollOffset.Y = rectangle.Top + rectangle.Height / 2;  				} else {  					newScrollOffset.Y = rectangle.Top;  				}  			} else if (rectangle.Bottom > visibleRectangle.Bottom) {  				newScrollOffset.Y = rectangle.Bottom - scrollViewport.Height;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: foreach (TextLine tl in TextLines) {  				if (tl == textLine) {  					switch (yPositionMode) {  						case VisualYPosition.LineTop:  							return pos;  						case VisualYPosition.LineMiddle:  							return pos + tl.Height / 2;  						case VisualYPosition.LineBottom:  							return pos + tl.Height;  						case VisualYPosition.TextTop:  							return pos + tl.Height - textView.FontSize;  						default:  							throw new ArgumentException("Invalid yPositionMode:" + yPositionMode);  					}  				} else {  					pos += tl.Height;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineByVisualYPosition,The following statement contains a magic number: const double epsilon = 0.0001;
Magic Number,ICSharpCode.AvalonEdit.Snippets,Renderer,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Snippets\SnippetReplaceableTextElement.cs,CreateBackgroundBrush,The following statement contains a magic number: b.Opacity = 0.4;
Magic Number,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: if (stream.Length >= 2) {  				// the autodetection of StreamReader is not capable of detecting the difference  				// between ISO-8859-1 and UTF-8 without BOM.  				int firstByte = stream.ReadByte();  				int secondByte = stream.ReadByte();  				switch ((firstByte << 8) | secondByte) {  					case 0x0000: // either UTF-32 Big Endian or a binary file; use StreamReader  					case 0xfffe: // Unicode BOM (UTF-16 LE or UTF-32 LE)  					case 0xfeff: // UTF-16 BE BOM  					case 0xefbb: // start of UTF-8 BOM  						// StreamReader autodetection works  						stream.Position = 0;  						return new StreamReader(stream);  					default:  						return AutoDetect(stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  				}  			} else {  				if (defaultEncoding != null) {  					return new StreamReader(stream' defaultEncoding);  				} else {  					return new StreamReader(stream);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: if (stream.Length >= 2) {  				// the autodetection of StreamReader is not capable of detecting the difference  				// between ISO-8859-1 and UTF-8 without BOM.  				int firstByte = stream.ReadByte();  				int secondByte = stream.ReadByte();  				switch ((firstByte << 8) | secondByte) {  					case 0x0000: // either UTF-32 Big Endian or a binary file; use StreamReader  					case 0xfffe: // Unicode BOM (UTF-16 LE or UTF-32 LE)  					case 0xfeff: // UTF-16 BE BOM  					case 0xefbb: // start of UTF-8 BOM  						// StreamReader autodetection works  						stream.Position = 0;  						return new StreamReader(stream);  					default:  						return AutoDetect(stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  				}  			} else {  				if (defaultEncoding != null) {  					return new StreamReader(stream' defaultEncoding);  				} else {  					return new StreamReader(stream);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: int max = (int)Math.Min(fs.Length' 500000);
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: const int UTF8  = 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: const int UTF8Sequence = 3;
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) {  				if (i == 0) {  					b = firstByte;  				} else if (i == 1) {  					b = secondByte;  				} else {  					b = (byte)fs.ReadByte();  				}  				if (b < 0x80) {  					// normal ASCII character  					if (state == UTF8Sequence) {  						state = Error;  						break;  					}  				} else if (b < 0xc0) {  					// 10xxxxxx : continues UTF8 byte sequence  					if (state == UTF8Sequence) {  						--sequenceLength;  						if (sequenceLength < 0) {  							state = Error;  							break;  						} else if (sequenceLength == 0) {  							state = UTF8;  						}  					} else {  						state = Error;  						break;  					}  				} else if (b >= 0xc2 && b < 0xf5) {  					// beginning of byte sequence  					if (state == UTF8 || state == ASCII) {  						state = UTF8Sequence;  						if (b < 0xe0) {  							sequenceLength = 1; // one more byte following  						} else if (b < 0xf0) {  							sequenceLength = 2; // two more bytes following  						} else {  							sequenceLength = 3; // three more bytes following  						}  					} else {  						state = Error;  						break;  					}  				} else {  					// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  					state = Error;  					break;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) {  				if (i == 0) {  					b = firstByte;  				} else if (i == 1) {  					b = secondByte;  				} else {  					b = (byte)fs.ReadByte();  				}  				if (b < 0x80) {  					// normal ASCII character  					if (state == UTF8Sequence) {  						state = Error;  						break;  					}  				} else if (b < 0xc0) {  					// 10xxxxxx : continues UTF8 byte sequence  					if (state == UTF8Sequence) {  						--sequenceLength;  						if (sequenceLength < 0) {  							state = Error;  							break;  						} else if (sequenceLength == 0) {  							state = UTF8;  						}  					} else {  						state = Error;  						break;  					}  				} else if (b >= 0xc2 && b < 0xf5) {  					// beginning of byte sequence  					if (state == UTF8 || state == ASCII) {  						state = UTF8Sequence;  						if (b < 0xe0) {  							sequenceLength = 1; // one more byte following  						} else if (b < 0xf0) {  							sequenceLength = 2; // two more bytes following  						} else {  							sequenceLength = 3; // three more bytes following  						}  					} else {  						state = Error;  						break;  					}  				} else {  					// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  					state = Error;  					break;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,RopeNode<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,CreateNodes,The following statement contains a magic number: if (leafCount == 1) {  				result.contents = new T[NodeSize];  			} else {  				int rightSide = leafCount / 2;  				int leftSide = leafCount - rightSide;  				int leftLength = leftSide * NodeSize;  				result.left = CreateNodes(leftSide' leftLength);  				result.right = CreateNodes(rightSide' totalLength - leftLength);  				result.height = (byte)(1 + Math.Max(result.left.height' result.right.height));  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,RopeNode<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,FunctionNode<T>,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,PixelAlign,The following statement contains a magic number: return pixelSize * (Math.Round((value / pixelSize) + 0.5) - 0.5);
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,PixelAlign,The following statement contains a magic number: return pixelSize * (Math.Round((value / pixelSize) + 0.5) - 0.5);
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,RoundToOdd,The following statement contains a magic number: return Round(value - pixelSize' pixelSize * 2) + pixelSize;
Missing Default,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,HandleKey,The following switch statement is missing a default case: switch (e.Key) {  				case Key.Down:  					e.Handled = true;  			        index = listBox.SelectedIndex + 1;                      if(index > listBox.Items.Count - 1)                      {                          index = 0;                      }  					listBox.SelectIndex(index);  					break;  				case Key.Up:  					e.Handled = true;  			        index = listBox.SelectedIndex - 1;                      if(0 == listBox.SelectedIndex)                      {                          index = listBox.Items.Count - 1;                      }  					listBox.SelectIndex(index);  					break;  				case Key.PageDown:  					e.Handled = true;  					listBox.SelectIndex(listBox.SelectedIndex + listBox.VisibleItemCount);  					break;  				case Key.PageUp:  					e.Handled = true;  					listBox.SelectIndex(listBox.SelectedIndex - listBox.VisibleItemCount);  					break;  				case Key.Home:  					e.Handled = true;  					listBox.SelectIndex(0);  					break;  				case Key.End:  					e.Handled = true;  					listBox.SelectIndex(listBox.Items.Count - 1);  					break;  				case Key.Tab:  					e.Handled = true;  			        index = listBox.SelectedIndex + 1;                      if(index > listBox.Items.Count - 1)                      {                          index = 0;                      }  					listBox.SelectIndex(index);  					break;  				case Key.Enter:  					e.Handled = true;  					RequestInsertion(e);  					break;  				case Key.Oem5:  					RequestInsertion(e);  					break;  			}
Missing Default,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  					case Key.Up:  						e.Handled = true;  						overloadViewer.ChangeIndex(-1);  						break;  					case Key.Down:  						e.Handled = true;  						overloadViewer.ChangeIndex(+1);  						break;  				}
Missing Default,ICSharpCode.AvalonEdit.Document,NewLineFinder,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following switch statement is missing a default case: switch (text[i]) {  					case '\r':  						if (i + 1 < text.Length) {  							if (text[i + 1] == '\n') {  								return new SimpleSegment(i' 2);  							}  						}  						goto case '\n';  					case '\n':  						return new SimpleSegment(i' 1);  				}
Missing Default,ICSharpCode.AvalonEdit.Document,NewLineFinder,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following switch statement is missing a default case: switch (text.GetCharAt(i)) {  					case '\r':  						if (i + 1 < textLength) {  							if (text.GetCharAt(i + 1) == '\n') {  								return new SimpleSegment(i' 2);  							}  						}  						goto case '\n';  					case '\n':  						return new SimpleSegment(i' 1);  				}
Missing Default,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateNewFoldings,The following switch statement is missing a default case: switch (reader.NodeType) {  						case XmlNodeType.Element:  							if (!reader.IsEmptyElement) {  								XmlFoldStart newFoldStart = CreateElementFoldStart(document' reader);  								stack.Push(newFoldStart);  							}  							break;  							  						case XmlNodeType.EndElement:  							XmlFoldStart foldStart = stack.Pop();  							CreateElementFold(document' foldMarkers' reader' foldStart);  							break;  							  						case XmlNodeType.Comment:  							CreateCommentFold(document' foldMarkers' reader);  							break;  					}
Missing Default,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The following switch statement is missing a default case: switch (c) {  					case '/':  						if (blockComment && lastchar == '*')  							blockComment = false;  						if (!inString && !inChar) {  							if (!blockComment && nextchar == '/')  								lineComment = true;  							if (!lineComment && nextchar == '*')  								blockComment = true;  						}  						break;  					case '#':  						if (!(inChar || blockComment || inString))  							lineComment = true;  						break;  					case '"':  						if (!(inChar || lineComment || blockComment)) {  							inString = !inString;  							if (!inString && verbatim) {  								if (nextchar == '"') {  									escape = true; // skip escaped quote  									inString = true;  								} else {  									verbatim = false;  								}  							} else if (inString && lastchar == '@') {  								verbatim = true;  							}  						}  						break;  					case '\'':  						if (!(inString || lineComment || blockComment)) {  							inChar = !inChar;  						}  						break;  					case '\\':  						if ((inString && !verbatim) || inChar)  							escape = true; // skip next character  						break;  				}
Missing Default,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The following switch statement is missing a default case: switch (c) {  					case '{':  						block.ResetOneLineBlock();  						blocks.Push(block);  						block.StartLine = doc.LineNumber;  						if (block.LastWord == "switch") {  							block.Indent(set.IndentString + set.IndentString);  							/* oldBlock refers to the previous line' not the previous block  							 * The block we want is not available anymore because it was never pushed.  							 * } else if (oldBlock.OneLineBlock) {  							// Inside a one-line-block is another statement  							// with a full block: indent the inner full block  							// by one additional level  							block.Indent(set' set.IndentString + set.IndentString);  							block.OuterIndent += set.IndentString;  							// Indent current line if it starts with the '{' character  							if (i == 0) {  								oldBlock.InnerIndent += set.IndentString;  							}*/  						} else {  							block.Indent(set);  						}  						block.Bracket = '{';  						break;  					case '}':  						while (block.Bracket != '{') {  							if (blocks.Count == 0) break;  							block = blocks.Pop();  						}  						if (blocks.Count == 0) break;  						block = blocks.Pop();  						block.Continuation = false;  						block.ResetOneLineBlock();  						break;  					case '(':  					case '[':  						blocks.Push(block);  						if (block.StartLine == doc.LineNumber)  							block.InnerIndent = block.OuterIndent;  						else  							block.StartLine = doc.LineNumber;  						block.Indent(Repeat(set.IndentString' oldBlock.OneLineBlock) +  						             (oldBlock.Continuation ? set.IndentString : "") +  						             (i == line.Length - 1 ? set.IndentString : new String(' '' i + 1)));  						block.Bracket = c;  						break;  					case ')':  						if (blocks.Count == 0) break;  						if (block.Bracket == '(') {  							block = blocks.Pop();  							if (IsSingleStatementKeyword(block.LastWord))  								block.Continuation = false;  						}  						break;  					case ']':  						if (blocks.Count == 0) break;  						if (block.Bracket == '[')  							block = blocks.Pop();  						break;  					case ';':  					case ''':  						block.Continuation = false;  						block.ResetOneLineBlock();  						break;  					case ':':  						if (block.LastWord == "case"   						    || line.StartsWith("case "' StringComparison.Ordinal)   						    || line.StartsWith(block.LastWord + ":"' StringComparison.Ordinal))   						{  							block.Continuation = false;  							block.ResetOneLineBlock();  						}  						break;  				}
Missing Default,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\tltjr_Wish\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,The following switch statement is missing a default case: switch (position) {  							case LayerInsertionPosition.Below:  								layers.Insert(i' layer);  								return;  							case LayerInsertionPosition.Above:  								layers.Insert(i + 1' layer);  								return;  							case LayerInsertionPosition.Replace:  								layers[i] = layer;  								return;  						}
