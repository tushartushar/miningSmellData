Implementation smell,Namespace,Class,File,Method,Description
Long Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,symbexec,The method has 166 lines of code.
Long Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,llex,The method has 113 lines of code.
Long Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,GetUnmanagedSize,The method has 102 lines of code.
Long Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,The method has 455 lines of code.
Long Method,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The method has 292 lines of code.
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,lua_gc,Cyclomatic complexity of the method is 12
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaL_loadfile,Cyclomatic complexity of the method is 11
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,discharge2reg,Cyclomatic complexity of the method is 8
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,constfolding,Cyclomatic complexity of the method is 13
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaK_posfix,Cyclomatic complexity of the method is 17
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_getinfo,Cyclomatic complexity of the method is 11
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_errorfb,Cyclomatic complexity of the method is 12
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxgetinfo,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,symbexec,Cyclomatic complexity of the method is 64
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,getobjname,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaD_precall,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,reallymarkobject,Cyclomatic complexity of the method is 10
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,traversetable,Cyclomatic complexity of the method is 11
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,traverseproto,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,freeobj,Cyclomatic complexity of the method is 8
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,singlestep,Cyclomatic complexity of the method is 11
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,g_read,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,read_long_string,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,read_string,Cyclomatic complexity of the method is 16
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,llex,Cyclomatic complexity of the method is 29
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ll_require,Cyclomatic complexity of the method is 10
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_pushvfstring,Cyclomatic complexity of the method is 11
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,funcargs,Cyclomatic complexity of the method is 8
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,simpleexp,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,getbinopr,Cyclomatic complexity of the method is 16
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,statement,Cyclomatic complexity of the method is 11
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,match_class,Cyclomatic complexity of the method is 11
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,matchbracketclass,Cyclomatic complexity of the method is 8
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,scanformat,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_format,Cyclomatic complexity of the method is 11
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,resize,Cyclomatic complexity of the method is 8
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxsort,Cyclomatic complexity of the method is 14
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,strtoul,Cyclomatic complexity of the method is 12
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,strcmp,Cyclomatic complexity of the method is 8
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,GetUnmanagedSize,Cyclomatic complexity of the method is 50
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,LoadConstants,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_equalval,Cyclomatic complexity of the method is 10
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,Arith,Cyclomatic complexity of the method is 10
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,Dump,Cyclomatic complexity of the method is 8
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,Cyclomatic complexity of the method is 78
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,PrintString,Cyclomatic complexity of the method is 12
Complex Method,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,PrintCode,Cyclomatic complexity of the method is 22
Complex Method,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,IsPositive,Cyclomatic complexity of the method is 13
Complex Method,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,ToUnsigned,Cyclomatic complexity of the method is 12
Complex Method,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,ToInteger,Cyclomatic complexity of the method is 12
Complex Method,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,UnboxToLong,Cyclomatic complexity of the method is 12
Complex Method,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,Cyclomatic complexity of the method is 10
Complex Method,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,Cyclomatic complexity of the method is 46
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,condjump,The method has 5 parameters. Parameters: fs' op' A' B' C
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,patchlistaux,The method has 5 parameters. Parameters: fs' list' vtarget' reg' dtarget
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,codecomp,The method has 5 parameters. Parameters: fs' op' cond' e1' e2
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaK_codeABC,The method has 5 parameters. Parameters: fs' o' a' b' c
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxgetinfo,The method has 5 parameters. Parameters: L' what' ar' f' ci
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaD_pcall,The method has 5 parameters. Parameters: L' func' u' old_top' ef
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaU_dump,The method has 5 parameters. Parameters: L' f' w' data' strip
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaM_growvector,The method has 6 parameters. Parameters: L' v' nelems' size' limit' e
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaM_growaux_,The method has 5 parameters. Parameters: L' block' size' limit' errormsg
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,opmode,The method has 5 parameters. Parameters: t' a' b' c' m
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,forbody,The method has 5 parameters. Parameters: ls' base_' line' nvars' isnum
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTMres,The method has 5 parameters. Parameters: L' res' f' p1' p2
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTM,The method has 5 parameters. Parameters: L' f' p1' p2' p3
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,call_binTM,The method has 5 parameters. Parameters: L' p1' p2' res' event_
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,Arith,The method has 5 parameters. Parameters: L' ra' rb' rc' op
Long Parameter List,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,arith_op,The method has 8 parameters. Parameters: L' op' tm' base_' i' k' ra' pc
Long Parameter List,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatOct,The method has 7 parameters. Parameters: NativeFormat' Alternate' FieldLength' FieldPrecision' Left2Right' Padding' Value
Long Parameter List,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatHex,The method has 7 parameters. Parameters: NativeFormat' Alternate' FieldLength' FieldPrecision' Left2Right' Padding' Value
Long Parameter List,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatNumber,The method has 9 parameters. Parameters: NativeFormat' Alternate' FieldLength' FieldPrecision' Left2Right' PositiveSign' PositiveSpace' Padding' Value
Long Statement,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "						string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}"; " is 146.
Complex Conditional,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,findindex,The conditional expression  "(luaO_rawequalObj(key2tval(n)' key) != 0) ||  					(ttype(gkey(n)) == LUA_TDEADKEY && iscollectable(key) &&  					 gcvalue(gkey(n)) == gcvalue(key))"  is complex.
Complex Conditional,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The conditional expression  "fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper( formatSpecifier ) != 'X' &&  					formatSpecifier != 'o'"  is complex.
Empty Catch Block,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,fgets,The method has an empty catch block.
Empty Catch Block,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,freopen,The method has an empty catch block.
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,lua_settable,The following statement contains a magic number: api_checknelems(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,lua_settable,The following statement contains a magic number: luaV_settable(L' t' L.top - 2' L.top - 1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,lua_settable,The following statement contains a magic number: L.top -= 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,lua_rawset,The following statement contains a magic number: api_checknelems(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,lua_rawset,The following statement contains a magic number: setobj2t(L' luaH_set(L' hvalue(t)' L.top-2)' L.top-1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,lua_rawset,The following statement contains a magic number: L.top -= 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,f_Ccall,The following statement contains a magic number: luaD_call(L' L.top - 2' 0);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,lua_gc,The following statement contains a magic number: switch (what) {  			case LUA_GCSTOP: {  			  g.GCthreshold = MAX_LUMEM;  			  break;  			}  			case LUA_GCRESTART: {  			  g.GCthreshold = g.totalbytes;  			  break;  			}  			case LUA_GCCOLLECT: {  			  luaC_fullgc(L);  			  break;  			}  			case LUA_GCCOUNT: {  			  /* GC values are expressed in Kbytes: #bytes/2^10 */  			  res = cast_int(g.totalbytes >> 10);  			  break;  			}  			case LUA_GCCOUNTB: {  			  res = cast_int(g.totalbytes & 0x3ff);  			  break;  			}  			case LUA_GCSTEP: {  			  lu_mem a = ((lu_mem)data << 10);  			  if (a <= g.totalbytes)  				g.GCthreshold = (uint)(g.totalbytes - a);  			  else  				g.GCthreshold = 0;  			  while (g.GCthreshold <= g.totalbytes) {  				luaC_step(L);  				if (g.gcstate == GCSpause) {  /* end of cycle? */  				  res = 1;  /* signal it */  				  break;  				}  			  }  			  break;  			}  			case LUA_GCSETPAUSE: {  			  res = g.gcpause;  			  g.gcpause = data;  			  break;  			}  			case LUA_GCSETSTEPMUL: {  			  res = g.gcstepmul;  			  g.gcstepmul = data;  			  break;  			}  			default:  				res = -1;  /* invalid option */  				break;  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,lua_gc,The following statement contains a magic number: switch (what) {  			case LUA_GCSTOP: {  			  g.GCthreshold = MAX_LUMEM;  			  break;  			}  			case LUA_GCRESTART: {  			  g.GCthreshold = g.totalbytes;  			  break;  			}  			case LUA_GCCOLLECT: {  			  luaC_fullgc(L);  			  break;  			}  			case LUA_GCCOUNT: {  			  /* GC values are expressed in Kbytes: #bytes/2^10 */  			  res = cast_int(g.totalbytes >> 10);  			  break;  			}  			case LUA_GCCOUNTB: {  			  res = cast_int(g.totalbytes & 0x3ff);  			  break;  			}  			case LUA_GCSTEP: {  			  lu_mem a = ((lu_mem)data << 10);  			  if (a <= g.totalbytes)  				g.GCthreshold = (uint)(g.totalbytes - a);  			  else  				g.GCthreshold = 0;  			  while (g.GCthreshold <= g.totalbytes) {  				luaC_step(L);  				if (g.gcstate == GCSpause) {  /* end of cycle? */  				  res = 1;  /* signal it */  				  break;  				}  			  }  			  break;  			}  			case LUA_GCSETPAUSE: {  			  res = g.gcpause;  			  g.gcpause = data;  			  break;  			}  			case LUA_GCSETSTEPMUL: {  			  res = g.gcstepmul;  			  g.gcstepmul = data;  			  break;  			}  			default:  				res = -1;  /* invalid option */  				break;  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,lua_concat,The following statement contains a magic number: n >= 2
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaL_error,The following statement contains a magic number: lua_concat(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaL_checkudata,The following statement contains a magic number: lua_pop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaL_checkudata,The following statement contains a magic number: lua_rawequal(L' -1' -2) != 0
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaL_getmetafield,The following statement contains a magic number: lua_rawget(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaL_getmetafield,The following statement contains a magic number: lua_pop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaI_openlib,The following statement contains a magic number: lua_setfield(L' -3' libname);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaI_openlib,The following statement contains a magic number: lua_remove(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaI_openlib,The following statement contains a magic number: lua_setfield(L' -(nup+2)' l[reg_num].name);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaL_findtable,The following statement contains a magic number: lua_rawget(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaL_findtable,The following statement contains a magic number: lua_pushvalue(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaL_findtable,The following statement contains a magic number: lua_settable(L' -4);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaL_findtable,The following statement contains a magic number: lua_remove(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_tonumber,The following statement contains a magic number: int base_ = luaL_optint(L' 2' 10);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_tonumber,The following statement contains a magic number: int base_ = luaL_optint(L' 2' 10);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_tonumber,The following statement contains a magic number: base_ == 10
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_error,The following statement contains a magic number: int level = luaL_optint(L' 2' 1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_error,The following statement contains a magic number: lua_concat(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_setmetatable,The following statement contains a magic number: int t = lua_type(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_setmetatable,The following statement contains a magic number: luaL_argcheck(L' t == LUA_TNIL || t == LUA_TTABLE' 2'  							"nil or table expected");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_setmetatable,The following statement contains a magic number: lua_settop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_setfenv,The following statement contains a magic number: luaL_checktype(L' 2' LUA_TTABLE);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_setfenv,The following statement contains a magic number: lua_pushvalue(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_setfenv,The following statement contains a magic number: lua_insert(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_setfenv,The following statement contains a magic number: lua_setfenv(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_rawequal,The following statement contains a magic number: luaL_checkany(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_rawequal,The following statement contains a magic number: lua_pushboolean(L' lua_rawequal(L' 1' 2));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_rawget,The following statement contains a magic number: luaL_checkany(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_rawget,The following statement contains a magic number: lua_settop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_rawset,The following statement contains a magic number: luaL_checkany(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_rawset,The following statement contains a magic number: luaL_checkany(L' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_rawset,The following statement contains a magic number: lua_settop(L' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_collectgarbage,The following statement contains a magic number: int ex = luaL_optint(L' 2' 0);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_collectgarbage,The following statement contains a magic number: switch (optsnum[o]) {  			case LUA_GCCOUNT: {  			  int b = lua_gc(L' LUA_GCCOUNTB' 0);  			  lua_pushnumber(L' res + ((lua_Number)b/1024));  			  return 1;  			}  			case LUA_GCSTEP: {  			  lua_pushboolean(L' res);  			  return 1;  			}  			default: {  			  lua_pushnumber(L' res);  			  return 1;  			}  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_next,The following statement contains a magic number: lua_settop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_next,The following statement contains a magic number: return 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_pairs,The following statement contains a magic number: return 3;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ipairsaux,The following statement contains a magic number: int i = luaL_checkint(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ipairsaux,The following statement contains a magic number: return (lua_isnil(L' -1)) ? 0 : 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_ipairs,The following statement contains a magic number: return 3;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_loadstring,The following statement contains a magic number: CharPtr chunkname = luaL_optstring(L' 2' s);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,generic_reader,The following statement contains a magic number: luaL_checkstack(L' 2' "too many nested functions");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_load,The following statement contains a magic number: CharPtr cname = luaL_optstring(L' 2' "=(load)");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_load,The following statement contains a magic number: lua_settop(L' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_assert,The following statement contains a magic number: return luaL_error(L' "%s"' luaL_optstring(L' 2' "assertion failed!"));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_unpack,The following statement contains a magic number: i = luaL_optint(L' 2' 1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_unpack,The following statement contains a magic number: e = luaL_opt_integer(L' luaL_checkint' 3' luaL_getn(L' 1));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_xpcall,The following statement contains a magic number: luaL_checkany(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_xpcall,The following statement contains a magic number: lua_settop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_newproxy,The following statement contains a magic number: lua_setmetatable(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_coresume,The following statement contains a magic number: lua_insert(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_coresume,The following statement contains a magic number: return 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_auxwrap,The following statement contains a magic number: lua_insert(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaB_auxwrap,The following statement contains a magic number: lua_concat(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxopen,The following statement contains a magic number: lua_setfield(L' -2' name);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,base_open,The following statement contains a magic number: lua_setmetatable(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,base_open,The following statement contains a magic number: lua_setfield(L' -2' "__mode");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_base,The following statement contains a magic number: return 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaK_self,The following statement contains a magic number: luaK_reserveregs(fs' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_setmetatable,The following statement contains a magic number: int t = lua_type(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_setmetatable,The following statement contains a magic number: luaL_argcheck(L' t == LUA_TNIL || t == LUA_TTABLE' 2'  							"nil or table expected");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_setmetatable,The following statement contains a magic number: lua_settop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_setfenv,The following statement contains a magic number: luaL_checktype(L' 2' LUA_TTABLE);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_setfenv,The following statement contains a magic number: lua_settop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,settabss,The following statement contains a magic number: lua_setfield(L' -2' i);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,settabsi,The following statement contains a magic number: lua_setfield(L' -2' i);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,treatstackoption,The following statement contains a magic number: lua_pushvalue(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,treatstackoption,The following statement contains a magic number: lua_remove(L' -3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,treatstackoption,The following statement contains a magic number: lua_setfield(L' -2' fname);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_getinfo,The following statement contains a magic number: CharPtr options = luaL_optstring(L' arg+2' "flnSu");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_getinfo,The following statement contains a magic number: return luaL_argerror(L' arg+2' "invalid option");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_getinfo,The following statement contains a magic number: lua_createtable(L' 0' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_getlocal,The following statement contains a magic number: name = lua_getlocal(L1' ar' luaL_checkint(L' arg+2));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_getlocal,The following statement contains a magic number: lua_pushvalue(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_getlocal,The following statement contains a magic number: return 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_setlocal,The following statement contains a magic number: luaL_checkany(L' arg+3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_setlocal,The following statement contains a magic number: lua_settop(L' arg+3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_setlocal,The following statement contains a magic number: lua_pushstring(L' lua_setlocal(L1' ar' luaL_checkint(L' arg+2)));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxupvalue,The following statement contains a magic number: int n = luaL_checkint(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_setupvalue,The following statement contains a magic number: luaL_checkany(L' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,hookf,The following statement contains a magic number: lua_rawget(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,hookf,The following statement contains a magic number: lua_call(L' 2' 0);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,gethooktable,The following statement contains a magic number: lua_pushvalue(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_sethook,The following statement contains a magic number: lua_rawset(L' -3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_gethook,The following statement contains a magic number: CharPtr buff = new char[5];
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_gethook,The following statement contains a magic number: return 3;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_debug,The following statement contains a magic number: CharPtr buffer = new char[250];
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_errorfb,The following statement contains a magic number: level = (int)lua_tointeger(L' arg+2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,db_errorfb,The following statement contains a magic number: lua_isnumber(L' arg+2) != 0
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,symbexec,The following statement contains a magic number: !(pc+2 < pt.sizecode)
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,symbexec,The following statement contains a magic number: switch (op) {  			  case OpCode.OP_LOADBOOL: {  				if (c == 1) {  /* does it jump? */  				  if (!(pc+2 < pt.sizecode)) return 0;  /* check its jump */  				  if (!(GET_OPCODE(pt.code[pc + 1]) != OpCode.OP_SETLIST ||  						GETARG_C(pt.code[pc + 1]) != 0)) return 0;  				}  				break;  			  }  			  case OpCode.OP_LOADNIL: {  				if (a <= reg && reg <= b)  				  last = pc;  /* set registers from `a' to `b' */  				break;  			  }  			  case OpCode.OP_GETUPVAL:  			  case OpCode.OP_SETUPVAL: {  				if (!(b < pt.nups)) return 0;  				break;  			  }  			  case OpCode.OP_GETGLOBAL:  			  case OpCode.OP_SETGLOBAL: {  				if (!(ttisstring(pt.k[b]))) return 0;  				break;  			  }  			  case OpCode.OP_SELF: {  				checkreg(pt' a+1);  				if (reg == a+1) last = pc;  				break;  			  }  			  case OpCode.OP_CONCAT: {  				if (!(b < c)) return 0;  /* at least two operands */  				break;  			  }  			  case OpCode.OP_TFORLOOP: {  				if (!(c >= 1)) return 0;  /* at least one result (control variable) */  				checkreg(pt' a+2+c);  /* space for results */  				if (reg >= a+2) last = pc;  /* affect all regs above its base */  				break;  			  }  			  case OpCode.OP_FORLOOP:  			  case OpCode.OP_FORPREP:  				checkreg(pt' a+3);  				/* go through ...no' on second thoughts don't' because this is C# */  				dest = pc + 1 + b;  				/* not full check and jump is forward and do not skip `lastpc'? */  				if (reg != NO_REG && pc < dest && dest <= lastpc)  					pc += b;  /* do the jump */  				break;    			  case OpCode.OP_JMP: {  				dest = pc+1+b;  				/* not full check and jump is forward and do not skip `lastpc'? */  				if (reg != NO_REG && pc < dest && dest <= lastpc)  				  pc += b;  /* do the jump */  				break;  			  }  			  case OpCode.OP_CALL:  			  case OpCode.OP_TAILCALL: {  				if (b != 0) {  				  checkreg(pt' a+b-1);  				}  				c--;  /* c = num. returns */  				if (c == LUA_MULTRET) {  				  if (checkopenop(pt' pc)==0) return 0;  				}  				else if (c != 0)  				  checkreg(pt' a+c-1);  				if (reg >= a) last = pc;  /* affect all registers above base */  				break;  			  }  			  case OpCode.OP_RETURN: {  				b--;  /* b = num. returns */  				if (b > 0) checkreg(pt' a+b-1);  				break;  			  }  			  case OpCode.OP_SETLIST: {  				if (b > 0) checkreg(pt' a + b);  				if (c == 0) {  				  pc++;  				  if (!(pc < pt.sizecode - 1)) return 0;  				}  				break;  			  }  			  case OpCode.OP_CLOSURE: {  				int nup' j;  				if (!(b < pt.sizep)) return 0;  				nup = pt.p[b].nups;  				if (!(pc + nup < pt.sizecode)) return 0;  				for (j = 1; j <= nup; j++) {  				  OpCode op1 = GET_OPCODE(pt.code[pc + j]);  				  if (!(op1 == OpCode.OP_GETUPVAL || op1 == OpCode.OP_MOVE)) return 0;  				}  				if (reg != NO_REG)  /* tracing? */  				  pc += nup;  /* do not 'execute' these pseudo-instructions */  				break;  			  }  			  case OpCode.OP_VARARG: {  				if (!(	(pt.is_vararg & VARARG_ISVARARG)!=0 &&  						(pt.is_vararg & VARARG_NEEDSARG)==0		)) return 0;  				b--;  				if (b == LUA_MULTRET) if (checkopenop(pt' pc)==0) return 0;  				checkreg(pt' a+b-1);  				break;  			  }  			  default:  				  break;  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,symbexec,The following statement contains a magic number: switch (op) {  			  case OpCode.OP_LOADBOOL: {  				if (c == 1) {  /* does it jump? */  				  if (!(pc+2 < pt.sizecode)) return 0;  /* check its jump */  				  if (!(GET_OPCODE(pt.code[pc + 1]) != OpCode.OP_SETLIST ||  						GETARG_C(pt.code[pc + 1]) != 0)) return 0;  				}  				break;  			  }  			  case OpCode.OP_LOADNIL: {  				if (a <= reg && reg <= b)  				  last = pc;  /* set registers from `a' to `b' */  				break;  			  }  			  case OpCode.OP_GETUPVAL:  			  case OpCode.OP_SETUPVAL: {  				if (!(b < pt.nups)) return 0;  				break;  			  }  			  case OpCode.OP_GETGLOBAL:  			  case OpCode.OP_SETGLOBAL: {  				if (!(ttisstring(pt.k[b]))) return 0;  				break;  			  }  			  case OpCode.OP_SELF: {  				checkreg(pt' a+1);  				if (reg == a+1) last = pc;  				break;  			  }  			  case OpCode.OP_CONCAT: {  				if (!(b < c)) return 0;  /* at least two operands */  				break;  			  }  			  case OpCode.OP_TFORLOOP: {  				if (!(c >= 1)) return 0;  /* at least one result (control variable) */  				checkreg(pt' a+2+c);  /* space for results */  				if (reg >= a+2) last = pc;  /* affect all regs above its base */  				break;  			  }  			  case OpCode.OP_FORLOOP:  			  case OpCode.OP_FORPREP:  				checkreg(pt' a+3);  				/* go through ...no' on second thoughts don't' because this is C# */  				dest = pc + 1 + b;  				/* not full check and jump is forward and do not skip `lastpc'? */  				if (reg != NO_REG && pc < dest && dest <= lastpc)  					pc += b;  /* do the jump */  				break;    			  case OpCode.OP_JMP: {  				dest = pc+1+b;  				/* not full check and jump is forward and do not skip `lastpc'? */  				if (reg != NO_REG && pc < dest && dest <= lastpc)  				  pc += b;  /* do the jump */  				break;  			  }  			  case OpCode.OP_CALL:  			  case OpCode.OP_TAILCALL: {  				if (b != 0) {  				  checkreg(pt' a+b-1);  				}  				c--;  /* c = num. returns */  				if (c == LUA_MULTRET) {  				  if (checkopenop(pt' pc)==0) return 0;  				}  				else if (c != 0)  				  checkreg(pt' a+c-1);  				if (reg >= a) last = pc;  /* affect all registers above base */  				break;  			  }  			  case OpCode.OP_RETURN: {  				b--;  /* b = num. returns */  				if (b > 0) checkreg(pt' a+b-1);  				break;  			  }  			  case OpCode.OP_SETLIST: {  				if (b > 0) checkreg(pt' a + b);  				if (c == 0) {  				  pc++;  				  if (!(pc < pt.sizecode - 1)) return 0;  				}  				break;  			  }  			  case OpCode.OP_CLOSURE: {  				int nup' j;  				if (!(b < pt.sizep)) return 0;  				nup = pt.p[b].nups;  				if (!(pc + nup < pt.sizecode)) return 0;  				for (j = 1; j <= nup; j++) {  				  OpCode op1 = GET_OPCODE(pt.code[pc + j]);  				  if (!(op1 == OpCode.OP_GETUPVAL || op1 == OpCode.OP_MOVE)) return 0;  				}  				if (reg != NO_REG)  /* tracing? */  				  pc += nup;  /* do not 'execute' these pseudo-instructions */  				break;  			  }  			  case OpCode.OP_VARARG: {  				if (!(	(pt.is_vararg & VARARG_ISVARARG)!=0 &&  						(pt.is_vararg & VARARG_NEEDSARG)==0		)) return 0;  				b--;  				if (b == LUA_MULTRET) if (checkopenop(pt' pc)==0) return 0;  				checkreg(pt' a+b-1);  				break;  			  }  			  default:  				  break;  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,symbexec,The following statement contains a magic number: switch (op) {  			  case OpCode.OP_LOADBOOL: {  				if (c == 1) {  /* does it jump? */  				  if (!(pc+2 < pt.sizecode)) return 0;  /* check its jump */  				  if (!(GET_OPCODE(pt.code[pc + 1]) != OpCode.OP_SETLIST ||  						GETARG_C(pt.code[pc + 1]) != 0)) return 0;  				}  				break;  			  }  			  case OpCode.OP_LOADNIL: {  				if (a <= reg && reg <= b)  				  last = pc;  /* set registers from `a' to `b' */  				break;  			  }  			  case OpCode.OP_GETUPVAL:  			  case OpCode.OP_SETUPVAL: {  				if (!(b < pt.nups)) return 0;  				break;  			  }  			  case OpCode.OP_GETGLOBAL:  			  case OpCode.OP_SETGLOBAL: {  				if (!(ttisstring(pt.k[b]))) return 0;  				break;  			  }  			  case OpCode.OP_SELF: {  				checkreg(pt' a+1);  				if (reg == a+1) last = pc;  				break;  			  }  			  case OpCode.OP_CONCAT: {  				if (!(b < c)) return 0;  /* at least two operands */  				break;  			  }  			  case OpCode.OP_TFORLOOP: {  				if (!(c >= 1)) return 0;  /* at least one result (control variable) */  				checkreg(pt' a+2+c);  /* space for results */  				if (reg >= a+2) last = pc;  /* affect all regs above its base */  				break;  			  }  			  case OpCode.OP_FORLOOP:  			  case OpCode.OP_FORPREP:  				checkreg(pt' a+3);  				/* go through ...no' on second thoughts don't' because this is C# */  				dest = pc + 1 + b;  				/* not full check and jump is forward and do not skip `lastpc'? */  				if (reg != NO_REG && pc < dest && dest <= lastpc)  					pc += b;  /* do the jump */  				break;    			  case OpCode.OP_JMP: {  				dest = pc+1+b;  				/* not full check and jump is forward and do not skip `lastpc'? */  				if (reg != NO_REG && pc < dest && dest <= lastpc)  				  pc += b;  /* do the jump */  				break;  			  }  			  case OpCode.OP_CALL:  			  case OpCode.OP_TAILCALL: {  				if (b != 0) {  				  checkreg(pt' a+b-1);  				}  				c--;  /* c = num. returns */  				if (c == LUA_MULTRET) {  				  if (checkopenop(pt' pc)==0) return 0;  				}  				else if (c != 0)  				  checkreg(pt' a+c-1);  				if (reg >= a) last = pc;  /* affect all registers above base */  				break;  			  }  			  case OpCode.OP_RETURN: {  				b--;  /* b = num. returns */  				if (b > 0) checkreg(pt' a+b-1);  				break;  			  }  			  case OpCode.OP_SETLIST: {  				if (b > 0) checkreg(pt' a + b);  				if (c == 0) {  				  pc++;  				  if (!(pc < pt.sizecode - 1)) return 0;  				}  				break;  			  }  			  case OpCode.OP_CLOSURE: {  				int nup' j;  				if (!(b < pt.sizep)) return 0;  				nup = pt.p[b].nups;  				if (!(pc + nup < pt.sizecode)) return 0;  				for (j = 1; j <= nup; j++) {  				  OpCode op1 = GET_OPCODE(pt.code[pc + j]);  				  if (!(op1 == OpCode.OP_GETUPVAL || op1 == OpCode.OP_MOVE)) return 0;  				}  				if (reg != NO_REG)  /* tracing? */  				  pc += nup;  /* do not 'execute' these pseudo-instructions */  				break;  			  }  			  case OpCode.OP_VARARG: {  				if (!(	(pt.is_vararg & VARARG_ISVARARG)!=0 &&  						(pt.is_vararg & VARARG_NEEDSARG)==0		)) return 0;  				b--;  				if (b == LUA_MULTRET) if (checkopenop(pt' pc)==0) return 0;  				checkreg(pt' a+b-1);  				break;  			  }  			  default:  				  break;  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,symbexec,The following statement contains a magic number: switch (op) {  			  case OpCode.OP_LOADBOOL: {  				if (c == 1) {  /* does it jump? */  				  if (!(pc+2 < pt.sizecode)) return 0;  /* check its jump */  				  if (!(GET_OPCODE(pt.code[pc + 1]) != OpCode.OP_SETLIST ||  						GETARG_C(pt.code[pc + 1]) != 0)) return 0;  				}  				break;  			  }  			  case OpCode.OP_LOADNIL: {  				if (a <= reg && reg <= b)  				  last = pc;  /* set registers from `a' to `b' */  				break;  			  }  			  case OpCode.OP_GETUPVAL:  			  case OpCode.OP_SETUPVAL: {  				if (!(b < pt.nups)) return 0;  				break;  			  }  			  case OpCode.OP_GETGLOBAL:  			  case OpCode.OP_SETGLOBAL: {  				if (!(ttisstring(pt.k[b]))) return 0;  				break;  			  }  			  case OpCode.OP_SELF: {  				checkreg(pt' a+1);  				if (reg == a+1) last = pc;  				break;  			  }  			  case OpCode.OP_CONCAT: {  				if (!(b < c)) return 0;  /* at least two operands */  				break;  			  }  			  case OpCode.OP_TFORLOOP: {  				if (!(c >= 1)) return 0;  /* at least one result (control variable) */  				checkreg(pt' a+2+c);  /* space for results */  				if (reg >= a+2) last = pc;  /* affect all regs above its base */  				break;  			  }  			  case OpCode.OP_FORLOOP:  			  case OpCode.OP_FORPREP:  				checkreg(pt' a+3);  				/* go through ...no' on second thoughts don't' because this is C# */  				dest = pc + 1 + b;  				/* not full check and jump is forward and do not skip `lastpc'? */  				if (reg != NO_REG && pc < dest && dest <= lastpc)  					pc += b;  /* do the jump */  				break;    			  case OpCode.OP_JMP: {  				dest = pc+1+b;  				/* not full check and jump is forward and do not skip `lastpc'? */  				if (reg != NO_REG && pc < dest && dest <= lastpc)  				  pc += b;  /* do the jump */  				break;  			  }  			  case OpCode.OP_CALL:  			  case OpCode.OP_TAILCALL: {  				if (b != 0) {  				  checkreg(pt' a+b-1);  				}  				c--;  /* c = num. returns */  				if (c == LUA_MULTRET) {  				  if (checkopenop(pt' pc)==0) return 0;  				}  				else if (c != 0)  				  checkreg(pt' a+c-1);  				if (reg >= a) last = pc;  /* affect all registers above base */  				break;  			  }  			  case OpCode.OP_RETURN: {  				b--;  /* b = num. returns */  				if (b > 0) checkreg(pt' a+b-1);  				break;  			  }  			  case OpCode.OP_SETLIST: {  				if (b > 0) checkreg(pt' a + b);  				if (c == 0) {  				  pc++;  				  if (!(pc < pt.sizecode - 1)) return 0;  				}  				break;  			  }  			  case OpCode.OP_CLOSURE: {  				int nup' j;  				if (!(b < pt.sizep)) return 0;  				nup = pt.p[b].nups;  				if (!(pc + nup < pt.sizecode)) return 0;  				for (j = 1; j <= nup; j++) {  				  OpCode op1 = GET_OPCODE(pt.code[pc + j]);  				  if (!(op1 == OpCode.OP_GETUPVAL || op1 == OpCode.OP_MOVE)) return 0;  				}  				if (reg != NO_REG)  /* tracing? */  				  pc += nup;  /* do not 'execute' these pseudo-instructions */  				break;  			  }  			  case OpCode.OP_VARARG: {  				if (!(	(pt.is_vararg & VARARG_ISVARARG)!=0 &&  						(pt.is_vararg & VARARG_NEEDSARG)==0		)) return 0;  				b--;  				if (b == LUA_MULTRET) if (checkopenop(pt' pc)==0) return 0;  				checkreg(pt' a+b-1);  				break;  			  }  			  default:  				  break;  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaG_ordererror,The following statement contains a magic number: t1[2] == t2[2]
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaG_ordererror,The following statement contains a magic number: t1[2] == t2[2]
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaG_errormsg,The following statement contains a magic number: luaD_call(L' L.top - 2' 1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaD_growstack,The following statement contains a magic number: luaD_reallocstack(L' 2*L.stacksize);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,setthreshold,The following statement contains a magic number: g.GCthreshold = (uint)((g.estimate / 100) * g.gcpause);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkstacksizes,The following statement contains a magic number: luaD_reallocCI(L' L.size_ci/2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkstacksizes,The following statement contains a magic number: 4*ci_used < L.size_ci && 2*BASIC_CI_SIZE < L.size_ci
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkstacksizes,The following statement contains a magic number: 4*ci_used < L.size_ci && 2*BASIC_CI_SIZE < L.size_ci
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkstacksizes,The following statement contains a magic number: luaD_reallocstack(L' L.stacksize/2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkstacksizes,The following statement contains a magic number: 4*s_used < L.stacksize &&  			  2*(BASIC_STACK_SIZE+EXTRA_STACK) < L.stacksize
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkstacksizes,The following statement contains a magic number: 4*s_used < L.stacksize &&  			  2*(BASIC_STACK_SIZE+EXTRA_STACK) < L.stacksize
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkSizes,The following statement contains a magic number: luaS_resize(L' g.strt.size/2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkSizes,The following statement contains a magic number: g.strt.nuse < (lu_int32)(g.strt.size/4) &&  			  g.strt.size > MINSTRTABSIZE*2
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkSizes,The following statement contains a magic number: g.strt.nuse < (lu_int32)(g.strt.size/4) &&  			  g.strt.size > MINSTRTABSIZE*2
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkSizes,The following statement contains a magic number: uint newsize = luaZ_sizebuffer(g.buff) / 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkSizes,The following statement contains a magic number: luaZ_sizebuffer(g.buff) > LUA_MINBUFFER*2
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,GCTM,The following statement contains a magic number: g.GCthreshold = 2*g.totalbytes;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,GCTM,The following statement contains a magic number: L.top += 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,GCTM,The following statement contains a magic number: luaD_call(L' L.top - 2' 0);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaC_step,The following statement contains a magic number: l_mem lim = (l_mem)((GCSTEPSIZE / 100) * g.gcstepmul);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaC_step,The following statement contains a magic number: lim = (l_mem)((MAX_LUMEM-1)/2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,io_type,The following statement contains a magic number: ud == null || (lua_getmetatable(L' 1)==0) || (lua_rawequal(L' -2' -1)==0)
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,newfile,The following statement contains a magic number: lua_setmetatable(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,io_noclose,The following statement contains a magic number: return 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,io_open,The following statement contains a magic number: CharPtr mode = luaL_optstring(L' 2' "r");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,io_popen,The following statement contains a magic number: CharPtr mode = luaL_optstring(L' 2' "r");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,aux_lines,The following statement contains a magic number: lua_pushcclosure(L' io_readline' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,f_read,The following statement contains a magic number: return g_read(L' tofile(L)' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,f_write,The following statement contains a magic number: return g_write(L' tofile(L)' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,f_seek,The following statement contains a magic number: int op = luaL_checkoption(L' 2' "cur"' modenames);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,f_seek,The following statement contains a magic number: long offset = luaL_optlong(L' 3' 0);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,f_setvbuf,The following statement contains a magic number: int op = luaL_checkoption(L' 2' null' modenames);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,f_setvbuf,The following statement contains a magic number: lua_Integer sz = luaL_optinteger(L' 3' LUAL_BUFFERSIZE);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,createmeta,The following statement contains a magic number: lua_setfield(L' -2' "__index");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,createstdfile,The following statement contains a magic number: lua_pushvalue(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,createstdfile,The following statement contains a magic number: lua_setfenv(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,createstdfile,The following statement contains a magic number: lua_setfield(L' -3' fname);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,newfenv,The following statement contains a magic number: lua_setfield(L' -2' "__close");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_io,The following statement contains a magic number: lua_setfenv(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,save,The following statement contains a magic number: b.buffsize >= MAX_SIZET/2
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,save,The following statement contains a magic number: newsize = b.buffsize * 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,read_long_string,The following statement contains a magic number: seminfo.ts = luaX_newstring(ls' luaZ_buffer(ls.buff) + (2 + sep)'   											(uint)(luaZ_bufflen(ls.buff) - 2*(2 + sep)));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,read_long_string,The following statement contains a magic number: seminfo.ts = luaX_newstring(ls' luaZ_buffer(ls.buff) + (2 + sep)'   											(uint)(luaZ_bufflen(ls.buff) - 2*(2 + sep)));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,read_long_string,The following statement contains a magic number: seminfo.ts = luaX_newstring(ls' luaZ_buffer(ls.buff) + (2 + sep)'   											(uint)(luaZ_bufflen(ls.buff) - 2*(2 + sep)));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,read_string,The following statement contains a magic number: switch (ls.current) {  			  case EOZ:  				luaX_lexerror(ls' "unfinished string"' (int)RESERVED.TK_EOS);  				continue;  /* to avoid warnings */  			  case '\n':  			  case '\r':  				luaX_lexerror(ls' "unfinished string"' (int)RESERVED.TK_STRING);  				continue;  /* to avoid warnings */  			  case '\\': {  				int c;  				next(ls);  /* do not save the `\' */  				switch (ls.current) {  				  case 'a': c = '\a'; break;  				  case 'b': c = '\b'; break;  				  case 'f': c = '\f'; break;  				  case 'n': c = '\n'; break;  				  case 'r': c = '\r'; break;  				  case 't': c = '\t'; break;  				  case 'v': c = '\v'; break;  				  case '\n':  /* go through */  				  case '\r': save(ls' '\n'); inclinenumber(ls); continue;  				  case EOZ: continue;  /* will raise an error next loop */  				  default: {  					if (!isdigit(ls.current))  					  save_and_next(ls);  /* handles \\' \"' \'' and \? */  					else {  /* \xxx */  					  int i = 0;  					  c = 0;  					  do {  						c = 10*c + (ls.current-'0');  						next(ls);  					  } while (++i<3 && isdigit(ls.current));  					  if (c > System.Byte.MaxValue)  						luaX_lexerror(ls' "escape sequence too large"' (int)RESERVED.TK_STRING);  					  save(ls' c);  					}  					continue;  				  }  				}  				save(ls' c);  				next(ls);  				continue;  			  }  			  default:  				save_and_next(ls);  				break;  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,read_string,The following statement contains a magic number: switch (ls.current) {  			  case EOZ:  				luaX_lexerror(ls' "unfinished string"' (int)RESERVED.TK_EOS);  				continue;  /* to avoid warnings */  			  case '\n':  			  case '\r':  				luaX_lexerror(ls' "unfinished string"' (int)RESERVED.TK_STRING);  				continue;  /* to avoid warnings */  			  case '\\': {  				int c;  				next(ls);  /* do not save the `\' */  				switch (ls.current) {  				  case 'a': c = '\a'; break;  				  case 'b': c = '\b'; break;  				  case 'f': c = '\f'; break;  				  case 'n': c = '\n'; break;  				  case 'r': c = '\r'; break;  				  case 't': c = '\t'; break;  				  case 'v': c = '\v'; break;  				  case '\n':  /* go through */  				  case '\r': save(ls' '\n'); inclinenumber(ls); continue;  				  case EOZ: continue;  /* will raise an error next loop */  				  default: {  					if (!isdigit(ls.current))  					  save_and_next(ls);  /* handles \\' \"' \'' and \? */  					else {  /* \xxx */  					  int i = 0;  					  c = 0;  					  do {  						c = 10*c + (ls.current-'0');  						next(ls);  					  } while (++i<3 && isdigit(ls.current));  					  if (c > System.Byte.MaxValue)  						luaX_lexerror(ls' "escape sequence too large"' (int)RESERVED.TK_STRING);  					  save(ls' c);  					}  					continue;  				  }  				}  				save(ls' c);  				next(ls);  				continue;  			  }  			  default:  				save_and_next(ls);  				break;  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,read_string,The following statement contains a magic number: seminfo.ts = luaX_newstring(ls' luaZ_buffer(ls.buff) + 1'  		                                  luaZ_bufflen(ls.buff) - 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,math_atan2,The following statement contains a magic number: lua_pushnumber(L' Math.Atan2(luaL_checknumber(L' 1)' luaL_checknumber(L' 2)));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,math_fmod,The following statement contains a magic number: lua_pushnumber(L' fmod(luaL_checknumber(L' 1)' luaL_checknumber(L' 2)));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,math_modf,The following statement contains a magic number: return 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,math_pow,The following statement contains a magic number: lua_pushnumber(L' Math.Pow(luaL_checknumber(L' 1)' luaL_checknumber(L' 2)));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,math_frexp,The following statement contains a magic number: return 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,math_ldexp,The following statement contains a magic number: lua_pushnumber(L' ldexp(luaL_checknumber(L' 1)' luaL_checkint(L' 2)));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,math_random,The following statement contains a magic number: switch (lua_gettop(L)) {  /* check number of arguments */  			case 0: {  /* no arguments */  			  lua_pushnumber(L' r);  /* Number between 0 and 1 */  			  break;  			}  			case 1: {  /* only upper limit */  			  int u = luaL_checkint(L' 1);  			  luaL_argcheck(L' 1<=u' 1' "interval is empty");  			  lua_pushnumber(L' Math.Floor(r*u)+1);  /* int between 1 and `u' */  			  break;  			}  			case 2: {  /* lower and upper limits */  			  int l = luaL_checkint(L' 1);  			  int u = luaL_checkint(L' 2);  			  luaL_argcheck(L' l<=u' 2' "interval is empty");  			  lua_pushnumber(L' Math.Floor(r * (u - l + 1)) + l);  /* int between `l' and `u' */  			  break;  			}  			default: return luaL_error(L' "wrong number of arguments");  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,math_random,The following statement contains a magic number: switch (lua_gettop(L)) {  /* check number of arguments */  			case 0: {  /* no arguments */  			  lua_pushnumber(L' r);  /* Number between 0 and 1 */  			  break;  			}  			case 1: {  /* only upper limit */  			  int u = luaL_checkint(L' 1);  			  luaL_argcheck(L' 1<=u' 1' "interval is empty");  			  lua_pushnumber(L' Math.Floor(r*u)+1);  /* int between 1 and `u' */  			  break;  			}  			case 2: {  /* lower and upper limits */  			  int l = luaL_checkint(L' 1);  			  int u = luaL_checkint(L' 2);  			  luaL_argcheck(L' l<=u' 2' "interval is empty");  			  lua_pushnumber(L' Math.Floor(r * (u - l + 1)) + l);  /* int between `l' and `u' */  			  break;  			}  			default: return luaL_error(L' "wrong number of arguments");  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,math_random,The following statement contains a magic number: switch (lua_gettop(L)) {  /* check number of arguments */  			case 0: {  /* no arguments */  			  lua_pushnumber(L' r);  /* Number between 0 and 1 */  			  break;  			}  			case 1: {  /* only upper limit */  			  int u = luaL_checkint(L' 1);  			  luaL_argcheck(L' 1<=u' 1' "interval is empty");  			  lua_pushnumber(L' Math.Floor(r*u)+1);  /* int between 1 and `u' */  			  break;  			}  			case 2: {  /* lower and upper limits */  			  int l = luaL_checkint(L' 1);  			  int u = luaL_checkint(L' 2);  			  luaL_argcheck(L' l<=u' 2' "interval is empty");  			  lua_pushnumber(L' Math.Floor(r * (u - l + 1)) + l);  /* int between `l' and `u' */  			  break;  			}  			default: return luaL_error(L' "wrong number of arguments");  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_math,The following statement contains a magic number: lua_setfield(L' -2' "pi");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_math,The following statement contains a magic number: lua_setfield(L' -2' "huge");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_math,The following statement contains a magic number: lua_setfield(L' -2' "mod");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaM_growaux_,The following statement contains a magic number: size >= limit / 2
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,setprogdir,The following statement contains a magic number: lua_remove(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ll_loadlib,The following statement contains a magic number: CharPtr init = luaL_checkstring(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,findfile,The following statement contains a magic number: lua_remove(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,findfile,The following statement contains a magic number: lua_remove(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,findfile,The following statement contains a magic number: lua_concat(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,mkfuncname,The following statement contains a magic number: lua_remove(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ll_require,The following statement contains a magic number: lua_getfield(L' 2' name);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ll_require,The following statement contains a magic number: lua_rawgeti(L' -2' i);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ll_require,The following statement contains a magic number: luaL_error(L' "module " + LUA_QS + " not found:%s"'  							name' lua_tostring(L' -2));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ll_require,The following statement contains a magic number: lua_setfield(L' 2' name);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ll_require,The following statement contains a magic number: lua_setfield(L' 2' name);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ll_require,The following statement contains a magic number: lua_getfield(L' 2' name);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ll_require,The following statement contains a magic number: lua_setfield(L' 2' name);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,setfenv,The following statement contains a magic number: lua_pushvalue(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,setfenv,The following statement contains a magic number: lua_setfenv(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,dooptions,The following statement contains a magic number: lua_pushvalue(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,modinit,The following statement contains a magic number: lua_setfield(L' -2' "_M");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,modinit,The following statement contains a magic number: lua_setfield(L' -2' "_NAME");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,modinit,The following statement contains a magic number: lua_setfield(L' -2' "_PACKAGE");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ll_seeall,The following statement contains a magic number: lua_setfield(L' -2' "__index");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,setpath,The following statement contains a magic number: lua_setfield(L' -2' fieldname);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_package,The following statement contains a magic number: lua_setfield(L' -2' "__gc");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_package,The following statement contains a magic number: lua_rawseti(L' -2' i+1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_package,The following statement contains a magic number: lua_setfield(L' -2' "loaders");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_package,The following statement contains a magic number: lua_setfield(L' -2' "config");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_package,The following statement contains a magic number: luaL_findtable(L' LUA_REGISTRYINDEX' "_LOADED"' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_package,The following statement contains a magic number: lua_setfield(L' -2' "loaded");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_package,The following statement contains a magic number: lua_setfield(L' -2' "preload");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_int2fb,The following statement contains a magic number: x >= 16
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_int2fb,The following statement contains a magic number: x < 8
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_fb2int,The following statement contains a magic number: int e = (x >> 3) & 31;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_fb2int,The following statement contains a magic number: int e = (x >> 3) & 31;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_log2,The following statement contains a magic number: l += 8;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_log2,The following statement contains a magic number: x >>= 8;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_log2,The following statement contains a magic number: x >= 256
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_str2d,The following statement contains a magic number: result = cast_num(strtoul(s' out endptr' 16));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_pushvfstring,The following statement contains a magic number: switch (e[1]) {  		      case 's': {  				  object o = argp[parm_index++];  				  CharPtr s = o as CharPtr;  				  if (s == null)  					  s = (string)o;  				  if (s == null) s = "(null)";  		          pushstr(L' s);  		          break;  		      }  		      case 'c': {  		        CharPtr buff = new char[2];  		        buff[0] = (char)(int)argp[parm_index++];  		        buff[1] = '\0';  		        pushstr(L' buff);  		        break;  		      }  		      case 'd': {  		        setnvalue(L.top' (int)argp[parm_index++]);  		        incr_top(L);  		        break;  		      }  		      case 'f': {  		        setnvalue(L.top' (l_uacNumber)argp[parm_index++]);  		        incr_top(L);  		        break;  		      }  		      case 'p': {  		        //CharPtr buff = new char[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */  				CharPtr buff = new char[32];  				sprintf(buff' "0x%08x"' argp[parm_index++].GetHashCode());  		        pushstr(L' buff);  		        break;  		      }  		      case '%': {  		        pushstr(L' "%");  		        break;  		      }  		      default: {  		        CharPtr buff = new char[3];  		        buff[0] = '%';  		        buff[1] = e[1];  		        buff[2] = '\0';  		        pushstr(L' buff);  		        break;  		      }  		    }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_pushvfstring,The following statement contains a magic number: switch (e[1]) {  		      case 's': {  				  object o = argp[parm_index++];  				  CharPtr s = o as CharPtr;  				  if (s == null)  					  s = (string)o;  				  if (s == null) s = "(null)";  		          pushstr(L' s);  		          break;  		      }  		      case 'c': {  		        CharPtr buff = new char[2];  		        buff[0] = (char)(int)argp[parm_index++];  		        buff[1] = '\0';  		        pushstr(L' buff);  		        break;  		      }  		      case 'd': {  		        setnvalue(L.top' (int)argp[parm_index++]);  		        incr_top(L);  		        break;  		      }  		      case 'f': {  		        setnvalue(L.top' (l_uacNumber)argp[parm_index++]);  		        incr_top(L);  		        break;  		      }  		      case 'p': {  		        //CharPtr buff = new char[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */  				CharPtr buff = new char[32];  				sprintf(buff' "0x%08x"' argp[parm_index++].GetHashCode());  		        pushstr(L' buff);  		        break;  		      }  		      case '%': {  		        pushstr(L' "%");  		        break;  		      }  		      default: {  		        CharPtr buff = new char[3];  		        buff[0] = '%';  		        buff[1] = e[1];  		        buff[2] = '\0';  		        pushstr(L' buff);  		        break;  		      }  		    }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_pushvfstring,The following statement contains a magic number: switch (e[1]) {  		      case 's': {  				  object o = argp[parm_index++];  				  CharPtr s = o as CharPtr;  				  if (s == null)  					  s = (string)o;  				  if (s == null) s = "(null)";  		          pushstr(L' s);  		          break;  		      }  		      case 'c': {  		        CharPtr buff = new char[2];  		        buff[0] = (char)(int)argp[parm_index++];  		        buff[1] = '\0';  		        pushstr(L' buff);  		        break;  		      }  		      case 'd': {  		        setnvalue(L.top' (int)argp[parm_index++]);  		        incr_top(L);  		        break;  		      }  		      case 'f': {  		        setnvalue(L.top' (l_uacNumber)argp[parm_index++]);  		        incr_top(L);  		        break;  		      }  		      case 'p': {  		        //CharPtr buff = new char[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */  				CharPtr buff = new char[32];  				sprintf(buff' "0x%08x"' argp[parm_index++].GetHashCode());  		        pushstr(L' buff);  		        break;  		      }  		      case '%': {  		        pushstr(L' "%");  		        break;  		      }  		      default: {  		        CharPtr buff = new char[3];  		        buff[0] = '%';  		        buff[1] = e[1];  		        buff[2] = '\0';  		        pushstr(L' buff);  		        break;  		      }  		    }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_pushvfstring,The following statement contains a magic number: switch (e[1]) {  		      case 's': {  				  object o = argp[parm_index++];  				  CharPtr s = o as CharPtr;  				  if (s == null)  					  s = (string)o;  				  if (s == null) s = "(null)";  		          pushstr(L' s);  		          break;  		      }  		      case 'c': {  		        CharPtr buff = new char[2];  		        buff[0] = (char)(int)argp[parm_index++];  		        buff[1] = '\0';  		        pushstr(L' buff);  		        break;  		      }  		      case 'd': {  		        setnvalue(L.top' (int)argp[parm_index++]);  		        incr_top(L);  		        break;  		      }  		      case 'f': {  		        setnvalue(L.top' (l_uacNumber)argp[parm_index++]);  		        incr_top(L);  		        break;  		      }  		      case 'p': {  		        //CharPtr buff = new char[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */  				CharPtr buff = new char[32];  				sprintf(buff' "0x%08x"' argp[parm_index++].GetHashCode());  		        pushstr(L' buff);  		        break;  		      }  		      case '%': {  		        pushstr(L' "%");  		        break;  		      }  		      default: {  		        CharPtr buff = new char[3];  		        buff[0] = '%';  		        buff[1] = e[1];  		        buff[2] = '\0';  		        pushstr(L' buff);  		        break;  		      }  		    }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_pushvfstring,The following statement contains a magic number: n += 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaO_pushvfstring,The following statement contains a magic number: fmt = e+2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,getOpMode,The following statement contains a magic number: return (OpMode)(luaP_opmodes[(int)m] & 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,getBMode,The following statement contains a magic number: return (OpArgMask)((luaP_opmodes[(int)m] >> 4) & 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,getBMode,The following statement contains a magic number: return (OpArgMask)((luaP_opmodes[(int)m] >> 4) & 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,getCMode,The following statement contains a magic number: return (OpArgMask)((luaP_opmodes[(int)m] >> 2) & 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,getCMode,The following statement contains a magic number: return (OpArgMask)((luaP_opmodes[(int)m] >> 2) & 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,testAMode,The following statement contains a magic number: return luaP_opmodes[(int)m] & (1 << 6);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,testTMode,The following statement contains a magic number: return luaP_opmodes[(int)m] & (1 << 7);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,opmode,The following statement contains a magic number: return (lu_byte)(((t) << 7) | ((a) << 6) | (((lu_byte)b) << 4) | (((lu_byte)c) << 2) | ((lu_byte)m));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,opmode,The following statement contains a magic number: return (lu_byte)(((t) << 7) | ((a) << 6) | (((lu_byte)b) << 4) | (((lu_byte)c) << 2) | ((lu_byte)m));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,opmode,The following statement contains a magic number: return (lu_byte)(((t) << 7) | ((a) << 6) | (((lu_byte)b) << 4) | (((lu_byte)c) << 2) | ((lu_byte)m));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,opmode,The following statement contains a magic number: return (lu_byte)(((t) << 7) | ((a) << 6) | (((lu_byte)b) << 4) | (((lu_byte)c) << 2) | ((lu_byte)m));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,os_rename,The following statement contains a magic number: CharPtr toname = luaL_checkstring(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,os_clock,The following statement contains a magic number: lua_pushnumber(L' ((lua_Number)ticks)/(lua_Number)1000);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,setfield,The following statement contains a magic number: lua_setfield(L' -2' key);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,setboolfield,The following statement contains a magic number: lua_setfield(L' -2' key);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,os_date,The following statement contains a magic number: lua_createtable(L' 0' 9);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,os_difftime,The following statement contains a magic number: long ticks = (long)luaL_checknumber(L' 1) - (long)luaL_optnumber(L' 2' 0);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,open_func,The following statement contains a magic number: f.maxstacksize = 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,close_func,The following statement contains a magic number: L.top -= 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,funcargs,The following statement contains a magic number: init_exp(f' expkind.VCALL' luaK_codeABC(fs' OpCode.OP_CALL' base_' nparams + 1' 2));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,forbody,The following statement contains a magic number: adjustlocalvars(ls' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,fornum,The following statement contains a magic number: new_localvarliteral(ls' "(for step)"' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,fornum,The following statement contains a magic number: new_localvar(ls' varname' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,forlist,The following statement contains a magic number: adjust_assign(ls' 3' explist1(ls' e)' e);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,forlist,The following statement contains a magic number: luaK_checkstack(fs' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,forlist,The following statement contains a magic number: forbody(ls' base_' line' nvars - 3' 0);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,f_luaopen,The following statement contains a magic number: sethvalue(L' gt(L)' luaH_new(L' 0' 2));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,f_luaopen,The following statement contains a magic number: sethvalue(L' registry(L)' luaH_new(L' 0' 2));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,f_luaopen,The following statement contains a magic number: g.GCthreshold = 4*g.totalbytes;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,newlstr,The following statement contains a magic number: luaS_resize(L' tb.size*2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,newlstr,The following statement contains a magic number: (tb.nuse > (int)tb.size) && (tb.size <= MAX_INT/2)
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaS_newlstr,The following statement contains a magic number: uint step = (l>>5)+1;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaS_newlstr,The following statement contains a magic number: h = h ^ ((h<<5)+(h>>2)+(byte)str[l1-1]);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaS_newlstr,The following statement contains a magic number: h = h ^ ((h<<5)+(h>>2)+(byte)str[l1-1]);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_sub,The following statement contains a magic number: ptrdiff_t start = posrelat(luaL_checkinteger(L' 2)' l);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_sub,The following statement contains a magic number: ptrdiff_t end = posrelat(luaL_optinteger(L' 3' -1)' l);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_rep,The following statement contains a magic number: int n = luaL_checkint(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_byte,The following statement contains a magic number: ptrdiff_t posi = posrelat(luaL_optinteger(L' 2' 1)' l);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_byte,The following statement contains a magic number: ptrdiff_t pose = posrelat(luaL_optinteger(L' 3' posi)' l);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_find_aux,The following statement contains a magic number: CharPtr p = luaL_checklstring(L' 2' out l2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_find_aux,The following statement contains a magic number: ptrdiff_t init = posrelat(luaL_optinteger(L' 3' 1)' l1) - 1;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_find_aux,The following statement contains a magic number: return 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_find_aux,The following statement contains a magic number: (find!=0) && ((lua_toboolean(L' 4)!=0) ||  /* explicit request? */  			  strpbrk(p' SPECIALS) == null)
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,gmatch_aux,The following statement contains a magic number: CharPtr p = lua_tostring(L' lua_upvalueindex(2));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,gmatch_aux,The following statement contains a magic number: lua_replace(L' lua_upvalueindex(3));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,gmatch,The following statement contains a magic number: luaL_checkstring(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,gmatch,The following statement contains a magic number: lua_settop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,gmatch,The following statement contains a magic number: lua_pushcclosure(L' gmatch_aux' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,add_s,The following statement contains a magic number: CharPtr news = lua_tolstring(ms.L' 3' out l);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,add_value,The following statement contains a magic number: switch (lua_type(L' 3)) {  			case LUA_TNUMBER:  			case LUA_TSTRING: {  			  add_s(ms' b' s' e);  			  return;  			}  			case LUA_TFUNCTION: {  			  int n;  			  lua_pushvalue(L' 3);  			  n = push_captures(ms' s' e);  			  lua_call(L' n' 1);  			  break;  			}  			case LUA_TTABLE: {  			  push_onecapture(ms' 0' s' e);  			  lua_gettable(L' 3);  			  break;  			}  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,add_value,The following statement contains a magic number: switch (lua_type(L' 3)) {  			case LUA_TNUMBER:  			case LUA_TSTRING: {  			  add_s(ms' b' s' e);  			  return;  			}  			case LUA_TFUNCTION: {  			  int n;  			  lua_pushvalue(L' 3);  			  n = push_captures(ms' s' e);  			  lua_call(L' n' 1);  			  break;  			}  			case LUA_TTABLE: {  			  push_onecapture(ms' 0' s' e);  			  lua_gettable(L' 3);  			  break;  			}  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,add_value,The following statement contains a magic number: switch (lua_type(L' 3)) {  			case LUA_TNUMBER:  			case LUA_TSTRING: {  			  add_s(ms' b' s' e);  			  return;  			}  			case LUA_TFUNCTION: {  			  int n;  			  lua_pushvalue(L' 3);  			  n = push_captures(ms' s' e);  			  lua_call(L' n' 1);  			  break;  			}  			case LUA_TTABLE: {  			  push_onecapture(ms' 0' s' e);  			  lua_gettable(L' 3);  			  break;  			}  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_gsub,The following statement contains a magic number: CharPtr p = luaL_checkstring(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_gsub,The following statement contains a magic number: int  tr = lua_type(L' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_gsub,The following statement contains a magic number: int max_s = luaL_optint(L' 4' (int)(srcl+1));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_gsub,The following statement contains a magic number: luaL_argcheck(L' tr == LUA_TNUMBER || tr == LUA_TSTRING ||  						   tr == LUA_TFUNCTION || tr == LUA_TTABLE' 3'  							  "string/function/table expected");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,str_gsub,The following statement contains a magic number: return 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,addquoted,The following statement contains a magic number: switch (s[0]) {  			  case '"': case '\\': case '\n': {  				luaL_addchar(b' '\\');  				luaL_addchar(b' s[0]);  				break;  			  }  			  case '\r': {  				luaL_addlstring(b' "\\r"' 2);  				break;  			  }  			  case '\0': {  				luaL_addlstring(b' "\\000"' 4);  				break;  			  }  			  default: {  				luaL_addchar(b' s[0]);  				break;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,addquoted,The following statement contains a magic number: switch (s[0]) {  			  case '"': case '\\': case '\n': {  				luaL_addchar(b' '\\');  				luaL_addchar(b' s[0]);  				break;  			  }  			  case '\r': {  				luaL_addlstring(b' "\\r"' 2);  				break;  			  }  			  case '\0': {  				luaL_addlstring(b' "\\000"' 4);  				break;  			  }  			  default: {  				luaL_addchar(b' s[0]);  				break;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,addintlen,The following statement contains a magic number: form[l + (LUA_INTFRMLEN.Length + 1) - 2] = spec;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,createmetatable,The following statement contains a magic number: lua_pushvalue(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,createmetatable,The following statement contains a magic number: lua_setmetatable(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,createmetatable,The following statement contains a magic number: lua_pushvalue(L' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,createmetatable,The following statement contains a magic number: lua_setfield(L' -2' "__index");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaopen_string,The following statement contains a magic number: lua_setfield(L' -2' "gfind");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,computesizes,The following statement contains a magic number: a > twotoi/2
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,computesizes,The following statement contains a magic number: twotoi/2 < narray
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,computesizes,The following statement contains a magic number: lua_assert(narray/2 <= na && na <= narray);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,unbound_search,The following statement contains a magic number: j *= 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,unbound_search,The following statement contains a magic number: uint m = (i+j)/2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaH_getn,The following statement contains a magic number: uint m = (i+j)/2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,foreachi,The following statement contains a magic number: luaL_checktype(L' 2' LUA_TFUNCTION);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,foreachi,The following statement contains a magic number: lua_pushvalue(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,foreachi,The following statement contains a magic number: lua_call(L' 2' 1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,_foreach,The following statement contains a magic number: luaL_checktype(L' 2' LUA_TFUNCTION);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,_foreach,The following statement contains a magic number: lua_pushvalue(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,_foreach,The following statement contains a magic number: lua_pushvalue(L' -3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,_foreach,The following statement contains a magic number: lua_pushvalue(L' -3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,_foreach,The following statement contains a magic number: lua_call(L' 2' 1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,_foreach,The following statement contains a magic number: lua_pop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,tinsert,The following statement contains a magic number: switch (lua_gettop(L)) {  			case 2: {  /* called with only 2 arguments */  			  pos = e;  /* insert new element at the end */  			  break;  			}  			case 3: {  			  int i;  			  pos = luaL_checkint(L' 2);  /* 2nd argument is the position */  			  if (pos > e) e = pos;  /* `grow' array if necessary */  			  for (i = e; i > pos; i--) {  /* move up elements */  				lua_rawgeti(L' 1' i-1);  				lua_rawseti(L' 1' i);  /* t[i] = t[i-1] */  			  }  			  break;  			}  			default: {  			  return luaL_error(L' "wrong number of arguments to " + LUA_QL("insert"));  			}  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,tinsert,The following statement contains a magic number: switch (lua_gettop(L)) {  			case 2: {  /* called with only 2 arguments */  			  pos = e;  /* insert new element at the end */  			  break;  			}  			case 3: {  			  int i;  			  pos = luaL_checkint(L' 2);  /* 2nd argument is the position */  			  if (pos > e) e = pos;  /* `grow' array if necessary */  			  for (i = e; i > pos; i--) {  /* move up elements */  				lua_rawgeti(L' 1' i-1);  				lua_rawseti(L' 1' i);  /* t[i] = t[i-1] */  			  }  			  break;  			}  			default: {  			  return luaL_error(L' "wrong number of arguments to " + LUA_QL("insert"));  			}  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,tinsert,The following statement contains a magic number: switch (lua_gettop(L)) {  			case 2: {  /* called with only 2 arguments */  			  pos = e;  /* insert new element at the end */  			  break;  			}  			case 3: {  			  int i;  			  pos = luaL_checkint(L' 2);  /* 2nd argument is the position */  			  if (pos > e) e = pos;  /* `grow' array if necessary */  			  for (i = e; i > pos; i--) {  /* move up elements */  				lua_rawgeti(L' 1' i-1);  				lua_rawseti(L' 1' i);  /* t[i] = t[i-1] */  			  }  			  break;  			}  			default: {  			  return luaL_error(L' "wrong number of arguments to " + LUA_QL("insert"));  			}  		  }
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,tremove,The following statement contains a magic number: int pos = luaL_optint(L' 2' e);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,tconcat,The following statement contains a magic number: CharPtr sep = luaL_optlstring(L' 2' ""' out lsep);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,tconcat,The following statement contains a magic number: i = luaL_optint(L' 3' 1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,tconcat,The following statement contains a magic number: last = luaL_opt_integer(L' luaL_checkint' 4' luaL_getn(L' 1));
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,sort_comp,The following statement contains a magic number: lua_pushvalue(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,sort_comp,The following statement contains a magic number: lua_pushvalue(L' b-2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,sort_comp,The following statement contains a magic number: lua_call(L' 2' 1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,sort_comp,The following statement contains a magic number: !lua_isnil(L' 2)
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxsort_loop1,The following statement contains a magic number: return sort_comp(L' -1' -2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxsort_loop2,The following statement contains a magic number: return sort_comp(L' -3' -1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxsort,The following statement contains a magic number: sort_comp(L' -1' -2) != 0
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxsort,The following statement contains a magic number: i = (l+u)/2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxsort,The following statement contains a magic number: sort_comp(L' -2' -1) != 0
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxsort,The following statement contains a magic number: u-l == 2
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxsort,The following statement contains a magic number: lua_pop(L' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,auxsort,The following statement contains a magic number: l=i+2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,sort,The following statement contains a magic number: luaL_checkstack(L' 40' "");
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,sort,The following statement contains a magic number: luaL_checktype(L' 2' LUA_TFUNCTION);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,sort,The following statement contains a magic number: !lua_isnoneornil(L' 2)
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,sort,The following statement contains a magic number: lua_settop(L' 2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,isprint,The following statement contains a magic number: return (c >= (byte)' ') && (c <= (byte)127);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,frexp,The following statement contains a magic number: expptr = (int)Math.Log(x' 2) + 1;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,frexp,The following statement contains a magic number: double s = x / Math.Pow(2' expptr);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,ldexp,The following statement contains a magic number: return x * Math.Pow(2' expptr);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,GetUnmanagedSize,The following statement contains a magic number: return 228;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTMres,The following statement contains a magic number: setobj2s(L' L.top+2' p2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTMres,The following statement contains a magic number: luaD_checkstack(L' 3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTMres,The following statement contains a magic number: L.top += 3;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTMres,The following statement contains a magic number: luaD_call(L' L.top-3' 1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTM,The following statement contains a magic number: setobj2s(L' L.top + 2' p2);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTM,The following statement contains a magic number: setobj2s(L' L.top + 3' p3);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTM,The following statement contains a magic number: luaD_checkstack(L' 4);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTM,The following statement contains a magic number: L.top += 4;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,callTM,The following statement contains a magic number: luaD_call(L' L.top - 4' 0);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_concat,The following statement contains a magic number: int n = 2;
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_concat,The following statement contains a magic number: luaG_concaterror(L' top-2' top-1);
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_concat,The following statement contains a magic number: call_binTM(L' top-2' top-1' top-2' TMS.TM_CONCAT)==0
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_concat,The following statement contains a magic number: call_binTM(L' top-2' top-1' top-2' TMS.TM_CONCAT)==0
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_concat,The following statement contains a magic number: !(ttisstring(top-2) || ttisnumber(top-2)) || (tostring(L' top-1)==0)
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_concat,The following statement contains a magic number: !(ttisstring(top-2) || ttisnumber(top-2)) || (tostring(L' top-1)==0)
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,The following statement contains a magic number: switch (GET_OPCODE(i)) {  			  case OpCode.OP_MOVE: {  				setobjs2s(L' ra' RB(L' base_' i));  				continue;  			  }  			  case OpCode.OP_LOADK: {  				setobj2s(L' ra' KBx(L' i' k));  				continue;  			  }  			  case OpCode.OP_LOADBOOL: {  				setbvalue(ra' GETARG_B(i));  				if (GETARG_C(i) != 0) InstructionPtr.inc(ref pc);  /* skip next instruction (if C) */  				continue;  			  }  			  case OpCode.OP_LOADNIL: {  				TValue rb = RB(L' base_' i);  				do {  					setnilvalue(StkId.dec(ref rb));  				} while (rb >= ra);  				continue;  			  }  			  case OpCode.OP_GETUPVAL: {  				int b = GETARG_B(i);  				setobj2s(L' ra' cl.upvals[b].v);  				continue;  			  }  			  case OpCode.OP_GETGLOBAL: {  				TValue g = new TValue();  				TValue rb = KBx(L' i' k);  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(rb));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' g' rb' ra);  				  base_ = L.base_;  				  //);  				  L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_GETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' RB(L' base_' i)' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETGLOBAL: {  				TValue g = new TValue();  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(KBx(L' i' k)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' g' KBx(L' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETUPVAL: {  				UpVal uv = cl.upvals[GETARG_B(i)];  				setobj(L' uv.v' ra);  				luaC_barrier(L' uv' ra);  				continue;  			  }  			  case OpCode.OP_SETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' ra' RKB(L' base_' i' k)' RKC(L' base_' i' k));  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_NEWTABLE: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				sethvalue(L' ra' luaH_new(L' luaO_fb2int(b)' luaO_fb2int(c)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SELF: {  				StkId rb = RB(L' base_' i);  				setobjs2s(L' ra + 1' rb);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' rb' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_ADD: {  				arith_op(L' luai_numadd' TMS.TM_ADD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_SUB: {  				arith_op(L' luai_numsub' TMS.TM_SUB' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MUL: {  				arith_op(L' luai_nummul' TMS.TM_MUL' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_DIV: {  				arith_op(L' luai_numdiv' TMS.TM_DIV' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MOD: {  				arith_op(L' luai_nummod' TMS.TM_MOD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_POW: {  				arith_op(L' luai_numpow' TMS.TM_POW' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_UNM: {  				TValue rb = RB(L' base_' i);  				if (ttisnumber(rb)) {  				  lua_Number nb = nvalue(rb);  				  setnvalue(ra' luai_numunm(nb));  				}  				else {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					Arith(L' ra' rb' rb' TMS.TM_UNM);  					base_ = L.base_;  					//);  				  L.savedpc = InstructionPtr.Assign(pc);  				}  				continue;  			  }  			  case OpCode.OP_NOT: {  				int res = l_isfalse(RB(L' base_' i)) == 0 ? 0 : 1;  /* next assignment may change this value */  				setbvalue(ra' res);  				continue;  			  }  			  case OpCode.OP_LEN: {  				TValue rb = RB(L' base_' i);  				switch (ttype(rb)) {  				  case LUA_TTABLE: {  					setnvalue(ra' (lua_Number)luaH_getn(hvalue(rb)));  					break;  				  }  				  case LUA_TSTRING: {  					setnvalue(ra' (lua_Number)tsvalue(rb).len);  					break;  				  }  				  default: {  /* try metamethod */  					//Protect(  					  L.savedpc = InstructionPtr.Assign(pc);  					  if (call_binTM(L' rb' luaO_nilobject' ra' TMS.TM_LEN) == 0)  						luaG_typeerror(L' rb' "get length of");  					  base_ = L.base_;  					//)  					  break;  				  }  				}  				continue;  			  }  			  case OpCode.OP_CONCAT: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_concat(L' c-b+1' c); luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				setobjs2s(L' RA(L' base_' i)' base_ + b);  				continue;  			  }  			  case OpCode.OP_JMP: {  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_EQ: {  				TValue rb = RKB(L' base_' i' k);  				TValue rc = RKC(L' base_' i' k);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (equalobj(L' rb' rc) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LT: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (luaV_lessthan(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (lessequal(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TEST: {  				if (l_isfalse(ra) != GETARG_C(i))  				  dojump(L' pc' GETARG_sBx(pc[0]));  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TESTSET: {  				TValue rb = RB(L' base_' i);  				if (l_isfalse(rb) != GETARG_C(i)) {  				  setobjs2s(L' ra' rb);  				  dojump(L' pc' GETARG_sBx(pc[0]));  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_CALL: {  				int b = GETARG_B(i);  				int nresults = GETARG_C(i) - 1;  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				switch (luaD_precall(L' ra' nresults)) {  				  case PCRLUA: {  					nexeccalls++;  					goto reentry;  /* restart luaV_execute over new Lua function */  				  }  				  case PCRC: {  					/* it was a C function (`precall' called it); adjust results */  					if (nresults >= 0) L.top = L.ci.top;  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_TAILCALL: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);  				switch (luaD_precall(L' ra' LUA_MULTRET)) {  				  case PCRLUA: {  					/* tail call: put new frame in place of previous one */  					CallInfo ci = L.ci - 1;  /* previous frame */  					int aux;  					StkId func = ci.func;  					StkId pfunc = (ci+1).func;  /* previous function index */  					if (L.openupval != null) luaF_close(L' ci.base_);  					L.base_ = ci.base_ = ci.func + (ci[1].base_ - pfunc);  					for (aux = 0; pfunc+aux < L.top; aux++)  /* move frame down */  					  setobjs2s(L' func+aux' pfunc+aux);  					ci.top = L.top = func+aux;  /* correct top */  					lua_assert(L.top == L.base_ + clvalue(func).l.p.maxstacksize);  					ci.savedpc = InstructionPtr.Assign(L.savedpc);  					ci.tailcalls++;  /* one more call lost */  					CallInfo.dec(ref L.ci);  /* remove new frame */  					goto reentry;  				  }  				  case PCRC: {  /* it was a C function (`precall' called it) */  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_RETURN: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra+b-1;  				if (L.openupval != null) luaF_close(L' base_);  				L.savedpc = InstructionPtr.Assign(pc);  				b = luaD_poscall(L' ra);  				if (--nexeccalls == 0)  /* was previous function running `here'? */  				  return;  /* no: return */  				else {  /* yes: continue its execution */  				  if (b != 0) L.top = L.ci.top;  				  lua_assert(isLua(L.ci));  				  lua_assert(GET_OPCODE(L.ci.savedpc[-1]) == OpCode.OP_CALL);  				  goto reentry;  				}  			  }  			  case OpCode.OP_FORLOOP: {  				lua_Number step = nvalue(ra+2);  				lua_Number idx = luai_numadd(nvalue(ra)' step); /* increment index */  				lua_Number limit = nvalue(ra+1);  				if (luai_numlt(0' step) ? luai_numle(idx' limit)  										: luai_numle(limit' idx)) {  				  dojump(L' pc' GETARG_sBx(i));  /* jump back */  				  setnvalue(ra' idx);  /* update internal index... */  				  setnvalue(ra+3' idx);  /* ...and external index */  				}  				continue;  			  }  			  case OpCode.OP_FORPREP: {  				TValue init = ra;  				TValue plimit = ra+1;  				TValue pstep = ra+2;  				L.savedpc = InstructionPtr.Assign(pc);  /* next steps may throw errors */  				if (tonumber(ref init' ra) == 0)  				  luaG_runerror(L' LUA_QL("for") + " initial value must be a number");  				else if (tonumber(ref plimit' ra+1)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " limit must be a number");  				else if (tonumber(ref pstep' ra+2)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " step must be a number");  				setnvalue(ra' luai_numsub(nvalue(ra)' nvalue(pstep)));  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_TFORLOOP: {  				StkId cb = ra + 3;  /* call base */  				setobjs2s(L' cb+2' ra+2);  				setobjs2s(L' cb+1' ra+1);  				setobjs2s(L' cb' ra);  				L.top = cb+3;  /* func. + 2 args (state and index) */  				//Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					luaD_call(L' cb' GETARG_C(i));  					base_ = L.base_;  				  //);  				L.top = L.ci.top;  				cb = RA(L' base_' i) + 3;  /* previous call may change the stack */  				if (!ttisnil(cb)) {  /* continue loop? */  				  setobjs2s(L' cb-1' cb);  /* save control variable */  				  dojump(L' pc' GETARG_sBx(pc[0]));  /* jump back */  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_SETLIST: {  				int n = GETARG_B(i);  				int c = GETARG_C(i);  				int last;  				Table h;  				if (n == 0) {  				  n = cast_int(L.top - ra) - 1;  				  L.top = L.ci.top;  				}  				if (c == 0)  				{  					c = cast_int(pc[0]);  					InstructionPtr.inc(ref pc);  				}  				runtime_check(L' ttistable(ra));  				h = hvalue(ra);  				last = ((c-1)*LFIELDS_PER_FLUSH) + n;  				if (last > h.sizearray)  /* needs more space? */  				  luaH_resizearray(L' h' last);  /* pre-alloc it at once */  				for (; n > 0; n--) {  				  TValue val = ra+n;  				  setobj2t(L' luaH_setnum(L' h' last--)' val);  				  luaC_barriert(L' h' val);  				}  				continue;  			  }  			  case OpCode.OP_CLOSE: {  				luaF_close(L' ra);  				continue;  			  }  			  case OpCode.OP_CLOSURE: {  				Proto p;  				Closure ncl;  				int nup' j;  				p = cl.p.p[GETARG_Bx(i)];  				nup = p.nups;  				ncl = luaF_newLclosure(L' nup' cl.env);  				ncl.l.p = p;  				for (j=0; j<nup; j++' InstructionPtr.inc(ref pc)) {  				  if (GET_OPCODE(pc[0]) == OpCode.OP_GETUPVAL)  					ncl.l.upvals[j] = cl.upvals[GETARG_B(pc[0])];  				  else {  					lua_assert(GET_OPCODE(pc[0]) == OpCode.OP_MOVE);  					ncl.l.upvals[j] = luaF_findupval(L' base_ + GETARG_B(pc[0]));  				  }  				}  				setclvalue(L' ra' ncl);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  					luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				continue;  			  }  			  case OpCode.OP_VARARG: {  				int b = GETARG_B(i) - 1;  				int j;  				CallInfo ci = L.ci;  				int n = cast_int(ci.base_ - ci.func) - cl.p.numparams - 1;  				if (b == LUA_MULTRET) {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					  luaD_checkstack(L' n);  					base_ = L.base_;  					//);  				  ra = RA(L' base_' i);  /* previous call may change the stack */  				  b = n;  				  L.top = ra + n;  				}  				for (j = 0; j < b; j++) {  				  if (j < n) {  					setobjs2s(L' ra + j' ci.base_ - n + j);  				  }  				  else {  					setnilvalue(ra + j);  				  }  				}  				continue;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,The following statement contains a magic number: switch (GET_OPCODE(i)) {  			  case OpCode.OP_MOVE: {  				setobjs2s(L' ra' RB(L' base_' i));  				continue;  			  }  			  case OpCode.OP_LOADK: {  				setobj2s(L' ra' KBx(L' i' k));  				continue;  			  }  			  case OpCode.OP_LOADBOOL: {  				setbvalue(ra' GETARG_B(i));  				if (GETARG_C(i) != 0) InstructionPtr.inc(ref pc);  /* skip next instruction (if C) */  				continue;  			  }  			  case OpCode.OP_LOADNIL: {  				TValue rb = RB(L' base_' i);  				do {  					setnilvalue(StkId.dec(ref rb));  				} while (rb >= ra);  				continue;  			  }  			  case OpCode.OP_GETUPVAL: {  				int b = GETARG_B(i);  				setobj2s(L' ra' cl.upvals[b].v);  				continue;  			  }  			  case OpCode.OP_GETGLOBAL: {  				TValue g = new TValue();  				TValue rb = KBx(L' i' k);  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(rb));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' g' rb' ra);  				  base_ = L.base_;  				  //);  				  L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_GETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' RB(L' base_' i)' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETGLOBAL: {  				TValue g = new TValue();  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(KBx(L' i' k)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' g' KBx(L' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETUPVAL: {  				UpVal uv = cl.upvals[GETARG_B(i)];  				setobj(L' uv.v' ra);  				luaC_barrier(L' uv' ra);  				continue;  			  }  			  case OpCode.OP_SETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' ra' RKB(L' base_' i' k)' RKC(L' base_' i' k));  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_NEWTABLE: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				sethvalue(L' ra' luaH_new(L' luaO_fb2int(b)' luaO_fb2int(c)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SELF: {  				StkId rb = RB(L' base_' i);  				setobjs2s(L' ra + 1' rb);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' rb' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_ADD: {  				arith_op(L' luai_numadd' TMS.TM_ADD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_SUB: {  				arith_op(L' luai_numsub' TMS.TM_SUB' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MUL: {  				arith_op(L' luai_nummul' TMS.TM_MUL' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_DIV: {  				arith_op(L' luai_numdiv' TMS.TM_DIV' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MOD: {  				arith_op(L' luai_nummod' TMS.TM_MOD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_POW: {  				arith_op(L' luai_numpow' TMS.TM_POW' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_UNM: {  				TValue rb = RB(L' base_' i);  				if (ttisnumber(rb)) {  				  lua_Number nb = nvalue(rb);  				  setnvalue(ra' luai_numunm(nb));  				}  				else {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					Arith(L' ra' rb' rb' TMS.TM_UNM);  					base_ = L.base_;  					//);  				  L.savedpc = InstructionPtr.Assign(pc);  				}  				continue;  			  }  			  case OpCode.OP_NOT: {  				int res = l_isfalse(RB(L' base_' i)) == 0 ? 0 : 1;  /* next assignment may change this value */  				setbvalue(ra' res);  				continue;  			  }  			  case OpCode.OP_LEN: {  				TValue rb = RB(L' base_' i);  				switch (ttype(rb)) {  				  case LUA_TTABLE: {  					setnvalue(ra' (lua_Number)luaH_getn(hvalue(rb)));  					break;  				  }  				  case LUA_TSTRING: {  					setnvalue(ra' (lua_Number)tsvalue(rb).len);  					break;  				  }  				  default: {  /* try metamethod */  					//Protect(  					  L.savedpc = InstructionPtr.Assign(pc);  					  if (call_binTM(L' rb' luaO_nilobject' ra' TMS.TM_LEN) == 0)  						luaG_typeerror(L' rb' "get length of");  					  base_ = L.base_;  					//)  					  break;  				  }  				}  				continue;  			  }  			  case OpCode.OP_CONCAT: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_concat(L' c-b+1' c); luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				setobjs2s(L' RA(L' base_' i)' base_ + b);  				continue;  			  }  			  case OpCode.OP_JMP: {  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_EQ: {  				TValue rb = RKB(L' base_' i' k);  				TValue rc = RKC(L' base_' i' k);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (equalobj(L' rb' rc) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LT: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (luaV_lessthan(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (lessequal(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TEST: {  				if (l_isfalse(ra) != GETARG_C(i))  				  dojump(L' pc' GETARG_sBx(pc[0]));  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TESTSET: {  				TValue rb = RB(L' base_' i);  				if (l_isfalse(rb) != GETARG_C(i)) {  				  setobjs2s(L' ra' rb);  				  dojump(L' pc' GETARG_sBx(pc[0]));  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_CALL: {  				int b = GETARG_B(i);  				int nresults = GETARG_C(i) - 1;  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				switch (luaD_precall(L' ra' nresults)) {  				  case PCRLUA: {  					nexeccalls++;  					goto reentry;  /* restart luaV_execute over new Lua function */  				  }  				  case PCRC: {  					/* it was a C function (`precall' called it); adjust results */  					if (nresults >= 0) L.top = L.ci.top;  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_TAILCALL: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);  				switch (luaD_precall(L' ra' LUA_MULTRET)) {  				  case PCRLUA: {  					/* tail call: put new frame in place of previous one */  					CallInfo ci = L.ci - 1;  /* previous frame */  					int aux;  					StkId func = ci.func;  					StkId pfunc = (ci+1).func;  /* previous function index */  					if (L.openupval != null) luaF_close(L' ci.base_);  					L.base_ = ci.base_ = ci.func + (ci[1].base_ - pfunc);  					for (aux = 0; pfunc+aux < L.top; aux++)  /* move frame down */  					  setobjs2s(L' func+aux' pfunc+aux);  					ci.top = L.top = func+aux;  /* correct top */  					lua_assert(L.top == L.base_ + clvalue(func).l.p.maxstacksize);  					ci.savedpc = InstructionPtr.Assign(L.savedpc);  					ci.tailcalls++;  /* one more call lost */  					CallInfo.dec(ref L.ci);  /* remove new frame */  					goto reentry;  				  }  				  case PCRC: {  /* it was a C function (`precall' called it) */  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_RETURN: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra+b-1;  				if (L.openupval != null) luaF_close(L' base_);  				L.savedpc = InstructionPtr.Assign(pc);  				b = luaD_poscall(L' ra);  				if (--nexeccalls == 0)  /* was previous function running `here'? */  				  return;  /* no: return */  				else {  /* yes: continue its execution */  				  if (b != 0) L.top = L.ci.top;  				  lua_assert(isLua(L.ci));  				  lua_assert(GET_OPCODE(L.ci.savedpc[-1]) == OpCode.OP_CALL);  				  goto reentry;  				}  			  }  			  case OpCode.OP_FORLOOP: {  				lua_Number step = nvalue(ra+2);  				lua_Number idx = luai_numadd(nvalue(ra)' step); /* increment index */  				lua_Number limit = nvalue(ra+1);  				if (luai_numlt(0' step) ? luai_numle(idx' limit)  										: luai_numle(limit' idx)) {  				  dojump(L' pc' GETARG_sBx(i));  /* jump back */  				  setnvalue(ra' idx);  /* update internal index... */  				  setnvalue(ra+3' idx);  /* ...and external index */  				}  				continue;  			  }  			  case OpCode.OP_FORPREP: {  				TValue init = ra;  				TValue plimit = ra+1;  				TValue pstep = ra+2;  				L.savedpc = InstructionPtr.Assign(pc);  /* next steps may throw errors */  				if (tonumber(ref init' ra) == 0)  				  luaG_runerror(L' LUA_QL("for") + " initial value must be a number");  				else if (tonumber(ref plimit' ra+1)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " limit must be a number");  				else if (tonumber(ref pstep' ra+2)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " step must be a number");  				setnvalue(ra' luai_numsub(nvalue(ra)' nvalue(pstep)));  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_TFORLOOP: {  				StkId cb = ra + 3;  /* call base */  				setobjs2s(L' cb+2' ra+2);  				setobjs2s(L' cb+1' ra+1);  				setobjs2s(L' cb' ra);  				L.top = cb+3;  /* func. + 2 args (state and index) */  				//Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					luaD_call(L' cb' GETARG_C(i));  					base_ = L.base_;  				  //);  				L.top = L.ci.top;  				cb = RA(L' base_' i) + 3;  /* previous call may change the stack */  				if (!ttisnil(cb)) {  /* continue loop? */  				  setobjs2s(L' cb-1' cb);  /* save control variable */  				  dojump(L' pc' GETARG_sBx(pc[0]));  /* jump back */  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_SETLIST: {  				int n = GETARG_B(i);  				int c = GETARG_C(i);  				int last;  				Table h;  				if (n == 0) {  				  n = cast_int(L.top - ra) - 1;  				  L.top = L.ci.top;  				}  				if (c == 0)  				{  					c = cast_int(pc[0]);  					InstructionPtr.inc(ref pc);  				}  				runtime_check(L' ttistable(ra));  				h = hvalue(ra);  				last = ((c-1)*LFIELDS_PER_FLUSH) + n;  				if (last > h.sizearray)  /* needs more space? */  				  luaH_resizearray(L' h' last);  /* pre-alloc it at once */  				for (; n > 0; n--) {  				  TValue val = ra+n;  				  setobj2t(L' luaH_setnum(L' h' last--)' val);  				  luaC_barriert(L' h' val);  				}  				continue;  			  }  			  case OpCode.OP_CLOSE: {  				luaF_close(L' ra);  				continue;  			  }  			  case OpCode.OP_CLOSURE: {  				Proto p;  				Closure ncl;  				int nup' j;  				p = cl.p.p[GETARG_Bx(i)];  				nup = p.nups;  				ncl = luaF_newLclosure(L' nup' cl.env);  				ncl.l.p = p;  				for (j=0; j<nup; j++' InstructionPtr.inc(ref pc)) {  				  if (GET_OPCODE(pc[0]) == OpCode.OP_GETUPVAL)  					ncl.l.upvals[j] = cl.upvals[GETARG_B(pc[0])];  				  else {  					lua_assert(GET_OPCODE(pc[0]) == OpCode.OP_MOVE);  					ncl.l.upvals[j] = luaF_findupval(L' base_ + GETARG_B(pc[0]));  				  }  				}  				setclvalue(L' ra' ncl);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  					luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				continue;  			  }  			  case OpCode.OP_VARARG: {  				int b = GETARG_B(i) - 1;  				int j;  				CallInfo ci = L.ci;  				int n = cast_int(ci.base_ - ci.func) - cl.p.numparams - 1;  				if (b == LUA_MULTRET) {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					  luaD_checkstack(L' n);  					base_ = L.base_;  					//);  				  ra = RA(L' base_' i);  /* previous call may change the stack */  				  b = n;  				  L.top = ra + n;  				}  				for (j = 0; j < b; j++) {  				  if (j < n) {  					setobjs2s(L' ra + j' ci.base_ - n + j);  				  }  				  else {  					setnilvalue(ra + j);  				  }  				}  				continue;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,The following statement contains a magic number: switch (GET_OPCODE(i)) {  			  case OpCode.OP_MOVE: {  				setobjs2s(L' ra' RB(L' base_' i));  				continue;  			  }  			  case OpCode.OP_LOADK: {  				setobj2s(L' ra' KBx(L' i' k));  				continue;  			  }  			  case OpCode.OP_LOADBOOL: {  				setbvalue(ra' GETARG_B(i));  				if (GETARG_C(i) != 0) InstructionPtr.inc(ref pc);  /* skip next instruction (if C) */  				continue;  			  }  			  case OpCode.OP_LOADNIL: {  				TValue rb = RB(L' base_' i);  				do {  					setnilvalue(StkId.dec(ref rb));  				} while (rb >= ra);  				continue;  			  }  			  case OpCode.OP_GETUPVAL: {  				int b = GETARG_B(i);  				setobj2s(L' ra' cl.upvals[b].v);  				continue;  			  }  			  case OpCode.OP_GETGLOBAL: {  				TValue g = new TValue();  				TValue rb = KBx(L' i' k);  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(rb));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' g' rb' ra);  				  base_ = L.base_;  				  //);  				  L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_GETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' RB(L' base_' i)' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETGLOBAL: {  				TValue g = new TValue();  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(KBx(L' i' k)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' g' KBx(L' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETUPVAL: {  				UpVal uv = cl.upvals[GETARG_B(i)];  				setobj(L' uv.v' ra);  				luaC_barrier(L' uv' ra);  				continue;  			  }  			  case OpCode.OP_SETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' ra' RKB(L' base_' i' k)' RKC(L' base_' i' k));  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_NEWTABLE: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				sethvalue(L' ra' luaH_new(L' luaO_fb2int(b)' luaO_fb2int(c)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SELF: {  				StkId rb = RB(L' base_' i);  				setobjs2s(L' ra + 1' rb);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' rb' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_ADD: {  				arith_op(L' luai_numadd' TMS.TM_ADD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_SUB: {  				arith_op(L' luai_numsub' TMS.TM_SUB' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MUL: {  				arith_op(L' luai_nummul' TMS.TM_MUL' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_DIV: {  				arith_op(L' luai_numdiv' TMS.TM_DIV' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MOD: {  				arith_op(L' luai_nummod' TMS.TM_MOD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_POW: {  				arith_op(L' luai_numpow' TMS.TM_POW' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_UNM: {  				TValue rb = RB(L' base_' i);  				if (ttisnumber(rb)) {  				  lua_Number nb = nvalue(rb);  				  setnvalue(ra' luai_numunm(nb));  				}  				else {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					Arith(L' ra' rb' rb' TMS.TM_UNM);  					base_ = L.base_;  					//);  				  L.savedpc = InstructionPtr.Assign(pc);  				}  				continue;  			  }  			  case OpCode.OP_NOT: {  				int res = l_isfalse(RB(L' base_' i)) == 0 ? 0 : 1;  /* next assignment may change this value */  				setbvalue(ra' res);  				continue;  			  }  			  case OpCode.OP_LEN: {  				TValue rb = RB(L' base_' i);  				switch (ttype(rb)) {  				  case LUA_TTABLE: {  					setnvalue(ra' (lua_Number)luaH_getn(hvalue(rb)));  					break;  				  }  				  case LUA_TSTRING: {  					setnvalue(ra' (lua_Number)tsvalue(rb).len);  					break;  				  }  				  default: {  /* try metamethod */  					//Protect(  					  L.savedpc = InstructionPtr.Assign(pc);  					  if (call_binTM(L' rb' luaO_nilobject' ra' TMS.TM_LEN) == 0)  						luaG_typeerror(L' rb' "get length of");  					  base_ = L.base_;  					//)  					  break;  				  }  				}  				continue;  			  }  			  case OpCode.OP_CONCAT: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_concat(L' c-b+1' c); luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				setobjs2s(L' RA(L' base_' i)' base_ + b);  				continue;  			  }  			  case OpCode.OP_JMP: {  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_EQ: {  				TValue rb = RKB(L' base_' i' k);  				TValue rc = RKC(L' base_' i' k);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (equalobj(L' rb' rc) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LT: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (luaV_lessthan(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (lessequal(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TEST: {  				if (l_isfalse(ra) != GETARG_C(i))  				  dojump(L' pc' GETARG_sBx(pc[0]));  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TESTSET: {  				TValue rb = RB(L' base_' i);  				if (l_isfalse(rb) != GETARG_C(i)) {  				  setobjs2s(L' ra' rb);  				  dojump(L' pc' GETARG_sBx(pc[0]));  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_CALL: {  				int b = GETARG_B(i);  				int nresults = GETARG_C(i) - 1;  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				switch (luaD_precall(L' ra' nresults)) {  				  case PCRLUA: {  					nexeccalls++;  					goto reentry;  /* restart luaV_execute over new Lua function */  				  }  				  case PCRC: {  					/* it was a C function (`precall' called it); adjust results */  					if (nresults >= 0) L.top = L.ci.top;  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_TAILCALL: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);  				switch (luaD_precall(L' ra' LUA_MULTRET)) {  				  case PCRLUA: {  					/* tail call: put new frame in place of previous one */  					CallInfo ci = L.ci - 1;  /* previous frame */  					int aux;  					StkId func = ci.func;  					StkId pfunc = (ci+1).func;  /* previous function index */  					if (L.openupval != null) luaF_close(L' ci.base_);  					L.base_ = ci.base_ = ci.func + (ci[1].base_ - pfunc);  					for (aux = 0; pfunc+aux < L.top; aux++)  /* move frame down */  					  setobjs2s(L' func+aux' pfunc+aux);  					ci.top = L.top = func+aux;  /* correct top */  					lua_assert(L.top == L.base_ + clvalue(func).l.p.maxstacksize);  					ci.savedpc = InstructionPtr.Assign(L.savedpc);  					ci.tailcalls++;  /* one more call lost */  					CallInfo.dec(ref L.ci);  /* remove new frame */  					goto reentry;  				  }  				  case PCRC: {  /* it was a C function (`precall' called it) */  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_RETURN: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra+b-1;  				if (L.openupval != null) luaF_close(L' base_);  				L.savedpc = InstructionPtr.Assign(pc);  				b = luaD_poscall(L' ra);  				if (--nexeccalls == 0)  /* was previous function running `here'? */  				  return;  /* no: return */  				else {  /* yes: continue its execution */  				  if (b != 0) L.top = L.ci.top;  				  lua_assert(isLua(L.ci));  				  lua_assert(GET_OPCODE(L.ci.savedpc[-1]) == OpCode.OP_CALL);  				  goto reentry;  				}  			  }  			  case OpCode.OP_FORLOOP: {  				lua_Number step = nvalue(ra+2);  				lua_Number idx = luai_numadd(nvalue(ra)' step); /* increment index */  				lua_Number limit = nvalue(ra+1);  				if (luai_numlt(0' step) ? luai_numle(idx' limit)  										: luai_numle(limit' idx)) {  				  dojump(L' pc' GETARG_sBx(i));  /* jump back */  				  setnvalue(ra' idx);  /* update internal index... */  				  setnvalue(ra+3' idx);  /* ...and external index */  				}  				continue;  			  }  			  case OpCode.OP_FORPREP: {  				TValue init = ra;  				TValue plimit = ra+1;  				TValue pstep = ra+2;  				L.savedpc = InstructionPtr.Assign(pc);  /* next steps may throw errors */  				if (tonumber(ref init' ra) == 0)  				  luaG_runerror(L' LUA_QL("for") + " initial value must be a number");  				else if (tonumber(ref plimit' ra+1)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " limit must be a number");  				else if (tonumber(ref pstep' ra+2)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " step must be a number");  				setnvalue(ra' luai_numsub(nvalue(ra)' nvalue(pstep)));  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_TFORLOOP: {  				StkId cb = ra + 3;  /* call base */  				setobjs2s(L' cb+2' ra+2);  				setobjs2s(L' cb+1' ra+1);  				setobjs2s(L' cb' ra);  				L.top = cb+3;  /* func. + 2 args (state and index) */  				//Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					luaD_call(L' cb' GETARG_C(i));  					base_ = L.base_;  				  //);  				L.top = L.ci.top;  				cb = RA(L' base_' i) + 3;  /* previous call may change the stack */  				if (!ttisnil(cb)) {  /* continue loop? */  				  setobjs2s(L' cb-1' cb);  /* save control variable */  				  dojump(L' pc' GETARG_sBx(pc[0]));  /* jump back */  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_SETLIST: {  				int n = GETARG_B(i);  				int c = GETARG_C(i);  				int last;  				Table h;  				if (n == 0) {  				  n = cast_int(L.top - ra) - 1;  				  L.top = L.ci.top;  				}  				if (c == 0)  				{  					c = cast_int(pc[0]);  					InstructionPtr.inc(ref pc);  				}  				runtime_check(L' ttistable(ra));  				h = hvalue(ra);  				last = ((c-1)*LFIELDS_PER_FLUSH) + n;  				if (last > h.sizearray)  /* needs more space? */  				  luaH_resizearray(L' h' last);  /* pre-alloc it at once */  				for (; n > 0; n--) {  				  TValue val = ra+n;  				  setobj2t(L' luaH_setnum(L' h' last--)' val);  				  luaC_barriert(L' h' val);  				}  				continue;  			  }  			  case OpCode.OP_CLOSE: {  				luaF_close(L' ra);  				continue;  			  }  			  case OpCode.OP_CLOSURE: {  				Proto p;  				Closure ncl;  				int nup' j;  				p = cl.p.p[GETARG_Bx(i)];  				nup = p.nups;  				ncl = luaF_newLclosure(L' nup' cl.env);  				ncl.l.p = p;  				for (j=0; j<nup; j++' InstructionPtr.inc(ref pc)) {  				  if (GET_OPCODE(pc[0]) == OpCode.OP_GETUPVAL)  					ncl.l.upvals[j] = cl.upvals[GETARG_B(pc[0])];  				  else {  					lua_assert(GET_OPCODE(pc[0]) == OpCode.OP_MOVE);  					ncl.l.upvals[j] = luaF_findupval(L' base_ + GETARG_B(pc[0]));  				  }  				}  				setclvalue(L' ra' ncl);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  					luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				continue;  			  }  			  case OpCode.OP_VARARG: {  				int b = GETARG_B(i) - 1;  				int j;  				CallInfo ci = L.ci;  				int n = cast_int(ci.base_ - ci.func) - cl.p.numparams - 1;  				if (b == LUA_MULTRET) {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					  luaD_checkstack(L' n);  					base_ = L.base_;  					//);  				  ra = RA(L' base_' i);  /* previous call may change the stack */  				  b = n;  				  L.top = ra + n;  				}  				for (j = 0; j < b; j++) {  				  if (j < n) {  					setobjs2s(L' ra + j' ci.base_ - n + j);  				  }  				  else {  					setnilvalue(ra + j);  				  }  				}  				continue;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,The following statement contains a magic number: switch (GET_OPCODE(i)) {  			  case OpCode.OP_MOVE: {  				setobjs2s(L' ra' RB(L' base_' i));  				continue;  			  }  			  case OpCode.OP_LOADK: {  				setobj2s(L' ra' KBx(L' i' k));  				continue;  			  }  			  case OpCode.OP_LOADBOOL: {  				setbvalue(ra' GETARG_B(i));  				if (GETARG_C(i) != 0) InstructionPtr.inc(ref pc);  /* skip next instruction (if C) */  				continue;  			  }  			  case OpCode.OP_LOADNIL: {  				TValue rb = RB(L' base_' i);  				do {  					setnilvalue(StkId.dec(ref rb));  				} while (rb >= ra);  				continue;  			  }  			  case OpCode.OP_GETUPVAL: {  				int b = GETARG_B(i);  				setobj2s(L' ra' cl.upvals[b].v);  				continue;  			  }  			  case OpCode.OP_GETGLOBAL: {  				TValue g = new TValue();  				TValue rb = KBx(L' i' k);  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(rb));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' g' rb' ra);  				  base_ = L.base_;  				  //);  				  L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_GETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' RB(L' base_' i)' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETGLOBAL: {  				TValue g = new TValue();  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(KBx(L' i' k)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' g' KBx(L' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETUPVAL: {  				UpVal uv = cl.upvals[GETARG_B(i)];  				setobj(L' uv.v' ra);  				luaC_barrier(L' uv' ra);  				continue;  			  }  			  case OpCode.OP_SETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' ra' RKB(L' base_' i' k)' RKC(L' base_' i' k));  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_NEWTABLE: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				sethvalue(L' ra' luaH_new(L' luaO_fb2int(b)' luaO_fb2int(c)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SELF: {  				StkId rb = RB(L' base_' i);  				setobjs2s(L' ra + 1' rb);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' rb' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_ADD: {  				arith_op(L' luai_numadd' TMS.TM_ADD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_SUB: {  				arith_op(L' luai_numsub' TMS.TM_SUB' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MUL: {  				arith_op(L' luai_nummul' TMS.TM_MUL' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_DIV: {  				arith_op(L' luai_numdiv' TMS.TM_DIV' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MOD: {  				arith_op(L' luai_nummod' TMS.TM_MOD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_POW: {  				arith_op(L' luai_numpow' TMS.TM_POW' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_UNM: {  				TValue rb = RB(L' base_' i);  				if (ttisnumber(rb)) {  				  lua_Number nb = nvalue(rb);  				  setnvalue(ra' luai_numunm(nb));  				}  				else {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					Arith(L' ra' rb' rb' TMS.TM_UNM);  					base_ = L.base_;  					//);  				  L.savedpc = InstructionPtr.Assign(pc);  				}  				continue;  			  }  			  case OpCode.OP_NOT: {  				int res = l_isfalse(RB(L' base_' i)) == 0 ? 0 : 1;  /* next assignment may change this value */  				setbvalue(ra' res);  				continue;  			  }  			  case OpCode.OP_LEN: {  				TValue rb = RB(L' base_' i);  				switch (ttype(rb)) {  				  case LUA_TTABLE: {  					setnvalue(ra' (lua_Number)luaH_getn(hvalue(rb)));  					break;  				  }  				  case LUA_TSTRING: {  					setnvalue(ra' (lua_Number)tsvalue(rb).len);  					break;  				  }  				  default: {  /* try metamethod */  					//Protect(  					  L.savedpc = InstructionPtr.Assign(pc);  					  if (call_binTM(L' rb' luaO_nilobject' ra' TMS.TM_LEN) == 0)  						luaG_typeerror(L' rb' "get length of");  					  base_ = L.base_;  					//)  					  break;  				  }  				}  				continue;  			  }  			  case OpCode.OP_CONCAT: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_concat(L' c-b+1' c); luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				setobjs2s(L' RA(L' base_' i)' base_ + b);  				continue;  			  }  			  case OpCode.OP_JMP: {  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_EQ: {  				TValue rb = RKB(L' base_' i' k);  				TValue rc = RKC(L' base_' i' k);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (equalobj(L' rb' rc) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LT: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (luaV_lessthan(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (lessequal(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TEST: {  				if (l_isfalse(ra) != GETARG_C(i))  				  dojump(L' pc' GETARG_sBx(pc[0]));  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TESTSET: {  				TValue rb = RB(L' base_' i);  				if (l_isfalse(rb) != GETARG_C(i)) {  				  setobjs2s(L' ra' rb);  				  dojump(L' pc' GETARG_sBx(pc[0]));  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_CALL: {  				int b = GETARG_B(i);  				int nresults = GETARG_C(i) - 1;  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				switch (luaD_precall(L' ra' nresults)) {  				  case PCRLUA: {  					nexeccalls++;  					goto reentry;  /* restart luaV_execute over new Lua function */  				  }  				  case PCRC: {  					/* it was a C function (`precall' called it); adjust results */  					if (nresults >= 0) L.top = L.ci.top;  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_TAILCALL: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);  				switch (luaD_precall(L' ra' LUA_MULTRET)) {  				  case PCRLUA: {  					/* tail call: put new frame in place of previous one */  					CallInfo ci = L.ci - 1;  /* previous frame */  					int aux;  					StkId func = ci.func;  					StkId pfunc = (ci+1).func;  /* previous function index */  					if (L.openupval != null) luaF_close(L' ci.base_);  					L.base_ = ci.base_ = ci.func + (ci[1].base_ - pfunc);  					for (aux = 0; pfunc+aux < L.top; aux++)  /* move frame down */  					  setobjs2s(L' func+aux' pfunc+aux);  					ci.top = L.top = func+aux;  /* correct top */  					lua_assert(L.top == L.base_ + clvalue(func).l.p.maxstacksize);  					ci.savedpc = InstructionPtr.Assign(L.savedpc);  					ci.tailcalls++;  /* one more call lost */  					CallInfo.dec(ref L.ci);  /* remove new frame */  					goto reentry;  				  }  				  case PCRC: {  /* it was a C function (`precall' called it) */  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_RETURN: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra+b-1;  				if (L.openupval != null) luaF_close(L' base_);  				L.savedpc = InstructionPtr.Assign(pc);  				b = luaD_poscall(L' ra);  				if (--nexeccalls == 0)  /* was previous function running `here'? */  				  return;  /* no: return */  				else {  /* yes: continue its execution */  				  if (b != 0) L.top = L.ci.top;  				  lua_assert(isLua(L.ci));  				  lua_assert(GET_OPCODE(L.ci.savedpc[-1]) == OpCode.OP_CALL);  				  goto reentry;  				}  			  }  			  case OpCode.OP_FORLOOP: {  				lua_Number step = nvalue(ra+2);  				lua_Number idx = luai_numadd(nvalue(ra)' step); /* increment index */  				lua_Number limit = nvalue(ra+1);  				if (luai_numlt(0' step) ? luai_numle(idx' limit)  										: luai_numle(limit' idx)) {  				  dojump(L' pc' GETARG_sBx(i));  /* jump back */  				  setnvalue(ra' idx);  /* update internal index... */  				  setnvalue(ra+3' idx);  /* ...and external index */  				}  				continue;  			  }  			  case OpCode.OP_FORPREP: {  				TValue init = ra;  				TValue plimit = ra+1;  				TValue pstep = ra+2;  				L.savedpc = InstructionPtr.Assign(pc);  /* next steps may throw errors */  				if (tonumber(ref init' ra) == 0)  				  luaG_runerror(L' LUA_QL("for") + " initial value must be a number");  				else if (tonumber(ref plimit' ra+1)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " limit must be a number");  				else if (tonumber(ref pstep' ra+2)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " step must be a number");  				setnvalue(ra' luai_numsub(nvalue(ra)' nvalue(pstep)));  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_TFORLOOP: {  				StkId cb = ra + 3;  /* call base */  				setobjs2s(L' cb+2' ra+2);  				setobjs2s(L' cb+1' ra+1);  				setobjs2s(L' cb' ra);  				L.top = cb+3;  /* func. + 2 args (state and index) */  				//Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					luaD_call(L' cb' GETARG_C(i));  					base_ = L.base_;  				  //);  				L.top = L.ci.top;  				cb = RA(L' base_' i) + 3;  /* previous call may change the stack */  				if (!ttisnil(cb)) {  /* continue loop? */  				  setobjs2s(L' cb-1' cb);  /* save control variable */  				  dojump(L' pc' GETARG_sBx(pc[0]));  /* jump back */  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_SETLIST: {  				int n = GETARG_B(i);  				int c = GETARG_C(i);  				int last;  				Table h;  				if (n == 0) {  				  n = cast_int(L.top - ra) - 1;  				  L.top = L.ci.top;  				}  				if (c == 0)  				{  					c = cast_int(pc[0]);  					InstructionPtr.inc(ref pc);  				}  				runtime_check(L' ttistable(ra));  				h = hvalue(ra);  				last = ((c-1)*LFIELDS_PER_FLUSH) + n;  				if (last > h.sizearray)  /* needs more space? */  				  luaH_resizearray(L' h' last);  /* pre-alloc it at once */  				for (; n > 0; n--) {  				  TValue val = ra+n;  				  setobj2t(L' luaH_setnum(L' h' last--)' val);  				  luaC_barriert(L' h' val);  				}  				continue;  			  }  			  case OpCode.OP_CLOSE: {  				luaF_close(L' ra);  				continue;  			  }  			  case OpCode.OP_CLOSURE: {  				Proto p;  				Closure ncl;  				int nup' j;  				p = cl.p.p[GETARG_Bx(i)];  				nup = p.nups;  				ncl = luaF_newLclosure(L' nup' cl.env);  				ncl.l.p = p;  				for (j=0; j<nup; j++' InstructionPtr.inc(ref pc)) {  				  if (GET_OPCODE(pc[0]) == OpCode.OP_GETUPVAL)  					ncl.l.upvals[j] = cl.upvals[GETARG_B(pc[0])];  				  else {  					lua_assert(GET_OPCODE(pc[0]) == OpCode.OP_MOVE);  					ncl.l.upvals[j] = luaF_findupval(L' base_ + GETARG_B(pc[0]));  				  }  				}  				setclvalue(L' ra' ncl);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  					luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				continue;  			  }  			  case OpCode.OP_VARARG: {  				int b = GETARG_B(i) - 1;  				int j;  				CallInfo ci = L.ci;  				int n = cast_int(ci.base_ - ci.func) - cl.p.numparams - 1;  				if (b == LUA_MULTRET) {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					  luaD_checkstack(L' n);  					base_ = L.base_;  					//);  				  ra = RA(L' base_' i);  /* previous call may change the stack */  				  b = n;  				  L.top = ra + n;  				}  				for (j = 0; j < b; j++) {  				  if (j < n) {  					setobjs2s(L' ra + j' ci.base_ - n + j);  				  }  				  else {  					setnilvalue(ra + j);  				  }  				}  				continue;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,The following statement contains a magic number: switch (GET_OPCODE(i)) {  			  case OpCode.OP_MOVE: {  				setobjs2s(L' ra' RB(L' base_' i));  				continue;  			  }  			  case OpCode.OP_LOADK: {  				setobj2s(L' ra' KBx(L' i' k));  				continue;  			  }  			  case OpCode.OP_LOADBOOL: {  				setbvalue(ra' GETARG_B(i));  				if (GETARG_C(i) != 0) InstructionPtr.inc(ref pc);  /* skip next instruction (if C) */  				continue;  			  }  			  case OpCode.OP_LOADNIL: {  				TValue rb = RB(L' base_' i);  				do {  					setnilvalue(StkId.dec(ref rb));  				} while (rb >= ra);  				continue;  			  }  			  case OpCode.OP_GETUPVAL: {  				int b = GETARG_B(i);  				setobj2s(L' ra' cl.upvals[b].v);  				continue;  			  }  			  case OpCode.OP_GETGLOBAL: {  				TValue g = new TValue();  				TValue rb = KBx(L' i' k);  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(rb));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' g' rb' ra);  				  base_ = L.base_;  				  //);  				  L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_GETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' RB(L' base_' i)' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETGLOBAL: {  				TValue g = new TValue();  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(KBx(L' i' k)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' g' KBx(L' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETUPVAL: {  				UpVal uv = cl.upvals[GETARG_B(i)];  				setobj(L' uv.v' ra);  				luaC_barrier(L' uv' ra);  				continue;  			  }  			  case OpCode.OP_SETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' ra' RKB(L' base_' i' k)' RKC(L' base_' i' k));  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_NEWTABLE: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				sethvalue(L' ra' luaH_new(L' luaO_fb2int(b)' luaO_fb2int(c)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SELF: {  				StkId rb = RB(L' base_' i);  				setobjs2s(L' ra + 1' rb);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' rb' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_ADD: {  				arith_op(L' luai_numadd' TMS.TM_ADD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_SUB: {  				arith_op(L' luai_numsub' TMS.TM_SUB' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MUL: {  				arith_op(L' luai_nummul' TMS.TM_MUL' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_DIV: {  				arith_op(L' luai_numdiv' TMS.TM_DIV' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MOD: {  				arith_op(L' luai_nummod' TMS.TM_MOD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_POW: {  				arith_op(L' luai_numpow' TMS.TM_POW' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_UNM: {  				TValue rb = RB(L' base_' i);  				if (ttisnumber(rb)) {  				  lua_Number nb = nvalue(rb);  				  setnvalue(ra' luai_numunm(nb));  				}  				else {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					Arith(L' ra' rb' rb' TMS.TM_UNM);  					base_ = L.base_;  					//);  				  L.savedpc = InstructionPtr.Assign(pc);  				}  				continue;  			  }  			  case OpCode.OP_NOT: {  				int res = l_isfalse(RB(L' base_' i)) == 0 ? 0 : 1;  /* next assignment may change this value */  				setbvalue(ra' res);  				continue;  			  }  			  case OpCode.OP_LEN: {  				TValue rb = RB(L' base_' i);  				switch (ttype(rb)) {  				  case LUA_TTABLE: {  					setnvalue(ra' (lua_Number)luaH_getn(hvalue(rb)));  					break;  				  }  				  case LUA_TSTRING: {  					setnvalue(ra' (lua_Number)tsvalue(rb).len);  					break;  				  }  				  default: {  /* try metamethod */  					//Protect(  					  L.savedpc = InstructionPtr.Assign(pc);  					  if (call_binTM(L' rb' luaO_nilobject' ra' TMS.TM_LEN) == 0)  						luaG_typeerror(L' rb' "get length of");  					  base_ = L.base_;  					//)  					  break;  				  }  				}  				continue;  			  }  			  case OpCode.OP_CONCAT: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_concat(L' c-b+1' c); luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				setobjs2s(L' RA(L' base_' i)' base_ + b);  				continue;  			  }  			  case OpCode.OP_JMP: {  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_EQ: {  				TValue rb = RKB(L' base_' i' k);  				TValue rc = RKC(L' base_' i' k);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (equalobj(L' rb' rc) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LT: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (luaV_lessthan(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (lessequal(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TEST: {  				if (l_isfalse(ra) != GETARG_C(i))  				  dojump(L' pc' GETARG_sBx(pc[0]));  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TESTSET: {  				TValue rb = RB(L' base_' i);  				if (l_isfalse(rb) != GETARG_C(i)) {  				  setobjs2s(L' ra' rb);  				  dojump(L' pc' GETARG_sBx(pc[0]));  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_CALL: {  				int b = GETARG_B(i);  				int nresults = GETARG_C(i) - 1;  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				switch (luaD_precall(L' ra' nresults)) {  				  case PCRLUA: {  					nexeccalls++;  					goto reentry;  /* restart luaV_execute over new Lua function */  				  }  				  case PCRC: {  					/* it was a C function (`precall' called it); adjust results */  					if (nresults >= 0) L.top = L.ci.top;  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_TAILCALL: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);  				switch (luaD_precall(L' ra' LUA_MULTRET)) {  				  case PCRLUA: {  					/* tail call: put new frame in place of previous one */  					CallInfo ci = L.ci - 1;  /* previous frame */  					int aux;  					StkId func = ci.func;  					StkId pfunc = (ci+1).func;  /* previous function index */  					if (L.openupval != null) luaF_close(L' ci.base_);  					L.base_ = ci.base_ = ci.func + (ci[1].base_ - pfunc);  					for (aux = 0; pfunc+aux < L.top; aux++)  /* move frame down */  					  setobjs2s(L' func+aux' pfunc+aux);  					ci.top = L.top = func+aux;  /* correct top */  					lua_assert(L.top == L.base_ + clvalue(func).l.p.maxstacksize);  					ci.savedpc = InstructionPtr.Assign(L.savedpc);  					ci.tailcalls++;  /* one more call lost */  					CallInfo.dec(ref L.ci);  /* remove new frame */  					goto reentry;  				  }  				  case PCRC: {  /* it was a C function (`precall' called it) */  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_RETURN: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra+b-1;  				if (L.openupval != null) luaF_close(L' base_);  				L.savedpc = InstructionPtr.Assign(pc);  				b = luaD_poscall(L' ra);  				if (--nexeccalls == 0)  /* was previous function running `here'? */  				  return;  /* no: return */  				else {  /* yes: continue its execution */  				  if (b != 0) L.top = L.ci.top;  				  lua_assert(isLua(L.ci));  				  lua_assert(GET_OPCODE(L.ci.savedpc[-1]) == OpCode.OP_CALL);  				  goto reentry;  				}  			  }  			  case OpCode.OP_FORLOOP: {  				lua_Number step = nvalue(ra+2);  				lua_Number idx = luai_numadd(nvalue(ra)' step); /* increment index */  				lua_Number limit = nvalue(ra+1);  				if (luai_numlt(0' step) ? luai_numle(idx' limit)  										: luai_numle(limit' idx)) {  				  dojump(L' pc' GETARG_sBx(i));  /* jump back */  				  setnvalue(ra' idx);  /* update internal index... */  				  setnvalue(ra+3' idx);  /* ...and external index */  				}  				continue;  			  }  			  case OpCode.OP_FORPREP: {  				TValue init = ra;  				TValue plimit = ra+1;  				TValue pstep = ra+2;  				L.savedpc = InstructionPtr.Assign(pc);  /* next steps may throw errors */  				if (tonumber(ref init' ra) == 0)  				  luaG_runerror(L' LUA_QL("for") + " initial value must be a number");  				else if (tonumber(ref plimit' ra+1)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " limit must be a number");  				else if (tonumber(ref pstep' ra+2)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " step must be a number");  				setnvalue(ra' luai_numsub(nvalue(ra)' nvalue(pstep)));  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_TFORLOOP: {  				StkId cb = ra + 3;  /* call base */  				setobjs2s(L' cb+2' ra+2);  				setobjs2s(L' cb+1' ra+1);  				setobjs2s(L' cb' ra);  				L.top = cb+3;  /* func. + 2 args (state and index) */  				//Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					luaD_call(L' cb' GETARG_C(i));  					base_ = L.base_;  				  //);  				L.top = L.ci.top;  				cb = RA(L' base_' i) + 3;  /* previous call may change the stack */  				if (!ttisnil(cb)) {  /* continue loop? */  				  setobjs2s(L' cb-1' cb);  /* save control variable */  				  dojump(L' pc' GETARG_sBx(pc[0]));  /* jump back */  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_SETLIST: {  				int n = GETARG_B(i);  				int c = GETARG_C(i);  				int last;  				Table h;  				if (n == 0) {  				  n = cast_int(L.top - ra) - 1;  				  L.top = L.ci.top;  				}  				if (c == 0)  				{  					c = cast_int(pc[0]);  					InstructionPtr.inc(ref pc);  				}  				runtime_check(L' ttistable(ra));  				h = hvalue(ra);  				last = ((c-1)*LFIELDS_PER_FLUSH) + n;  				if (last > h.sizearray)  /* needs more space? */  				  luaH_resizearray(L' h' last);  /* pre-alloc it at once */  				for (; n > 0; n--) {  				  TValue val = ra+n;  				  setobj2t(L' luaH_setnum(L' h' last--)' val);  				  luaC_barriert(L' h' val);  				}  				continue;  			  }  			  case OpCode.OP_CLOSE: {  				luaF_close(L' ra);  				continue;  			  }  			  case OpCode.OP_CLOSURE: {  				Proto p;  				Closure ncl;  				int nup' j;  				p = cl.p.p[GETARG_Bx(i)];  				nup = p.nups;  				ncl = luaF_newLclosure(L' nup' cl.env);  				ncl.l.p = p;  				for (j=0; j<nup; j++' InstructionPtr.inc(ref pc)) {  				  if (GET_OPCODE(pc[0]) == OpCode.OP_GETUPVAL)  					ncl.l.upvals[j] = cl.upvals[GETARG_B(pc[0])];  				  else {  					lua_assert(GET_OPCODE(pc[0]) == OpCode.OP_MOVE);  					ncl.l.upvals[j] = luaF_findupval(L' base_ + GETARG_B(pc[0]));  				  }  				}  				setclvalue(L' ra' ncl);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  					luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				continue;  			  }  			  case OpCode.OP_VARARG: {  				int b = GETARG_B(i) - 1;  				int j;  				CallInfo ci = L.ci;  				int n = cast_int(ci.base_ - ci.func) - cl.p.numparams - 1;  				if (b == LUA_MULTRET) {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					  luaD_checkstack(L' n);  					base_ = L.base_;  					//);  				  ra = RA(L' base_' i);  /* previous call may change the stack */  				  b = n;  				  L.top = ra + n;  				}  				for (j = 0; j < b; j++) {  				  if (j < n) {  					setobjs2s(L' ra + j' ci.base_ - n + j);  				  }  				  else {  					setnilvalue(ra + j);  				  }  				}  				continue;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,The following statement contains a magic number: switch (GET_OPCODE(i)) {  			  case OpCode.OP_MOVE: {  				setobjs2s(L' ra' RB(L' base_' i));  				continue;  			  }  			  case OpCode.OP_LOADK: {  				setobj2s(L' ra' KBx(L' i' k));  				continue;  			  }  			  case OpCode.OP_LOADBOOL: {  				setbvalue(ra' GETARG_B(i));  				if (GETARG_C(i) != 0) InstructionPtr.inc(ref pc);  /* skip next instruction (if C) */  				continue;  			  }  			  case OpCode.OP_LOADNIL: {  				TValue rb = RB(L' base_' i);  				do {  					setnilvalue(StkId.dec(ref rb));  				} while (rb >= ra);  				continue;  			  }  			  case OpCode.OP_GETUPVAL: {  				int b = GETARG_B(i);  				setobj2s(L' ra' cl.upvals[b].v);  				continue;  			  }  			  case OpCode.OP_GETGLOBAL: {  				TValue g = new TValue();  				TValue rb = KBx(L' i' k);  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(rb));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' g' rb' ra);  				  base_ = L.base_;  				  //);  				  L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_GETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' RB(L' base_' i)' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETGLOBAL: {  				TValue g = new TValue();  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(KBx(L' i' k)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' g' KBx(L' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETUPVAL: {  				UpVal uv = cl.upvals[GETARG_B(i)];  				setobj(L' uv.v' ra);  				luaC_barrier(L' uv' ra);  				continue;  			  }  			  case OpCode.OP_SETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' ra' RKB(L' base_' i' k)' RKC(L' base_' i' k));  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_NEWTABLE: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				sethvalue(L' ra' luaH_new(L' luaO_fb2int(b)' luaO_fb2int(c)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SELF: {  				StkId rb = RB(L' base_' i);  				setobjs2s(L' ra + 1' rb);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' rb' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_ADD: {  				arith_op(L' luai_numadd' TMS.TM_ADD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_SUB: {  				arith_op(L' luai_numsub' TMS.TM_SUB' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MUL: {  				arith_op(L' luai_nummul' TMS.TM_MUL' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_DIV: {  				arith_op(L' luai_numdiv' TMS.TM_DIV' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MOD: {  				arith_op(L' luai_nummod' TMS.TM_MOD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_POW: {  				arith_op(L' luai_numpow' TMS.TM_POW' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_UNM: {  				TValue rb = RB(L' base_' i);  				if (ttisnumber(rb)) {  				  lua_Number nb = nvalue(rb);  				  setnvalue(ra' luai_numunm(nb));  				}  				else {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					Arith(L' ra' rb' rb' TMS.TM_UNM);  					base_ = L.base_;  					//);  				  L.savedpc = InstructionPtr.Assign(pc);  				}  				continue;  			  }  			  case OpCode.OP_NOT: {  				int res = l_isfalse(RB(L' base_' i)) == 0 ? 0 : 1;  /* next assignment may change this value */  				setbvalue(ra' res);  				continue;  			  }  			  case OpCode.OP_LEN: {  				TValue rb = RB(L' base_' i);  				switch (ttype(rb)) {  				  case LUA_TTABLE: {  					setnvalue(ra' (lua_Number)luaH_getn(hvalue(rb)));  					break;  				  }  				  case LUA_TSTRING: {  					setnvalue(ra' (lua_Number)tsvalue(rb).len);  					break;  				  }  				  default: {  /* try metamethod */  					//Protect(  					  L.savedpc = InstructionPtr.Assign(pc);  					  if (call_binTM(L' rb' luaO_nilobject' ra' TMS.TM_LEN) == 0)  						luaG_typeerror(L' rb' "get length of");  					  base_ = L.base_;  					//)  					  break;  				  }  				}  				continue;  			  }  			  case OpCode.OP_CONCAT: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_concat(L' c-b+1' c); luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				setobjs2s(L' RA(L' base_' i)' base_ + b);  				continue;  			  }  			  case OpCode.OP_JMP: {  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_EQ: {  				TValue rb = RKB(L' base_' i' k);  				TValue rc = RKC(L' base_' i' k);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (equalobj(L' rb' rc) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LT: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (luaV_lessthan(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (lessequal(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TEST: {  				if (l_isfalse(ra) != GETARG_C(i))  				  dojump(L' pc' GETARG_sBx(pc[0]));  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TESTSET: {  				TValue rb = RB(L' base_' i);  				if (l_isfalse(rb) != GETARG_C(i)) {  				  setobjs2s(L' ra' rb);  				  dojump(L' pc' GETARG_sBx(pc[0]));  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_CALL: {  				int b = GETARG_B(i);  				int nresults = GETARG_C(i) - 1;  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				switch (luaD_precall(L' ra' nresults)) {  				  case PCRLUA: {  					nexeccalls++;  					goto reentry;  /* restart luaV_execute over new Lua function */  				  }  				  case PCRC: {  					/* it was a C function (`precall' called it); adjust results */  					if (nresults >= 0) L.top = L.ci.top;  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_TAILCALL: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);  				switch (luaD_precall(L' ra' LUA_MULTRET)) {  				  case PCRLUA: {  					/* tail call: put new frame in place of previous one */  					CallInfo ci = L.ci - 1;  /* previous frame */  					int aux;  					StkId func = ci.func;  					StkId pfunc = (ci+1).func;  /* previous function index */  					if (L.openupval != null) luaF_close(L' ci.base_);  					L.base_ = ci.base_ = ci.func + (ci[1].base_ - pfunc);  					for (aux = 0; pfunc+aux < L.top; aux++)  /* move frame down */  					  setobjs2s(L' func+aux' pfunc+aux);  					ci.top = L.top = func+aux;  /* correct top */  					lua_assert(L.top == L.base_ + clvalue(func).l.p.maxstacksize);  					ci.savedpc = InstructionPtr.Assign(L.savedpc);  					ci.tailcalls++;  /* one more call lost */  					CallInfo.dec(ref L.ci);  /* remove new frame */  					goto reentry;  				  }  				  case PCRC: {  /* it was a C function (`precall' called it) */  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_RETURN: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra+b-1;  				if (L.openupval != null) luaF_close(L' base_);  				L.savedpc = InstructionPtr.Assign(pc);  				b = luaD_poscall(L' ra);  				if (--nexeccalls == 0)  /* was previous function running `here'? */  				  return;  /* no: return */  				else {  /* yes: continue its execution */  				  if (b != 0) L.top = L.ci.top;  				  lua_assert(isLua(L.ci));  				  lua_assert(GET_OPCODE(L.ci.savedpc[-1]) == OpCode.OP_CALL);  				  goto reentry;  				}  			  }  			  case OpCode.OP_FORLOOP: {  				lua_Number step = nvalue(ra+2);  				lua_Number idx = luai_numadd(nvalue(ra)' step); /* increment index */  				lua_Number limit = nvalue(ra+1);  				if (luai_numlt(0' step) ? luai_numle(idx' limit)  										: luai_numle(limit' idx)) {  				  dojump(L' pc' GETARG_sBx(i));  /* jump back */  				  setnvalue(ra' idx);  /* update internal index... */  				  setnvalue(ra+3' idx);  /* ...and external index */  				}  				continue;  			  }  			  case OpCode.OP_FORPREP: {  				TValue init = ra;  				TValue plimit = ra+1;  				TValue pstep = ra+2;  				L.savedpc = InstructionPtr.Assign(pc);  /* next steps may throw errors */  				if (tonumber(ref init' ra) == 0)  				  luaG_runerror(L' LUA_QL("for") + " initial value must be a number");  				else if (tonumber(ref plimit' ra+1)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " limit must be a number");  				else if (tonumber(ref pstep' ra+2)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " step must be a number");  				setnvalue(ra' luai_numsub(nvalue(ra)' nvalue(pstep)));  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_TFORLOOP: {  				StkId cb = ra + 3;  /* call base */  				setobjs2s(L' cb+2' ra+2);  				setobjs2s(L' cb+1' ra+1);  				setobjs2s(L' cb' ra);  				L.top = cb+3;  /* func. + 2 args (state and index) */  				//Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					luaD_call(L' cb' GETARG_C(i));  					base_ = L.base_;  				  //);  				L.top = L.ci.top;  				cb = RA(L' base_' i) + 3;  /* previous call may change the stack */  				if (!ttisnil(cb)) {  /* continue loop? */  				  setobjs2s(L' cb-1' cb);  /* save control variable */  				  dojump(L' pc' GETARG_sBx(pc[0]));  /* jump back */  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_SETLIST: {  				int n = GETARG_B(i);  				int c = GETARG_C(i);  				int last;  				Table h;  				if (n == 0) {  				  n = cast_int(L.top - ra) - 1;  				  L.top = L.ci.top;  				}  				if (c == 0)  				{  					c = cast_int(pc[0]);  					InstructionPtr.inc(ref pc);  				}  				runtime_check(L' ttistable(ra));  				h = hvalue(ra);  				last = ((c-1)*LFIELDS_PER_FLUSH) + n;  				if (last > h.sizearray)  /* needs more space? */  				  luaH_resizearray(L' h' last);  /* pre-alloc it at once */  				for (; n > 0; n--) {  				  TValue val = ra+n;  				  setobj2t(L' luaH_setnum(L' h' last--)' val);  				  luaC_barriert(L' h' val);  				}  				continue;  			  }  			  case OpCode.OP_CLOSE: {  				luaF_close(L' ra);  				continue;  			  }  			  case OpCode.OP_CLOSURE: {  				Proto p;  				Closure ncl;  				int nup' j;  				p = cl.p.p[GETARG_Bx(i)];  				nup = p.nups;  				ncl = luaF_newLclosure(L' nup' cl.env);  				ncl.l.p = p;  				for (j=0; j<nup; j++' InstructionPtr.inc(ref pc)) {  				  if (GET_OPCODE(pc[0]) == OpCode.OP_GETUPVAL)  					ncl.l.upvals[j] = cl.upvals[GETARG_B(pc[0])];  				  else {  					lua_assert(GET_OPCODE(pc[0]) == OpCode.OP_MOVE);  					ncl.l.upvals[j] = luaF_findupval(L' base_ + GETARG_B(pc[0]));  				  }  				}  				setclvalue(L' ra' ncl);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  					luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				continue;  			  }  			  case OpCode.OP_VARARG: {  				int b = GETARG_B(i) - 1;  				int j;  				CallInfo ci = L.ci;  				int n = cast_int(ci.base_ - ci.func) - cl.p.numparams - 1;  				if (b == LUA_MULTRET) {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					  luaD_checkstack(L' n);  					base_ = L.base_;  					//);  				  ra = RA(L' base_' i);  /* previous call may change the stack */  				  b = n;  				  L.top = ra + n;  				}  				for (j = 0; j < b; j++) {  				  if (j < n) {  					setobjs2s(L' ra + j' ci.base_ - n + j);  				  }  				  else {  					setnilvalue(ra + j);  				  }  				}  				continue;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,The following statement contains a magic number: switch (GET_OPCODE(i)) {  			  case OpCode.OP_MOVE: {  				setobjs2s(L' ra' RB(L' base_' i));  				continue;  			  }  			  case OpCode.OP_LOADK: {  				setobj2s(L' ra' KBx(L' i' k));  				continue;  			  }  			  case OpCode.OP_LOADBOOL: {  				setbvalue(ra' GETARG_B(i));  				if (GETARG_C(i) != 0) InstructionPtr.inc(ref pc);  /* skip next instruction (if C) */  				continue;  			  }  			  case OpCode.OP_LOADNIL: {  				TValue rb = RB(L' base_' i);  				do {  					setnilvalue(StkId.dec(ref rb));  				} while (rb >= ra);  				continue;  			  }  			  case OpCode.OP_GETUPVAL: {  				int b = GETARG_B(i);  				setobj2s(L' ra' cl.upvals[b].v);  				continue;  			  }  			  case OpCode.OP_GETGLOBAL: {  				TValue g = new TValue();  				TValue rb = KBx(L' i' k);  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(rb));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' g' rb' ra);  				  base_ = L.base_;  				  //);  				  L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_GETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' RB(L' base_' i)' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETGLOBAL: {  				TValue g = new TValue();  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(KBx(L' i' k)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' g' KBx(L' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETUPVAL: {  				UpVal uv = cl.upvals[GETARG_B(i)];  				setobj(L' uv.v' ra);  				luaC_barrier(L' uv' ra);  				continue;  			  }  			  case OpCode.OP_SETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' ra' RKB(L' base_' i' k)' RKC(L' base_' i' k));  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_NEWTABLE: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				sethvalue(L' ra' luaH_new(L' luaO_fb2int(b)' luaO_fb2int(c)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SELF: {  				StkId rb = RB(L' base_' i);  				setobjs2s(L' ra + 1' rb);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' rb' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_ADD: {  				arith_op(L' luai_numadd' TMS.TM_ADD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_SUB: {  				arith_op(L' luai_numsub' TMS.TM_SUB' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MUL: {  				arith_op(L' luai_nummul' TMS.TM_MUL' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_DIV: {  				arith_op(L' luai_numdiv' TMS.TM_DIV' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MOD: {  				arith_op(L' luai_nummod' TMS.TM_MOD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_POW: {  				arith_op(L' luai_numpow' TMS.TM_POW' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_UNM: {  				TValue rb = RB(L' base_' i);  				if (ttisnumber(rb)) {  				  lua_Number nb = nvalue(rb);  				  setnvalue(ra' luai_numunm(nb));  				}  				else {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					Arith(L' ra' rb' rb' TMS.TM_UNM);  					base_ = L.base_;  					//);  				  L.savedpc = InstructionPtr.Assign(pc);  				}  				continue;  			  }  			  case OpCode.OP_NOT: {  				int res = l_isfalse(RB(L' base_' i)) == 0 ? 0 : 1;  /* next assignment may change this value */  				setbvalue(ra' res);  				continue;  			  }  			  case OpCode.OP_LEN: {  				TValue rb = RB(L' base_' i);  				switch (ttype(rb)) {  				  case LUA_TTABLE: {  					setnvalue(ra' (lua_Number)luaH_getn(hvalue(rb)));  					break;  				  }  				  case LUA_TSTRING: {  					setnvalue(ra' (lua_Number)tsvalue(rb).len);  					break;  				  }  				  default: {  /* try metamethod */  					//Protect(  					  L.savedpc = InstructionPtr.Assign(pc);  					  if (call_binTM(L' rb' luaO_nilobject' ra' TMS.TM_LEN) == 0)  						luaG_typeerror(L' rb' "get length of");  					  base_ = L.base_;  					//)  					  break;  				  }  				}  				continue;  			  }  			  case OpCode.OP_CONCAT: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_concat(L' c-b+1' c); luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				setobjs2s(L' RA(L' base_' i)' base_ + b);  				continue;  			  }  			  case OpCode.OP_JMP: {  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_EQ: {  				TValue rb = RKB(L' base_' i' k);  				TValue rc = RKC(L' base_' i' k);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (equalobj(L' rb' rc) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LT: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (luaV_lessthan(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (lessequal(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TEST: {  				if (l_isfalse(ra) != GETARG_C(i))  				  dojump(L' pc' GETARG_sBx(pc[0]));  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TESTSET: {  				TValue rb = RB(L' base_' i);  				if (l_isfalse(rb) != GETARG_C(i)) {  				  setobjs2s(L' ra' rb);  				  dojump(L' pc' GETARG_sBx(pc[0]));  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_CALL: {  				int b = GETARG_B(i);  				int nresults = GETARG_C(i) - 1;  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				switch (luaD_precall(L' ra' nresults)) {  				  case PCRLUA: {  					nexeccalls++;  					goto reentry;  /* restart luaV_execute over new Lua function */  				  }  				  case PCRC: {  					/* it was a C function (`precall' called it); adjust results */  					if (nresults >= 0) L.top = L.ci.top;  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_TAILCALL: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);  				switch (luaD_precall(L' ra' LUA_MULTRET)) {  				  case PCRLUA: {  					/* tail call: put new frame in place of previous one */  					CallInfo ci = L.ci - 1;  /* previous frame */  					int aux;  					StkId func = ci.func;  					StkId pfunc = (ci+1).func;  /* previous function index */  					if (L.openupval != null) luaF_close(L' ci.base_);  					L.base_ = ci.base_ = ci.func + (ci[1].base_ - pfunc);  					for (aux = 0; pfunc+aux < L.top; aux++)  /* move frame down */  					  setobjs2s(L' func+aux' pfunc+aux);  					ci.top = L.top = func+aux;  /* correct top */  					lua_assert(L.top == L.base_ + clvalue(func).l.p.maxstacksize);  					ci.savedpc = InstructionPtr.Assign(L.savedpc);  					ci.tailcalls++;  /* one more call lost */  					CallInfo.dec(ref L.ci);  /* remove new frame */  					goto reentry;  				  }  				  case PCRC: {  /* it was a C function (`precall' called it) */  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_RETURN: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra+b-1;  				if (L.openupval != null) luaF_close(L' base_);  				L.savedpc = InstructionPtr.Assign(pc);  				b = luaD_poscall(L' ra);  				if (--nexeccalls == 0)  /* was previous function running `here'? */  				  return;  /* no: return */  				else {  /* yes: continue its execution */  				  if (b != 0) L.top = L.ci.top;  				  lua_assert(isLua(L.ci));  				  lua_assert(GET_OPCODE(L.ci.savedpc[-1]) == OpCode.OP_CALL);  				  goto reentry;  				}  			  }  			  case OpCode.OP_FORLOOP: {  				lua_Number step = nvalue(ra+2);  				lua_Number idx = luai_numadd(nvalue(ra)' step); /* increment index */  				lua_Number limit = nvalue(ra+1);  				if (luai_numlt(0' step) ? luai_numle(idx' limit)  										: luai_numle(limit' idx)) {  				  dojump(L' pc' GETARG_sBx(i));  /* jump back */  				  setnvalue(ra' idx);  /* update internal index... */  				  setnvalue(ra+3' idx);  /* ...and external index */  				}  				continue;  			  }  			  case OpCode.OP_FORPREP: {  				TValue init = ra;  				TValue plimit = ra+1;  				TValue pstep = ra+2;  				L.savedpc = InstructionPtr.Assign(pc);  /* next steps may throw errors */  				if (tonumber(ref init' ra) == 0)  				  luaG_runerror(L' LUA_QL("for") + " initial value must be a number");  				else if (tonumber(ref plimit' ra+1)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " limit must be a number");  				else if (tonumber(ref pstep' ra+2)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " step must be a number");  				setnvalue(ra' luai_numsub(nvalue(ra)' nvalue(pstep)));  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_TFORLOOP: {  				StkId cb = ra + 3;  /* call base */  				setobjs2s(L' cb+2' ra+2);  				setobjs2s(L' cb+1' ra+1);  				setobjs2s(L' cb' ra);  				L.top = cb+3;  /* func. + 2 args (state and index) */  				//Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					luaD_call(L' cb' GETARG_C(i));  					base_ = L.base_;  				  //);  				L.top = L.ci.top;  				cb = RA(L' base_' i) + 3;  /* previous call may change the stack */  				if (!ttisnil(cb)) {  /* continue loop? */  				  setobjs2s(L' cb-1' cb);  /* save control variable */  				  dojump(L' pc' GETARG_sBx(pc[0]));  /* jump back */  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_SETLIST: {  				int n = GETARG_B(i);  				int c = GETARG_C(i);  				int last;  				Table h;  				if (n == 0) {  				  n = cast_int(L.top - ra) - 1;  				  L.top = L.ci.top;  				}  				if (c == 0)  				{  					c = cast_int(pc[0]);  					InstructionPtr.inc(ref pc);  				}  				runtime_check(L' ttistable(ra));  				h = hvalue(ra);  				last = ((c-1)*LFIELDS_PER_FLUSH) + n;  				if (last > h.sizearray)  /* needs more space? */  				  luaH_resizearray(L' h' last);  /* pre-alloc it at once */  				for (; n > 0; n--) {  				  TValue val = ra+n;  				  setobj2t(L' luaH_setnum(L' h' last--)' val);  				  luaC_barriert(L' h' val);  				}  				continue;  			  }  			  case OpCode.OP_CLOSE: {  				luaF_close(L' ra);  				continue;  			  }  			  case OpCode.OP_CLOSURE: {  				Proto p;  				Closure ncl;  				int nup' j;  				p = cl.p.p[GETARG_Bx(i)];  				nup = p.nups;  				ncl = luaF_newLclosure(L' nup' cl.env);  				ncl.l.p = p;  				for (j=0; j<nup; j++' InstructionPtr.inc(ref pc)) {  				  if (GET_OPCODE(pc[0]) == OpCode.OP_GETUPVAL)  					ncl.l.upvals[j] = cl.upvals[GETARG_B(pc[0])];  				  else {  					lua_assert(GET_OPCODE(pc[0]) == OpCode.OP_MOVE);  					ncl.l.upvals[j] = luaF_findupval(L' base_ + GETARG_B(pc[0]));  				  }  				}  				setclvalue(L' ra' ncl);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  					luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				continue;  			  }  			  case OpCode.OP_VARARG: {  				int b = GETARG_B(i) - 1;  				int j;  				CallInfo ci = L.ci;  				int n = cast_int(ci.base_ - ci.func) - cl.p.numparams - 1;  				if (b == LUA_MULTRET) {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					  luaD_checkstack(L' n);  					base_ = L.base_;  					//);  				  ra = RA(L' base_' i);  /* previous call may change the stack */  				  b = n;  				  L.top = ra + n;  				}  				for (j = 0; j < b; j++) {  				  if (j < n) {  					setobjs2s(L' ra + j' ci.base_ - n + j);  				  }  				  else {  					setnilvalue(ra + j);  				  }  				}  				continue;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,The following statement contains a magic number: switch (GET_OPCODE(i)) {  			  case OpCode.OP_MOVE: {  				setobjs2s(L' ra' RB(L' base_' i));  				continue;  			  }  			  case OpCode.OP_LOADK: {  				setobj2s(L' ra' KBx(L' i' k));  				continue;  			  }  			  case OpCode.OP_LOADBOOL: {  				setbvalue(ra' GETARG_B(i));  				if (GETARG_C(i) != 0) InstructionPtr.inc(ref pc);  /* skip next instruction (if C) */  				continue;  			  }  			  case OpCode.OP_LOADNIL: {  				TValue rb = RB(L' base_' i);  				do {  					setnilvalue(StkId.dec(ref rb));  				} while (rb >= ra);  				continue;  			  }  			  case OpCode.OP_GETUPVAL: {  				int b = GETARG_B(i);  				setobj2s(L' ra' cl.upvals[b].v);  				continue;  			  }  			  case OpCode.OP_GETGLOBAL: {  				TValue g = new TValue();  				TValue rb = KBx(L' i' k);  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(rb));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' g' rb' ra);  				  base_ = L.base_;  				  //);  				  L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_GETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' RB(L' base_' i)' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETGLOBAL: {  				TValue g = new TValue();  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(KBx(L' i' k)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' g' KBx(L' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETUPVAL: {  				UpVal uv = cl.upvals[GETARG_B(i)];  				setobj(L' uv.v' ra);  				luaC_barrier(L' uv' ra);  				continue;  			  }  			  case OpCode.OP_SETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' ra' RKB(L' base_' i' k)' RKC(L' base_' i' k));  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_NEWTABLE: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				sethvalue(L' ra' luaH_new(L' luaO_fb2int(b)' luaO_fb2int(c)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SELF: {  				StkId rb = RB(L' base_' i);  				setobjs2s(L' ra + 1' rb);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' rb' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_ADD: {  				arith_op(L' luai_numadd' TMS.TM_ADD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_SUB: {  				arith_op(L' luai_numsub' TMS.TM_SUB' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MUL: {  				arith_op(L' luai_nummul' TMS.TM_MUL' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_DIV: {  				arith_op(L' luai_numdiv' TMS.TM_DIV' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MOD: {  				arith_op(L' luai_nummod' TMS.TM_MOD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_POW: {  				arith_op(L' luai_numpow' TMS.TM_POW' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_UNM: {  				TValue rb = RB(L' base_' i);  				if (ttisnumber(rb)) {  				  lua_Number nb = nvalue(rb);  				  setnvalue(ra' luai_numunm(nb));  				}  				else {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					Arith(L' ra' rb' rb' TMS.TM_UNM);  					base_ = L.base_;  					//);  				  L.savedpc = InstructionPtr.Assign(pc);  				}  				continue;  			  }  			  case OpCode.OP_NOT: {  				int res = l_isfalse(RB(L' base_' i)) == 0 ? 0 : 1;  /* next assignment may change this value */  				setbvalue(ra' res);  				continue;  			  }  			  case OpCode.OP_LEN: {  				TValue rb = RB(L' base_' i);  				switch (ttype(rb)) {  				  case LUA_TTABLE: {  					setnvalue(ra' (lua_Number)luaH_getn(hvalue(rb)));  					break;  				  }  				  case LUA_TSTRING: {  					setnvalue(ra' (lua_Number)tsvalue(rb).len);  					break;  				  }  				  default: {  /* try metamethod */  					//Protect(  					  L.savedpc = InstructionPtr.Assign(pc);  					  if (call_binTM(L' rb' luaO_nilobject' ra' TMS.TM_LEN) == 0)  						luaG_typeerror(L' rb' "get length of");  					  base_ = L.base_;  					//)  					  break;  				  }  				}  				continue;  			  }  			  case OpCode.OP_CONCAT: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_concat(L' c-b+1' c); luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				setobjs2s(L' RA(L' base_' i)' base_ + b);  				continue;  			  }  			  case OpCode.OP_JMP: {  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_EQ: {  				TValue rb = RKB(L' base_' i' k);  				TValue rc = RKC(L' base_' i' k);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (equalobj(L' rb' rc) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LT: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (luaV_lessthan(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (lessequal(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TEST: {  				if (l_isfalse(ra) != GETARG_C(i))  				  dojump(L' pc' GETARG_sBx(pc[0]));  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TESTSET: {  				TValue rb = RB(L' base_' i);  				if (l_isfalse(rb) != GETARG_C(i)) {  				  setobjs2s(L' ra' rb);  				  dojump(L' pc' GETARG_sBx(pc[0]));  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_CALL: {  				int b = GETARG_B(i);  				int nresults = GETARG_C(i) - 1;  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				switch (luaD_precall(L' ra' nresults)) {  				  case PCRLUA: {  					nexeccalls++;  					goto reentry;  /* restart luaV_execute over new Lua function */  				  }  				  case PCRC: {  					/* it was a C function (`precall' called it); adjust results */  					if (nresults >= 0) L.top = L.ci.top;  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_TAILCALL: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);  				switch (luaD_precall(L' ra' LUA_MULTRET)) {  				  case PCRLUA: {  					/* tail call: put new frame in place of previous one */  					CallInfo ci = L.ci - 1;  /* previous frame */  					int aux;  					StkId func = ci.func;  					StkId pfunc = (ci+1).func;  /* previous function index */  					if (L.openupval != null) luaF_close(L' ci.base_);  					L.base_ = ci.base_ = ci.func + (ci[1].base_ - pfunc);  					for (aux = 0; pfunc+aux < L.top; aux++)  /* move frame down */  					  setobjs2s(L' func+aux' pfunc+aux);  					ci.top = L.top = func+aux;  /* correct top */  					lua_assert(L.top == L.base_ + clvalue(func).l.p.maxstacksize);  					ci.savedpc = InstructionPtr.Assign(L.savedpc);  					ci.tailcalls++;  /* one more call lost */  					CallInfo.dec(ref L.ci);  /* remove new frame */  					goto reentry;  				  }  				  case PCRC: {  /* it was a C function (`precall' called it) */  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_RETURN: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra+b-1;  				if (L.openupval != null) luaF_close(L' base_);  				L.savedpc = InstructionPtr.Assign(pc);  				b = luaD_poscall(L' ra);  				if (--nexeccalls == 0)  /* was previous function running `here'? */  				  return;  /* no: return */  				else {  /* yes: continue its execution */  				  if (b != 0) L.top = L.ci.top;  				  lua_assert(isLua(L.ci));  				  lua_assert(GET_OPCODE(L.ci.savedpc[-1]) == OpCode.OP_CALL);  				  goto reentry;  				}  			  }  			  case OpCode.OP_FORLOOP: {  				lua_Number step = nvalue(ra+2);  				lua_Number idx = luai_numadd(nvalue(ra)' step); /* increment index */  				lua_Number limit = nvalue(ra+1);  				if (luai_numlt(0' step) ? luai_numle(idx' limit)  										: luai_numle(limit' idx)) {  				  dojump(L' pc' GETARG_sBx(i));  /* jump back */  				  setnvalue(ra' idx);  /* update internal index... */  				  setnvalue(ra+3' idx);  /* ...and external index */  				}  				continue;  			  }  			  case OpCode.OP_FORPREP: {  				TValue init = ra;  				TValue plimit = ra+1;  				TValue pstep = ra+2;  				L.savedpc = InstructionPtr.Assign(pc);  /* next steps may throw errors */  				if (tonumber(ref init' ra) == 0)  				  luaG_runerror(L' LUA_QL("for") + " initial value must be a number");  				else if (tonumber(ref plimit' ra+1)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " limit must be a number");  				else if (tonumber(ref pstep' ra+2)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " step must be a number");  				setnvalue(ra' luai_numsub(nvalue(ra)' nvalue(pstep)));  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_TFORLOOP: {  				StkId cb = ra + 3;  /* call base */  				setobjs2s(L' cb+2' ra+2);  				setobjs2s(L' cb+1' ra+1);  				setobjs2s(L' cb' ra);  				L.top = cb+3;  /* func. + 2 args (state and index) */  				//Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					luaD_call(L' cb' GETARG_C(i));  					base_ = L.base_;  				  //);  				L.top = L.ci.top;  				cb = RA(L' base_' i) + 3;  /* previous call may change the stack */  				if (!ttisnil(cb)) {  /* continue loop? */  				  setobjs2s(L' cb-1' cb);  /* save control variable */  				  dojump(L' pc' GETARG_sBx(pc[0]));  /* jump back */  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_SETLIST: {  				int n = GETARG_B(i);  				int c = GETARG_C(i);  				int last;  				Table h;  				if (n == 0) {  				  n = cast_int(L.top - ra) - 1;  				  L.top = L.ci.top;  				}  				if (c == 0)  				{  					c = cast_int(pc[0]);  					InstructionPtr.inc(ref pc);  				}  				runtime_check(L' ttistable(ra));  				h = hvalue(ra);  				last = ((c-1)*LFIELDS_PER_FLUSH) + n;  				if (last > h.sizearray)  /* needs more space? */  				  luaH_resizearray(L' h' last);  /* pre-alloc it at once */  				for (; n > 0; n--) {  				  TValue val = ra+n;  				  setobj2t(L' luaH_setnum(L' h' last--)' val);  				  luaC_barriert(L' h' val);  				}  				continue;  			  }  			  case OpCode.OP_CLOSE: {  				luaF_close(L' ra);  				continue;  			  }  			  case OpCode.OP_CLOSURE: {  				Proto p;  				Closure ncl;  				int nup' j;  				p = cl.p.p[GETARG_Bx(i)];  				nup = p.nups;  				ncl = luaF_newLclosure(L' nup' cl.env);  				ncl.l.p = p;  				for (j=0; j<nup; j++' InstructionPtr.inc(ref pc)) {  				  if (GET_OPCODE(pc[0]) == OpCode.OP_GETUPVAL)  					ncl.l.upvals[j] = cl.upvals[GETARG_B(pc[0])];  				  else {  					lua_assert(GET_OPCODE(pc[0]) == OpCode.OP_MOVE);  					ncl.l.upvals[j] = luaF_findupval(L' base_ + GETARG_B(pc[0]));  				  }  				}  				setclvalue(L' ra' ncl);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  					luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				continue;  			  }  			  case OpCode.OP_VARARG: {  				int b = GETARG_B(i) - 1;  				int j;  				CallInfo ci = L.ci;  				int n = cast_int(ci.base_ - ci.func) - cl.p.numparams - 1;  				if (b == LUA_MULTRET) {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					  luaD_checkstack(L' n);  					base_ = L.base_;  					//);  				  ra = RA(L' base_' i);  /* previous call may change the stack */  				  b = n;  				  L.top = ra + n;  				}  				for (j = 0; j < b; j++) {  				  if (j < n) {  					setobjs2s(L' ra + j' ci.base_ - n + j);  				  }  				  else {  					setnilvalue(ra + j);  				  }  				}  				continue;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaV_execute,The following statement contains a magic number: switch (GET_OPCODE(i)) {  			  case OpCode.OP_MOVE: {  				setobjs2s(L' ra' RB(L' base_' i));  				continue;  			  }  			  case OpCode.OP_LOADK: {  				setobj2s(L' ra' KBx(L' i' k));  				continue;  			  }  			  case OpCode.OP_LOADBOOL: {  				setbvalue(ra' GETARG_B(i));  				if (GETARG_C(i) != 0) InstructionPtr.inc(ref pc);  /* skip next instruction (if C) */  				continue;  			  }  			  case OpCode.OP_LOADNIL: {  				TValue rb = RB(L' base_' i);  				do {  					setnilvalue(StkId.dec(ref rb));  				} while (rb >= ra);  				continue;  			  }  			  case OpCode.OP_GETUPVAL: {  				int b = GETARG_B(i);  				setobj2s(L' ra' cl.upvals[b].v);  				continue;  			  }  			  case OpCode.OP_GETGLOBAL: {  				TValue g = new TValue();  				TValue rb = KBx(L' i' k);  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(rb));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' g' rb' ra);  				  base_ = L.base_;  				  //);  				  L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_GETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' RB(L' base_' i)' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETGLOBAL: {  				TValue g = new TValue();  				sethvalue(L' g' cl.env);  				lua_assert(ttisstring(KBx(L' i' k)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' g' KBx(L' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SETUPVAL: {  				UpVal uv = cl.upvals[GETARG_B(i)];  				setobj(L' uv.v' ra);  				luaC_barrier(L' uv' ra);  				continue;  			  }  			  case OpCode.OP_SETTABLE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_settable(L' ra' RKB(L' base_' i' k)' RKC(L' base_' i' k));  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_NEWTABLE: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				sethvalue(L' ra' luaH_new(L' luaO_fb2int(b)' luaO_fb2int(c)));  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_SELF: {  				StkId rb = RB(L' base_' i);  				setobjs2s(L' ra + 1' rb);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_gettable(L' rb' RKC(L' base_' i' k)' ra);  				  base_ = L.base_;  				  //);  				L.savedpc = InstructionPtr.Assign(pc);  				continue;  			  }  			  case OpCode.OP_ADD: {  				arith_op(L' luai_numadd' TMS.TM_ADD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_SUB: {  				arith_op(L' luai_numsub' TMS.TM_SUB' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MUL: {  				arith_op(L' luai_nummul' TMS.TM_MUL' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_DIV: {  				arith_op(L' luai_numdiv' TMS.TM_DIV' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_MOD: {  				arith_op(L' luai_nummod' TMS.TM_MOD' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_POW: {  				arith_op(L' luai_numpow' TMS.TM_POW' base_' i' k' ra' pc);  				continue;  			  }  			  case OpCode.OP_UNM: {  				TValue rb = RB(L' base_' i);  				if (ttisnumber(rb)) {  				  lua_Number nb = nvalue(rb);  				  setnvalue(ra' luai_numunm(nb));  				}  				else {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					Arith(L' ra' rb' rb' TMS.TM_UNM);  					base_ = L.base_;  					//);  				  L.savedpc = InstructionPtr.Assign(pc);  				}  				continue;  			  }  			  case OpCode.OP_NOT: {  				int res = l_isfalse(RB(L' base_' i)) == 0 ? 0 : 1;  /* next assignment may change this value */  				setbvalue(ra' res);  				continue;  			  }  			  case OpCode.OP_LEN: {  				TValue rb = RB(L' base_' i);  				switch (ttype(rb)) {  				  case LUA_TTABLE: {  					setnvalue(ra' (lua_Number)luaH_getn(hvalue(rb)));  					break;  				  }  				  case LUA_TSTRING: {  					setnvalue(ra' (lua_Number)tsvalue(rb).len);  					break;  				  }  				  default: {  /* try metamethod */  					//Protect(  					  L.savedpc = InstructionPtr.Assign(pc);  					  if (call_binTM(L' rb' luaO_nilobject' ra' TMS.TM_LEN) == 0)  						luaG_typeerror(L' rb' "get length of");  					  base_ = L.base_;  					//)  					  break;  				  }  				}  				continue;  			  }  			  case OpCode.OP_CONCAT: {  				int b = GETARG_B(i);  				int c = GETARG_C(i);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  luaV_concat(L' c-b+1' c); luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				setobjs2s(L' RA(L' base_' i)' base_ + b);  				continue;  			  }  			  case OpCode.OP_JMP: {  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_EQ: {  				TValue rb = RKB(L' base_' i' k);  				TValue rc = RKC(L' base_' i' k);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (equalobj(L' rb' rc) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LT: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (luaV_lessthan(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_LE: {  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  				  if (lessequal(L' RKB(L' base_' i' k)' RKC(L' base_' i' k)) == GETARG_A(i))  					dojump(L' pc' GETARG_sBx(pc[0]));  				  base_ = L.base_;  				//);  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TEST: {  				if (l_isfalse(ra) != GETARG_C(i))  				  dojump(L' pc' GETARG_sBx(pc[0]));  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_TESTSET: {  				TValue rb = RB(L' base_' i);  				if (l_isfalse(rb) != GETARG_C(i)) {  				  setobjs2s(L' ra' rb);  				  dojump(L' pc' GETARG_sBx(pc[0]));  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_CALL: {  				int b = GETARG_B(i);  				int nresults = GETARG_C(i) - 1;  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				switch (luaD_precall(L' ra' nresults)) {  				  case PCRLUA: {  					nexeccalls++;  					goto reentry;  /* restart luaV_execute over new Lua function */  				  }  				  case PCRC: {  					/* it was a C function (`precall' called it); adjust results */  					if (nresults >= 0) L.top = L.ci.top;  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_TAILCALL: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra + b;  /* else previous instruction set top */  				L.savedpc = InstructionPtr.Assign(pc);  				lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);  				switch (luaD_precall(L' ra' LUA_MULTRET)) {  				  case PCRLUA: {  					/* tail call: put new frame in place of previous one */  					CallInfo ci = L.ci - 1;  /* previous frame */  					int aux;  					StkId func = ci.func;  					StkId pfunc = (ci+1).func;  /* previous function index */  					if (L.openupval != null) luaF_close(L' ci.base_);  					L.base_ = ci.base_ = ci.func + (ci[1].base_ - pfunc);  					for (aux = 0; pfunc+aux < L.top; aux++)  /* move frame down */  					  setobjs2s(L' func+aux' pfunc+aux);  					ci.top = L.top = func+aux;  /* correct top */  					lua_assert(L.top == L.base_ + clvalue(func).l.p.maxstacksize);  					ci.savedpc = InstructionPtr.Assign(L.savedpc);  					ci.tailcalls++;  /* one more call lost */  					CallInfo.dec(ref L.ci);  /* remove new frame */  					goto reentry;  				  }  				  case PCRC: {  /* it was a C function (`precall' called it) */  					base_ = L.base_;  					continue;  				  }  				  default: {  					return;  /* yield */  				  }  				}  			  }  			  case OpCode.OP_RETURN: {  				int b = GETARG_B(i);  				if (b != 0) L.top = ra+b-1;  				if (L.openupval != null) luaF_close(L' base_);  				L.savedpc = InstructionPtr.Assign(pc);  				b = luaD_poscall(L' ra);  				if (--nexeccalls == 0)  /* was previous function running `here'? */  				  return;  /* no: return */  				else {  /* yes: continue its execution */  				  if (b != 0) L.top = L.ci.top;  				  lua_assert(isLua(L.ci));  				  lua_assert(GET_OPCODE(L.ci.savedpc[-1]) == OpCode.OP_CALL);  				  goto reentry;  				}  			  }  			  case OpCode.OP_FORLOOP: {  				lua_Number step = nvalue(ra+2);  				lua_Number idx = luai_numadd(nvalue(ra)' step); /* increment index */  				lua_Number limit = nvalue(ra+1);  				if (luai_numlt(0' step) ? luai_numle(idx' limit)  										: luai_numle(limit' idx)) {  				  dojump(L' pc' GETARG_sBx(i));  /* jump back */  				  setnvalue(ra' idx);  /* update internal index... */  				  setnvalue(ra+3' idx);  /* ...and external index */  				}  				continue;  			  }  			  case OpCode.OP_FORPREP: {  				TValue init = ra;  				TValue plimit = ra+1;  				TValue pstep = ra+2;  				L.savedpc = InstructionPtr.Assign(pc);  /* next steps may throw errors */  				if (tonumber(ref init' ra) == 0)  				  luaG_runerror(L' LUA_QL("for") + " initial value must be a number");  				else if (tonumber(ref plimit' ra+1)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " limit must be a number");  				else if (tonumber(ref pstep' ra+2)  == 0)  				  luaG_runerror(L' LUA_QL("for") + " step must be a number");  				setnvalue(ra' luai_numsub(nvalue(ra)' nvalue(pstep)));  				dojump(L' pc' GETARG_sBx(i));  				continue;  			  }  			  case OpCode.OP_TFORLOOP: {  				StkId cb = ra + 3;  /* call base */  				setobjs2s(L' cb+2' ra+2);  				setobjs2s(L' cb+1' ra+1);  				setobjs2s(L' cb' ra);  				L.top = cb+3;  /* func. + 2 args (state and index) */  				//Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					luaD_call(L' cb' GETARG_C(i));  					base_ = L.base_;  				  //);  				L.top = L.ci.top;  				cb = RA(L' base_' i) + 3;  /* previous call may change the stack */  				if (!ttisnil(cb)) {  /* continue loop? */  				  setobjs2s(L' cb-1' cb);  /* save control variable */  				  dojump(L' pc' GETARG_sBx(pc[0]));  /* jump back */  				}  				InstructionPtr.inc(ref pc);  				continue;  			  }  			  case OpCode.OP_SETLIST: {  				int n = GETARG_B(i);  				int c = GETARG_C(i);  				int last;  				Table h;  				if (n == 0) {  				  n = cast_int(L.top - ra) - 1;  				  L.top = L.ci.top;  				}  				if (c == 0)  				{  					c = cast_int(pc[0]);  					InstructionPtr.inc(ref pc);  				}  				runtime_check(L' ttistable(ra));  				h = hvalue(ra);  				last = ((c-1)*LFIELDS_PER_FLUSH) + n;  				if (last > h.sizearray)  /* needs more space? */  				  luaH_resizearray(L' h' last);  /* pre-alloc it at once */  				for (; n > 0; n--) {  				  TValue val = ra+n;  				  setobj2t(L' luaH_setnum(L' h' last--)' val);  				  luaC_barriert(L' h' val);  				}  				continue;  			  }  			  case OpCode.OP_CLOSE: {  				luaF_close(L' ra);  				continue;  			  }  			  case OpCode.OP_CLOSURE: {  				Proto p;  				Closure ncl;  				int nup' j;  				p = cl.p.p[GETARG_Bx(i)];  				nup = p.nups;  				ncl = luaF_newLclosure(L' nup' cl.env);  				ncl.l.p = p;  				for (j=0; j<nup; j++' InstructionPtr.inc(ref pc)) {  				  if (GET_OPCODE(pc[0]) == OpCode.OP_GETUPVAL)  					ncl.l.upvals[j] = cl.upvals[GETARG_B(pc[0])];  				  else {  					lua_assert(GET_OPCODE(pc[0]) == OpCode.OP_MOVE);  					ncl.l.upvals[j] = luaF_findupval(L' base_ + GETARG_B(pc[0]));  				  }  				}  				setclvalue(L' ra' ncl);  				//Protect(  				  L.savedpc = InstructionPtr.Assign(pc);  					luaC_checkGC(L);  				  base_ = L.base_;  				  //);  				continue;  			  }  			  case OpCode.OP_VARARG: {  				int b = GETARG_B(i) - 1;  				int j;  				CallInfo ci = L.ci;  				int n = cast_int(ci.base_ - ci.func) - cl.p.numparams - 1;  				if (b == LUA_MULTRET) {  				  //Protect(  					L.savedpc = InstructionPtr.Assign(pc);  					  luaD_checkstack(L' n);  					base_ = L.base_;  					//);  				  ra = RA(L' base_' i);  /* previous call may change the stack */  				  b = n;  				  L.top = ra + n;  				}  				for (j = 0; j < b; j++) {  				  if (j < n) {  					setobjs2s(L' ra + j' ci.base_ - n + j);  				  }  				  else {  					setnilvalue(ra + j);  				  }  				}  				continue;  			  }  			}
Magic Number,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,PrintCode,The following statement contains a magic number: switch (o)  		  {  		   case OpCode.OP_LOADK:  			printf("\t; "); PrintConstant(f'bx);  			break;  		   case OpCode.OP_GETUPVAL:  		   case OpCode.OP_SETUPVAL:  			printf("\t; %s"' (f.sizeupvalues>0) ? getstr(f.upvalues[b]) : "-");  			break;  		   case OpCode.OP_GETGLOBAL:  		   case OpCode.OP_SETGLOBAL:  			printf("\t; %s"'svalue(f.k[bx]));  			break;  		   case OpCode.OP_GETTABLE:  		   case OpCode.OP_SELF:  			if (ISK(c) != 0) { printf("\t; "); PrintConstant(f'INDEXK(c)); }  			break;  		   case OpCode.OP_SETTABLE:  		   case OpCode.OP_ADD:  		   case OpCode.OP_SUB:  		   case OpCode.OP_MUL:  		   case OpCode.OP_DIV:  		   case OpCode.OP_POW:  		   case OpCode.OP_EQ:  		   case OpCode.OP_LT:  		   case OpCode.OP_LE:  			if (ISK(b)!=0 || ISK(c)!=0)  			{  			 printf("\t; ");  			 if (ISK(b) != 0) PrintConstant(f'INDEXK(b)); else printf("-");  			 printf(" ");  			 if (ISK(c) != 0) PrintConstant(f'INDEXK(c)); else printf("-");  			}  			break;  		   case OpCode.OP_JMP:  		   case OpCode.OP_FORLOOP:  		   case OpCode.OP_FORPREP:  			printf("\t; to %d"'sbx+pc+2);  			break;  		   case OpCode.OP_CLOSURE:  			printf("\t; %p"'VOID(f.p[bx]));  			break;  		   case OpCode.OP_SETLIST:  			if (c==0) printf("\t; %d"'(int)code[++pc]);  			else printf("\t; %d"'c);  			break;  		   default:  			break;  		  }
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: return Convert.ToChar( Convert.ToByte( m.Groups[2].Value' 8 ) ).ToString();
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: return Convert.ToChar( Convert.ToByte( m.Groups[2].Value' 8 ) ).ToString();
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: m.Groups[2].Length == 3
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: m.Groups[2].Length == 3
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: string flags = m.Groups[2].Value;
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: m.Groups[2] != null && m.Groups[2].Value.Length > 0
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: m.Groups[2] != null && m.Groups[2].Value.Length > 0
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: fieldLength = Convert.ToInt32( m.Groups[3].Value );
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: flagZeroPadding = ( m.Groups[3].Value[0] == '0' );
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: m.Groups[3] != null && m.Groups[3].Value.Length > 0
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: m.Groups[3] != null && m.Groups[3].Value.Length > 0
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: fieldPrecision = Convert.ToInt32( m.Groups[4].Value );
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: m.Groups[4] != null && m.Groups[4].Value.Length > 0
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: m.Groups[4] != null && m.Groups[4].Value.Length > 0
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: shortLongIndicator = m.Groups[5].Value[0];
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: m.Groups[5] != null && m.Groups[5].Value.Length > 0
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: m.Groups[5] != null && m.Groups[5].Value.Length > 0
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: formatSpecifier = m.Groups[6].Value[0];
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: m.Groups[6] != null && m.Groups[6].Value.Length > 0
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: m.Groups[6] != null && m.Groups[6].Value.Length > 0
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: fieldPrecision = 6;
Magic Number,AT.MIN,Tools,D:\research\architectureSmells\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatOct,The following statement contains a magic number: w = Convert.ToString( UnboxToLong( Value' true )' 8 );
Missing Default,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,checkArgMode,The following switch statement is missing a default case: switch (mode) {  			case OpArgMask.OpArgN: if (r!=0) return 0; break;  			case OpArgMask.OpArgU: break;  			case OpArgMask.OpArgR: checkreg(pt' r); break;  			case OpArgMask.OpArgK:  			  if (!( (ISK(r) != 0) ? INDEXK(r) < pt.sizek : r < pt.maxstacksize)) return 0;  			  break;  		  }
Missing Default,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,symbexec,The following switch statement is missing a default case: switch (getOpMode(op)) {  			  case OpMode.iABC: {  				b = GETARG_B(i);  				c = GETARG_C(i);  				if (checkArgMode(pt' b' getBMode(op))==0) return 0;  				if (checkArgMode(pt' c' getCMode(op))==0) return 0;  				break;  			  }  			  case OpMode.iABx: {  				b = GETARG_Bx(i);  				if (getBMode(op) == OpArgMask.OpArgK) if (!(b < pt.sizek)) return 0;  				break;  			  }  			  case OpMode.iAsBx: {  				b = GETARG_sBx(i);  				if (getBMode(op) == OpArgMask.OpArgR) {  				  dest = pc+1+b;  				  if (!((0 <= dest && dest < pt.sizecode))) return 0;  				  if (dest > 0) {  					int j;  					/* check that it does not jump to a setlist count; this  					   is tricky' because the count from a previous setlist may  					   have the same value of an invalid setlist; so' we must  					   go all the way back to the first of them (if any) */  					for (j = 0; j < dest; j++) {  					  Instruction d = pt.code[dest-1-j];  					  if (!(GET_OPCODE(d) == OpCode.OP_SETLIST && GETARG_C(d) == 0)) break;  					}  					/* if 'j' is even' previous value is not a setlist (even if  					   it looks like one) */  					  if ((j&1)!=0) return 0;  				  }  				}  				break;  			  }  			}
Missing Default,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,luaD_seterrorobj,The following switch statement is missing a default case: switch (errcode) {  			case LUA_ERRMEM: {  			  setsvalue2s(L' oldtop' luaS_newliteral(L' MEMERRMSG));  			  break;  			}  			case LUA_ERRERR: {  			  setsvalue2s(L' oldtop' luaS_newliteral(L' "error in error handling"));  			  break;  			}  			case LUA_ERRSYNTAX:  			case LUA_ERRRUN: {  			  setobjs2s(L' oldtop' L.top-1);  /* error message on current top */  			  break;  			}  		  }
Missing Default,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,add_value,The following switch statement is missing a default case: switch (lua_type(L' 3)) {  			case LUA_TNUMBER:  			case LUA_TSTRING: {  			  add_s(ms' b' s' e);  			  return;  			}  			case LUA_TFUNCTION: {  			  int n;  			  lua_pushvalue(L' 3);  			  n = push_captures(ms' s' e);  			  lua_call(L' n' 1);  			  break;  			}  			case LUA_TTABLE: {  			  push_onecapture(ms' 0' s' e);  			  lua_gettable(L' 3);  			  break;  			}  		  }
Missing Default,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,parse_scanf,The following switch statement is missing a default case: switch (fmt[index++])  					{  						case 's':  							{  								argp[parm_index++] = str;  								break;  							}  						case 'c':  							{                                  argp[parm_index++] = Convert.ToChar(str' Culture("en-US"));  								break;  							}  						case 'd':  							{                                  argp[parm_index++] = Convert.ToInt32(str' Culture("en-US"));  								break;  							}  						case 'l':  							{                                  argp[parm_index++] = Convert.ToDouble(str' Culture("en-US"));  								break;  							}  						case 'f':  							{                                  argp[parm_index++] = Convert.ToDouble(str' Culture("en-US"));  								break;  							}  						//case 'p':  						//    {  						//        result += "(pointer)";  						//        break;  						//    }  					}
Missing Default,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,fopen,The following switch statement is missing a default case: switch (mode[i])  				{  					case 'r':   						fileaccess = fileaccess | FileAccess.Read;  						if (!File.Exists(str))  							return null;  						break;    					case 'w':  						filemode = FileMode.Create;  						fileaccess = fileaccess | FileAccess.Write;  						break;  				}
Missing Default,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,Dump,The following switch statement is missing a default case: switch (GET_OPCODE(i))  			{  				case OpCode.OP_CLOSE:  					Console.Write("{0}"' A);  					break;    				case OpCode.OP_MOVE:  				case OpCode.OP_LOADNIL:  				case OpCode.OP_GETUPVAL:  				case OpCode.OP_SETUPVAL:  				case OpCode.OP_UNM:  				case OpCode.OP_NOT:  				case OpCode.OP_RETURN:  					Console.Write("{0}' {1}"' A' B);  					break;    				case OpCode.OP_LOADBOOL:  				case OpCode.OP_GETTABLE:  				case OpCode.OP_SETTABLE:  				case OpCode.OP_NEWTABLE:  				case OpCode.OP_SELF:  				case OpCode.OP_ADD:  				case OpCode.OP_SUB:  				case OpCode.OP_MUL:  				case OpCode.OP_DIV:  				case OpCode.OP_POW:  				case OpCode.OP_CONCAT:  				case OpCode.OP_EQ:  				case OpCode.OP_LT:  				case OpCode.OP_LE:  				case OpCode.OP_TEST:  				case OpCode.OP_CALL:  				case OpCode.OP_TAILCALL:  					Console.Write("{0}' {1}' {2}"' A' B' C);  					break;    				case OpCode.OP_LOADK:					  					Console.Write("{0}' {1}"' A' Bx);  					break;    				case OpCode.OP_GETGLOBAL:  				case OpCode.OP_SETGLOBAL:  				case OpCode.OP_SETLIST:  				case OpCode.OP_CLOSURE:  					Console.Write("{0}' {1}"' A' Bx);  					break;    				case OpCode.OP_TFORLOOP:  					Console.Write("{0}' {1}"' A' C);  					break;    				case OpCode.OP_JMP:  				case OpCode.OP_FORLOOP:  				case OpCode.OP_FORPREP:  					Console.Write("{0}' {1}"' A' sBx);  					break;  			}
Missing Default,KopiLua,Lua,D:\research\architectureSmells\repos\gerich-home_kopilua\src\lapi.cs,PrintCode,The following switch statement is missing a default case: switch (getOpMode(o))  		  {  		   case OpMode.iABC:  			printf("%d"'a);  			if (getBMode(o) != OpArgMask.OpArgN) printf(" %d"' (ISK(b) != 0) ? (-1 - INDEXK(b)) : b);  			if (getCMode(o) != OpArgMask.OpArgN) printf(" %d"' (ISK(c) != 0) ? (-1 - INDEXK(c)) : c);  			break;  		   case OpMode.iABx:  			if (getBMode(o)==OpArgMask.OpArgK) printf("%d %d"'a'-1-bx); else printf("%d %d"'a'bx);  			break;  		   case OpMode.iAsBx:  			if (o==OpCode.OP_JMP) printf("%d"'sbx); else printf("%d %d"'a'sbx);  			break;  		  }
