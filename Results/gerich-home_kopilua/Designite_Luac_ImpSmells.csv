Implementation smell,Namespace,Class,File,Method,Description
Long Method,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The method has 266 lines of code.
Complex Method,KopiLua,Program,C:\repos\gerich-home_kopilua\luac.cs,doargs,Cyclomatic complexity of the method is 17
Complex Method,KopiLua,Program,C:\repos\gerich-home_kopilua\luac.cs,pmain,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_getmetatable,Cyclomatic complexity of the method is 10
Complex Method,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_getfenv,Cyclomatic complexity of the method is 12
Complex Method,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_setmetatable,Cyclomatic complexity of the method is 9
Complex Method,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_setfenv,Cyclomatic complexity of the method is 13
Complex Method,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_gc,Cyclomatic complexity of the method is 22
Complex Method,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,IsPositive,Cyclomatic complexity of the method is 13
Complex Method,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ToUnsigned,Cyclomatic complexity of the method is 12
Complex Method,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ToInteger,Cyclomatic complexity of the method is 12
Complex Method,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,UnboxToLong,Cyclomatic complexity of the method is 12
Complex Method,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,Cyclomatic complexity of the method is 9
Complex Method,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,Cyclomatic complexity of the method is 96
Long Parameter List,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatOct,The method has 7 parameters.
Long Parameter List,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatHex,The method has 7 parameters.
Long Parameter List,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatNumber,The method has 9 parameters.
Long Statement,KopiLua,Program,C:\repos\gerich-home_kopilua\luac.cs,usage,The length of the statement  "	Lua.fprintf (Lua.stderr' "usage: %s [options] [filenames].\n" + "Available options are:\n" + "  -        process stdin\n" + "  -l       list\n" + "  -o name  output to file " + Lua.LUA_QL ("name") + " (default is \"%s\")\n" + "  -p       parse only\n" + "  -s       strip debug information\n" + "  -v       show version information\n" + "  --       stop handling options\n"' progname' Output); " is 393.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,IsNumericType,The length of the statement  "	return (o is byte || o is sbyte || o is short || o is ushort || o is int || o is uint || o is long || o is ulong || o is float || o is double || o is decimal); " is 159.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "		if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o') " is 154.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "			w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o); " is 168.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "			w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o)); " is 158.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "			string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}"; " is 143.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "			w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o); " is 170.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "			w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o); " is 141.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "			w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o); " is 141.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "			w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o); " is 141.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "			w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o); " is 141.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The length of the statement  "			w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index); " is 145.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatOct,The length of the statement  "	string lengthFormat = "{0" + (FieldLength != int.MinValue ? "'" + (Left2Right ? "-" : String.Empty) + FieldLength.ToString () : String.Empty) + "}"; " is 148.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatHex,The length of the statement  "	string lengthFormat = "{0" + (FieldLength != int.MinValue ? "'" + (Left2Right ? "-" : String.Empty) + FieldLength.ToString () : String.Empty) + "}"; " is 148.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatHex,The length of the statement  "	string numberFormat = "{0:" + NativeFormat + (FieldPrecision != int.MinValue ? FieldPrecision.ToString () : String.Empty) + "}"; " is 128.
Long Statement,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatNumber,The length of the statement  "	string lengthFormat = "{0" + (FieldLength != int.MinValue ? "'" + (Left2Right ? "-" : String.Empty) + FieldLength.ToString () : String.Empty) + "}"; " is 148.
Complex Conditional,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The conditional expression  "fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o'"  is complex.
Magic Number,KopiLua,Program,C:\repos\gerich-home_kopilua\luac.cs,combine,The following statement contains a magic number: if (n == 1)  	return toproto (L' -1);  else {  	int i' pc;  	Lua.Proto f = Lua.luaF_newproto (L);  	Lua.setptvalue2s (L' L.top' f);  	Lua.incr_top (L);  	f.source = Lua.luaS_newliteral (L' "=(" + PROGNAME + ")");  	f.maxstacksize = 1;  	pc = 2 * n + 1;  	f.code = (Instruction[])Lua.luaM_newvector<Instruction> (L' pc);  	f.sizecode = pc;  	f.p = Lua.luaM_newvector<Lua.Proto> (L' n);  	f.sizep = n;  	pc = 0;  	for (i = 0; i < n; i++) {  		f.p [i] = toproto (L' i - n - 1);  		f.code [pc++] = (uint)Lua.CREATE_ABx (Lua.OpCode.OP_CLOSURE' 0' i);  		f.code [pc++] = (uint)Lua.CREATE_ABC (Lua.OpCode.OP_CALL' 0' 1' 1);  	}  	f.code [pc++] = (uint)Lua.CREATE_ABC (Lua.OpCode.OP_RETURN' 0' 1' 0);  	return f;  }  
Magic Number,KopiLua,Program,C:\repos\gerich-home_kopilua\luac.cs,combine,The following statement contains a magic number: pc = 2 * n + 1;  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_settable,The following statement contains a magic number: api_checknelems (L' 2);  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_settable,The following statement contains a magic number: luaV_settable (L' t' L.top - 2' L.top - 1);  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_settable,The following statement contains a magic number: L.top -= 2;  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_rawset,The following statement contains a magic number: api_checknelems (L' 2);  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_rawset,The following statement contains a magic number: setobj2t (L' luaH_set (L' hvalue (t)' L.top - 2)' L.top - 1);  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_rawset,The following statement contains a magic number: L.top -= 2;  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,f_Ccall,The following statement contains a magic number: luaD_call (L' L.top - 2' 0);  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_gc,The following statement contains a magic number: switch (what) {  case LUA_GCSTOP: {  	g.GCthreshold = MAX_LUMEM;  	break;  }  case LUA_GCRESTART: {  	g.GCthreshold = g.totalbytes;  	break;  }  case LUA_GCCOLLECT: {  	luaC_fullgc (L);  	break;  }  case LUA_GCCOUNT: {  	/* GC values are expressed in Kbytes: #bytes/2^10 */res = cast_int (g.totalbytes >> 10);  	break;  }  case LUA_GCCOUNTB: {  	res = cast_int (g.totalbytes & 0x3ff);  	break;  }  case LUA_GCSTEP: {  	lu_mem a = ((lu_mem)data << 10);  	if (a <= g.totalbytes)  		g.GCthreshold = (uint)(g.totalbytes - a);  	else  		g.GCthreshold = 0;  	while (g.GCthreshold <= g.totalbytes) {  		luaC_step (L);  		if (g.gcstate == GCSpause) {  			/* end of cycle? */res = 1;  			/* signal it */break;  		}  	}  	break;  }  case LUA_GCSETPAUSE: {  	res = g.gcpause;  	g.gcpause = data;  	break;  }  case LUA_GCSETSTEPMUL: {  	res = g.gcstepmul;  	g.gcstepmul = data;  	break;  }  default:  	res = -1;  	/* invalid option */break;  }  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_gc,The following statement contains a magic number: switch (what) {  case LUA_GCSTOP: {  	g.GCthreshold = MAX_LUMEM;  	break;  }  case LUA_GCRESTART: {  	g.GCthreshold = g.totalbytes;  	break;  }  case LUA_GCCOLLECT: {  	luaC_fullgc (L);  	break;  }  case LUA_GCCOUNT: {  	/* GC values are expressed in Kbytes: #bytes/2^10 */res = cast_int (g.totalbytes >> 10);  	break;  }  case LUA_GCCOUNTB: {  	res = cast_int (g.totalbytes & 0x3ff);  	break;  }  case LUA_GCSTEP: {  	lu_mem a = ((lu_mem)data << 10);  	if (a <= g.totalbytes)  		g.GCthreshold = (uint)(g.totalbytes - a);  	else  		g.GCthreshold = 0;  	while (g.GCthreshold <= g.totalbytes) {  		luaC_step (L);  		if (g.gcstate == GCSpause) {  			/* end of cycle? */res = 1;  			/* signal it */break;  		}  	}  	break;  }  case LUA_GCSETPAUSE: {  	res = g.gcpause;  	g.gcpause = data;  	break;  }  case LUA_GCSETSTEPMUL: {  	res = g.gcstepmul;  	g.gcstepmul = data;  	break;  }  default:  	res = -1;  	/* invalid option */break;  }  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_gc,The following statement contains a magic number: res = cast_int (g.totalbytes >> 10);  
Magic Number,KopiLua,Lua,C:\repos\gerich-home_kopilua\src\lapi.cs,lua_concat,The following statement contains a magic number: if (n >= 2) {  	luaC_checkGC (L);  	luaV_concat (L' n' cast_int (L.top - L.base_) - 1);  	L.top -= (n - 1);  }  else if (n == 0) {  	/* push empty string */setsvalue2s (L' L.top' luaS_newlstr (L' ""' 0));  	api_incr_top (L);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups [2].Length == 3)  	return Convert.ToChar (Convert.ToByte (m.Groups [2].Value' 8)).ToString ();  else {  	// convert all other special meta characters  	//TODO: \xhhh hex and possible dec !!  	switch (m.Groups [2].Value) {  	case "0":  		// null  		return "\0";  	case "a":  		// alert (beep)  		return "\a";  	case "b":  		// BS  		return "\b";  	case "f":  		// FF  		return "\f";  	case "v":  		// vertical tab  		return "\v";  	case "r":  		// CR  		return "\r";  	case "n":  		// LF  		return "\n";  	case "t":  		// Tab  		return "\t";  	default:  		// if neither an octal quote nor a special meta character  		// so just remove the backslash  		return m.Groups [2].Value;  	}  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups [2].Length == 3)  	return Convert.ToChar (Convert.ToByte (m.Groups [2].Value' 8)).ToString ();  else {  	// convert all other special meta characters  	//TODO: \xhhh hex and possible dec !!  	switch (m.Groups [2].Value) {  	case "0":  		// null  		return "\0";  	case "a":  		// alert (beep)  		return "\a";  	case "b":  		// BS  		return "\b";  	case "f":  		// FF  		return "\f";  	case "v":  		// vertical tab  		return "\v";  	case "r":  		// CR  		return "\r";  	case "n":  		// LF  		return "\n";  	case "t":  		// Tab  		return "\t";  	default:  		// if neither an octal quote nor a special meta character  		// so just remove the backslash  		return m.Groups [2].Value;  	}  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups [2].Length == 3)  	return Convert.ToChar (Convert.ToByte (m.Groups [2].Value' 8)).ToString ();  else {  	// convert all other special meta characters  	//TODO: \xhhh hex and possible dec !!  	switch (m.Groups [2].Value) {  	case "0":  		// null  		return "\0";  	case "a":  		// alert (beep)  		return "\a";  	case "b":  		// BS  		return "\b";  	case "f":  		// FF  		return "\f";  	case "v":  		// vertical tab  		return "\v";  	case "r":  		// CR  		return "\r";  	case "n":  		// LF  		return "\n";  	case "t":  		// Tab  		return "\t";  	default:  		// if neither an octal quote nor a special meta character  		// so just remove the backslash  		return m.Groups [2].Value;  	}  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups [2].Length == 3)  	return Convert.ToChar (Convert.ToByte (m.Groups [2].Value' 8)).ToString ();  else {  	// convert all other special meta characters  	//TODO: \xhhh hex and possible dec !!  	switch (m.Groups [2].Value) {  	case "0":  		// null  		return "\0";  	case "a":  		// alert (beep)  		return "\a";  	case "b":  		// BS  		return "\b";  	case "f":  		// FF  		return "\f";  	case "v":  		// vertical tab  		return "\v";  	case "r":  		// CR  		return "\r";  	case "n":  		// LF  		return "\n";  	case "t":  		// Tab  		return "\t";  	default:  		// if neither an octal quote nor a special meta character  		// so just remove the backslash  		return m.Groups [2].Value;  	}  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups [2].Length == 3)  	return Convert.ToChar (Convert.ToByte (m.Groups [2].Value' 8)).ToString ();  else {  	// convert all other special meta characters  	//TODO: \xhhh hex and possible dec !!  	switch (m.Groups [2].Value) {  	case "0":  		// null  		return "\0";  	case "a":  		// alert (beep)  		return "\a";  	case "b":  		// BS  		return "\b";  	case "f":  		// FF  		return "\f";  	case "v":  		// vertical tab  		return "\v";  	case "r":  		// CR  		return "\r";  	case "n":  		// LF  		return "\n";  	case "t":  		// Tab  		return "\t";  	default:  		// if neither an octal quote nor a special meta character  		// so just remove the backslash  		return m.Groups [2].Value;  	}  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups [2].Length == 3)  	return Convert.ToChar (Convert.ToByte (m.Groups [2].Value' 8)).ToString ();  else {  	// convert all other special meta characters  	//TODO: \xhhh hex and possible dec !!  	switch (m.Groups [2].Value) {  	case "0":  		// null  		return "\0";  	case "a":  		// alert (beep)  		return "\a";  	case "b":  		// BS  		return "\b";  	case "f":  		// FF  		return "\f";  	case "v":  		// vertical tab  		return "\v";  	case "r":  		// CR  		return "\r";  	case "n":  		// LF  		return "\n";  	case "t":  		// Tab  		return "\t";  	default:  		// if neither an octal quote nor a special meta character  		// so just remove the backslash  		return m.Groups [2].Value;  	}  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: return Convert.ToChar (Convert.ToByte (m.Groups [2].Value' 8)).ToString ();  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: return Convert.ToChar (Convert.ToByte (m.Groups [2].Value' 8)).ToString ();  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: switch (m.Groups [2].Value) {  case "0":  	// null  	return "\0";  case "a":  	// alert (beep)  	return "\a";  case "b":  	// BS  	return "\b";  case "f":  	// FF  	return "\f";  case "v":  	// vertical tab  	return "\v";  case "r":  	// CR  	return "\r";  case "n":  	// LF  	return "\n";  case "t":  	// Tab  	return "\t";  default:  	// if neither an octal quote nor a special meta character  	// so just remove the backslash  	return m.Groups [2].Value;  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: switch (m.Groups [2].Value) {  case "0":  	// null  	return "\0";  case "a":  	// alert (beep)  	return "\a";  case "b":  	// BS  	return "\b";  case "f":  	// FF  	return "\f";  case "v":  	// vertical tab  	return "\v";  case "r":  	// CR  	return "\r";  case "n":  	// LF  	return "\n";  case "t":  	// Tab  	return "\t";  default:  	// if neither an octal quote nor a special meta character  	// so just remove the backslash  	return m.Groups [2].Value;  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: return m.Groups [2].Value;  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success) {  	#region parameter index  	paramIx = defaultParamIx;  	if (m.Groups [1] != null && m.Groups [1].Value.Length > 0) {  		string val = m.Groups [1].Value.Substring (0' m.Groups [1].Value.Length - 1);  		paramIx = Convert.ToInt32 (val) - 1;  	}  	;  	#endregion  	#region format flags  	// extract format flags  	flagAlternate = false;  	flagLeft2Right = false;  	flagPositiveSign = false;  	flagPositiveSpace = false;  	flagZeroPadding = false;  	flagGroupThousands = false;  	if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  		string flags = m.Groups [2].Value;  		flagAlternate = (flags.IndexOf ('#') >= 0);  		flagLeft2Right = (flags.IndexOf ('-') >= 0);  		flagPositiveSign = (flags.IndexOf ('+') >= 0);  		flagPositiveSpace = (flags.IndexOf (' ') >= 0);  		flagGroupThousands = (flags.IndexOf ('\'') >= 0);  		// positive + indicator overrides a  		// positive space character  		if (flagPositiveSign && flagPositiveSpace)  			flagPositiveSpace = false;  	}  	#endregion  	#region field length  	// extract field length and   	// pading character  	paddingCharacter = ' ';  	fieldLength = int.MinValue;  	if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  		fieldLength = Convert.ToInt32 (m.Groups [3].Value);  		flagZeroPadding = (m.Groups [3].Value [0] == '0');  	}  	#endregion  	if (flagZeroPadding)  		paddingCharacter = '0';  	// left2right allignment overrides zero padding  	if (flagLeft2Right && flagZeroPadding) {  		flagZeroPadding = false;  		paddingCharacter = ' ';  	}  	#region field precision  	// extract field precision  	fieldPrecision = int.MinValue;  	if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  		fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  	#endregion  	#region short / long indicator  	// extract short / long indicator  	shortLongIndicator = Char.MinValue;  	if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  		shortLongIndicator = m.Groups [5].Value [0];  	#endregion  	#region format specifier  	// extract format  	formatSpecifier = Char.MinValue;  	if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  		formatSpecifier = m.Groups [6].Value [0];  	#endregion  	// default precision is 6 digits if none is specified except  	if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  		fieldPrecision = 6;  	#region get next value parameter  	// get next value parameter and convert value parameter depending on short / long indicator  	if (Parameters == null || paramIx >= Parameters.Length)  		o = null;  	else {  		o = Parameters [paramIx];  		if (shortLongIndicator == 'h') {  			if (o is int)  				o = (short)((int)o);  			else if (o is long)  				o = (short)((long)o);  			else if (o is uint)  				o = (ushort)((uint)o);  			else if (o is ulong)  				o = (ushort)((ulong)o);  		}  		else if (shortLongIndicator == 'l') {  			if (o is short)  				o = (long)((short)o);  			else if (o is int)  				o = (long)((int)o);  			else if (o is ushort)  				o = (ulong)((ushort)o);  			else if (o is uint)  				o = (ulong)((uint)o);  		}  	}  	#endregion  	// convert value parameters to a string depending on the formatSpecifier  	w = String.Empty;  	switch (formatSpecifier) {  	#region % - character  	case '%':  		// % character  		w = "%";  		break;  	#endregion  	#region d - integer  	case 'd':  		// integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region i - integer  	case 'i':  		// integer  		goto case 'd';  	#endregion  	#region o - octal integer  	case 'o':  		// octal integer - no leading zero  		w = FormatOct ("o"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region x - hex integer  	case 'x':  		// hex integer - no leading zero  		w = FormatHex ("x"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region X - hex integer  	case 'X':  		// same as x but with capital hex characters  		w = FormatHex ("X"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region u - unsigned integer  	case 'u':  		// unsigned integer  		w = FormatNumber ((flagGroupThousands ? "n" : "d")' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' false' false' paddingCharacter' ToUnsigned (o));  		defaultParamIx++;  		break;  	#endregion  	#region c - character  	case 'c':  		// character  		if (IsNumericType (o))  			w = Convert.ToChar (o).ToString ();  		else if (o is char)  			w = ((char)o).ToString ();  		else if (o is string && ((string)o).Length > 0)  			w = ((string)o) [0].ToString ();  		defaultParamIx++;  		break;  	#endregion  	#region s - string  	case 's':  		// string  		string t = "{0" + (fieldLength != int.MinValue ? "'" + (flagLeft2Right ? "-" : String.Empty) + fieldLength.ToString () : String.Empty) + ":s}";  		w = o.ToString ();  		if (fieldPrecision >= 0)  			w = w.Substring (0' fieldPrecision);  		if (fieldLength != int.MinValue)  			if (flagLeft2Right)  				w = w.PadRight (fieldLength' paddingCharacter);  			else  				w = w.PadLeft (fieldLength' paddingCharacter);  		defaultParamIx++;  		break;  	#endregion  	#region f - double number  	case 'f':  		// double  		w = FormatNumber ((flagGroupThousands ? "n" : "f")' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region e - exponent number  	case 'e':  		// double / exponent  		w = FormatNumber ("e"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region E - exponent number  	case 'E':  		// double / exponent  		w = FormatNumber ("E"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region g - general number  	case 'g':  		// double / exponent  		w = FormatNumber ("g"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region G - general number  	case 'G':  		// double / exponent  		w = FormatNumber ("G"' flagAlternate' fieldLength' fieldPrecision' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' o);  		defaultParamIx++;  		break;  	#endregion  	#region p - pointer  	case 'p':  		// pointer  		if (o is IntPtr)  			#if XBOX || SILVERLIGHT  										w = ( (IntPtr)o ).ToString(); #else  			w = "0x" + ((IntPtr)o).ToString ("x");  		#endif  		defaultParamIx++;  		break;  	#endregion  	#region n - number of processed chars so far  	case 'n':  		// number of characters so far  		w = FormatNumber ("d"' flagAlternate' fieldLength' int.MinValue' flagLeft2Right' flagPositiveSign' flagPositiveSpace' paddingCharacter' m.Index);  		break;  	#endregion  	default:  		w = String.Empty;  		defaultParamIx++;  		break;  	}  	// replace format parameter with parameter value  	// and start searching for the next format parameter  	// AFTER the position of the current inserted value  	// to prohibit recursive matches if the value also  	// includes a format specifier  	f.Remove (m.Index' m.Length);  	f.Insert (m.Index' w);  	m = r.Match (f.ToString ()' m.Index + w.Length);  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  	string flags = m.Groups [2].Value;  	flagAlternate = (flags.IndexOf ('#') >= 0);  	flagLeft2Right = (flags.IndexOf ('-') >= 0);  	flagPositiveSign = (flags.IndexOf ('+') >= 0);  	flagPositiveSpace = (flags.IndexOf (' ') >= 0);  	flagGroupThousands = (flags.IndexOf ('\'') >= 0);  	// positive + indicator overrides a  	// positive space character  	if (flagPositiveSign && flagPositiveSpace)  		flagPositiveSpace = false;  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  	string flags = m.Groups [2].Value;  	flagAlternate = (flags.IndexOf ('#') >= 0);  	flagLeft2Right = (flags.IndexOf ('-') >= 0);  	flagPositiveSign = (flags.IndexOf ('+') >= 0);  	flagPositiveSpace = (flags.IndexOf (' ') >= 0);  	flagGroupThousands = (flags.IndexOf ('\'') >= 0);  	// positive + indicator overrides a  	// positive space character  	if (flagPositiveSign && flagPositiveSpace)  		flagPositiveSpace = false;  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [2] != null && m.Groups [2].Value.Length > 0) {  	string flags = m.Groups [2].Value;  	flagAlternate = (flags.IndexOf ('#') >= 0);  	flagLeft2Right = (flags.IndexOf ('-') >= 0);  	flagPositiveSign = (flags.IndexOf ('+') >= 0);  	flagPositiveSpace = (flags.IndexOf (' ') >= 0);  	flagGroupThousands = (flags.IndexOf ('\'') >= 0);  	// positive + indicator overrides a  	// positive space character  	if (flagPositiveSign && flagPositiveSpace)  		flagPositiveSpace = false;  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  	fieldLength = Convert.ToInt32 (m.Groups [3].Value);  	flagZeroPadding = (m.Groups [3].Value [0] == '0');  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  	fieldLength = Convert.ToInt32 (m.Groups [3].Value);  	flagZeroPadding = (m.Groups [3].Value [0] == '0');  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  	fieldLength = Convert.ToInt32 (m.Groups [3].Value);  	flagZeroPadding = (m.Groups [3].Value [0] == '0');  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [3] != null && m.Groups [3].Value.Length > 0) {  	fieldLength = Convert.ToInt32 (m.Groups [3].Value);  	flagZeroPadding = (m.Groups [3].Value [0] == '0');  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: fieldLength = Convert.ToInt32 (m.Groups [3].Value);  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: flagZeroPadding = (m.Groups [3].Value [0] == '0');  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  	fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  	fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [4] != null && m.Groups [4].Value.Length > 0)  	fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: fieldPrecision = Convert.ToInt32 (m.Groups [4].Value);  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  	shortLongIndicator = m.Groups [5].Value [0];  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  	shortLongIndicator = m.Groups [5].Value [0];  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [5] != null && m.Groups [5].Value.Length > 0)  	shortLongIndicator = m.Groups [5].Value [0];  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: shortLongIndicator = m.Groups [5].Value [0];  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  	formatSpecifier = m.Groups [6].Value [0];  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  	formatSpecifier = m.Groups [6].Value [0];  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (m.Groups [6] != null && m.Groups [6].Value.Length > 0)  	formatSpecifier = m.Groups [6].Value [0];  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: formatSpecifier = m.Groups [6].Value [0];  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: if (fieldPrecision == int.MinValue && formatSpecifier != 's' && formatSpecifier != 'c' && Char.ToUpper (formatSpecifier) != 'X' && formatSpecifier != 'o')  	fieldPrecision = 6;  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,sprintf,The following statement contains a magic number: fieldPrecision = 6;  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatOct,The following statement contains a magic number: if (IsNumericType (Value)) {  	w = Convert.ToString (UnboxToLong (Value' true)' 8);  	if (Left2Right || Padding == ' ') {  		if (Alternate && w != "0")  			w = "0" + w;  		w = String.Format (lengthFormat' w);  	}  	else {  		if (FieldLength != int.MinValue)  			w = w.PadLeft (FieldLength - (Alternate && w != "0" ? 1 : 0)' Padding);  		if (Alternate && w != "0")  			w = "0" + w;  	}  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatOct,The following statement contains a magic number: w = Convert.ToString (UnboxToLong (Value' true)' 8);  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatHex,The following statement contains a magic number: if (IsNumericType (Value)) {  	w = String.Format (numberFormat' Value);  	if (Left2Right || Padding == ' ') {  		if (Alternate)  			w = (NativeFormat == "x" ? "0x" : "0X") + w;  		w = String.Format (lengthFormat' w);  	}  	else {  		if (FieldLength != int.MinValue)  			w = w.PadLeft (FieldLength - (Alternate ? 2 : 0)' Padding);  		if (Alternate)  			w = (NativeFormat == "x" ? "0x" : "0X") + w;  	}  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatHex,The following statement contains a magic number: if (Left2Right || Padding == ' ') {  	if (Alternate)  		w = (NativeFormat == "x" ? "0x" : "0X") + w;  	w = String.Format (lengthFormat' w);  }  else {  	if (FieldLength != int.MinValue)  		w = w.PadLeft (FieldLength - (Alternate ? 2 : 0)' Padding);  	if (Alternate)  		w = (NativeFormat == "x" ? "0x" : "0X") + w;  }  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatHex,The following statement contains a magic number: if (FieldLength != int.MinValue)  	w = w.PadLeft (FieldLength - (Alternate ? 2 : 0)' Padding);  
Magic Number,AT.MIN,Tools,C:\repos\gerich-home_kopilua\src\printf\Tools.cs,FormatHex,The following statement contains a magic number: w = w.PadLeft (FieldLength - (Alternate ? 2 : 0)' Padding);  
