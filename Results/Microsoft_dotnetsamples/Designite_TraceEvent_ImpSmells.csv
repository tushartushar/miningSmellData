Implementation smell,Namespace,Class,File,Method,Description
Long Method,TraceEventSamples,SimpleEventSourceMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\10_SimpleEventSourceMonitor.cs,Run,The method has 125 lines of code.
Long Method,TraceEventSamples,KernelAndClrMonitorWin7,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\33_KernelAndClrMonitorWin7.cs,Run,The method has 102 lines of code.
Long Method,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The method has 118 lines of code.
Long Method,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,Run,The method has 103 lines of code.
Long Statement,TraceEventSamples,SimpleEventSourceMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\10_SimpleEventSourceMonitor.cs,Run,The length of the statement  "                // Hook up events.   To so this first we need a 'Parser. which knows how to part the events of a particular Event Provider. " is 123.
Long Statement,TraceEventSamples,SimpleEventSourceMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\10_SimpleEventSourceMonitor.cs,Run,The length of the statement  "                session.Source.Dynamic.AddCallbackForProviderEvent("Microsoft-Demos-SimpleMonitor"' "MyFirstEvent"' delegate(TraceEvent data) " is 125.
Long Statement,TraceEventSamples,SimpleEventSourceMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\10_SimpleEventSourceMonitor.cs,Run,The length of the statement  "                session.Source.Dynamic.AddCallbackForProviderEvent("Microsoft-Demos-SimpleMonitor"' "MySecondEvent"' delegate(TraceEvent data) " is 126.
Long Statement,TraceEventSamples,SimpleEventSourceMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\10_SimpleEventSourceMonitor.cs,Run,The length of the statement  "                // The callback above will only be called for events the parser recognizes (in the case of DynamicTraceEventParser' EventSources) " is 129.
Long Statement,TraceEventSamples,SimpleEventSourceMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\10_SimpleEventSourceMonitor.cs,Run,The length of the statement  "                // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you  " is 125.
Long Statement,TraceEventSamples,SimpleEventSourceFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\11_SimpleEventSourceFile.cs,CollectData,The length of the statement  "            using (var session = new TraceEventSession(sessionName' dataFileName))      // Since we give it a file name' the data goes there.    " is 129.
Long Statement,TraceEventSamples,SimpleEventSourceFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\11_SimpleEventSourceFile.cs,ProcessData,The length of the statement  "                // Hook up events.   To so this first we need a 'Parser. which knows how to part the events of a particular Event Provider. " is 123.
Long Statement,TraceEventSamples,ObserveGCEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\20_ObserveGCEvent.cs,Run,The length of the statement  "                    Out.WriteLine("GC Alloc  :  Proc: {0'10} Amount: {1'6:f1}K  TypeSample: {2}"' GetProcessName(allocData.ProcessID)' allocData.AllocationAmount / 1000.0' allocData.TypeName)); " is 173.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The length of the statement  "                userSession.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)(ClrTraceEventParser.Keywords.Default)); " is 133.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The length of the statement  "                IObservable<MethodJittingStartedTraceData> jitStartStream = userSession.Source.Clr.Observe<MethodJittingStartedTraceData>("Method/JittingStarted"); " is 147.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The length of the statement  "                IObservable<MethodLoadUnloadVerboseTraceData> jitEndStream = userSession.Source.Clr.Observe<MethodLoadUnloadVerboseTraceData>("Method/LoadVerbose"); " is 148.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The length of the statement  "                // Compute the stream of matched-up pairs' and for each create a tuple of the start event and the time between the pair of events.   " is 130.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The length of the statement  "                // Note that the 'Take(1)' is pretty important because a nested 'from' statement logically creates the 'cross product' of a two streams " is 135.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The length of the statement  "                // In this case the stream of starts and the stream of ends).   Because we filter this stream only to matching entities and then only " is 133.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The length of the statement  "                // take the first entry' we stop waiting.   Thus we only 'remember' those 'starts' that are not yet matched' which is very important " is 132.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The length of the statement  "                // for efficiency.   Note that any 'lost' end events will never be matched and will accumulate over time' slowing things down. " is 126.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The length of the statement  "                jitTimes.Subscribe(onNext: jitData => Out.WriteLine("JIT_TIME: {0'7:f2} PROC: {1'10} METHOD: {2}"' jitData.JitTIme' GetProcessName(jitData.ProcessID)' jitData.Name)); " is 166.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The length of the statement  "                // unhandledEventStream.Subscribe(onNext: ev => Out.WriteLine("UNHANDLED :  PID: {0'5} {1}/{2} "' ev.ProcessID' ev.ProviderName' ev.EventName)); " is 144.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,ComputeRunningStats,The length of the statement  "                             new { curCount = 0' curSum = 0.0' curSumSquares = 0.0' curMin = double.PositiveInfinity' curMax = double.NegativeInfinity }' " is 124.
Long Statement,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,ComputeRunningStats,The length of the statement  "                            Deviation = Math.Sqrt((accum.curCount * accum.curSumSquares - accum.curSum * accum.curSum) / (accum.curCount * accum.curCount - 1))' " is 132.
Long Statement,TraceEventSamples,Statistics,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,ToString,The length of the statement  "{ return string.Format("STATS: count {0} avg {1:F1}. stddev {2:F1}. min {3:F1}. max {4:F1}."' Count' Average' Deviation' Min' Max); }" is 133.
Long Statement,TraceEventSamples,ObserveEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\22_ObserveEventSource.cs,Run,The length of the statement  "                IObservable<TraceEvent> firstEventStream = userSession.Source.Dynamic.Observe("Microsoft-Demos-SimpleMonitor"' "MyFirstEvent"); " is 127.
Long Statement,TraceEventSamples,ObserveEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\22_ObserveEventSource.cs,Run,The length of the statement  "                firstEventStream.Subscribe(onNext: ev => Out.WriteLine("FIRST_EVENTS :  MyName: '{0}' MyId: {1}"' ev.PayloadByName("MyName")' ev.PayloadByName("MyId"))); " is 153.
Long Statement,TraceEventSamples,ObserveEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\22_ObserveEventSource.cs,Run,The length of the statement  "                IObservable<TraceEvent> secondEventStream = userSession.Source.Dynamic.Observe("Microsoft-Demos-SimpleMonitor"' "MySecondEvent"); " is 129.
Long Statement,TraceEventSamples,ObserveEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\22_ObserveEventSource.cs,Run,The length of the statement  "                // It is also useful for debugging purposes to see any events that entered by were not handled by any parser.   These can be bugs.   " is 130.
Long Statement,TraceEventSamples,ModuleLoadMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\30_MonitorLoads.cs,Run,The length of the statement  "                    cancelArgs.Cancel = true;                   // This says don't abort' since Process() will return we can terminate nicely.    " is 122.
Long Statement,TraceEventSamples,ModuleLoadMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\30_MonitorLoads.cs,Run,The length of the statement  "                // Enable the Kernel events that we want.   At this point data is being collected (but being buffered since we are not reading it) " is 130.
Long Statement,TraceEventSamples,ModuleLoadMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\30_MonitorLoads.cs,Run,The length of the statement  "                // .ImageLoad is an event that you can subscribe to that will be called back when Image load events happen (complete with parsed event) " is 135.
Long Statement,TraceEventSamples,KernelAndClrFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\32_KernelAndClrFile.cs,DataProcessing,The length of the statement  "                // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you  " is 125.
Long Statement,TraceEventSamples,KernelAndClrFileWin7,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\34_KernelAndClrFileWin7.cs,DataProcessing,The length of the statement  "                // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you  " is 125.
Long Statement,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,CollectData,The length of the statement  "            using (var session = new TraceEventSession(sessionName' dataFileName))      // Since we give it a file name' the data goes there.  " is 129.
Long Statement,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,CollectData,The length of the statement  "            using (var kernelSession = new TraceEventSession(KernelTraceEventParser.KernelSessionName' Path.ChangeExtension(dataFileName' ".kernel.etl"))) " is 142.
Long Statement,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,CollectData,The length of the statement  "                Console.CancelKeyPress += delegate(object sender' ConsoleCancelEventArgs e) { session.Dispose(); kernelSession.Dispose(); }; " is 124.
Long Statement,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,CollectData,The length of the statement  "                kernelSession.EnableKernelProvider(KernelTraceEventParser.Keywords.ImageLoad | KernelTraceEventParser.Keywords.Process | KernelTraceEventParser.Keywords.Thread); " is 161.
Long Statement,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,CollectData,The length of the statement  "                session.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)ClrTraceEventParser.Keywords.Default); " is 127.
Long Statement,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,CollectData,The length of the statement  "                    rundownSession.EnableProvider(ClrRundownTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)ClrRundownTraceEventParser.Keywords.Default); " is 148.
Long Statement,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,ProcessData,The length of the statement  "            silentSymbolReader.Options = SymbolReaderOptions.CacheOnly;     // don't try to look things up on the network for source  " is 120.
Long Statement,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,ProcessData,The length of the statement  "            silentSymbolReader.SecurityCheck = (pdbPath) => true;           // for this demo we trust any pdb location.   This lets us find the PDB of the demo itself " is 154.
Long Statement,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,ProcessData,The length of the statement  "                Out.WriteLine("Found an EXCEPTION event in SimpleTraceLog: Type: {0} Message: {1}"' exceptionData.ExceptionType' exceptionData.ExceptionMessage); " is 145.
Long Statement,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,PrintStack,The length of the statement  "                        lineInfo = string.Format("  AT: {0}({1})"' Path.GetFileName(sourceLocation.SourceFile.BuildTimeFilePath)' sourceLocation.LineNumber); " is 133.
Long Statement,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The length of the statement  "                    // KernelTraceEventParser.Keywords.Thread |             // If you want context switch events you also need thread start events.   " is 127.
Long Statement,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The length of the statement  "                    KernelTraceEventParser.Keywords.Process'   /****** The second parameter indicates which kernel events should have stacks *****/ " is 127.
Long Statement,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The length of the statement  "                    (ulong)(ClrTraceEventParser.Keywords.Jit |              // Turning on JIT events is necessary to resolve JIT compiled code  " is 122.
Long Statement,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The length of the statement  "                    ClrTraceEventParser.Keywords.JittedMethodILToNativeMap | // This is needed if you want line number information in the stacks " is 124.
Long Statement,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The length of the statement  "                    ClrTraceEventParser.Keywords.Loader |                   // You must include loader events as well to resolve JIT compiled code.  " is 127.
Long Statement,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The length of the statement  "                    ClrTraceEventParser.Keywords.JittedMethodILToNativeMap | // This is needed if you want line number information in the stacks " is 124.
Long Statement,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The length of the statement  "                    // We use this action in the particular callbacks below.  Basically we pass in a symbol reader so we can decode the stack.   " is 122.
Long Statement,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The length of the statement  "                    // If you want to see stacks for various other kernel events' uncomment these (you also need to turn on the events above) " is 121.
Long Statement,TraceEventSamples,SimpleFileRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\50_SimpleFileRelogger.cs,DataProcessing,The length of the statement  "                // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you  " is 125.
Long Statement,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,Run,The length of the statement  "                session.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)ClrTraceEventParser.Keywords.Default); " is 127.
Long Statement,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,Run,The length of the statement  "                Out.WriteLine("The monitor will run for a maximum of {0} seconds.  Run managed code for more output."' monitoringTimeSec); " is 122.
Long Statement,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,DataProcessing,The length of the statement  "                // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you  " is 125.
Empty Catch Block,TraceEventSamples,ObserveGCEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\20_ObserveGCEvent.cs,GetProcessName,The method has an empty catch block.
Empty Catch Block,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,GetProcessName,The method has an empty catch block.
Empty Catch Block,TraceEventSamples,ObserveEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\22_ObserveEventSource.cs,GetProcessName,The method has an empty catch block.
Empty Catch Block,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,ThrowException1,The method has an empty catch block.
Empty Catch Block,TraceEventSamples,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,GenerateExceptions,The method has an empty catch block.
Empty Catch Block,TraceEventSamples,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,GenerateExceptions,The method has an empty catch block.
Empty Catch Block,Producer,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,GenerateExceptions,The method has an empty catch block.
Empty Catch Block,Producer,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,GenerateExceptions,The method has an empty catch block.
Magic Number,TraceEventSamples,SimpleEventSourceFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\11_SimpleEventSourceFile.cs,CollectData,The following statement contains a magic number: using (var session = new TraceEventSession(sessionName' dataFileName))      // Since we give it a file name' the data goes there.                 {                  /* BY DEFAULT ETW SESSIONS SURVIVE THE DEATH OF THE PROESS THAT CREATES THEM! */                  // Unlike most other resources on the system' ETW session live beyond the lifetime of the                   // process that created them.   This is very useful in some scenarios' but also creates the                   // very real possibility of leaving 'orphan' sessions running.                    //                  // To help avoid this by default TraceEventSession sets 'StopOnDispose' so that it will stop                  // the ETW session if the TraceEventSession dies.   Thus executions that 'clean up' the TraceEventSession                  // will clean up the ETW session.   This covers many cases (including throwing exceptions)                  //                    // However if the process is killed manually (including control C) this cleanup will not happen.                    // Thus best practices include                  //                  //     * Add a Control C handler that calls session.Dispose() so it gets cleaned up in this common case                  //     * use the same session name run-to-run so you don't create many orphans.                   //                  // By default TraceEventSessions are in 'create' mode where it assumes you want to create a new session.                  // In this mode if a session already exists' it is stopped and the new one is created.                     //                   // Here we install the Control C handler.   It is OK if Dispose is called more than once.                    Console.CancelKeyPress += delegate(object sender' ConsoleCancelEventArgs e) { session.Dispose(); };                    // Enable my provider' you can call many of these on the same session to get other events.                     var restarted = session.EnableProvider(MyEventSource.Log.Name);                  if (restarted)      // Generally you don't bother with this warning' but for the demo we do.                        Out.WriteLine("The session {0} was already active' it has been restarted."' sessionName);                    // Start another thread that Causes MyEventSource to create some events                  // Normally this code as well as the EventSource itself would be in a different process.                    EventGenerator.CreateEvents();                    Out.WriteLine("Waiting 12 seconds for events to come in.");                  Thread.Sleep(12000);              }
Magic Number,TraceEventSamples,ObserveGCEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\20_ObserveGCEvent.cs,Run,The following statement contains a magic number: var monitoringTimeSec = 10;
Magic Number,TraceEventSamples,ObserveGCEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\20_ObserveGCEvent.cs,Run,The following statement contains a magic number: using (var userSession = new TraceEventSession("ObserveGCAllocs"))              {                  // Set up Ctrl-C to stop the session                  SetupCtrlCHandler(() => { userSession.Stop(); });                    // enable the CLR provider with default keywords (minus the rundown CLR events)                  userSession.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose'                      (ulong)(ClrTraceEventParser.Keywords.GC));                    // Create a stream of GC Allocation events (happens every time 100K of allocations happen)                  IObservable<GCAllocationTickTraceData> gcAllocStream = userSession.Source.Clr.Observe<GCAllocationTickTraceData>();                    // Print the outgoing stream to the console                  gcAllocStream.Subscribe(allocData =>                      Out.WriteLine("GC Alloc  :  Proc: {0'10} Amount: {1'6:f1}K  TypeSample: {2}"' GetProcessName(allocData.ProcessID)' allocData.AllocationAmount / 1000.0' allocData.TypeName));                    // Create a stream of GC Collection events                  IObservable<GCHeapStatsTraceData> gcCollectStream = userSession.Source.Clr.Observe<GCHeapStatsTraceData>();                    // Print the outgoing stream to the console                  gcCollectStream.Subscribe(collectData =>                      Out.WriteLine("GC Collect:  Proc: {0'10} Gen0: {1'6:f1}M Gen1: {2'6:f1}M Gen2: {3'6:f1}M LargeObj: {4'6:f1}M"'                           GetProcessName(collectData.ProcessID)'                           collectData.GenerationSize0 / 1000000.0'                           collectData.GenerationSize1 / 1000000.0'                           collectData.GenerationSize2 / 1000000.0'                           collectData.GenerationSize3 / 1000000.0));                    IObservable<long> timer = Observable.Timer(new TimeSpan(0' 0' monitoringTimeSec));                  timer.Subscribe(delegate                  {                      Out.WriteLine("Stopped after {0} sec"' monitoringTimeSec);                      userSession.Dispose();                  });                    // OK we are all set up' time to listen for events and pass them to the observers.                    userSession.Source.Process();              }
Magic Number,TraceEventSamples,ObserveGCEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\20_ObserveGCEvent.cs,Run,The following statement contains a magic number: using (var userSession = new TraceEventSession("ObserveGCAllocs"))              {                  // Set up Ctrl-C to stop the session                  SetupCtrlCHandler(() => { userSession.Stop(); });                    // enable the CLR provider with default keywords (minus the rundown CLR events)                  userSession.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose'                      (ulong)(ClrTraceEventParser.Keywords.GC));                    // Create a stream of GC Allocation events (happens every time 100K of allocations happen)                  IObservable<GCAllocationTickTraceData> gcAllocStream = userSession.Source.Clr.Observe<GCAllocationTickTraceData>();                    // Print the outgoing stream to the console                  gcAllocStream.Subscribe(allocData =>                      Out.WriteLine("GC Alloc  :  Proc: {0'10} Amount: {1'6:f1}K  TypeSample: {2}"' GetProcessName(allocData.ProcessID)' allocData.AllocationAmount / 1000.0' allocData.TypeName));                    // Create a stream of GC Collection events                  IObservable<GCHeapStatsTraceData> gcCollectStream = userSession.Source.Clr.Observe<GCHeapStatsTraceData>();                    // Print the outgoing stream to the console                  gcCollectStream.Subscribe(collectData =>                      Out.WriteLine("GC Collect:  Proc: {0'10} Gen0: {1'6:f1}M Gen1: {2'6:f1}M Gen2: {3'6:f1}M LargeObj: {4'6:f1}M"'                           GetProcessName(collectData.ProcessID)'                           collectData.GenerationSize0 / 1000000.0'                           collectData.GenerationSize1 / 1000000.0'                           collectData.GenerationSize2 / 1000000.0'                           collectData.GenerationSize3 / 1000000.0));                    IObservable<long> timer = Observable.Timer(new TimeSpan(0' 0' monitoringTimeSec));                  timer.Subscribe(delegate                  {                      Out.WriteLine("Stopped after {0} sec"' monitoringTimeSec);                      userSession.Dispose();                  });                    // OK we are all set up' time to listen for events and pass them to the observers.                    userSession.Source.Process();              }
Magic Number,TraceEventSamples,ObserveGCEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\20_ObserveGCEvent.cs,Run,The following statement contains a magic number: using (var userSession = new TraceEventSession("ObserveGCAllocs"))              {                  // Set up Ctrl-C to stop the session                  SetupCtrlCHandler(() => { userSession.Stop(); });                    // enable the CLR provider with default keywords (minus the rundown CLR events)                  userSession.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose'                      (ulong)(ClrTraceEventParser.Keywords.GC));                    // Create a stream of GC Allocation events (happens every time 100K of allocations happen)                  IObservable<GCAllocationTickTraceData> gcAllocStream = userSession.Source.Clr.Observe<GCAllocationTickTraceData>();                    // Print the outgoing stream to the console                  gcAllocStream.Subscribe(allocData =>                      Out.WriteLine("GC Alloc  :  Proc: {0'10} Amount: {1'6:f1}K  TypeSample: {2}"' GetProcessName(allocData.ProcessID)' allocData.AllocationAmount / 1000.0' allocData.TypeName));                    // Create a stream of GC Collection events                  IObservable<GCHeapStatsTraceData> gcCollectStream = userSession.Source.Clr.Observe<GCHeapStatsTraceData>();                    // Print the outgoing stream to the console                  gcCollectStream.Subscribe(collectData =>                      Out.WriteLine("GC Collect:  Proc: {0'10} Gen0: {1'6:f1}M Gen1: {2'6:f1}M Gen2: {3'6:f1}M LargeObj: {4'6:f1}M"'                           GetProcessName(collectData.ProcessID)'                           collectData.GenerationSize0 / 1000000.0'                           collectData.GenerationSize1 / 1000000.0'                           collectData.GenerationSize2 / 1000000.0'                           collectData.GenerationSize3 / 1000000.0));                    IObservable<long> timer = Observable.Timer(new TimeSpan(0' 0' monitoringTimeSec));                  timer.Subscribe(delegate                  {                      Out.WriteLine("Stopped after {0} sec"' monitoringTimeSec);                      userSession.Dispose();                  });                    // OK we are all set up' time to listen for events and pass them to the observers.                    userSession.Source.Process();              }
Magic Number,TraceEventSamples,ObserveGCEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\20_ObserveGCEvent.cs,Run,The following statement contains a magic number: using (var userSession = new TraceEventSession("ObserveGCAllocs"))              {                  // Set up Ctrl-C to stop the session                  SetupCtrlCHandler(() => { userSession.Stop(); });                    // enable the CLR provider with default keywords (minus the rundown CLR events)                  userSession.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose'                      (ulong)(ClrTraceEventParser.Keywords.GC));                    // Create a stream of GC Allocation events (happens every time 100K of allocations happen)                  IObservable<GCAllocationTickTraceData> gcAllocStream = userSession.Source.Clr.Observe<GCAllocationTickTraceData>();                    // Print the outgoing stream to the console                  gcAllocStream.Subscribe(allocData =>                      Out.WriteLine("GC Alloc  :  Proc: {0'10} Amount: {1'6:f1}K  TypeSample: {2}"' GetProcessName(allocData.ProcessID)' allocData.AllocationAmount / 1000.0' allocData.TypeName));                    // Create a stream of GC Collection events                  IObservable<GCHeapStatsTraceData> gcCollectStream = userSession.Source.Clr.Observe<GCHeapStatsTraceData>();                    // Print the outgoing stream to the console                  gcCollectStream.Subscribe(collectData =>                      Out.WriteLine("GC Collect:  Proc: {0'10} Gen0: {1'6:f1}M Gen1: {2'6:f1}M Gen2: {3'6:f1}M LargeObj: {4'6:f1}M"'                           GetProcessName(collectData.ProcessID)'                           collectData.GenerationSize0 / 1000000.0'                           collectData.GenerationSize1 / 1000000.0'                           collectData.GenerationSize2 / 1000000.0'                           collectData.GenerationSize3 / 1000000.0));                    IObservable<long> timer = Observable.Timer(new TimeSpan(0' 0' monitoringTimeSec));                  timer.Subscribe(delegate                  {                      Out.WriteLine("Stopped after {0} sec"' monitoringTimeSec);                      userSession.Dispose();                  });                    // OK we are all set up' time to listen for events and pass them to the observers.                    userSession.Source.Process();              }
Magic Number,TraceEventSamples,ObserveGCEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\20_ObserveGCEvent.cs,Run,The following statement contains a magic number: using (var userSession = new TraceEventSession("ObserveGCAllocs"))              {                  // Set up Ctrl-C to stop the session                  SetupCtrlCHandler(() => { userSession.Stop(); });                    // enable the CLR provider with default keywords (minus the rundown CLR events)                  userSession.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose'                      (ulong)(ClrTraceEventParser.Keywords.GC));                    // Create a stream of GC Allocation events (happens every time 100K of allocations happen)                  IObservable<GCAllocationTickTraceData> gcAllocStream = userSession.Source.Clr.Observe<GCAllocationTickTraceData>();                    // Print the outgoing stream to the console                  gcAllocStream.Subscribe(allocData =>                      Out.WriteLine("GC Alloc  :  Proc: {0'10} Amount: {1'6:f1}K  TypeSample: {2}"' GetProcessName(allocData.ProcessID)' allocData.AllocationAmount / 1000.0' allocData.TypeName));                    // Create a stream of GC Collection events                  IObservable<GCHeapStatsTraceData> gcCollectStream = userSession.Source.Clr.Observe<GCHeapStatsTraceData>();                    // Print the outgoing stream to the console                  gcCollectStream.Subscribe(collectData =>                      Out.WriteLine("GC Collect:  Proc: {0'10} Gen0: {1'6:f1}M Gen1: {2'6:f1}M Gen2: {3'6:f1}M LargeObj: {4'6:f1}M"'                           GetProcessName(collectData.ProcessID)'                           collectData.GenerationSize0 / 1000000.0'                           collectData.GenerationSize1 / 1000000.0'                           collectData.GenerationSize2 / 1000000.0'                           collectData.GenerationSize3 / 1000000.0));                    IObservable<long> timer = Observable.Timer(new TimeSpan(0' 0' monitoringTimeSec));                  timer.Subscribe(delegate                  {                      Out.WriteLine("Stopped after {0} sec"' monitoringTimeSec);                      userSession.Dispose();                  });                    // OK we are all set up' time to listen for events and pass them to the observers.                    userSession.Source.Process();              }
Magic Number,TraceEventSamples,ObserveGCEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\20_ObserveGCEvent.cs,GetProcessName,The following statement contains a magic number: if ((now - s_processNameCacheLastUpdate).TotalSeconds > 10)                  s_processNameCache.Clear();
Magic Number,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The following statement contains a magic number: var monitoringTimeSec = 10;
Magic Number,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,Run,The following statement contains a magic number: using (var userSession = new TraceEventSession("ObserveJitEvents1"))              {                  // Set up Ctrl-C to stop both user mode and kernel mode sessions                  SetupCtrlCHandler(() => { if (userSession != null) userSession.Stop(); });                    // enable the CLR JIT compiler events.                   userSession.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)(ClrTraceEventParser.Keywords.Default));                    // Get the stream of starts.                  IObservable<MethodJittingStartedTraceData> jitStartStream = userSession.Source.Clr.Observe<MethodJittingStartedTraceData>("Method/JittingStarted");                    // And the stream of ends.                  IObservable<MethodLoadUnloadVerboseTraceData> jitEndStream = userSession.Source.Clr.Observe<MethodLoadUnloadVerboseTraceData>("Method/LoadVerbose");                    // Compute the stream of matched-up pairs' and for each create a tuple of the start event and the time between the pair of events.                    // Note that the 'Take(1)' is pretty important because a nested 'from' statement logically creates the 'cross product' of a two streams                  // In this case the stream of starts and the stream of ends).   Because we filter this stream only to matching entities and then only                  // take the first entry' we stop waiting.   Thus we only 'remember' those 'starts' that are not yet matched' which is very important                  // for efficiency.   Note that any 'lost' end events will never be matched and will accumulate over time' slowing things down.                  // We should put a time window on it as well to 'forget' old start events.                    var jitTimes =                      from start in jitStartStream                      from end in jitEndStream.Where(e => start.MethodID == e.MethodID && start.ProcessID == e.ProcessID).Take(1)                      select new                      {                          Name = GetName(start)'                          ProcessID = start.ProcessID'                          JitTIme = end.TimeStampRelativeMSec - start.TimeStampRelativeMSec                      };                    // Create a stream of just the JIT times and compute statistics every 8 methods that are JIT compiled.                  IObservable<Statistics> jitStats = ComputeRunningStats(jitTimes' jitData => jitData.JitTIme' windowSize: 8);                    // Print every time you compile a method                   jitTimes.Subscribe(onNext: jitData => Out.WriteLine("JIT_TIME: {0'7:f2} PROC: {1'10} METHOD: {2}"' jitData.JitTIme' GetProcessName(jitData.ProcessID)' jitData.Name));                    // Also output the statistics.                    jitStats.Subscribe(onNext: Out.WriteLine);      // print some aggregation stats                    // for debugging purposes to see any events that entered by were not handled by any parser.   These can be bugs.                    // IObservable<TraceEvent> unhandledEventStream = userSession.Source.ObserveUnhandled();                  // unhandledEventStream.Subscribe(onNext: ev => Out.WriteLine("UNHANDLED :  PID: {0'5} {1}/{2} "' ev.ProcessID' ev.ProviderName' ev.EventName));                    // Set up a timer to stop processing after monitoringTimeSec                  IObservable<long> timer = Observable.Timer(new TimeSpan(0' 0' monitoringTimeSec));                  timer.Subscribe(delegate                  {                      Out.WriteLine("Stopped after {0} sec"' monitoringTimeSec);                      userSession.Stop();                  });                    // OK we are all set up' time to listen for events and pass them to the observers.                    userSession.Source.Process();              }
Magic Number,TraceEventSamples,ObserveJitEvents,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\21_ObserveJitEvents.cs,GetProcessName,The following statement contains a magic number: if ((now - s_processNameCacheLastUpdate).TotalSeconds > 10)                  s_processNameCache.Clear();
Magic Number,TraceEventSamples,ObserveEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\22_ObserveEventSource.cs,Run,The following statement contains a magic number: var monitoringTimeSec = 15;
Magic Number,TraceEventSamples,ObserveEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\22_ObserveEventSource.cs,GetProcessName,The following statement contains a magic number: if ((now - s_processNameCacheLastUpdate).TotalSeconds > 10)                  s_processNameCache.Clear();
Magic Number,TraceEventSamples,ModuleLoadMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\30_MonitorLoads.cs,Run,The following statement contains a magic number: var monitoringTimeSec = 10;
Magic Number,TraceEventSamples,ModuleLoadMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\30_MonitorLoads.cs,Run,The following statement contains a magic number: using (TraceEventSession session = new TraceEventSession(KernelTraceEventParser.KernelSessionName))              {                  /* BY DEFAULT ETW SESSIONS SURVIVE THE DEATH OF THE PROESS THAT CREATES THEM! */                  // Unlike most other resources on the system' ETW session live beyond the lifetime of the                   // process that created them.   This is very useful in some scenarios' but also creates the                   // very real possibility of leaving 'orphan' sessions running.                    //                  // To help avoid this by default TraceEventSession sets 'StopOnDispose' so that it will stop                  // the ETW session if the TraceEventSession dies.   Thus executions that 'clean up' the TraceEventSession                  // will clean up the ETW session.   This covers many cases (including throwing exceptions)                  //                    // However if the process is killed manually (including control C) this cleanup will not happen.                    // Thus best practices include                  //                  //     * Add a Control C handler that calls session.Dispose() so it gets cleaned up in this common case                  //     * use the same session name run-to-run so you don't create many orphans.                   //                  // By default TraceEventSessions are in 'create' mode where it assumes you want to create a new session.                  // In this mode if a session already exists' it is stopped and the new one is created.                     //                   // Here we install the Control C handler.                     Console.CancelKeyPress += new ConsoleCancelEventHandler((object sender' ConsoleCancelEventArgs cancelArgs) =>                  {                      Out.WriteLine("Control C pressed");     // Note that if you hit Ctrl-C twice rapidly you may be called concurrently.                        session.Dispose();                          // Note that this causes Process() to return.                        cancelArgs.Cancel = true;                   // This says don't abort' since Process() will return we can terminate nicely.                     });                    // Enable the Kernel events that we want.   At this point data is being collected (but being buffered since we are not reading it)                  // See KernelTraceEventParser.Keywords for what else can be turned on and KernelTraceEventParser for a description                  // of the events that you get when you turn on the various kernel keywords.   Many kernel events will also log a stack                  // when they fire see EnableKernelProvider for more on that.                    session.EnableKernelProvider(KernelTraceEventParser.Keywords.ImageLoad | KernelTraceEventParser.Keywords.Process);                    // .Source will auto-create a TraceEventSource reading the data from the session                  // .Kernel will auto-create a KernelTraceEventParser getting its events from the source                  // .ImageLoad is an event that you can subscribe to that will be called back when Image load events happen (complete with parsed event)                  session.Source.Kernel.ImageLoad += delegate(ImageLoadTraceData data)                  {                      Out.WriteLine("Process {0'16} At 0x{1'8:x} Loaded {2}"' data.ProcessName' data.ImageBase' data.FileName);                  };                  //  Subscribe to more events (process start)                   session.Source.Kernel.ProcessStart += delegate(ProcessTraceData data)                  {                      Out.WriteLine("Process Started {0'6} Parent {1'6} Name {2'8} Cmd: {3}"'                          data.ProcessID' data.ParentID' data.ProcessName' data.CommandLine);                  };                  //  Subscribe to more events (process end)                  session.Source.Kernel.ProcessStop += delegate(ProcessTraceData data)                  {                      Out.WriteLine("Process Ending {0'6} "' data.ProcessID);                  };                    // Set up a timer to stop processing after monitoringTimeSec                  var timer = new Timer(delegate(object state)                  {                      Out.WriteLine("Stopped after {0} sec"' monitoringTimeSec);                      session.Source.StopProcessing();                  }' null' monitoringTimeSec * 1000' Timeout.Infinite);                    // Start listening for events' will end if session.Source.StopProcessing() is called or session.Dispose() is called.                    // Here we never do either of these and thus will only stop when Ctrl-C is hit (but it will clean up because of                   // our control C handler).                   session.Source.Process();                  timer.Dispose();    // Done with the timer.                }
Magic Number,TraceEventSamples,KernelAndClrMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\31_KernelAndClrMonitor.cs,Run,The following statement contains a magic number: var monitoringTimeSec = 10;
Magic Number,TraceEventSamples,KernelAndClrMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\31_KernelAndClrMonitor.cs,Run,The following statement contains a magic number: if (Environment.OSVersion.Version.Major * 10 + Environment.OSVersion.Version.Minor < 62)              {                  Out.WriteLine("This demo only works on Win8 / Win 2012 an above)");                  return;              }
Magic Number,TraceEventSamples,KernelAndClrMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\31_KernelAndClrMonitor.cs,Run,The following statement contains a magic number: if (Environment.OSVersion.Version.Major * 10 + Environment.OSVersion.Version.Minor < 62)              {                  Out.WriteLine("This demo only works on Win8 / Win 2012 an above)");                  return;              }
Magic Number,TraceEventSamples,KernelAndClrMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\31_KernelAndClrMonitor.cs,Run,The following statement contains a magic number: var timer = new Timer(delegate(object state)              {                  Out.WriteLine("Stopped Monitoring after {0} sec"' monitoringTimeSec);                  if (session != null)                      session.Dispose();              }' null' monitoringTimeSec * 1000' Timeout.Infinite);
Magic Number,TraceEventSamples,KernelAndClrFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\32_KernelAndClrFile.cs,Run,The following statement contains a magic number: if (Environment.OSVersion.Version.Major * 10 + Environment.OSVersion.Version.Minor < 62)              {                  Out.WriteLine("This demo only works on Win8 / Win 2012 an above)");                  return;              }
Magic Number,TraceEventSamples,KernelAndClrFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\32_KernelAndClrFile.cs,Run,The following statement contains a magic number: if (Environment.OSVersion.Version.Major * 10 + Environment.OSVersion.Version.Minor < 62)              {                  Out.WriteLine("This demo only works on Win8 / Win 2012 an above)");                  return;              }
Magic Number,TraceEventSamples,KernelAndClrFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\32_KernelAndClrFile.cs,DataCollection,The following statement contains a magic number: using (var session = new TraceEventSession("MonitorKernelAndClrEventsSession"' dataFileName))              {                  // Set up Ctrl-C to stop both user mode and kernel mode sessions                  Console.CancelKeyPress += delegate(object sender' ConsoleCancelEventArgs cancelArgs)                  {                      Out.WriteLine("Insuring all ETW sessions are stopped.");                      session.Stop(true);         // true means don't throw on error                      // Since we don't cancel the Ctrl-C we will terminate the process as normal for Ctrl-C                      Out.WriteLine("OnCtrl C handler ending.");                  };                    // Enable the events we care about for the kernel in the kernel session                  // For this instant the session will buffer any incoming events.                    // THis has to be first' and it will fail if you are not on Win8.                    session.EnableKernelProvider(                      KernelTraceEventParser.Keywords.ImageLoad |                      KernelTraceEventParser.Keywords.Process |                      KernelTraceEventParser.Keywords.Thread);                    // Enable the events we care about for the CLR (in the user session).                  // unlike the kernel session' you can call EnableProvider on other things too.                    // For this instant the session will buffer any incoming events.                    session.EnableProvider(                      ClrTraceEventParser.ProviderGuid'                      TraceEventLevel.Informational'                      (ulong)(ClrTraceEventParser.Keywords.Default));                    Out.WriteLine("Collecting data for 10 seconds (run a .Net program to generate events).");                  Thread.Sleep(10000);                    Out.WriteLine("Stopping sessions");              }
Magic Number,TraceEventSamples,KernelAndClrFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\32_KernelAndClrFile.cs,DataProcessing,The following statement contains a magic number: using (var source = new ETWTraceEventSource(dataFileName))              {                  if (source.EventsLost != 0)                      Out.WriteLine("WARNING: there were {0} lost events"' source.EventsLost);                    // Set up callbacks to                   source.Clr.All += Print;                  source.Kernel.All += Print;                    // When you merge a file' some 'symbol' events are injected into the trace.                    // To avoid these showing up as 'unknown' add the parser for these.  This                  // also shows how you hook up a TraceEventParser that is not support by                  // properties on the source itself (like CLR' and kernel)                  var symbolParser = new SymbolTraceEventParser(source);                  symbolParser.All += Print;        #if DEBUG                  // The callback above will only be called for events the parser recognizes (in the case of Kernel and CLR parsers)                  // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you                   // can ask the source to send them to you like this.                    source.UnhandledEvents += delegate(TraceEvent data)                  {                      if ((int)data.ID == 0xFFFE)         // The EventSource manifest events show up as unhandled' filter them out.                          return;                        // To avoid 'rundown' events that happen in the beginning and end of the trace filter out things during those times                      if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                          return;                        Out.WriteLine("GOT UNHANDLED EVENT: " + data.Dump());                  };  #endif                    // go into a loop processing events can calling the callbacks.  This will return when the all the events                  // In the file are processed' or the StopProcessing() call is made.                    source.Process();                  Out.WriteLine("Done Processing.");              }
Magic Number,TraceEventSamples,KernelAndClrFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\32_KernelAndClrFile.cs,DataProcessing,The following statement contains a magic number: using (var source = new ETWTraceEventSource(dataFileName))              {                  if (source.EventsLost != 0)                      Out.WriteLine("WARNING: there were {0} lost events"' source.EventsLost);                    // Set up callbacks to                   source.Clr.All += Print;                  source.Kernel.All += Print;                    // When you merge a file' some 'symbol' events are injected into the trace.                    // To avoid these showing up as 'unknown' add the parser for these.  This                  // also shows how you hook up a TraceEventParser that is not support by                  // properties on the source itself (like CLR' and kernel)                  var symbolParser = new SymbolTraceEventParser(source);                  symbolParser.All += Print;        #if DEBUG                  // The callback above will only be called for events the parser recognizes (in the case of Kernel and CLR parsers)                  // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you                   // can ask the source to send them to you like this.                    source.UnhandledEvents += delegate(TraceEvent data)                  {                      if ((int)data.ID == 0xFFFE)         // The EventSource manifest events show up as unhandled' filter them out.                          return;                        // To avoid 'rundown' events that happen in the beginning and end of the trace filter out things during those times                      if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                          return;                        Out.WriteLine("GOT UNHANDLED EVENT: " + data.Dump());                  };  #endif                    // go into a loop processing events can calling the callbacks.  This will return when the all the events                  // In the file are processed' or the StopProcessing() call is made.                    source.Process();                  Out.WriteLine("Done Processing.");              }
Magic Number,TraceEventSamples,KernelAndClrFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\32_KernelAndClrFile.cs,Print,The following statement contains a magic number: if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                  return;
Magic Number,TraceEventSamples,KernelAndClrFile,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\32_KernelAndClrFile.cs,Print,The following statement contains a magic number: if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                  return;
Magic Number,TraceEventSamples,KernelAndClrMonitorWin7,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\33_KernelAndClrMonitorWin7.cs,Run,The following statement contains a magic number: var monitoringTimeSec = 10;
Magic Number,TraceEventSamples,KernelAndClrMonitorWin7,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\33_KernelAndClrMonitorWin7.cs,Run,The following statement contains a magic number: var timer = new Timer(delegate(object state)              {                  Out.WriteLine("Stopped Monitoring after {0} sec"' monitoringTimeSec);                  StopSessions();              }' null' monitoringTimeSec * 1000' Timeout.Infinite);
Magic Number,TraceEventSamples,KernelAndClrFileWin7,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\34_KernelAndClrFileWin7.cs,DataCollection,The following statement contains a magic number: using (var userSession = new TraceEventSession("MonitorKernelAndClrEventsSession"' dataFileName))              using (var kernelSession = new TraceEventSession(KernelTraceEventParser.KernelSessionName' kernelDataFileName))              {                  // Set up Ctrl-C to stop both user mode and kernel mode sessions                  Console.CancelKeyPress += delegate(object sender' ConsoleCancelEventArgs cancelArgs)                  {                      Out.WriteLine("Insuring all ETW sessions are stopped.");                      kernelSession.Stop(true);         // true means don't throw on error                      userSession.Stop(true);           // true means don't throw on error                      // Since we don't cancel the Ctrl-C we will terminate the process as normal for Ctrl-C                      Out.WriteLine("OnCtrl C handler ending.");                  };                    // Enable the events we care about for the kernel in the kernel session                  // For this instant the session will buffer any incoming events.                    kernelSession.EnableKernelProvider(                      KernelTraceEventParser.Keywords.ImageLoad |                      KernelTraceEventParser.Keywords.Process |                      KernelTraceEventParser.Keywords.Thread);                    // Enable the events we care about for the CLR (in the user session).                  // unlike the kernel session' you can call EnableProvider on other things too.                    // For this instant the session will buffer any incoming events.                    userSession.EnableProvider(                      ClrTraceEventParser.ProviderGuid'                      TraceEventLevel.Informational'                      (ulong)(ClrTraceEventParser.Keywords.Default));                    Out.WriteLine("Collecting data for 10 seconds (run a .Net program to generate events).");                  Thread.Sleep(10000);                    Out.WriteLine("Stopping sessions");              }
Magic Number,TraceEventSamples,KernelAndClrFileWin7,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\34_KernelAndClrFileWin7.cs,DataProcessing,The following statement contains a magic number: using (var source = new ETWTraceEventSource(dataFileName))              {                  if (source.EventsLost != 0)                      Out.WriteLine("WARNING: there were {0} lost events"' source.EventsLost);                    // Set up callbacks to                   source.Clr.All += Print;                  source.Kernel.All += Print;                    // When you merge a file' some 'symbol' events are injected into the trace.                    // To avoid these showing up as 'unknown' add the parser for these.  This                  // also shows how you hook up a TraceEventParser that is not support by                  // properties on the source itself (like CLR' and kernel)                  var symbolParser = new SymbolTraceEventParser(source);                  symbolParser.All += Print;    #if DEBUG                  // The callback above will only be called for events the parser recognizes (in the case of Kernel and CLR parsers)                  // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you                   // can ask the source to send them to you like this.                    source.UnhandledEvents += delegate(TraceEvent data)                  {                      if ((int)data.ID == 0xFFFE)         // The EventSource manifest events show up as unhandled' filter them out.                          return;                        // To avoid 'rundown' events that happen in the beginning and end of the trace filter out things during those times                      if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                          return;                        Out.WriteLine("GOT UNHANDLED EVENT: " + data.Dump());                  };  #endif                    // go into a loop processing events can calling the callbacks.  This will return when the all the events                  // In the file are processed' or the StopProcessing() call is made.                    source.Process();                  Out.WriteLine("Done Processing.");              }
Magic Number,TraceEventSamples,KernelAndClrFileWin7,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\34_KernelAndClrFileWin7.cs,DataProcessing,The following statement contains a magic number: using (var source = new ETWTraceEventSource(dataFileName))              {                  if (source.EventsLost != 0)                      Out.WriteLine("WARNING: there were {0} lost events"' source.EventsLost);                    // Set up callbacks to                   source.Clr.All += Print;                  source.Kernel.All += Print;                    // When you merge a file' some 'symbol' events are injected into the trace.                    // To avoid these showing up as 'unknown' add the parser for these.  This                  // also shows how you hook up a TraceEventParser that is not support by                  // properties on the source itself (like CLR' and kernel)                  var symbolParser = new SymbolTraceEventParser(source);                  symbolParser.All += Print;    #if DEBUG                  // The callback above will only be called for events the parser recognizes (in the case of Kernel and CLR parsers)                  // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you                   // can ask the source to send them to you like this.                    source.UnhandledEvents += delegate(TraceEvent data)                  {                      if ((int)data.ID == 0xFFFE)         // The EventSource manifest events show up as unhandled' filter them out.                          return;                        // To avoid 'rundown' events that happen in the beginning and end of the trace filter out things during those times                      if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                          return;                        Out.WriteLine("GOT UNHANDLED EVENT: " + data.Dump());                  };  #endif                    // go into a loop processing events can calling the callbacks.  This will return when the all the events                  // In the file are processed' or the StopProcessing() call is made.                    source.Process();                  Out.WriteLine("Done Processing.");              }
Magic Number,TraceEventSamples,KernelAndClrFileWin7,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\34_KernelAndClrFileWin7.cs,Print,The following statement contains a magic number: if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                  return;
Magic Number,TraceEventSamples,KernelAndClrFileWin7,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\34_KernelAndClrFileWin7.cs,Print,The following statement contains a magic number: if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                  return;
Magic Number,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,CollectData,The following statement contains a magic number: using (var session = new TraceEventSession(sessionName' dataFileName))      // Since we give it a file name' the data goes there.               using (var kernelSession = new TraceEventSession(KernelTraceEventParser.KernelSessionName' Path.ChangeExtension(dataFileName' ".kernel.etl")))              {                  /* BY DEFAULT ETW SESSIONS SURVIVE THE DEATH OF THE PROESS THAT CREATES THEM! */                  // Unlike most other resources on the system' ETW session live beyond the lifetime of the                   // process that created them.   This is very useful in some scenarios' but also creates the                   // very real possibility of leaving 'orphan' sessions running.                    //                  // To help avoid this by default TraceEventSession sets 'StopOnDispose' so that it will stop                  // the ETW session if the TraceEventSession dies.   Thus executions that 'clean up' the TraceEventSession                  // will clean up the ETW session.   This covers many cases (including throwing exceptions)                  //                    // However if the process is killed manually (including control C) this cleanup will not happen.                    // Thus best practices include                  //                  //     * Add a Control C handler that calls session.Dispose() so it gets cleaned up in this common case                  //     * use the same session name run-to-run so you don't create many orphans.                   //                  // By default TraceEventSessions are in 'create' mode where it assumes you want to create a new session.                  // In this mode if a session already exists' it is stopped and the new one is created.                     //                   // Here we install the Control C handler.   It is OK if Dispose is called more than once.                    Console.CancelKeyPress += delegate(object sender' ConsoleCancelEventArgs e) { session.Dispose(); kernelSession.Dispose(); };                    // Enable kernel events.                    kernelSession.EnableKernelProvider(KernelTraceEventParser.Keywords.ImageLoad | KernelTraceEventParser.Keywords.Process | KernelTraceEventParser.Keywords.Thread);                    // Enable my provider' you can call many of these on the same session to get events from other providers                      // Turn on the eventSource given its name.                     // Note we turn on Verbose level all keywords (ulong.MaxValue == 0xFFF....) and turn on stacks for                   // this provider (for all events' until Windows 8.1 you can only turn on stacks for every event                   // for a particular provider or no stacks)                  var options = new TraceEventProviderOptions() { StacksEnabled = true };                  var restarted = session.EnableProvider(eventSourceName' TraceEventLevel.Verbose' ulong.MaxValue' options);                  if (restarted)      // Generally you don't bother with this warning' but for the demo we do.                        Out.WriteLine("The session {0} was already active' it has been restarted."' sessionName);                    // We also turn on CLR events because we need them to decode Stacks and we also get exception events (and their stacks)                  session.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)ClrTraceEventParser.Keywords.Default);                    // Start another thread that Causes MyEventSource to create some events                  // Normally this code as well as the EventSource itself would be in a different process.                    EventGenerator.CreateEvents();                    // Also generate some exceptions so we have interesting stacks to look at                  Thread.Sleep(100);                  EventGenerator.GenerateExceptions();                    Out.WriteLine("Waiting 12 seconds for events to come in.");                  Thread.Sleep(12000);                    // Because the process in question (this process) lives both before and after the time the events were                   // collected' we don't have complete information about JIT compiled methods in that method.   There are                   // some methods that were JIT compiled before the session started (e.g. SimpleTraceLog.Main) for which                  // we do not have information.   We collect this by forcing a CLR 'rundown' which will dump method information                  // for JIT compiled methods that were not present.  If you know that the process of interest ends before                  // data collection ended or that data collection started before the process started' then this is not needed.                    Out.WriteLine("Forcing rundown of JIT methods.");                  var rundownFileName = Path.ChangeExtension(dataFileName' ".clrRundown.etl");                  using (var rundownSession = new TraceEventSession(sessionName + "Rundown"' rundownFileName))                  {                      rundownSession.EnableProvider(ClrRundownTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)ClrRundownTraceEventParser.Keywords.Default);                      // Poll until 2 second goes by without growth.                        for (var prevLength = new FileInfo(rundownFileName).Length; ; )                      {                          Thread.Sleep(2000);                          var newLength = new FileInfo(rundownFileName).Length;                          if (newLength == prevLength) break;                          prevLength = newLength;                      }                  }                  Out.WriteLine("Done with rundown.");              }
Magic Number,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,CollectData,The following statement contains a magic number: using (var session = new TraceEventSession(sessionName' dataFileName))      // Since we give it a file name' the data goes there.               using (var kernelSession = new TraceEventSession(KernelTraceEventParser.KernelSessionName' Path.ChangeExtension(dataFileName' ".kernel.etl")))              {                  /* BY DEFAULT ETW SESSIONS SURVIVE THE DEATH OF THE PROESS THAT CREATES THEM! */                  // Unlike most other resources on the system' ETW session live beyond the lifetime of the                   // process that created them.   This is very useful in some scenarios' but also creates the                   // very real possibility of leaving 'orphan' sessions running.                    //                  // To help avoid this by default TraceEventSession sets 'StopOnDispose' so that it will stop                  // the ETW session if the TraceEventSession dies.   Thus executions that 'clean up' the TraceEventSession                  // will clean up the ETW session.   This covers many cases (including throwing exceptions)                  //                    // However if the process is killed manually (including control C) this cleanup will not happen.                    // Thus best practices include                  //                  //     * Add a Control C handler that calls session.Dispose() so it gets cleaned up in this common case                  //     * use the same session name run-to-run so you don't create many orphans.                   //                  // By default TraceEventSessions are in 'create' mode where it assumes you want to create a new session.                  // In this mode if a session already exists' it is stopped and the new one is created.                     //                   // Here we install the Control C handler.   It is OK if Dispose is called more than once.                    Console.CancelKeyPress += delegate(object sender' ConsoleCancelEventArgs e) { session.Dispose(); kernelSession.Dispose(); };                    // Enable kernel events.                    kernelSession.EnableKernelProvider(KernelTraceEventParser.Keywords.ImageLoad | KernelTraceEventParser.Keywords.Process | KernelTraceEventParser.Keywords.Thread);                    // Enable my provider' you can call many of these on the same session to get events from other providers                      // Turn on the eventSource given its name.                     // Note we turn on Verbose level all keywords (ulong.MaxValue == 0xFFF....) and turn on stacks for                   // this provider (for all events' until Windows 8.1 you can only turn on stacks for every event                   // for a particular provider or no stacks)                  var options = new TraceEventProviderOptions() { StacksEnabled = true };                  var restarted = session.EnableProvider(eventSourceName' TraceEventLevel.Verbose' ulong.MaxValue' options);                  if (restarted)      // Generally you don't bother with this warning' but for the demo we do.                        Out.WriteLine("The session {0} was already active' it has been restarted."' sessionName);                    // We also turn on CLR events because we need them to decode Stacks and we also get exception events (and their stacks)                  session.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)ClrTraceEventParser.Keywords.Default);                    // Start another thread that Causes MyEventSource to create some events                  // Normally this code as well as the EventSource itself would be in a different process.                    EventGenerator.CreateEvents();                    // Also generate some exceptions so we have interesting stacks to look at                  Thread.Sleep(100);                  EventGenerator.GenerateExceptions();                    Out.WriteLine("Waiting 12 seconds for events to come in.");                  Thread.Sleep(12000);                    // Because the process in question (this process) lives both before and after the time the events were                   // collected' we don't have complete information about JIT compiled methods in that method.   There are                   // some methods that were JIT compiled before the session started (e.g. SimpleTraceLog.Main) for which                  // we do not have information.   We collect this by forcing a CLR 'rundown' which will dump method information                  // for JIT compiled methods that were not present.  If you know that the process of interest ends before                  // data collection ended or that data collection started before the process started' then this is not needed.                    Out.WriteLine("Forcing rundown of JIT methods.");                  var rundownFileName = Path.ChangeExtension(dataFileName' ".clrRundown.etl");                  using (var rundownSession = new TraceEventSession(sessionName + "Rundown"' rundownFileName))                  {                      rundownSession.EnableProvider(ClrRundownTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)ClrRundownTraceEventParser.Keywords.Default);                      // Poll until 2 second goes by without growth.                        for (var prevLength = new FileInfo(rundownFileName).Length; ; )                      {                          Thread.Sleep(2000);                          var newLength = new FileInfo(rundownFileName).Length;                          if (newLength == prevLength) break;                          prevLength = newLength;                      }                  }                  Out.WriteLine("Done with rundown.");              }
Magic Number,TraceEventSamples,SimpleTraceLog,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\40_SimpleTraceLog.cs,CollectData,The following statement contains a magic number: using (var session = new TraceEventSession(sessionName' dataFileName))      // Since we give it a file name' the data goes there.               using (var kernelSession = new TraceEventSession(KernelTraceEventParser.KernelSessionName' Path.ChangeExtension(dataFileName' ".kernel.etl")))              {                  /* BY DEFAULT ETW SESSIONS SURVIVE THE DEATH OF THE PROESS THAT CREATES THEM! */                  // Unlike most other resources on the system' ETW session live beyond the lifetime of the                   // process that created them.   This is very useful in some scenarios' but also creates the                   // very real possibility of leaving 'orphan' sessions running.                    //                  // To help avoid this by default TraceEventSession sets 'StopOnDispose' so that it will stop                  // the ETW session if the TraceEventSession dies.   Thus executions that 'clean up' the TraceEventSession                  // will clean up the ETW session.   This covers many cases (including throwing exceptions)                  //                    // However if the process is killed manually (including control C) this cleanup will not happen.                    // Thus best practices include                  //                  //     * Add a Control C handler that calls session.Dispose() so it gets cleaned up in this common case                  //     * use the same session name run-to-run so you don't create many orphans.                   //                  // By default TraceEventSessions are in 'create' mode where it assumes you want to create a new session.                  // In this mode if a session already exists' it is stopped and the new one is created.                     //                   // Here we install the Control C handler.   It is OK if Dispose is called more than once.                    Console.CancelKeyPress += delegate(object sender' ConsoleCancelEventArgs e) { session.Dispose(); kernelSession.Dispose(); };                    // Enable kernel events.                    kernelSession.EnableKernelProvider(KernelTraceEventParser.Keywords.ImageLoad | KernelTraceEventParser.Keywords.Process | KernelTraceEventParser.Keywords.Thread);                    // Enable my provider' you can call many of these on the same session to get events from other providers                      // Turn on the eventSource given its name.                     // Note we turn on Verbose level all keywords (ulong.MaxValue == 0xFFF....) and turn on stacks for                   // this provider (for all events' until Windows 8.1 you can only turn on stacks for every event                   // for a particular provider or no stacks)                  var options = new TraceEventProviderOptions() { StacksEnabled = true };                  var restarted = session.EnableProvider(eventSourceName' TraceEventLevel.Verbose' ulong.MaxValue' options);                  if (restarted)      // Generally you don't bother with this warning' but for the demo we do.                        Out.WriteLine("The session {0} was already active' it has been restarted."' sessionName);                    // We also turn on CLR events because we need them to decode Stacks and we also get exception events (and their stacks)                  session.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)ClrTraceEventParser.Keywords.Default);                    // Start another thread that Causes MyEventSource to create some events                  // Normally this code as well as the EventSource itself would be in a different process.                    EventGenerator.CreateEvents();                    // Also generate some exceptions so we have interesting stacks to look at                  Thread.Sleep(100);                  EventGenerator.GenerateExceptions();                    Out.WriteLine("Waiting 12 seconds for events to come in.");                  Thread.Sleep(12000);                    // Because the process in question (this process) lives both before and after the time the events were                   // collected' we don't have complete information about JIT compiled methods in that method.   There are                   // some methods that were JIT compiled before the session started (e.g. SimpleTraceLog.Main) for which                  // we do not have information.   We collect this by forcing a CLR 'rundown' which will dump method information                  // for JIT compiled methods that were not present.  If you know that the process of interest ends before                  // data collection ended or that data collection started before the process started' then this is not needed.                    Out.WriteLine("Forcing rundown of JIT methods.");                  var rundownFileName = Path.ChangeExtension(dataFileName' ".clrRundown.etl");                  using (var rundownSession = new TraceEventSession(sessionName + "Rundown"' rundownFileName))                  {                      rundownSession.EnableProvider(ClrRundownTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)ClrRundownTraceEventParser.Keywords.Default);                      // Poll until 2 second goes by without growth.                        for (var prevLength = new FileInfo(rundownFileName).Length; ; )                      {                          Thread.Sleep(2000);                          var newLength = new FileInfo(rundownFileName).Length;                          if (newLength == prevLength) break;                          prevLength = newLength;                      }                  }                  Out.WriteLine("Done with rundown.");              }
Magic Number,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The following statement contains a magic number: var monitoringTimeSec = 10;
Magic Number,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The following statement contains a magic number: if (Environment.OSVersion.Version.Major * 10 + Environment.OSVersion.Version.Minor < 62)              {                  Out.WriteLine("This demo only works on Win8 / Win 2012 and above)");                  return;              }
Magic Number,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The following statement contains a magic number: if (Environment.OSVersion.Version.Major * 10 + Environment.OSVersion.Version.Minor < 62)              {                  Out.WriteLine("This demo only works on Win8 / Win 2012 and above)");                  return;              }
Magic Number,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The following statement contains a magic number: var exceptionGeneationTask = Task.Factory.StartNew(delegate              {                  Thread.Sleep(3000);                  ThrowException();              });
Magic Number,TraceEventSamples,TraceLogMonitor,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\41_TraceLogMonitor.cs,Run,The following statement contains a magic number: using (session = new TraceEventSession("TraceLogSession"))              {                  // Enable the events we care about for the kernel                  // For this instant the session will buffer any incoming events.                    // Enabling kernel events must be done before anything else.                     // This will fail on Win7.                      //                  // Note that if you turn on the KernelTraceEventParser.Keywords.Profile' you can also get stacks for CPU sampling                   // (every millisecond).  (You can use the traceLogSource.Kernel.PerfInfoSample callback).                    Out.WriteLine("Enabling Image load' Process and Thread events.  These are needed to look up native method names.");                  session.EnableKernelProvider(                      // KernelTraceEventParser.Keywords.Profile |            // If you want CPU sampling events                       // KernelTraceEventParser.Keywords.ContextSwitch |      // If you want context switch events                      // KernelTraceEventParser.Keywords.Thread |             // If you want context switch events you also need thread start events.                        KernelTraceEventParser.Keywords.ImageLoad |                      KernelTraceEventParser.Keywords.Process'   /****** The second parameter indicates which kernel events should have stacks *****/                      // KernelTraceEventParser.Keywords.ImageLoad |          // If you want Stacks image load (load library) events                      // KernelTraceEventParser.Keywords.Profile |            // If you want Stacks for CPU sampling events                       // KernelTraceEventParser.Keywords.ContextSwitch |      // If you want Stacks for context switch events                      KernelTraceEventParser.Keywords.None                      );                    Out.WriteLine("Enabling CLR Exception and Load events (and stack for those events)");                  // We are monitoring exception events (with stacks) and module load events (with stacks)                  session.EnableProvider(                      ClrTraceEventParser.ProviderGuid'                      TraceEventLevel.Informational'                      (ulong)(ClrTraceEventParser.Keywords.Jit |              // Turning on JIT events is necessary to resolve JIT compiled code                       ClrTraceEventParser.Keywords.JittedMethodILToNativeMap | // This is needed if you want line number information in the stacks                      ClrTraceEventParser.Keywords.Loader |                   // You must include loader events as well to resolve JIT compiled code.                       ClrTraceEventParser.Keywords.Exception |                // We want to see the exception events.                         ClrTraceEventParser.Keywords.Stack));                   // And stacks on all CLR events where it makes sense.                      // The CLR events turned on above will let you resolve JIT compiled code as long as the JIT compilation                  // happens AFTER the session has started.   To handle the case for JIT compiled code that was already                  // compiled we need to tell the CLR to dump 'Rundown' events for all existing JIT compiled code.  We                  // do that here.                    Out.WriteLine("Enabling CLR Events to 'catch up' on JIT compiled code in running processes.");                  session.EnableProvider(ClrRundownTraceEventParser.ProviderGuid' TraceEventLevel.Informational'                      (ulong)(ClrTraceEventParser.Keywords.Jit |          // We need JIT events to be rundown to resolve method names                      ClrTraceEventParser.Keywords.JittedMethodILToNativeMap | // This is needed if you want line number information in the stacks                      ClrTraceEventParser.Keywords.Loader |               // As well as the module load events.                        ClrTraceEventParser.Keywords.StartEnumeration));    // This indicates to do the rundown now (at enable time)                    // Because we care about symbols in native code or NGEN images' we need a SymbolReader to decode them.                      // There is a lot of messages associated with looking up symbols' but we don't want to clutter up                   // The output by default' so we save it to an internal buffer you can ToString in debug code.                    // A real app should make this available somehow to the user' because sooner or later you DO need it.                    TextWriter SymbolLookupMessages = new StringWriter();                  // TextWriter SymbolLookupMessages = Out;           // If you want the symbol debug spew to go to the output' use this.                     // By default a symbol Reader uses whatever is in the _NT_SYMBOL_PATH variable.  However you can override                  // if you wish by passing it to the SymbolReader constructor.  Since we want this to work even if you                   // have not set an _NT_SYMBOL_PATH' so we add the Microsoft default symbol server path to be sure/                  var symbolPath = new SymbolPath(SymbolPath.SymbolPathFromEnvironment).Add(SymbolPath.MicrosoftSymbolServerPath);                  SymbolReader symbolReader = new SymbolReader(SymbolLookupMessages' symbolPath.ToString());                    Out.WriteLine("Open a real time TraceLog session (which understands how to decode stacks).");                  using (TraceLogEventSource traceLogSource = TraceLog.CreateFromTraceEventSession(session))                   {                      // We use this action in the particular callbacks below.  Basically we pass in a symbol reader so we can decode the stack.                        // Often the symbol reader is a global variable instead.                        Action<TraceEvent> PrintEvent = ((TraceEvent data) => Print(data' symbolReader));                        // We will print Exceptions and ModuleLoad events. (with stacks).                        traceLogSource.Clr.ExceptionStart += PrintEvent;                      traceLogSource.Clr.LoaderModuleLoad += PrintEvent;                      // traceLogSource.Clr.All += PrintEvent;                        // If you want to see stacks for various other kernel events' uncomment these (you also need to turn on the events above)                      traceLogSource.Kernel.PerfInfoSample += ((SampledProfileTraceData data) => Print(data' symbolReader));                      // traceLogSource.Kernel.ImageLoad += ((ImageLoadTraceData data) => Print(data' symbolReader));                        // process events until Ctrl-C is pressed or timeout expires                      Out.WriteLine("Waiting {0} sec for Events.  Run managed code to see data. "' monitoringTimeSec);                      Out.WriteLine("Keep in mind there is a several second buffering delay");                        // Set up a timer to stop processing after monitoringTimeSec                       timer = new Timer(delegate(object state)                      {                          Out.WriteLine("Stopped Monitoring after {0} sec"' monitoringTimeSec);                          if (session != null)                              session.Dispose();                          session = null;                      }' null' monitoringTimeSec * 1000' Timeout.Infinite);                        traceLogSource.Process();                  }              }
Magic Number,TraceEventSamples,SimpleFileRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\50_SimpleFileRelogger.cs,DataCollection,The following statement contains a magic number: using (var session = new TraceEventSession("MonitorKernelAndClrEventsSession"' dataFileName))              {                  // Set up Ctrl-C to stop both user mode and kernel mode sessions                  Console.CancelKeyPress += delegate(object sender' ConsoleCancelEventArgs cancelArgs)                  {                      Out.WriteLine("Insuring all ETW sessions are stopped.");                      session.Stop(true);         // true means don't throw on error                      // Since we don't cancel the Ctrl-C we will terminate the process as normal for Ctrl-C                      Out.WriteLine("OnCtrl C handler ending.");                  };                    // Enable the events we care about for the kernel in the kernel session                  // For this instant the session will buffer any incoming events.                    // This has to be first' and it will fail if you are not on Win8.                    session.EnableKernelProvider(                      KernelTraceEventParser.Keywords.ImageLoad |                      KernelTraceEventParser.Keywords.Process |                      KernelTraceEventParser.Keywords.Thread);                    // Enable the events we care about for the CLR (in the user session).                  // unlike the kernel session' you can call EnableProvider on other things too.                    // For this instant the session will buffer any incoming events.                    session.EnableProvider(                      ClrTraceEventParser.ProviderGuid'                      TraceEventLevel.Verbose'                      (ulong)(ClrTraceEventParser.Keywords.Default));                    Out.WriteLine("Collecting data for 10 seconds (run a .Net program to generate events).");                  Thread.Sleep(10000);                    Out.WriteLine("Stopping sessions");              }
Magic Number,TraceEventSamples,SimpleFileRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\50_SimpleFileRelogger.cs,DataProcessing,The following statement contains a magic number: using (var source = new ETWTraceEventSource(dataFileName))              {                  if (source.EventsLost != 0)                      Out.WriteLine("WARNING: there were {0} lost events"' source.EventsLost);                    // Set up callbacks to                   source.Clr.All += Print;                  source.Kernel.All += Print;                    // When you merge a file' some 'symbol' events are injected into the trace.                    // To avoid these showing up as 'unknown' add the parser for these.  This                  // also shows how you hook up a TraceEventParser that is not support by                  // properties on the source itself (like CLR' and kernel)                  var symbolParser = new SymbolTraceEventParser(source);                  symbolParser.All += Print;    #if DEBUG                  // The callback above will only be called for events the parser recognizes (in the case of Kernel and CLR parsers)                  // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you                   // can ask the source to send them to you like this.                    source.UnhandledEvents += delegate(TraceEvent data)                  {                      // To avoid 'rundown' events that happen in the beginning and end of the trace filter out things during those times                      if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                          return;                        Out.WriteLine("GOT UNHANDLED EVENT: " + data.Dump());                  };  #endif                    // go into a loop processing events can calling the callbacks.  This will return when the all the events                  // In the file are processed' or the StopProcessing() call is made.                    source.Process();                  Out.WriteLine("Done Processing.");              }
Magic Number,TraceEventSamples,SimpleFileRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\50_SimpleFileRelogger.cs,DataProcessing,The following statement contains a magic number: using (var source = new ETWTraceEventSource(dataFileName))              {                  if (source.EventsLost != 0)                      Out.WriteLine("WARNING: there were {0} lost events"' source.EventsLost);                    // Set up callbacks to                   source.Clr.All += Print;                  source.Kernel.All += Print;                    // When you merge a file' some 'symbol' events are injected into the trace.                    // To avoid these showing up as 'unknown' add the parser for these.  This                  // also shows how you hook up a TraceEventParser that is not support by                  // properties on the source itself (like CLR' and kernel)                  var symbolParser = new SymbolTraceEventParser(source);                  symbolParser.All += Print;    #if DEBUG                  // The callback above will only be called for events the parser recognizes (in the case of Kernel and CLR parsers)                  // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you                   // can ask the source to send them to you like this.                    source.UnhandledEvents += delegate(TraceEvent data)                  {                      // To avoid 'rundown' events that happen in the beginning and end of the trace filter out things during those times                      if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                          return;                        Out.WriteLine("GOT UNHANDLED EVENT: " + data.Dump());                  };  #endif                    // go into a loop processing events can calling the callbacks.  This will return when the all the events                  // In the file are processed' or the StopProcessing() call is made.                    source.Process();                  Out.WriteLine("Done Processing.");              }
Magic Number,TraceEventSamples,SimpleFileRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\50_SimpleFileRelogger.cs,Print,The following statement contains a magic number: if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                  return;
Magic Number,TraceEventSamples,SimpleFileRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\50_SimpleFileRelogger.cs,Print,The following statement contains a magic number: if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                  return;
Magic Number,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,Run,The following statement contains a magic number: int monitoringTimeSec = 10;
Magic Number,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,Run,The following statement contains a magic number: if (Environment.OSVersion.Version.Major * 10 + Environment.OSVersion.Version.Minor < 62)              {                  Out.WriteLine("This demo only works on Win8 / Win 2012 an above)");                  return;              }
Magic Number,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,Run,The following statement contains a magic number: if (Environment.OSVersion.Version.Major * 10 + Environment.OSVersion.Version.Minor < 62)              {                  Out.WriteLine("This demo only works on Win8 / Win 2012 an above)");                  return;              }
Magic Number,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,Run,The following statement contains a magic number: using (var session = new TraceEventSession(sessionName))              {                  // Enable the events we care about for the kernel in the kernel session                  // For this instant the session will buffer any incoming events.                    // This has to be first' and it will fail if you are not on Win8.                    session.EnableKernelProvider(                      KernelTraceEventParser.Keywords.ImageLoad |                      KernelTraceEventParser.Keywords.Process |                      KernelTraceEventParser.Keywords.Thread);                    // A relogger is a TraceEventSource and acts much like an ETWTraceEventSource' with extra Write APIS.                   // Thus you get a callback on any event you want.                     // Only things that you call 'WriteEvent' on will end up in the output file.                    var relogger = new ETWReloggerTraceEventSource(sessionName' TraceEventSourceType.Session' outputFileName);                    // Here we set up the callbacks we want in the output file.   In this case all GC allocation Tick                  // events for 'String' as well as any ExceptionStart events.                    relogger.Clr.GCAllocationTick += delegate(GCAllocationTickTraceData data)                  {                      if (data.TypeName == "System.String")                          relogger.WriteEvent(data);                  };                  relogger.Clr.ExceptionStart += delegate(ExceptionTraceData data)                  {                      relogger.WriteEvent(data);                  };                    // We also keep the image load events for DLL with 'clr' in their name.                  relogger.Kernel.ImageGroup += delegate(ImageLoadTraceData data)                  {                      if (0 <= data.FileName.IndexOf("clr"' StringComparison.OrdinalIgnoreCase))                          relogger.WriteEvent(data);                  };    #if false       // Turn on to get debugging on unhandled events.                    relogger.UnhandledEvents += delegate(TraceEvent data)                  {                      Console.WriteLine("Unknown Event " + data);                  };  #endif                  // Allow the test to be terminated with Ctrl-C cleanly.                   Console.CancelKeyPress += delegate(object sender' ConsoleCancelEventArgs e) { session.Dispose(); };                    // Set up a timer to stop processing after monitoringTimeSec                  var timer = new Timer(delegate(object state)                  {                      Out.WriteLine("Stopped after {0} sec"' monitoringTimeSec);                      session.Dispose();                  }' null' monitoringTimeSec * 1000' Timeout.Infinite);                    // Turn on the events to the provider.  In this case most CLR events                     Out.WriteLine("**** Turn on CLR Etw Providers.  Run managed code to see events.");                  session.EnableProvider(ClrTraceEventParser.ProviderGuid' TraceEventLevel.Verbose' (ulong)ClrTraceEventParser.Keywords.Default);                    // go into a loop processing events can calling the callbacks.  Because this is live data (not from a file)                  // processing never completes by itself' but only because someone called 'source.Dispose()'.                    Out.WriteLine("**** Start listening for events from the Microsoft-Demos-SimpleMonitor provider.");                  Out.WriteLine("The monitor will run for a maximum of {0} seconds.  Run managed code for more output."' monitoringTimeSec);                  relogger.Process();                  Out.WriteLine();                  Out.WriteLine("Stopping the collection of events.");                  timer.Dispose();    // Turn off the timer.                }
Magic Number,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,DataProcessing,The following statement contains a magic number: using (var source = new ETWTraceEventSource(dataFileName))              {                  if (source.EventsLost != 0)                      Out.WriteLine("WARNING: there were {0} lost events"' source.EventsLost);                    // Set up callbacks to                   source.Clr.All += Print;                  source.Kernel.All += Print;                    // When you merge a file' some 'symbol' events are injected into the trace.                    // To avoid these showing up as 'unknown' add the parser for these.  This                  // also shows how you hook up a TraceEventParser that is not support by                  // properties on the source itself (like CLR' and kernel)                  var symbolParser = new SymbolTraceEventParser(source);                  symbolParser.All += Print;    #if DEBUG                  // The callback above will only be called for events the parser recognizes (in the case of Kernel and CLR parsers)                  // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you                   // can ask the source to send them to you like this.                    source.UnhandledEvents += delegate(TraceEvent data)                  {                      // To avoid 'rundown' events that happen in the beginning and end of the trace filter out things during those times                      if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                          return;                        Out.WriteLine("GOT UNHANDLED EVENT: " + data.Dump());                  };  #endif                    // go into a loop processing events can calling the callbacks.  This will return when the all the events                  // In the file are processed' or the StopProcessing() call is made.                    source.Process();                  Out.WriteLine("Done Processing.");              }
Magic Number,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,DataProcessing,The following statement contains a magic number: using (var source = new ETWTraceEventSource(dataFileName))              {                  if (source.EventsLost != 0)                      Out.WriteLine("WARNING: there were {0} lost events"' source.EventsLost);                    // Set up callbacks to                   source.Clr.All += Print;                  source.Kernel.All += Print;                    // When you merge a file' some 'symbol' events are injected into the trace.                    // To avoid these showing up as 'unknown' add the parser for these.  This                  // also shows how you hook up a TraceEventParser that is not support by                  // properties on the source itself (like CLR' and kernel)                  var symbolParser = new SymbolTraceEventParser(source);                  symbolParser.All += Print;    #if DEBUG                  // The callback above will only be called for events the parser recognizes (in the case of Kernel and CLR parsers)                  // It is sometimes useful to see the other events that are not otherwise being handled.  The source knows about these and you                   // can ask the source to send them to you like this.                    source.UnhandledEvents += delegate(TraceEvent data)                  {                      // To avoid 'rundown' events that happen in the beginning and end of the trace filter out things during those times                      if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                          return;                        Out.WriteLine("GOT UNHANDLED EVENT: " + data.Dump());                  };  #endif                    // go into a loop processing events can calling the callbacks.  This will return when the all the events                  // In the file are processed' or the StopProcessing() call is made.                    source.Process();                  Out.WriteLine("Done Processing.");              }
Magic Number,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,Print,The following statement contains a magic number: if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                  return;
Magic Number,TraceEventSamples,SimpleMonitorRelogger,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\51_SimpleMonitorRelogger.cs,Print,The following statement contains a magic number: if (data.TimeStampRelativeMSec < 1000 || 9000 < data.TimeStampRelativeMSec)                  return;
Magic Number,TraceEventSamples,MyEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,MySecondEvent,The following statement contains a magic number: WriteEvent(2' MyId);
Magic Number,TraceEventSamples,MyEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,Stop,The following statement contains a magic number: WriteEvent(3);
Magic Number,TraceEventSamples,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,CreateEvents,The following statement contains a magic number: Task.Factory.StartNew(delegate                  {                      Out.WriteLine("***** Starting to generate events to Microsoft-Demos-SimpleMonitor for 10 seconds.");                      for (int i = 0; i < 10; i++)                      {                          Out.WriteLine("** Generating a MyFirst and MySecond from Microsoft-Demos-SimpleMonitor.");                          MyEventSource.Log.MyFirstEvent("Some string " + i.ToString()' i);                          Thread.Sleep(10);                          MyEventSource.Log.MySecondEvent(i);                          Out.WriteLine("Waiting a second");                          Thread.Sleep(1000);                      }                      Out.WriteLine("** Generating the Microsoft-Demos-SimpleMonitor Stop Event.");                      MyEventSource.Log.Stop();                  });
Magic Number,TraceEventSamples,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,CreateEvents,The following statement contains a magic number: Task.Factory.StartNew(delegate                  {                      Out.WriteLine("***** Starting to generate events to Microsoft-Demos-SimpleMonitor for 10 seconds.");                      for (int i = 0; i < 10; i++)                      {                          Out.WriteLine("** Generating a MyFirst and MySecond from Microsoft-Demos-SimpleMonitor.");                          MyEventSource.Log.MyFirstEvent("Some string " + i.ToString()' i);                          Thread.Sleep(10);                          MyEventSource.Log.MySecondEvent(i);                          Out.WriteLine("Waiting a second");                          Thread.Sleep(1000);                      }                      Out.WriteLine("** Generating the Microsoft-Demos-SimpleMonitor Stop Event.");                      MyEventSource.Log.Stop();                  });
Magic Number,TraceEventSamples,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,CreateEvents,The following statement contains a magic number: Task.Factory.StartNew(delegate                  {                      Out.WriteLine("***** Starting to generate events to Microsoft-Demos-SimpleMonitor for 10 seconds.");                      for (int i = 0; i < 10; i++)                      {                          Out.WriteLine("** Generating a MyFirst and MySecond from Microsoft-Demos-SimpleMonitor.");                          MyEventSource.Log.MyFirstEvent("Some string " + i.ToString()' i);                          Thread.Sleep(10);                          MyEventSource.Log.MySecondEvent(i);                          Out.WriteLine("Waiting a second");                          Thread.Sleep(1000);                      }                      Out.WriteLine("** Generating the Microsoft-Demos-SimpleMonitor Stop Event.");                      MyEventSource.Log.Stop();                  });
Magic Number,TraceEventSamples,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,GenerateExceptions,The following statement contains a magic number: try { MethodB(-3); }                  catch (Exception) { }
Magic Number,Producer,MyEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,MySecondEvent,The following statement contains a magic number: WriteEvent(2' MyId);
Magic Number,Producer,MyEventSource,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,Stop,The following statement contains a magic number: WriteEvent(3);
Magic Number,Producer,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,CreateEvents,The following statement contains a magic number: Task.Factory.StartNew(delegate                  {                      Out.WriteLine("***** Starting to generate events to Microsoft-Demos-SimpleMonitor for 10 seconds.");                      for (int i = 0; i < 10; i++)                      {                          Out.WriteLine("** Generating a MyFirst and MySecond from Microsoft-Demos-SimpleMonitor.");                          MyEventSource.Log.MyFirstEvent("Some string " + i.ToString()' i);                          Thread.Sleep(10);                          MyEventSource.Log.MySecondEvent(i);                          Out.WriteLine("Waiting a second");                          Thread.Sleep(1000);                      }                      Out.WriteLine("** Generating the Microsoft-Demos-SimpleMonitor Stop Event.");                      MyEventSource.Log.Stop();                  });
Magic Number,Producer,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,CreateEvents,The following statement contains a magic number: Task.Factory.StartNew(delegate                  {                      Out.WriteLine("***** Starting to generate events to Microsoft-Demos-SimpleMonitor for 10 seconds.");                      for (int i = 0; i < 10; i++)                      {                          Out.WriteLine("** Generating a MyFirst and MySecond from Microsoft-Demos-SimpleMonitor.");                          MyEventSource.Log.MyFirstEvent("Some string " + i.ToString()' i);                          Thread.Sleep(10);                          MyEventSource.Log.MySecondEvent(i);                          Out.WriteLine("Waiting a second");                          Thread.Sleep(1000);                      }                      Out.WriteLine("** Generating the Microsoft-Demos-SimpleMonitor Stop Event.");                      MyEventSource.Log.Stop();                  });
Magic Number,Producer,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,CreateEvents,The following statement contains a magic number: Task.Factory.StartNew(delegate                  {                      Out.WriteLine("***** Starting to generate events to Microsoft-Demos-SimpleMonitor for 10 seconds.");                      for (int i = 0; i < 10; i++)                      {                          Out.WriteLine("** Generating a MyFirst and MySecond from Microsoft-Demos-SimpleMonitor.");                          MyEventSource.Log.MyFirstEvent("Some string " + i.ToString()' i);                          Thread.Sleep(10);                          MyEventSource.Log.MySecondEvent(i);                          Out.WriteLine("Waiting a second");                          Thread.Sleep(1000);                      }                      Out.WriteLine("** Generating the Microsoft-Demos-SimpleMonitor Stop Event.");                      MyEventSource.Log.Stop();                  });
Magic Number,Producer,EventGenerator,C:\repos\Microsoft_dotnetsamples\Microsoft.Diagnostics.Tracing\TraceEvent\TraceEvent\SupportFiles\EventProducer.cs,GenerateExceptions,The following statement contains a magic number: try { MethodB(-3); }                  catch (Exception) { }
