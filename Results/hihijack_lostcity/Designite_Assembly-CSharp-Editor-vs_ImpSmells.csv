Implementation smell,Namespace,Class,File,Method,Description
Long Method,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The method has 112 lines of code.
Complex Method,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,Cyclomatic complexity of the method is 20
Complex Method,tk2dAtlas,MaxRectsBinPack,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\MaxRectsBinPack.cs,Insert,Cyclomatic complexity of the method is 17
Complex Method,tk2dAtlas,MaxRectsBinPack,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\MaxRectsBinPack.cs,ScoreRect,Cyclomatic complexity of the method is 17
Long Parameter List,tk2dAtlas,MaxRectsBinPack,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\MaxRectsBinPack.cs,ScoreRect,The method has 5 parameters.
Long Statement,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,FindBestBinPacker,The length of the statement  "	//                                                         MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestShortSideFit' " is 120.
Long Statement,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,FindBestBinPacker,The length of the statement  "	//                                                         MaxRectsBinPack.FreeRectChoiceHeuristic.RectContactPointRule }; " is 122.
Long Statement,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The length of the statement  "			// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value " is 123.
Long Statement,tk2dAtlas,MaxRectsBinPack,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\MaxRectsBinPack.cs,FindPositionForNewNodeBestShortSideFit,The length of the statement  "			if (flippedShortSideFit < bestShortSideFit || (flippedShortSideFit == bestShortSideFit && flippedLongSideFit < bestLongSideFit)) { " is 130.
Long Statement,tk2dAtlas,MaxRectsBinPack,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\MaxRectsBinPack.cs,SplitFreeNode,The length of the statement  "	if (usedNode.x >= freeNode.x + freeNode.width || usedNode.x + usedNode.width <= freeNode.x || usedNode.y >= freeNode.y + freeNode.height || usedNode.y + usedNode.height <= freeNode.y) " is 183.
Complex Conditional,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The conditional expression  "firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted"  is complex.
Complex Conditional,tk2dAtlas,MaxRectsBinPack,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\MaxRectsBinPack.cs,SplitFreeNode,The conditional expression  "usedNode.x >= freeNode.x + freeNode.width || usedNode.x + usedNode.width <= freeNode.x || usedNode.y >= freeNode.y + freeNode.height || usedNode.y + usedNode.height <= freeNode.y"  is complex.
Complex Conditional,tk2dAtlas,DisjointRectCollection,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\Rect.cs,IsDisjoint,The conditional expression  "(a.x + a.width <= b.x) || (b.x + b.width <= a.x) || (a.y + a.height <= b.y) || (b.y + b.height <= a.y)"  is complex.
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  			List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  						matchedId = i;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  							matchedId = i;  							flipped = true;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				AtlasEntry newEntry = new AtlasEntry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x;  				newEntry.y = t.y;  				newEntry.w = t.width;  				newEntry.h = t.height;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			AtlasData currAtlas = new AtlasData ();  			currAtlas.width = thisCellW;  			currAtlas.height = thisCellH;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  				reverted = true;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  			List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  						matchedId = i;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  							matchedId = i;  							flipped = true;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				AtlasEntry newEntry = new AtlasEntry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x;  				newEntry.y = t.y;  				newEntry.w = t.width;  				newEntry.h = t.height;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			AtlasData currAtlas = new AtlasData ();  			currAtlas.width = thisCellW;  			currAtlas.height = thisCellH;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  				reverted = true;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  			List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  						matchedId = i;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  							matchedId = i;  							flipped = true;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				AtlasEntry newEntry = new AtlasEntry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x;  				newEntry.y = t.y;  				newEntry.w = t.width;  				newEntry.h = t.height;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			AtlasData currAtlas = new AtlasData ();  			currAtlas.width = thisCellW;  			currAtlas.height = thisCellH;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  				reverted = true;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  			List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  						matchedId = i;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  							matchedId = i;  							flipped = true;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				AtlasEntry newEntry = new AtlasEntry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x;  				newEntry.y = t.y;  				newEntry.w = t.width;  				newEntry.h = t.height;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			AtlasData currAtlas = new AtlasData ();  			currAtlas.width = thisCellW;  			currAtlas.height = thisCellH;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  				reverted = true;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  		List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  					matchedId = i;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  						matchedId = i;  						flipped = true;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			AtlasEntry newEntry = new AtlasEntry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x;  			newEntry.y = t.y;  			newEntry.w = t.width;  			newEntry.h = t.height;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		AtlasData currAtlas = new AtlasData ();  		currAtlas.width = thisCellW;  		currAtlas.height = thisCellH;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  			reverted = true;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  		numPasses++;  	}  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  		List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  					matchedId = i;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  						matchedId = i;  						flipped = true;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			AtlasEntry newEntry = new AtlasEntry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x;  			newEntry.y = t.y;  			newEntry.w = t.width;  			newEntry.h = t.height;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		AtlasData currAtlas = new AtlasData ();  		currAtlas.width = thisCellW;  		currAtlas.height = thisCellH;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  			reverted = true;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  		numPasses++;  	}  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  		List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  					matchedId = i;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  						matchedId = i;  						flipped = true;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			AtlasEntry newEntry = new AtlasEntry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x;  			newEntry.y = t.y;  			newEntry.w = t.width;  			newEntry.h = t.height;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		AtlasData currAtlas = new AtlasData ();  		currAtlas.width = thisCellW;  		currAtlas.height = thisCellH;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  			reverted = true;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  		numPasses++;  	}  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  		List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  					matchedId = i;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  						matchedId = i;  						flipped = true;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			AtlasEntry newEntry = new AtlasEntry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x;  			newEntry.y = t.y;  			newEntry.w = t.width;  			newEntry.h = t.height;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		AtlasData currAtlas = new AtlasData ();  		currAtlas.width = thisCellW;  		currAtlas.height = thisCellH;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  			reverted = true;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  		numPasses++;  	}  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  	List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  				matchedId = i;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  					matchedId = i;  					flipped = true;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		AtlasEntry newEntry = new AtlasEntry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x;  		newEntry.y = t.y;  		newEntry.w = t.width;  		newEntry.h = t.height;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	AtlasData currAtlas = new AtlasData ();  	currAtlas.width = thisCellW;  	currAtlas.height = thisCellH;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  		reverted = true;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  	numPasses++;  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  	List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  				matchedId = i;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  					matchedId = i;  					flipped = true;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		AtlasEntry newEntry = new AtlasEntry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x;  		newEntry.y = t.y;  		newEntry.w = t.width;  		newEntry.h = t.height;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	AtlasData currAtlas = new AtlasData ();  	currAtlas.width = thisCellW;  	currAtlas.height = thisCellH;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  		reverted = true;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  	numPasses++;  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  	List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  				matchedId = i;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  					matchedId = i;  					flipped = true;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		AtlasEntry newEntry = new AtlasEntry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x;  		newEntry.y = t.y;  		newEntry.w = t.width;  		newEntry.h = t.height;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	AtlasData currAtlas = new AtlasData ();  	currAtlas.width = thisCellW;  	currAtlas.height = thisCellH;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  		reverted = true;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  	numPasses++;  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted) {  	List<AtlasEntry> atlasEntries = new List<AtlasEntry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			if (!usedRect [i] && sourceRects [i].width == t.width && sourceRects [i].height == t.height) {  				matchedId = i;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				if (!usedRect [i] && sourceRects [i].width == t.height && sourceRects [i].height == t.width) {  					matchedId = i;  					flipped = true;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		AtlasEntry newEntry = new AtlasEntry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x;  		newEntry.y = t.y;  		newEntry.w = t.width;  		newEntry.h = t.height;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	AtlasData currAtlas = new AtlasData ();  	currAtlas.width = thisCellW;  	currAtlas.height = thisCellH;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  		reverted = true;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  	numPasses++;  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	// Can only try another size when it already has been scaled down for the first time  	if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  		// Tried to scale down' but the texture doesn't fit' so revert previous change' and   		// iterate over the data again forcing a pass even though there is wastage  		if (thisCellW < thisCellH)  			thisCellW *= 2;  		else  			thisCellH *= 2;  	}  	reverted = true;  }  else {  	// More than half the texture was unused' scale down by one of the dimensions  	if (thisCellW < thisCellH)  		thisCellH /= 2;  	else  		thisCellW /= 2;  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	// Can only try another size when it already has been scaled down for the first time  	if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  		// Tried to scale down' but the texture doesn't fit' so revert previous change' and   		// iterate over the data again forcing a pass even though there is wastage  		if (thisCellW < thisCellH)  			thisCellW *= 2;  		else  			thisCellH *= 2;  	}  	reverted = true;  }  else {  	// More than half the texture was unused' scale down by one of the dimensions  	if (thisCellW < thisCellH)  		thisCellH /= 2;  	else  		thisCellW /= 2;  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	// Can only try another size when it already has been scaled down for the first time  	if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  		// Tried to scale down' but the texture doesn't fit' so revert previous change' and   		// iterate over the data again forcing a pass even though there is wastage  		if (thisCellW < thisCellH)  			thisCellW *= 2;  		else  			thisCellH *= 2;  	}  	reverted = true;  }  else {  	// More than half the texture was unused' scale down by one of the dimensions  	if (thisCellW < thisCellH)  		thisCellH /= 2;  	else  		thisCellW /= 2;  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	// Can only try another size when it already has been scaled down for the first time  	if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  		// Tried to scale down' but the texture doesn't fit' so revert previous change' and   		// iterate over the data again forcing a pass even though there is wastage  		if (thisCellW < thisCellH)  			thisCellW *= 2;  		else  			thisCellH *= 2;  	}  	reverted = true;  }  else {  	// More than half the texture was unused' scale down by one of the dimensions  	if (thisCellW < thisCellH)  		thisCellH /= 2;  	else  		thisCellW /= 2;  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  	// Tried to scale down' but the texture doesn't fit' so revert previous change' and   	// iterate over the data again forcing a pass even though there is wastage  	if (thisCellW < thisCellH)  		thisCellW *= 2;  	else  		thisCellH *= 2;  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  	// Tried to scale down' but the texture doesn't fit' so revert previous change' and   	// iterate over the data again forcing a pass even though there is wastage  	if (thisCellW < thisCellH)  		thisCellW *= 2;  	else  		thisCellH *= 2;  }  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < thisCellH)  	thisCellW *= 2;  else  	thisCellH *= 2;  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < thisCellH)  	thisCellW *= 2;  else  	thisCellH *= 2;  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: thisCellW *= 2;  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: thisCellH *= 2;  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < thisCellH)  	thisCellH /= 2;  else  	thisCellW /= 2;  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < thisCellH)  	thisCellH /= 2;  else  	thisCellW /= 2;  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: thisCellH /= 2;  
Magic Number,tk2dAtlas,AtlasBuilder,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\AtlasBuilder.cs,Build,The following statement contains a magic number: thisCellW /= 2;  
Missing Default,tk2dAtlas,MaxRectsBinPack,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\MaxRectsBinPack.cs,Insert,The following switch statement is missing a default case: switch (method) {  case FreeRectChoiceHeuristic.RectBestShortSideFit:  	newNode = FindPositionForNewNodeBestShortSideFit (width' height' ref score1' ref score2);  	break;  case FreeRectChoiceHeuristic.RectBottomLeftRule:  	newNode = FindPositionForNewNodeBottomLeft (width' height' ref score1' ref score2);  	break;  case FreeRectChoiceHeuristic.RectContactPointRule:  	newNode = FindPositionForNewNodeContactPoint (width' height' ref score1);  	break;  case FreeRectChoiceHeuristic.RectBestLongSideFit:  	newNode = FindPositionForNewNodeBestLongSideFit (width' height' ref score2' ref score1);  	break;  case FreeRectChoiceHeuristic.RectBestAreaFit:  	newNode = FindPositionForNewNodeBestAreaFit (width' height' ref score1' ref score2);  	break;  }  
Missing Default,tk2dAtlas,MaxRectsBinPack,C:\repos\hihijack_lostcity\Assets\TK2DROOT\tk2d\Sprites\Editor\Atlas\MaxRectsBinPack.cs,ScoreRect,The following switch statement is missing a default case: switch (method) {  case FreeRectChoiceHeuristic.RectBestShortSideFit:  	newNode = FindPositionForNewNodeBestShortSideFit (width' height' ref score1' ref score2);  	break;  case FreeRectChoiceHeuristic.RectBottomLeftRule:  	newNode = FindPositionForNewNodeBottomLeft (width' height' ref score1' ref score2);  	break;  case FreeRectChoiceHeuristic.RectContactPointRule:  	newNode = FindPositionForNewNodeContactPoint (width' height' ref score1);  	score1 = -score1;  	// Reverse since we are minimizing' but for contact point score bigger is better.  	break;  case FreeRectChoiceHeuristic.RectBestLongSideFit:  	newNode = FindPositionForNewNodeBestLongSideFit (width' height' ref score2' ref score1);  	break;  case FreeRectChoiceHeuristic.RectBestAreaFit:  	newNode = FindPositionForNewNodeBestAreaFit (width' height' ref score1' ref score2);  	break;  }  
