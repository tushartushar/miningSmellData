Implementation smell,Namespace,Class,File,Method,Description
Complex Method,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Read,Cyclomatic complexity of the method is 21
Complex Method,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Write,Cyclomatic complexity of the method is 65
Long Parameter List,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,CIA,The method has 5 parameters.
Complex Conditional,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,IncrementTod,The conditional expression  "(_todClkCnt == 5 && clock != 0) || (_todClkCnt == 6 && clock == 0)"  is complex.
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,IncrementTod,The following statement contains a magic number: if ((_todClkCnt == 5 && clock != 0) || (_todClkCnt == 6 && clock == 0)) {  	_todClkCnt = 0;  	if (!_todPause) {  		bool alarm = true;  		byte lim = (byte)_todLimits.Length;  		for (byte carry = 1' i = 0; i < lim; i++) {  			byte value = _tod [(byte)TOD_R.CURRENT' i];  			value += carry;  			carry = 0;  			if (value == _todLimits [i]) {  				value = 0;  				carry = 1;  			}  			_tod [(byte)TOD_R.CURRENT' i] = value;  			alarm = alarm && _tod [(byte)TOD_R.ALARM' i] == value;  		}  		if (alarm)  			SetInterrupt (IR.TOD);  	}  }  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,IncrementTod,The following statement contains a magic number: if ((_todClkCnt == 5 && clock != 0) || (_todClkCnt == 6 && clock == 0)) {  	_todClkCnt = 0;  	if (!_todPause) {  		bool alarm = true;  		byte lim = (byte)_todLimits.Length;  		for (byte carry = 1' i = 0; i < lim; i++) {  			byte value = _tod [(byte)TOD_R.CURRENT' i];  			value += carry;  			carry = 0;  			if (value == _todLimits [i]) {  				value = 0;  				carry = 1;  			}  			_tod [(byte)TOD_R.CURRENT' i] = value;  			alarm = alarm && _tod [(byte)TOD_R.ALARM' i] == value;  		}  		if (alarm)  			SetInterrupt (IR.TOD);  	}  }  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Read,The following statement contains a magic number: switch (address) {  case (ushort)Registers.PA_D:  	return (byte)((_portA.Input | _portA.WriteOnly) & (_portA.Output | ~_portA.Direction));  case (ushort)Registers.PB_D:  	_pcState = true;  	return (byte)((_portB.Input | _portB.WriteOnly) & (_portB.Output | ~_portB.Direction));  case (ushort)Registers.PA_DD:  	return _portA.Direction;  case (ushort)Registers.PB_DD:  	return _portB.Direction;  case (ushort)Registers.TA_L:  	return (byte)_timerA._current;  case (ushort)Registers.TA_H:  	return (byte)(_timerA._current >> 8);  case (ushort)Registers.TB_L:  	return (byte)_timerB._current;  case (ushort)Registers.TB_H:  	return (byte)(_timerB._current >> 8);  case (ushort)Registers.TOD_T:  	return ReadTOD (TOD.TENTH);  case (ushort)Registers.TOD_S:  	return ReadTOD (TOD.SECONDS);  case (ushort)Registers.TOD_M:  	return ReadTOD (TOD.MINUTES);  case (ushort)Registers.TOD_H:  	return ReadTOD (TOD.HOURS);  case (ushort)Registers.SERIAL:  	return _serialRegister;  case (ushort)Registers.IR:  	byte status = _interruptRegisters [0];  	_interruptRegisters [0] = 0;  	if ((status & (byte)IR.REQ) != 0)  		_irqLine.Lower ();  	return status;  case (ushort)Registers.TA_CR:  	return _timerA._controlReg;  case (ushort)Registers.TB_CR:  	return _timerB._controlReg;  }  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Read,The following statement contains a magic number: switch (address) {  case (ushort)Registers.PA_D:  	return (byte)((_portA.Input | _portA.WriteOnly) & (_portA.Output | ~_portA.Direction));  case (ushort)Registers.PB_D:  	_pcState = true;  	return (byte)((_portB.Input | _portB.WriteOnly) & (_portB.Output | ~_portB.Direction));  case (ushort)Registers.PA_DD:  	return _portA.Direction;  case (ushort)Registers.PB_DD:  	return _portB.Direction;  case (ushort)Registers.TA_L:  	return (byte)_timerA._current;  case (ushort)Registers.TA_H:  	return (byte)(_timerA._current >> 8);  case (ushort)Registers.TB_L:  	return (byte)_timerB._current;  case (ushort)Registers.TB_H:  	return (byte)(_timerB._current >> 8);  case (ushort)Registers.TOD_T:  	return ReadTOD (TOD.TENTH);  case (ushort)Registers.TOD_S:  	return ReadTOD (TOD.SECONDS);  case (ushort)Registers.TOD_M:  	return ReadTOD (TOD.MINUTES);  case (ushort)Registers.TOD_H:  	return ReadTOD (TOD.HOURS);  case (ushort)Registers.SERIAL:  	return _serialRegister;  case (ushort)Registers.IR:  	byte status = _interruptRegisters [0];  	_interruptRegisters [0] = 0;  	if ((status & (byte)IR.REQ) != 0)  		_irqLine.Lower ();  	return status;  case (ushort)Registers.TA_CR:  	return _timerA._controlReg;  case (ushort)Registers.TB_CR:  	return _timerB._controlReg;  }  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Read,The following statement contains a magic number: return (byte)(_timerA._current >> 8);  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Read,The following statement contains a magic number: return (byte)(_timerB._current >> 8);  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.PA_D:  	_portA.Output = value;  	break;  case (ushort)Registers.PB_D:  	_pcState = true;  	_portB.Output = value;  	break;  case (ushort)Registers.PA_DD:  	_portA.Direction = value;  	break;  case (ushort)Registers.PB_DD:  	_portB.Direction = value;  	break;  case (ushort)Registers.TA_L:  	_timerA._latch = (ushort)((_timerA._latch & 0xff00) | value);  	break;  case (ushort)Registers.TA_H:  	_timerA._latch = (ushort)((_timerA._latch & 0x00ff) | (value << 8));  	break;  case (ushort)Registers.TB_L:  	_timerB._latch = (ushort)((_timerB._latch & 0xff00) | value);  	break;  case (ushort)Registers.TB_H:  	_timerB._latch = (ushort)((_timerB._latch & 0x00ff) | (value << 8));  	break;  case (ushort)Registers.TOD_T:  	WriteTOD (TOD.TENTH' value);  	break;  case (ushort)Registers.TOD_S:  	WriteTOD (TOD.SECONDS' value);  	break;  case (ushort)Registers.TOD_M:  	WriteTOD (TOD.MINUTES' value);  	break;  case (ushort)Registers.TOD_H:  	WriteTOD (TOD.HOURS' value);  	break;  case (ushort)Registers.SERIAL:  	break;  case (ushort)Registers.IR:  	if ((value & 0x80) != 0) {  		_interruptRegisters [1] |= (byte)(value & 0x7f);  		if ((_interruptRegisters [0] & _interruptRegisters [1]) != 0 && (_interruptRegisters [0] & (byte)IR.REQ) == 0) {  			_interruptRegisters [0] |= (byte)IR.REQ;  			_irqLine.Raise ();  		}  	}  	else {  		_interruptRegisters [1] &= (byte)(~value & 0x7f);  		if ((_interruptRegisters [0] & _interruptRegisters [1]) == 0 && (_interruptRegisters [0] & (byte)IR.REQ) != 0) {  			byte mask = (byte)IR.REQ;  			_interruptRegisters [0] &= (byte)~mask;  			_irqLine.Lower ();  		}  	}  	break;  case (ushort)Registers.TA_CR:  	_timerA._controlReg = value;  	_timerA._active = (value & (byte)TA_CR.ST) != 0;  	_timerA._mode = (byte)(value & 0x20);  	_timerA._oneTime = (value & (byte)TA_CR.RM) != 0;  	_timerA._output = (value & (byte)TA_CR.PB) == 0;  	_timerA._pulsing = (value & (byte)TA_CR.OM) == 0;  	if ((value & (byte)TA_CR.LD) != 0)  		_timerA._current = _timerA._latch;  	break;  case (ushort)Registers.TB_CR:  	_timerB._controlReg = value;  	_timerB._active = (value & (byte)TA_CR.ST) != 0;  	_timerB._mode = (byte)(value & 0x80);  	_timerB._oneTime = (value & (byte)TA_CR.RM) != 0;  	_timerB._output = (value & (byte)TA_CR.PB) == 0;  	_timerB._pulsing = (value & (byte)TA_CR.OM) == 0;  	if ((value & (byte)TB_CR.LD) != 0)  		_timerA._current = _timerA._latch;  	break;  }  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.PA_D:  	_portA.Output = value;  	break;  case (ushort)Registers.PB_D:  	_pcState = true;  	_portB.Output = value;  	break;  case (ushort)Registers.PA_DD:  	_portA.Direction = value;  	break;  case (ushort)Registers.PB_DD:  	_portB.Direction = value;  	break;  case (ushort)Registers.TA_L:  	_timerA._latch = (ushort)((_timerA._latch & 0xff00) | value);  	break;  case (ushort)Registers.TA_H:  	_timerA._latch = (ushort)((_timerA._latch & 0x00ff) | (value << 8));  	break;  case (ushort)Registers.TB_L:  	_timerB._latch = (ushort)((_timerB._latch & 0xff00) | value);  	break;  case (ushort)Registers.TB_H:  	_timerB._latch = (ushort)((_timerB._latch & 0x00ff) | (value << 8));  	break;  case (ushort)Registers.TOD_T:  	WriteTOD (TOD.TENTH' value);  	break;  case (ushort)Registers.TOD_S:  	WriteTOD (TOD.SECONDS' value);  	break;  case (ushort)Registers.TOD_M:  	WriteTOD (TOD.MINUTES' value);  	break;  case (ushort)Registers.TOD_H:  	WriteTOD (TOD.HOURS' value);  	break;  case (ushort)Registers.SERIAL:  	break;  case (ushort)Registers.IR:  	if ((value & 0x80) != 0) {  		_interruptRegisters [1] |= (byte)(value & 0x7f);  		if ((_interruptRegisters [0] & _interruptRegisters [1]) != 0 && (_interruptRegisters [0] & (byte)IR.REQ) == 0) {  			_interruptRegisters [0] |= (byte)IR.REQ;  			_irqLine.Raise ();  		}  	}  	else {  		_interruptRegisters [1] &= (byte)(~value & 0x7f);  		if ((_interruptRegisters [0] & _interruptRegisters [1]) == 0 && (_interruptRegisters [0] & (byte)IR.REQ) != 0) {  			byte mask = (byte)IR.REQ;  			_interruptRegisters [0] &= (byte)~mask;  			_irqLine.Lower ();  		}  	}  	break;  case (ushort)Registers.TA_CR:  	_timerA._controlReg = value;  	_timerA._active = (value & (byte)TA_CR.ST) != 0;  	_timerA._mode = (byte)(value & 0x20);  	_timerA._oneTime = (value & (byte)TA_CR.RM) != 0;  	_timerA._output = (value & (byte)TA_CR.PB) == 0;  	_timerA._pulsing = (value & (byte)TA_CR.OM) == 0;  	if ((value & (byte)TA_CR.LD) != 0)  		_timerA._current = _timerA._latch;  	break;  case (ushort)Registers.TB_CR:  	_timerB._controlReg = value;  	_timerB._active = (value & (byte)TA_CR.ST) != 0;  	_timerB._mode = (byte)(value & 0x80);  	_timerB._oneTime = (value & (byte)TA_CR.RM) != 0;  	_timerB._output = (value & (byte)TA_CR.PB) == 0;  	_timerB._pulsing = (value & (byte)TA_CR.OM) == 0;  	if ((value & (byte)TB_CR.LD) != 0)  		_timerA._current = _timerA._latch;  	break;  }  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Write,The following statement contains a magic number: _timerA._latch = (ushort)((_timerA._latch & 0x00ff) | (value << 8));  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Write,The following statement contains a magic number: _timerB._latch = (ushort)((_timerB._latch & 0x00ff) | (value << 8));  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,ReadTOD,The following statement contains a magic number: if (register == TOD.HOURS)  	value |= (byte)(value << 7);  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,ReadTOD,The following statement contains a magic number: value |= (byte)(value << 7);  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,FromBCD,The following statement contains a magic number: return (byte)((value & 0xf) + (value >> 4));  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,ToBCD,The following statement contains a magic number: return (byte)((value % 10) | (value / 10 << 4));  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,ToBCD,The following statement contains a magic number: return (byte)((value % 10) | (value / 10 << 4));  
Magic Number,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,ToBCD,The following statement contains a magic number: return (byte)((value % 10) | (value / 10 << 4));  
Missing Default,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Read,The following switch statement is missing a default case: switch (address) {  case (ushort)Registers.PA_D:  	return (byte)((_portA.Input | _portA.WriteOnly) & (_portA.Output | ~_portA.Direction));  case (ushort)Registers.PB_D:  	_pcState = true;  	return (byte)((_portB.Input | _portB.WriteOnly) & (_portB.Output | ~_portB.Direction));  case (ushort)Registers.PA_DD:  	return _portA.Direction;  case (ushort)Registers.PB_DD:  	return _portB.Direction;  case (ushort)Registers.TA_L:  	return (byte)_timerA._current;  case (ushort)Registers.TA_H:  	return (byte)(_timerA._current >> 8);  case (ushort)Registers.TB_L:  	return (byte)_timerB._current;  case (ushort)Registers.TB_H:  	return (byte)(_timerB._current >> 8);  case (ushort)Registers.TOD_T:  	return ReadTOD (TOD.TENTH);  case (ushort)Registers.TOD_S:  	return ReadTOD (TOD.SECONDS);  case (ushort)Registers.TOD_M:  	return ReadTOD (TOD.MINUTES);  case (ushort)Registers.TOD_H:  	return ReadTOD (TOD.HOURS);  case (ushort)Registers.SERIAL:  	return _serialRegister;  case (ushort)Registers.IR:  	byte status = _interruptRegisters [0];  	_interruptRegisters [0] = 0;  	if ((status & (byte)IR.REQ) != 0)  		_irqLine.Lower ();  	return status;  case (ushort)Registers.TA_CR:  	return _timerA._controlReg;  case (ushort)Registers.TB_CR:  	return _timerB._controlReg;  }  
Missing Default,IO,CIA,C:\repos\RonFields72_C64Emulator\c64_io\CIA.cs,Write,The following switch statement is missing a default case: switch (address) {  case (ushort)Registers.PA_D:  	_portA.Output = value;  	break;  case (ushort)Registers.PB_D:  	_pcState = true;  	_portB.Output = value;  	break;  case (ushort)Registers.PA_DD:  	_portA.Direction = value;  	break;  case (ushort)Registers.PB_DD:  	_portB.Direction = value;  	break;  case (ushort)Registers.TA_L:  	_timerA._latch = (ushort)((_timerA._latch & 0xff00) | value);  	break;  case (ushort)Registers.TA_H:  	_timerA._latch = (ushort)((_timerA._latch & 0x00ff) | (value << 8));  	break;  case (ushort)Registers.TB_L:  	_timerB._latch = (ushort)((_timerB._latch & 0xff00) | value);  	break;  case (ushort)Registers.TB_H:  	_timerB._latch = (ushort)((_timerB._latch & 0x00ff) | (value << 8));  	break;  case (ushort)Registers.TOD_T:  	WriteTOD (TOD.TENTH' value);  	break;  case (ushort)Registers.TOD_S:  	WriteTOD (TOD.SECONDS' value);  	break;  case (ushort)Registers.TOD_M:  	WriteTOD (TOD.MINUTES' value);  	break;  case (ushort)Registers.TOD_H:  	WriteTOD (TOD.HOURS' value);  	break;  case (ushort)Registers.SERIAL:  	break;  case (ushort)Registers.IR:  	if ((value & 0x80) != 0) {  		_interruptRegisters [1] |= (byte)(value & 0x7f);  		if ((_interruptRegisters [0] & _interruptRegisters [1]) != 0 && (_interruptRegisters [0] & (byte)IR.REQ) == 0) {  			_interruptRegisters [0] |= (byte)IR.REQ;  			_irqLine.Raise ();  		}  	}  	else {  		_interruptRegisters [1] &= (byte)(~value & 0x7f);  		if ((_interruptRegisters [0] & _interruptRegisters [1]) == 0 && (_interruptRegisters [0] & (byte)IR.REQ) != 0) {  			byte mask = (byte)IR.REQ;  			_interruptRegisters [0] &= (byte)~mask;  			_irqLine.Lower ();  		}  	}  	break;  case (ushort)Registers.TA_CR:  	_timerA._controlReg = value;  	_timerA._active = (value & (byte)TA_CR.ST) != 0;  	_timerA._mode = (byte)(value & 0x20);  	_timerA._oneTime = (value & (byte)TA_CR.RM) != 0;  	_timerA._output = (value & (byte)TA_CR.PB) == 0;  	_timerA._pulsing = (value & (byte)TA_CR.OM) == 0;  	if ((value & (byte)TA_CR.LD) != 0)  		_timerA._current = _timerA._latch;  	break;  case (ushort)Registers.TB_CR:  	_timerB._controlReg = value;  	_timerB._active = (value & (byte)TA_CR.ST) != 0;  	_timerB._mode = (byte)(value & 0x80);  	_timerB._oneTime = (value & (byte)TA_CR.RM) != 0;  	_timerB._output = (value & (byte)TA_CR.PB) == 0;  	_timerB._pulsing = (value & (byte)TA_CR.OM) == 0;  	if ((value & (byte)TB_CR.LD) != 0)  		_timerA._current = _timerA._latch;  	break;  }  
