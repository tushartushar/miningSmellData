Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteGraphOp,Cyclomatic complexity of the method is 12
Complex Method,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,Cyclomatic complexity of the method is 51
Long Parameter List,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,VIC,The method has 6 parameters.
Long Statement,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,RefreshReadOp13,The length of the statement  "	_vic.BadLine = _vic.Raster >= 0x30 && _vic.Raster <= 0xf7 && (_vic.Raster & 0x07) == _vic.YScroll && _vic.DisplayEnabled; " is 121.
Long Statement,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp,The length of the statement  "			_vic.SDataBuffer [sprite].Enqueue (_vic.Memory.Read ((ushort)(_vic.GetRawMemoryAddress ((ushort)(_vic.SpritePointers [sprite] + _vic.MC [sprite]))))); " is 150.
Long Statement,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteGraphOp,The length of the statement  "					if (!vBorder && x > left && x < right && (_vic.GetSpritePriority (s) || (collision [pc] & (ushort)CollisionState.Foreground) == 0)) " is 131.
Long Statement,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphLeftOp,The length of the statement  "		x = left == VIC.MAIN_BORDER [1' 0] ? _vic.GraphicMode.Render (_vic' (ushort)(x + _vic.XScroll)' 0) : _vic.GraphicMode.Render (_vic' x' (byte)(7 - _vic.XScroll)); " is 161.
Long Statement,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,GetSpritePosX,The length of the statement  "	return (ushort)(_registers [(byte)Registers.M0_X + sprite * 2] + (((_registers [(byte)Registers.Mx_X] >> sprite) & 1) << 8)); " is 125.
Long Statement,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The length of the statement  "		_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4]; " is 130.
Long Statement,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The length of the statement  "		_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4]; " is 130.
Long Statement,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,ReadDeviceState,The length of the statement  "	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4]; " is 160.
Complex Conditional,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteGraphOp,The conditional expression  "!vBorder && x > left && x < right && (_vic.GetSpritePriority (s) || (collision [pc] & (ushort)CollisionState.Foreground) == 0)"  is complex.
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,GraphReadOp54,The following statement contains a magic number: for (byte i = 0; i < 8; i++) {  	if (_vic.GetSpriteExpY (i))  		_vic.YExpandFlip [i] = !_vic.YExpandFlip [i];  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,IdleReadOp55,The following statement contains a magic number: IdleReadOp (clock' 0' 3);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,IdleReadOp56,The following statement contains a magic number: IdleReadOp (clock' 4' 7);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,IdleReadOp56,The following statement contains a magic number: IdleReadOp (clock' 4' 7);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,RefreshReadOp14,The following statement contains a magic number: if (_vic.BadLine) {  	clock.Stall (40' 1);  	_vic.WriteVideoMatrix (_vic.Memory.Read (_vic.GetVideoMemoryAddress (_vic.VC))' _vic.ColorRam.ReadDirect (_vic.VC));  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,RefreshReadOp14,The following statement contains a magic number: clock.Stall (40' 1);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,RefreshReadOp14,The following statement contains a magic number: for (byte i = 0; i < 8; i++) {  	if (_vic.YExpandFlip [i] || !_vic.GetSpriteExpY (i)) {  		_vic.MCBase [i] += 3;  		if (_vic.MCBase [i] > 63) {  			_vic.SDataBuffer [i].Clear ();  			_vic.SpriteDMA [i] = false;  			_vic.SpriteDisplay [i] = false;  		}  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,RefreshReadOp14,The following statement contains a magic number: for (byte i = 0; i < 8; i++) {  	if (_vic.YExpandFlip [i] || !_vic.GetSpriteExpY (i)) {  		_vic.MCBase [i] += 3;  		if (_vic.MCBase [i] > 63) {  			_vic.SDataBuffer [i].Clear ();  			_vic.SpriteDMA [i] = false;  			_vic.SpriteDisplay [i] = false;  		}  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,RefreshReadOp14,The following statement contains a magic number: for (byte i = 0; i < 8; i++) {  	if (_vic.YExpandFlip [i] || !_vic.GetSpriteExpY (i)) {  		_vic.MCBase [i] += 3;  		if (_vic.MCBase [i] > 63) {  			_vic.SDataBuffer [i].Clear ();  			_vic.SpriteDMA [i] = false;  			_vic.SpriteDisplay [i] = false;  		}  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,RefreshReadOp14,The following statement contains a magic number: if (_vic.YExpandFlip [i] || !_vic.GetSpriteExpY (i)) {  	_vic.MCBase [i] += 3;  	if (_vic.MCBase [i] > 63) {  		_vic.SDataBuffer [i].Clear ();  		_vic.SpriteDMA [i] = false;  		_vic.SpriteDisplay [i] = false;  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,RefreshReadOp14,The following statement contains a magic number: if (_vic.YExpandFlip [i] || !_vic.GetSpriteExpY (i)) {  	_vic.MCBase [i] += 3;  	if (_vic.MCBase [i] > 63) {  		_vic.SDataBuffer [i].Clear ();  		_vic.SpriteDMA [i] = false;  		_vic.SpriteDisplay [i] = false;  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,RefreshReadOp14,The following statement contains a magic number: _vic.MCBase [i] += 3;  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,RefreshReadOp14,The following statement contains a magic number: if (_vic.MCBase [i] > 63) {  	_vic.SDataBuffer [i].Clear ();  	_vic.SpriteDMA [i] = false;  	_vic.SpriteDisplay [i] = false;  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp,The following statement contains a magic number: if ((cycle & 1) == 0)  	_vic.SpritePointers [sprite] = (ushort)(_vic.Memory.Read (_vic.GetVideoMemoryAddress ((ushort)(0x3f8 | sprite))) << 6);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp,The following statement contains a magic number: _vic.SpritePointers [sprite] = (ushort)(_vic.Memory.Read (_vic.GetVideoMemoryAddress ((ushort)(0x3f8 | sprite))) << 6);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp,The following statement contains a magic number: if (_vic.SpriteDMA [sprite]) {  	if ((cycle & 1) == 0)  		clock.Stall (2' 1);  	for (byte reads = (byte)((cycle & 1) + 1); reads > 0; reads--) {  		_vic.SDataBuffer [sprite].Enqueue (_vic.Memory.Read ((ushort)(_vic.GetRawMemoryAddress ((ushort)(_vic.SpritePointers [sprite] + _vic.MC [sprite])))));  		_vic.MC [sprite]++;  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp,The following statement contains a magic number: if ((cycle & 1) == 0)  	clock.Stall (2' 1);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp,The following statement contains a magic number: clock.Stall (2' 1);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp0,The following statement contains a magic number: SpriteReadOp (clock' 3' _rasteCycle);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp1_9,The following statement contains a magic number: SpriteReadOp (clock' 3' _rasteCycle);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp57,The following statement contains a magic number: if (_vic.RC == 7) {  	_vic.DisplayState = false;  	_vic.VCBase = _vic.VC;  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp57,The following statement contains a magic number: for (byte i = 0; i < 8; i++) {  	_vic.MC [i] = _vic.MCBase [i];  	_vic.SpriteDisplay [i] = _vic.SpriteDMA [i] && (byte)_vic.Raster >= (byte)_vic.GetSpritePosY (i);  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp58_61,The following statement contains a magic number: SpriteReadOp (clock' 0' (byte)(_rasteCycle - 57));  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteReadOp62,The following statement contains a magic number: SpriteReadOp (clock' 0' 5);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteGraphOp,The following statement contains a magic number: for (byte s = 7; s != 0xff; s--) {  	if (enabled [s] && xLimit >= _vic.GetSpritePosX (s) && _vic.XCoord <= _vic.GetSpritePosX (s) + 24) {  		short offset = (short)(_vic.GetSpritePosX (s) - _vic.XCoord);  		if (offset < 0)  			offset = 0;  		bool mc = _vic.GetSpriteMulticolor (s);  		uint c = Pallete.CvtColors [_vic.GetSpriteColor (s)];  		ushort x = (ushort)(_vic.XCoord + offset);  		uint pos = (uint)(y * VIC.X_RESOLUTION);  		for (; x < xLimit && !_vic.SDataBuffer [s].IsEmpty; x++) {  			byte bits;  			if (mc)  				_vic.SDataBuffer [s].Dequeue2 (out bits);  			else  				_vic.SDataBuffer [s].Dequeue1 (out bits);  			uint pc = (uint)(pos + x);  			if (bits != 0) {  				if (!vBorder && x > left && x < right && (_vic.GetSpritePriority (s) || (collision [pc] & (ushort)CollisionState.Foreground) == 0))  					output.OutputPixel (pc' !mc || (bits & 1) == 0 ? c : Pallete.CvtColors [_vic.GetSpriteMulitcolor ((byte)(bits >> 1))]);  				byte mask = (byte)(1 << s);  				bool detected = false;  				ushort current = collision [pc];  				if ((current & (ushort)CollisionState.Foreground) != 0)  					_vic.SetSpriteDataCollision (mask);  				current &= (ushort)((ushort)CollisionState.Foreground - 1);  				for (byte sc = 0; current != 0; current >>= 1) {  					if ((current & 1) != 0) {  						_vic.SetSpriteSpriteCollision ((byte)(1 << sc));  						detected = true;  					}  				}  				if (detected)  					_vic.SetSpriteSpriteCollision (mask);  				collision [pc] |= mask;  			}  		}  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteGraphOp,The following statement contains a magic number: for (byte s = 7; s != 0xff; s--) {  	if (enabled [s] && xLimit >= _vic.GetSpritePosX (s) && _vic.XCoord <= _vic.GetSpritePosX (s) + 24) {  		short offset = (short)(_vic.GetSpritePosX (s) - _vic.XCoord);  		if (offset < 0)  			offset = 0;  		bool mc = _vic.GetSpriteMulticolor (s);  		uint c = Pallete.CvtColors [_vic.GetSpriteColor (s)];  		ushort x = (ushort)(_vic.XCoord + offset);  		uint pos = (uint)(y * VIC.X_RESOLUTION);  		for (; x < xLimit && !_vic.SDataBuffer [s].IsEmpty; x++) {  			byte bits;  			if (mc)  				_vic.SDataBuffer [s].Dequeue2 (out bits);  			else  				_vic.SDataBuffer [s].Dequeue1 (out bits);  			uint pc = (uint)(pos + x);  			if (bits != 0) {  				if (!vBorder && x > left && x < right && (_vic.GetSpritePriority (s) || (collision [pc] & (ushort)CollisionState.Foreground) == 0))  					output.OutputPixel (pc' !mc || (bits & 1) == 0 ? c : Pallete.CvtColors [_vic.GetSpriteMulitcolor ((byte)(bits >> 1))]);  				byte mask = (byte)(1 << s);  				bool detected = false;  				ushort current = collision [pc];  				if ((current & (ushort)CollisionState.Foreground) != 0)  					_vic.SetSpriteDataCollision (mask);  				current &= (ushort)((ushort)CollisionState.Foreground - 1);  				for (byte sc = 0; current != 0; current >>= 1) {  					if ((current & 1) != 0) {  						_vic.SetSpriteSpriteCollision ((byte)(1 << sc));  						detected = true;  					}  				}  				if (detected)  					_vic.SetSpriteSpriteCollision (mask);  				collision [pc] |= mask;  			}  		}  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,SpriteGraphOp,The following statement contains a magic number: if (enabled [s] && xLimit >= _vic.GetSpritePosX (s) && _vic.XCoord <= _vic.GetSpritePosX (s) + 24) {  	short offset = (short)(_vic.GetSpritePosX (s) - _vic.XCoord);  	if (offset < 0)  		offset = 0;  	bool mc = _vic.GetSpriteMulticolor (s);  	uint c = Pallete.CvtColors [_vic.GetSpriteColor (s)];  	ushort x = (ushort)(_vic.XCoord + offset);  	uint pos = (uint)(y * VIC.X_RESOLUTION);  	for (; x < xLimit && !_vic.SDataBuffer [s].IsEmpty; x++) {  		byte bits;  		if (mc)  			_vic.SDataBuffer [s].Dequeue2 (out bits);  		else  			_vic.SDataBuffer [s].Dequeue1 (out bits);  		uint pc = (uint)(pos + x);  		if (bits != 0) {  			if (!vBorder && x > left && x < right && (_vic.GetSpritePriority (s) || (collision [pc] & (ushort)CollisionState.Foreground) == 0))  				output.OutputPixel (pc' !mc || (bits & 1) == 0 ? c : Pallete.CvtColors [_vic.GetSpriteMulitcolor ((byte)(bits >> 1))]);  			byte mask = (byte)(1 << s);  			bool detected = false;  			ushort current = collision [pc];  			if ((current & (ushort)CollisionState.Foreground) != 0)  				_vic.SetSpriteDataCollision (mask);  			current &= (ushort)((ushort)CollisionState.Foreground - 1);  			for (byte sc = 0; current != 0; current >>= 1) {  				if ((current & 1) != 0) {  					_vic.SetSpriteSpriteCollision ((byte)(1 << sc));  					detected = true;  				}  			}  			if (detected)  				_vic.SetSpriteSpriteCollision (mask);  			collision [pc] |= mask;  		}  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,BorderGraphOp,The following statement contains a magic number: if (y > 15 && y < 285) {  	uint bColor = _vic.GetBorderColor ();  	IVideoOutput output = _vic.OutputDevice;  	uint pos = (uint)(y * VIC.X_RESOLUTION + x);  	ushort[] collision = _vic.CollisionMatrix;  	for (uint lim = pos + 8; pos < lim; pos++) {  		output.OutputPixel (pos' bColor);  		collision [pos] = 0;  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,BorderGraphOp,The following statement contains a magic number: if (y > 15 && y < 285) {  	uint bColor = _vic.GetBorderColor ();  	IVideoOutput output = _vic.OutputDevice;  	uint pos = (uint)(y * VIC.X_RESOLUTION + x);  	ushort[] collision = _vic.CollisionMatrix;  	for (uint lim = pos + 8; pos < lim; pos++) {  		output.OutputPixel (pos' bColor);  		collision [pos] = 0;  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,BorderGraphOp,The following statement contains a magic number: if (y > 15 && y < 285) {  	uint bColor = _vic.GetBorderColor ();  	IVideoOutput output = _vic.OutputDevice;  	uint pos = (uint)(y * VIC.X_RESOLUTION + x);  	ushort[] collision = _vic.CollisionMatrix;  	for (uint lim = pos + 8; pos < lim; pos++) {  		output.OutputPixel (pos' bColor);  		collision [pos] = 0;  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,BorderGraphOp,The following statement contains a magic number: for (uint lim = pos + 8; pos < lim; pos++) {  	output.OutputPixel (pos' bColor);  	collision [pos] = 0;  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,BorderGraphOp,The following statement contains a magic number: x += 8;  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,BorderWrapGraphOp,The following statement contains a magic number: for (uint lim = pos + 4; pos < lim; pos++) {  	output.OutputPixel (pos' bColor);  	collision [pos] = 0;  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,BorderWrapGraphOp,The following statement contains a magic number: SpriteGraphOp ((ushort)(_vic.XCoord + 4));  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,BorderWrapGraphOp,The following statement contains a magic number: SpriteGraphOp (4);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,BorderWrapGraphOp,The following statement contains a magic number: _vic.XCoord = 4;  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphLeftOp,The following statement contains a magic number: for (uint lim = (uint)(pos + ((x + 8) < left ? 8 : (left - x))); pos < lim; pos++' x++) {  	collision [pos] = 0;  	output.OutputPixel (pos' bColor);  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphLeftOp,The following statement contains a magic number: for (uint lim = (uint)(pos + ((x + 8) < left ? 8 : (left - x))); pos < lim; pos++' x++) {  	collision [pos] = 0;  	output.OutputPixel (pos' bColor);  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphLeftOp,The following statement contains a magic number: if (x > left)  	x = _vic.GraphicMode.Render (_vic' x' 0);  else if (x == left)  	x = left == VIC.MAIN_BORDER [1' 0] ? _vic.GraphicMode.Render (_vic' (ushort)(x + _vic.XScroll)' 0) : _vic.GraphicMode.Render (_vic' x' (byte)(7 - _vic.XScroll));  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphLeftOp,The following statement contains a magic number: if (x == left)  	x = left == VIC.MAIN_BORDER [1' 0] ? _vic.GraphicMode.Render (_vic' (ushort)(x + _vic.XScroll)' 0) : _vic.GraphicMode.Render (_vic' x' (byte)(7 - _vic.XScroll));  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphLeftOp,The following statement contains a magic number: x = left == VIC.MAIN_BORDER [1' 0] ? _vic.GraphicMode.Render (_vic' (ushort)(x + _vic.XScroll)' 0) : _vic.GraphicMode.Render (_vic' x' (byte)(7 - _vic.XScroll));  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphRight1Op,The following statement contains a magic number: if (x >= right) {  	uint bColor = _vic.GetBorderColor ();  	ushort y = _vic.Raster;  	uint pos = (uint)(y * VIC.X_RESOLUTION + x);  	uint lim = pos + 6;  	for (; pos < lim; pos++) {  		collision [pos] = 0;  		output.OutputPixel (pos' bColor);  	}  }  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphRight1Op,The following statement contains a magic number: x += 5;  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphRight2Op,The following statement contains a magic number: if (x < right)  	pos += 4;  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphRight2Op,The following statement contains a magic number: pos += 4;  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CheckedActiveGraphRight2Op,The following statement contains a magic number: x += 8;  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CreateOps,The following statement contains a magic number: _replacableOps = new Clock.ClockEntry[] {  	new Clock.ClockEntryRep (_activeOps [0]' 2)'  	new Clock.ClockEntryRep (_activeOps [1]' 37)'  	new Clock.ClockEntry (_activeOps [2])'  	new Clock.ClockEntry (_activeOps [3])'  };  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CreateOps,The following statement contains a magic number: _replacableOps = new Clock.ClockEntry[] {  	new Clock.ClockEntryRep (_activeOps [0]' 2)'  	new Clock.ClockEntryRep (_activeOps [1]' 37)'  	new Clock.ClockEntry (_activeOps [2])'  	new Clock.ClockEntry (_activeOps [3])'  };  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CreateOps,The following statement contains a magic number: _replacableOps = new Clock.ClockEntry[] {  	new Clock.ClockEntryRep (_activeOps [0]' 2)'  	new Clock.ClockEntryRep (_activeOps [1]' 37)'  	new Clock.ClockEntry (_activeOps [2])'  	new Clock.ClockEntry (_activeOps [3])'  };  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CreateOps,The following statement contains a magic number: _replacableOps = new Clock.ClockEntry[] {  	new Clock.ClockEntryRep (_activeOps [0]' 2)'  	new Clock.ClockEntryRep (_activeOps [1]' 37)'  	new Clock.ClockEntry (_activeOps [2])'  	new Clock.ClockEntry (_activeOps [3])'  };  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CreateOps,The following statement contains a magic number: next = next.Next = new Clock.ClockEntryRep (new VicNop (_vic)' 2);  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CreateOps,The following statement contains a magic number: next = next.Next = _replacableOps [2];  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CreateOps,The following statement contains a magic number: next = next.Next = _replacableOps [3];  
Magic Number,Video,RasterLine,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,CreateOps,The following statement contains a magic number: next = next.Next = new Clock.ClockEntryRep (new VicReadOp (_vic' SpriteReadOp58_61)' 4);  
Magic Number,Video,StandardTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8; pos < lim; pos++) {  	bits <<= 1;  	uint pixel = bits & 0x100;  	output.OutputPixel (pos' pixel == 0 ? bgColor : color);  	collision [pos] = (ushort)pixel;  }  
Magic Number,Video,StandardTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: return (ushort)(x + 8 - shift);  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (mc) {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << (shift & ~1));  	bits <<= 2;  	uint pixel = (bits & 0x300) >> 8;  	bool next = (shift & 1) != 0;  	for (uint lim = pos + 8 - shift; pos < lim; pos++) {  		output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  		collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  		if (next) {  			bits <<= 2;  			pixel = (bits & 0x300) >> 8;  		}  		next = !next;  	}  }  else {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << shift);  	for (uint lim = pos + 8; pos < lim; pos++) {  		bits <<= 1;  		uint pixel = bits & 0x100;  		output.OutputPixel (pos' pixel == 0 ? bgColor : color);  		collision [pos] = (ushort)pixel;  	}  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (mc) {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << (shift & ~1));  	bits <<= 2;  	uint pixel = (bits & 0x300) >> 8;  	bool next = (shift & 1) != 0;  	for (uint lim = pos + 8 - shift; pos < lim; pos++) {  		output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  		collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  		if (next) {  			bits <<= 2;  			pixel = (bits & 0x300) >> 8;  		}  		next = !next;  	}  }  else {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << shift);  	for (uint lim = pos + 8; pos < lim; pos++) {  		bits <<= 1;  		uint pixel = bits & 0x100;  		output.OutputPixel (pos' pixel == 0 ? bgColor : color);  		collision [pos] = (ushort)pixel;  	}  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (mc) {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << (shift & ~1));  	bits <<= 2;  	uint pixel = (bits & 0x300) >> 8;  	bool next = (shift & 1) != 0;  	for (uint lim = pos + 8 - shift; pos < lim; pos++) {  		output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  		collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  		if (next) {  			bits <<= 2;  			pixel = (bits & 0x300) >> 8;  		}  		next = !next;  	}  }  else {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << shift);  	for (uint lim = pos + 8; pos < lim; pos++) {  		bits <<= 1;  		uint pixel = bits & 0x100;  		output.OutputPixel (pos' pixel == 0 ? bgColor : color);  		collision [pos] = (ushort)pixel;  	}  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (mc) {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << (shift & ~1));  	bits <<= 2;  	uint pixel = (bits & 0x300) >> 8;  	bool next = (shift & 1) != 0;  	for (uint lim = pos + 8 - shift; pos < lim; pos++) {  		output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  		collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  		if (next) {  			bits <<= 2;  			pixel = (bits & 0x300) >> 8;  		}  		next = !next;  	}  }  else {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << shift);  	for (uint lim = pos + 8; pos < lim; pos++) {  		bits <<= 1;  		uint pixel = bits & 0x100;  		output.OutputPixel (pos' pixel == 0 ? bgColor : color);  		collision [pos] = (ushort)pixel;  	}  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (mc) {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << (shift & ~1));  	bits <<= 2;  	uint pixel = (bits & 0x300) >> 8;  	bool next = (shift & 1) != 0;  	for (uint lim = pos + 8 - shift; pos < lim; pos++) {  		output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  		collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  		if (next) {  			bits <<= 2;  			pixel = (bits & 0x300) >> 8;  		}  		next = !next;  	}  }  else {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << shift);  	for (uint lim = pos + 8; pos < lim; pos++) {  		bits <<= 1;  		uint pixel = bits & 0x100;  		output.OutputPixel (pos' pixel == 0 ? bgColor : color);  		collision [pos] = (ushort)pixel;  	}  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (mc) {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << (shift & ~1));  	bits <<= 2;  	uint pixel = (bits & 0x300) >> 8;  	bool next = (shift & 1) != 0;  	for (uint lim = pos + 8 - shift; pos < lim; pos++) {  		output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  		collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  		if (next) {  			bits <<= 2;  			pixel = (bits & 0x300) >> 8;  		}  		next = !next;  	}  }  else {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << shift);  	for (uint lim = pos + 8; pos < lim; pos++) {  		bits <<= 1;  		uint pixel = bits & 0x100;  		output.OutputPixel (pos' pixel == 0 ? bgColor : color);  		collision [pos] = (ushort)pixel;  	}  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (mc) {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << (shift & ~1));  	bits <<= 2;  	uint pixel = (bits & 0x300) >> 8;  	bool next = (shift & 1) != 0;  	for (uint lim = pos + 8 - shift; pos < lim; pos++) {  		output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  		collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  		if (next) {  			bits <<= 2;  			pixel = (bits & 0x300) >> 8;  		}  		next = !next;  	}  }  else {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << shift);  	for (uint lim = pos + 8; pos < lim; pos++) {  		bits <<= 1;  		uint pixel = bits & 0x100;  		output.OutputPixel (pos' pixel == 0 ? bgColor : color);  		collision [pos] = (ushort)pixel;  	}  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (mc) {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << (shift & ~1));  	bits <<= 2;  	uint pixel = (bits & 0x300) >> 8;  	bool next = (shift & 1) != 0;  	for (uint lim = pos + 8 - shift; pos < lim; pos++) {  		output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  		collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  		if (next) {  			bits <<= 2;  			pixel = (bits & 0x300) >> 8;  		}  		next = !next;  	}  }  else {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << shift);  	for (uint lim = pos + 8; pos < lim; pos++) {  		bits <<= 1;  		uint pixel = bits & 0x100;  		output.OutputPixel (pos' pixel == 0 ? bgColor : color);  		collision [pos] = (ushort)pixel;  	}  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (mc) {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << (shift & ~1));  	bits <<= 2;  	uint pixel = (bits & 0x300) >> 8;  	bool next = (shift & 1) != 0;  	for (uint lim = pos + 8 - shift; pos < lim; pos++) {  		output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  		collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  		if (next) {  			bits <<= 2;  			pixel = (bits & 0x300) >> 8;  		}  		next = !next;  	}  }  else {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << shift);  	for (uint lim = pos + 8; pos < lim; pos++) {  		bits <<= 1;  		uint pixel = bits & 0x100;  		output.OutputPixel (pos' pixel == 0 ? bgColor : color);  		collision [pos] = (ushort)pixel;  	}  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (mc) {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << (shift & ~1));  	bits <<= 2;  	uint pixel = (bits & 0x300) >> 8;  	bool next = (shift & 1) != 0;  	for (uint lim = pos + 8 - shift; pos < lim; pos++) {  		output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  		collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  		if (next) {  			bits <<= 2;  			pixel = (bits & 0x300) >> 8;  		}  		next = !next;  	}  }  else {  	uint bits = (uint)(vic.Memory.Read (vic.GetCharGenMemoryAddress ((ushort)((b1 << 3) | vic.RC))) << shift);  	for (uint lim = pos + 8; pos < lim; pos++) {  		bits <<= 1;  		uint pixel = bits & 0x100;  		output.OutputPixel (pos' pixel == 0 ? bgColor : color);  		collision [pos] = (ushort)pixel;  	}  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: bits <<= 2;  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8 - shift; pos < lim; pos++) {  	output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  	collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  	if (next) {  		bits <<= 2;  		pixel = (bits & 0x300) >> 8;  	}  	next = !next;  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8 - shift; pos < lim; pos++) {  	output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  	collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  	if (next) {  		bits <<= 2;  		pixel = (bits & 0x300) >> 8;  	}  	next = !next;  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8 - shift; pos < lim; pos++) {  	output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  	collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  	if (next) {  		bits <<= 2;  		pixel = (bits & 0x300) >> 8;  	}  	next = !next;  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8 - shift; pos < lim; pos++) {  	output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  	collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  	if (next) {  		bits <<= 2;  		pixel = (bits & 0x300) >> 8;  	}  	next = !next;  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8 - shift; pos < lim; pos++) {  	output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  	collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  	if (next) {  		bits <<= 2;  		pixel = (bits & 0x300) >> 8;  	}  	next = !next;  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: output.OutputPixel (pos' pixel < 3 ? vic.GetBackgroundColor ((byte)pixel) : color);  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: collision [pos] = (pixel & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (next) {  	bits <<= 2;  	pixel = (bits & 0x300) >> 8;  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (next) {  	bits <<= 2;  	pixel = (bits & 0x300) >> 8;  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: bits <<= 2;  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: pixel = (bits & 0x300) >> 8;  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8; pos < lim; pos++) {  	bits <<= 1;  	uint pixel = bits & 0x100;  	output.OutputPixel (pos' pixel == 0 ? bgColor : color);  	collision [pos] = (ushort)pixel;  }  
Magic Number,Video,MulticolorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: return (ushort)(x + 8 - shift);  
Magic Number,Video,StandardBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8; pos < lim; pos++) {  	bits <<= 1;  	uint pixel = bits & 0x100;  	output.OutputPixel (pos' pixel == 0 ? color0 : color1);  	collision [pos] = (ushort)pixel;  }  
Magic Number,Video,StandardBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: return (ushort)(x + 8 - shift);  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: _colors [1] = Pallete.CvtColors [b1 >> 4];  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: _colors [2] = Pallete.CvtColors [b1 & 0x0f];  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: _colors [3] = Pallete.CvtColors [b2];  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: bits <<= 2;  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8 - shift; pos < lim; pos++) {  	output.OutputPixel (pos' _colors [pixel]);  	collision [pos] = (bits & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  	if (next) {  		bits <<= 2;  		pixel = (bits & 0x300) >> 8;  	}  	next = !next;  }  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8 - shift; pos < lim; pos++) {  	output.OutputPixel (pos' _colors [pixel]);  	collision [pos] = (bits & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  	if (next) {  		bits <<= 2;  		pixel = (bits & 0x300) >> 8;  	}  	next = !next;  }  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8 - shift; pos < lim; pos++) {  	output.OutputPixel (pos' _colors [pixel]);  	collision [pos] = (bits & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  	if (next) {  		bits <<= 2;  		pixel = (bits & 0x300) >> 8;  	}  	next = !next;  }  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8 - shift; pos < lim; pos++) {  	output.OutputPixel (pos' _colors [pixel]);  	collision [pos] = (bits & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  	if (next) {  		bits <<= 2;  		pixel = (bits & 0x300) >> 8;  	}  	next = !next;  }  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: collision [pos] = (bits & 2) != 0 ? (ushort)CollisionState.Foreground : (ushort)0;  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (next) {  	bits <<= 2;  	pixel = (bits & 0x300) >> 8;  }  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: if (next) {  	bits <<= 2;  	pixel = (bits & 0x300) >> 8;  }  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: bits <<= 2;  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: pixel = (bits & 0x300) >> 8;  
Magic Number,Video,MulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: return (ushort)(x + 8 - shift);  
Magic Number,Video,ExtendedColorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: for (uint lim = pos + 8; pos < lim; pos++) {  	bits <<= 1;  	uint pixel = bits & 0x100;  	output.OutputPixel (pos' pixel == 0 ? vic.GetBackgroundColor (bgColor) : color);  	collision [pos] = (ushort)pixel;  }  
Magic Number,Video,ExtendedColorTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: return (ushort)(x + 8 - shift);  
Magic Number,Video,InvalidTextMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: return (ushort)(x + 8 - shift);  
Magic Number,Video,InvalidBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: return (ushort)(x + 8 - shift);  
Magic Number,Video,InvalidMulticolorBitmapMode,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Render,The following statement contains a magic number: return (ushort)(x + 8 - shift);  
Magic Number,Video,DataBuffer,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Enqueue,The following statement contains a magic number: _bits |= (uint)bits << (24 - _bitCount);  
Magic Number,Video,DataBuffer,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Enqueue,The following statement contains a magic number: _bitCount += 8;  
Magic Number,Video,DataBuffer,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Dequeue1,The following statement contains a magic number: bit = (byte)(_bits >> 31);  
Magic Number,Video,DataBuffer,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Dequeue2,The following statement contains a magic number: if (_emptyMultiplier) {  	_multiplierData = (byte)(_bits >> 30);  	_bits <<= 2;  	_bitCount -= 2;  }  
Magic Number,Video,DataBuffer,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Dequeue2,The following statement contains a magic number: if (_emptyMultiplier) {  	_multiplierData = (byte)(_bits >> 30);  	_bits <<= 2;  	_bitCount -= 2;  }  
Magic Number,Video,DataBuffer,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Dequeue2,The following statement contains a magic number: if (_emptyMultiplier) {  	_multiplierData = (byte)(_bits >> 30);  	_bits <<= 2;  	_bitCount -= 2;  }  
Magic Number,Video,DataBuffer,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Dequeue2,The following statement contains a magic number: _multiplierData = (byte)(_bits >> 30);  
Magic Number,Video,DataBuffer,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Dequeue2,The following statement contains a magic number: _bits <<= 2;  
Magic Number,Video,DataBuffer,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Dequeue2,The following statement contains a magic number: _bitCount -= 2;  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,GetSpritePosX,The following statement contains a magic number: return (ushort)(_registers [(byte)Registers.M0_X + sprite * 2] + (((_registers [(byte)Registers.Mx_X] >> sprite) & 1) << 8));  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,GetSpritePosX,The following statement contains a magic number: return (ushort)(_registers [(byte)Registers.M0_X + sprite * 2] + (((_registers [(byte)Registers.Mx_X] >> sprite) & 1) << 8));  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,GetSpritePosY,The following statement contains a magic number: return _registers [(byte)Registers.M0_Y + sprite * 2];  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.RASTER:  	_rasterComparison = (byte)((_rasterComparison & 0xff00) | value);  	break;  case (ushort)Registers.CR_1:  	_rasterComparison = (ushort)((_rasterComparison & 0xff) | ((value & (byte)CR1.RST8) << 1));  	_graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_rasterLine.SetReplacableOperations (_auxBorderFlip' (value & (byte)CR1.DEN) != 0);  	_topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  	_bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  	break;  case (ushort)Registers.CR_2:  	_graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  	_leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  	_rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  	break;  case (ushort)Registers.IN_R:  	_registers [address] &= (byte)((~value) | (byte)IR.IRQ);  	if ((_registers [address] & _registers [(byte)Registers.IN_E]) == 0 && (_registers [address] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [address] &= (byte)~clear;  		_irqLine.Lower ();  	}  	write = false;  	break;  case (ushort)Registers.IN_E:  	if ((value & _registers [(byte)Registers.IN_R]) != 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) == 0) {  		_registers [(byte)Registers.IN_R] |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	else if ((value & _registers [(byte)Registers.IN_R]) == 0 && (_registers [(byte)Registers.IN_R] & (byte)IR.IRQ) != 0) {  		byte clear = (byte)IR.IRQ;  		_registers [(byte)Registers.IN_R] &= (byte)~clear;  		_irqLine.Lower ();  	}  	break;  case (ushort)Registers.ME_P:  	_videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  	_charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  	_bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  	break;  case (ushort)Registers.EC:  	_borderColor = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_0:  	_backGroundColor [0] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_1:  	_backGroundColor [1] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_2:  	_backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  	break;  case (ushort)Registers.BC_3:  	_backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  	break;  default:  	if (address >= 0x20)  		value &= 0x0f;  	break;  }  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (value & (byte)(CR1.ECM | CR1.BMM))) >> 4];  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _topBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 0];  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _bottomBorder = AUX_BORDER [(value & (byte)CR1.RSEL) >> 3' 1];  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _graphicMode = _graphicModes [((value & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _leftBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 0];  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _rightBorder = MAIN_BORDER [(value & (byte)CR2.CSEL) >> 3' 1];  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _videoMemoryBase = (ushort)((value & (byte)MP.VM) << 6);  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _charGenMemoryBase = (ushort)((value & (byte)MP.CB) << 10);  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _bitmapMemoryBase = (ushort)((value & (byte)MP.BB) << 10);  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _backGroundColor [2] = Pallete.CvtColors [value & 0x0f];  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,Write,The following statement contains a magic number: _backGroundColor [3] = Pallete.CvtColors [value & 0x0f];  
Magic Number,Video,VIC,C:\repos\RonFields72_C64Emulator\c64_av\VIC.cs,ReadDeviceState,The following statement contains a magic number: _graphicMode = _graphicModes [((_registers [(ushort)Registers.CR_2] & (byte)CR2.MCM) | (_registers [(ushort)Registers.CR_1] & (byte)(CR1.ECM | CR1.BMM))) >> 4];  
