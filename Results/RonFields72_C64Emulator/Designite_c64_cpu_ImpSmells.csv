Implementation smell,Namespace,Class,File,Method,Description
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (_cpu.NMI.Check ())  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffa)' 7);  else if (_cpu.IRQ.IsRaised && !_cpu.State.P.IrqMask)  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffe)' 7);  else {  	_cpu.Opcode = _cpu.Memory.Read (_cpu.State.PC.Value);  	_cpu.State.PC.Next ();  	DecodingTable.Entry decoded = DecodingTable.Opcodes [_cpu.Opcode];  	DecodeAddressOp addrOp = new DecodeAddressOp (_cpu' decoded._addressing);  	ExecuteOpcodeOp execOp = new ExecuteOpcodeOp (_cpu' decoded._instruction' decoded._timing._prolongOnPageCross);  	byte addrTime = decoded._timing._addressingTime;  	byte execTime = decoded._timing._execTime;  	first = addrTime < 2 ? new Clock.ClockEntry (addrOp' true) : new Clock.ClockEntryRep (addrOp' addrTime);  	first.ComboNext = execTime == 0 || addrTime == 0;  	next = first.Next = execTime < 2 ? new Clock.ClockEntry (execOp) : new Clock.ClockEntryRep (execOp' execTime);  	sbyte writeCycles = decoded._timing._writeTime;  	if (writeCycles >= 0) {  		if (writeCycles < 2) {  			next.ComboNext = writeCycles == 0;  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  		else {  			next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  	}  }  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (_cpu.NMI.Check ())  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffa)' 7);  else if (_cpu.IRQ.IsRaised && !_cpu.State.P.IrqMask)  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffe)' 7);  else {  	_cpu.Opcode = _cpu.Memory.Read (_cpu.State.PC.Value);  	_cpu.State.PC.Next ();  	DecodingTable.Entry decoded = DecodingTable.Opcodes [_cpu.Opcode];  	DecodeAddressOp addrOp = new DecodeAddressOp (_cpu' decoded._addressing);  	ExecuteOpcodeOp execOp = new ExecuteOpcodeOp (_cpu' decoded._instruction' decoded._timing._prolongOnPageCross);  	byte addrTime = decoded._timing._addressingTime;  	byte execTime = decoded._timing._execTime;  	first = addrTime < 2 ? new Clock.ClockEntry (addrOp' true) : new Clock.ClockEntryRep (addrOp' addrTime);  	first.ComboNext = execTime == 0 || addrTime == 0;  	next = first.Next = execTime < 2 ? new Clock.ClockEntry (execOp) : new Clock.ClockEntryRep (execOp' execTime);  	sbyte writeCycles = decoded._timing._writeTime;  	if (writeCycles >= 0) {  		if (writeCycles < 2) {  			next.ComboNext = writeCycles == 0;  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  		else {  			next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  	}  }  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (_cpu.NMI.Check ())  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffa)' 7);  else if (_cpu.IRQ.IsRaised && !_cpu.State.P.IrqMask)  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffe)' 7);  else {  	_cpu.Opcode = _cpu.Memory.Read (_cpu.State.PC.Value);  	_cpu.State.PC.Next ();  	DecodingTable.Entry decoded = DecodingTable.Opcodes [_cpu.Opcode];  	DecodeAddressOp addrOp = new DecodeAddressOp (_cpu' decoded._addressing);  	ExecuteOpcodeOp execOp = new ExecuteOpcodeOp (_cpu' decoded._instruction' decoded._timing._prolongOnPageCross);  	byte addrTime = decoded._timing._addressingTime;  	byte execTime = decoded._timing._execTime;  	first = addrTime < 2 ? new Clock.ClockEntry (addrOp' true) : new Clock.ClockEntryRep (addrOp' addrTime);  	first.ComboNext = execTime == 0 || addrTime == 0;  	next = first.Next = execTime < 2 ? new Clock.ClockEntry (execOp) : new Clock.ClockEntryRep (execOp' execTime);  	sbyte writeCycles = decoded._timing._writeTime;  	if (writeCycles >= 0) {  		if (writeCycles < 2) {  			next.ComboNext = writeCycles == 0;  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  		else {  			next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  	}  }  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (_cpu.NMI.Check ())  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffa)' 7);  else if (_cpu.IRQ.IsRaised && !_cpu.State.P.IrqMask)  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffe)' 7);  else {  	_cpu.Opcode = _cpu.Memory.Read (_cpu.State.PC.Value);  	_cpu.State.PC.Next ();  	DecodingTable.Entry decoded = DecodingTable.Opcodes [_cpu.Opcode];  	DecodeAddressOp addrOp = new DecodeAddressOp (_cpu' decoded._addressing);  	ExecuteOpcodeOp execOp = new ExecuteOpcodeOp (_cpu' decoded._instruction' decoded._timing._prolongOnPageCross);  	byte addrTime = decoded._timing._addressingTime;  	byte execTime = decoded._timing._execTime;  	first = addrTime < 2 ? new Clock.ClockEntry (addrOp' true) : new Clock.ClockEntryRep (addrOp' addrTime);  	first.ComboNext = execTime == 0 || addrTime == 0;  	next = first.Next = execTime < 2 ? new Clock.ClockEntry (execOp) : new Clock.ClockEntryRep (execOp' execTime);  	sbyte writeCycles = decoded._timing._writeTime;  	if (writeCycles >= 0) {  		if (writeCycles < 2) {  			next.ComboNext = writeCycles == 0;  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  		else {  			next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  	}  }  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (_cpu.NMI.Check ())  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffa)' 7);  else if (_cpu.IRQ.IsRaised && !_cpu.State.P.IrqMask)  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffe)' 7);  else {  	_cpu.Opcode = _cpu.Memory.Read (_cpu.State.PC.Value);  	_cpu.State.PC.Next ();  	DecodingTable.Entry decoded = DecodingTable.Opcodes [_cpu.Opcode];  	DecodeAddressOp addrOp = new DecodeAddressOp (_cpu' decoded._addressing);  	ExecuteOpcodeOp execOp = new ExecuteOpcodeOp (_cpu' decoded._instruction' decoded._timing._prolongOnPageCross);  	byte addrTime = decoded._timing._addressingTime;  	byte execTime = decoded._timing._execTime;  	first = addrTime < 2 ? new Clock.ClockEntry (addrOp' true) : new Clock.ClockEntryRep (addrOp' addrTime);  	first.ComboNext = execTime == 0 || addrTime == 0;  	next = first.Next = execTime < 2 ? new Clock.ClockEntry (execOp) : new Clock.ClockEntryRep (execOp' execTime);  	sbyte writeCycles = decoded._timing._writeTime;  	if (writeCycles >= 0) {  		if (writeCycles < 2) {  			next.ComboNext = writeCycles == 0;  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  		else {  			next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  	}  }  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffa)' 7);  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (_cpu.IRQ.IsRaised && !_cpu.State.P.IrqMask)  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffe)' 7);  else {  	_cpu.Opcode = _cpu.Memory.Read (_cpu.State.PC.Value);  	_cpu.State.PC.Next ();  	DecodingTable.Entry decoded = DecodingTable.Opcodes [_cpu.Opcode];  	DecodeAddressOp addrOp = new DecodeAddressOp (_cpu' decoded._addressing);  	ExecuteOpcodeOp execOp = new ExecuteOpcodeOp (_cpu' decoded._instruction' decoded._timing._prolongOnPageCross);  	byte addrTime = decoded._timing._addressingTime;  	byte execTime = decoded._timing._execTime;  	first = addrTime < 2 ? new Clock.ClockEntry (addrOp' true) : new Clock.ClockEntryRep (addrOp' addrTime);  	first.ComboNext = execTime == 0 || addrTime == 0;  	next = first.Next = execTime < 2 ? new Clock.ClockEntry (execOp) : new Clock.ClockEntryRep (execOp' execTime);  	sbyte writeCycles = decoded._timing._writeTime;  	if (writeCycles >= 0) {  		if (writeCycles < 2) {  			next.ComboNext = writeCycles == 0;  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  		else {  			next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  	}  }  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (_cpu.IRQ.IsRaised && !_cpu.State.P.IrqMask)  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffe)' 7);  else {  	_cpu.Opcode = _cpu.Memory.Read (_cpu.State.PC.Value);  	_cpu.State.PC.Next ();  	DecodingTable.Entry decoded = DecodingTable.Opcodes [_cpu.Opcode];  	DecodeAddressOp addrOp = new DecodeAddressOp (_cpu' decoded._addressing);  	ExecuteOpcodeOp execOp = new ExecuteOpcodeOp (_cpu' decoded._instruction' decoded._timing._prolongOnPageCross);  	byte addrTime = decoded._timing._addressingTime;  	byte execTime = decoded._timing._execTime;  	first = addrTime < 2 ? new Clock.ClockEntry (addrOp' true) : new Clock.ClockEntryRep (addrOp' addrTime);  	first.ComboNext = execTime == 0 || addrTime == 0;  	next = first.Next = execTime < 2 ? new Clock.ClockEntry (execOp) : new Clock.ClockEntryRep (execOp' execTime);  	sbyte writeCycles = decoded._timing._writeTime;  	if (writeCycles >= 0) {  		if (writeCycles < 2) {  			next.ComboNext = writeCycles == 0;  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  		else {  			next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  	}  }  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (_cpu.IRQ.IsRaised && !_cpu.State.P.IrqMask)  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffe)' 7);  else {  	_cpu.Opcode = _cpu.Memory.Read (_cpu.State.PC.Value);  	_cpu.State.PC.Next ();  	DecodingTable.Entry decoded = DecodingTable.Opcodes [_cpu.Opcode];  	DecodeAddressOp addrOp = new DecodeAddressOp (_cpu' decoded._addressing);  	ExecuteOpcodeOp execOp = new ExecuteOpcodeOp (_cpu' decoded._instruction' decoded._timing._prolongOnPageCross);  	byte addrTime = decoded._timing._addressingTime;  	byte execTime = decoded._timing._execTime;  	first = addrTime < 2 ? new Clock.ClockEntry (addrOp' true) : new Clock.ClockEntryRep (addrOp' addrTime);  	first.ComboNext = execTime == 0 || addrTime == 0;  	next = first.Next = execTime < 2 ? new Clock.ClockEntry (execOp) : new Clock.ClockEntryRep (execOp' execTime);  	sbyte writeCycles = decoded._timing._writeTime;  	if (writeCycles >= 0) {  		if (writeCycles < 2) {  			next.ComboNext = writeCycles == 0;  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  		else {  			next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  	}  }  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (_cpu.IRQ.IsRaised && !_cpu.State.P.IrqMask)  	first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffe)' 7);  else {  	_cpu.Opcode = _cpu.Memory.Read (_cpu.State.PC.Value);  	_cpu.State.PC.Next ();  	DecodingTable.Entry decoded = DecodingTable.Opcodes [_cpu.Opcode];  	DecodeAddressOp addrOp = new DecodeAddressOp (_cpu' decoded._addressing);  	ExecuteOpcodeOp execOp = new ExecuteOpcodeOp (_cpu' decoded._instruction' decoded._timing._prolongOnPageCross);  	byte addrTime = decoded._timing._addressingTime;  	byte execTime = decoded._timing._execTime;  	first = addrTime < 2 ? new Clock.ClockEntry (addrOp' true) : new Clock.ClockEntryRep (addrOp' addrTime);  	first.ComboNext = execTime == 0 || addrTime == 0;  	next = first.Next = execTime < 2 ? new Clock.ClockEntry (execOp) : new Clock.ClockEntryRep (execOp' execTime);  	sbyte writeCycles = decoded._timing._writeTime;  	if (writeCycles >= 0) {  		if (writeCycles < 2) {  			next.ComboNext = writeCycles == 0;  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  		else {  			next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  			next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  		}  	}  }  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: first = next = new Clock.ClockEntryRep (new InterruptOp (_cpu' 0xfffe)' 7);  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: first = addrTime < 2 ? new Clock.ClockEntry (addrOp' true) : new Clock.ClockEntryRep (addrOp' addrTime);  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: next = first.Next = execTime < 2 ? new Clock.ClockEntry (execOp) : new Clock.ClockEntryRep (execOp' execTime);  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (writeCycles >= 0) {  	if (writeCycles < 2) {  		next.ComboNext = writeCycles == 0;  		next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  	}  	else {  		next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  		next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  	}  }  
Magic Number,CPU,DecodeOpcodeOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (writeCycles < 2) {  	next.ComboNext = writeCycles == 0;  	next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  }  else {  	next = next.Next = new Clock.ClockEntryRep (new Clock.StallOp ()' (byte)(writeCycles - 1));  	next = next.Next = new Clock.ClockEntry (new WriteResultOp (_cpu));  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCH);  	_cpu.State.S.Value--;  }  else if (cycle == 1) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCL);  	_cpu.State.S.Value--;  }  else if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCH);  	_cpu.State.S.Value--;  }  else if (cycle == 1) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCL);  	_cpu.State.S.Value--;  }  else if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCH);  	_cpu.State.S.Value--;  }  else if (cycle == 1) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCL);  	_cpu.State.S.Value--;  }  else if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCH);  	_cpu.State.S.Value--;  }  else if (cycle == 1) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCL);  	_cpu.State.S.Value--;  }  else if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCL);  	_cpu.State.S.Value--;  }  else if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCL);  	_cpu.State.S.Value--;  }  else if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCL);  	_cpu.State.S.Value--;  }  else if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.PC.PCL);  	_cpu.State.S.Value--;  }  else if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	_cpu.Memory.Write (_cpu.State.S.Value' _cpu.State.P.Value);  	_cpu.State.S.Value--;  }  else if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 3) {  	_readBuffer = _cpu.Memory.Read (_isrPointer);  }  else if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 4) {  	_cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  	_cpu.State.P.IrqMask = true;  }  
Magic Number,CPU,InterruptOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: _cpu.State.PC.Value = (ushort)((_cpu.Memory.Read ((ushort)(_isrPointer + 1)) << 8) | _readBuffer);  
Magic Number,CPU,ResetOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	_cpu.State.A.Reset ();  	_cpu.State.X.Reset ();  	_cpu.State.Y.Reset ();  	_cpu.State.S.Reset ();  	_cpu.State.P.Reset ();  }  else if (cycle == 1)  	_readBuffer = _cpu.Memory.Read (0xfffc);  else if (cycle == 2)  	_cpu.State.PC.Value = (ushort)(_readBuffer | (_cpu.Memory.Read (0xfffd) << 8));  
Magic Number,CPU,ResetOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	_cpu.State.A.Reset ();  	_cpu.State.X.Reset ();  	_cpu.State.Y.Reset ();  	_cpu.State.S.Reset ();  	_cpu.State.P.Reset ();  }  else if (cycle == 1)  	_readBuffer = _cpu.Memory.Read (0xfffc);  else if (cycle == 2)  	_cpu.State.PC.Value = (ushort)(_readBuffer | (_cpu.Memory.Read (0xfffd) << 8));  
Magic Number,CPU,ResetOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 1)  	_readBuffer = _cpu.Memory.Read (0xfffc);  else if (cycle == 2)  	_cpu.State.PC.Value = (ushort)(_readBuffer | (_cpu.Memory.Read (0xfffd) << 8));  
Magic Number,CPU,ResetOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 1)  	_readBuffer = _cpu.Memory.Read (0xfffc);  else if (cycle == 2)  	_cpu.State.PC.Value = (ushort)(_readBuffer | (_cpu.Memory.Read (0xfffd) << 8));  
Magic Number,CPU,ResetOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 2)  	_cpu.State.PC.Value = (ushort)(_readBuffer | (_cpu.Memory.Read (0xfffd) << 8));  
Magic Number,CPU,ResetOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: if (cycle == 2)  	_cpu.State.PC.Value = (ushort)(_readBuffer | (_cpu.Memory.Read (0xfffd) << 8));  
Magic Number,CPU,ResetOp,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,Execute,The following statement contains a magic number: _cpu.State.PC.Value = (ushort)(_readBuffer | (_cpu.Memory.Read (0xfffd) << 8));  
Magic Number,CPU,ReadableTarget,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,BuildAddress,The following statement contains a magic number: _address |= _part == 0 ? part : (ushort)(part << 8);  
Magic Number,CPU,IndirectTarget,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,BuildTempAddress,The following statement contains a magic number: _tempAddress |= _tempPart == 0 ? part : (ushort)(part << 8);  
Magic Number,CPU,AbsAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle < 2) {  	cpu.Target.BuildAddress (cpu.Memory.Read (cpu.State.PC.Value));  	cpu.State.PC.Next ();  }  
Magic Number,CPU,IndAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle < 2) {  	if (cycle == 0)  		cpu.Target = new IndirectTarget (cpu);  	((IndirectTarget)cpu.Target).BuildTempAddress (cpu.Memory.Read (cpu.State.PC.Value));  	cpu.State.PC.Next ();  }  else if (cycle < 4)  	cpu.Target.BuildAddress (cpu.Memory.Read (((IndirectTarget)cpu.Target).TempAddress++));  
Magic Number,CPU,IndAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle < 2) {  	if (cycle == 0)  		cpu.Target = new IndirectTarget (cpu);  	((IndirectTarget)cpu.Target).BuildTempAddress (cpu.Memory.Read (cpu.State.PC.Value));  	cpu.State.PC.Next ();  }  else if (cycle < 4)  	cpu.Target.BuildAddress (cpu.Memory.Read (((IndirectTarget)cpu.Target).TempAddress++));  
Magic Number,CPU,IndAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle < 4)  	cpu.Target.BuildAddress (cpu.Memory.Read (((IndirectTarget)cpu.Target).TempAddress++));  
Magic Number,CPU,IndXAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle == 0) {  	cpu.Target = new IndirectTarget (cpu' (byte)(cpu.Memory.Read (cpu.State.PC.Value) + cpu.State.X.Value));  	cpu.State.PC.Next ();  }  else if (cycle < 3)  	cpu.Target.BuildAddress (cpu.Memory.Read (((IndirectTarget)cpu.Target).TempAddress++));  
Magic Number,CPU,IndXAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle < 3)  	cpu.Target.BuildAddress (cpu.Memory.Read (((IndirectTarget)cpu.Target).TempAddress++));  
Magic Number,CPU,IndYAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle == 0) {  	cpu.Target = new IndirectTarget (cpu' cpu.Memory.Read (cpu.State.PC.Value));  	cpu.State.PC.Next ();  }  else if (cycle < 3) {  	cpu.Target.BuildAddress (cpu.Memory.Read (((IndirectTarget)cpu.Target).TempAddress++));  	if (cycle == 2)  		cpu.Target.MoveAddress (cpu.State.Y.Value);  }  
Magic Number,CPU,IndYAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle == 0) {  	cpu.Target = new IndirectTarget (cpu' cpu.Memory.Read (cpu.State.PC.Value));  	cpu.State.PC.Next ();  }  else if (cycle < 3) {  	cpu.Target.BuildAddress (cpu.Memory.Read (((IndirectTarget)cpu.Target).TempAddress++));  	if (cycle == 2)  		cpu.Target.MoveAddress (cpu.State.Y.Value);  }  
Magic Number,CPU,IndYAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle < 3) {  	cpu.Target.BuildAddress (cpu.Memory.Read (((IndirectTarget)cpu.Target).TempAddress++));  	if (cycle == 2)  		cpu.Target.MoveAddress (cpu.State.Y.Value);  }  
Magic Number,CPU,IndYAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle < 3) {  	cpu.Target.BuildAddress (cpu.Memory.Read (((IndirectTarget)cpu.Target).TempAddress++));  	if (cycle == 2)  		cpu.Target.MoveAddress (cpu.State.Y.Value);  }  
Magic Number,CPU,IndYAddressing,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,Decode,The following statement contains a magic number: if (cycle == 2)  	cpu.Target.MoveAddress (cpu.State.Y.Value);  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCH);  	cpu.State.S.Value--;  }  else if (cycle == 1) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCL);  	cpu.State.S.Value--;  }  else if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCH);  	cpu.State.S.Value--;  }  else if (cycle == 1) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCL);  	cpu.State.S.Value--;  }  else if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCH);  	cpu.State.S.Value--;  }  else if (cycle == 1) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCL);  	cpu.State.S.Value--;  }  else if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCH);  	cpu.State.S.Value--;  }  else if (cycle == 1) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCL);  	cpu.State.S.Value--;  }  else if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCL);  	cpu.State.S.Value--;  }  else if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCL);  	cpu.State.S.Value--;  }  else if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCL);  	cpu.State.S.Value--;  }  else if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.PC.PCL);  	cpu.State.S.Value--;  }  else if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	cpu.Memory.Write (cpu.State.S.Value' cpu.State.P.Value);  	cpu.State.S.Value--;  }  else if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 3)  	cpu.Result = cpu.Memory.Read (0xfffe);  else if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 4) {  	cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  	cpu.State.P.BreakCmd = true;  }  
Magic Number,CPU,BRK,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: cpu.State.PC.Value = (ushort)((cpu.Memory.Read (0xffff) << 8) | cpu.Result);  
Magic Number,CPU,JSR,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	cpu.Memory.Write (cpu.State.S.Value' (byte)((cpu.State.PC.Value - 1) >> 8));  	cpu.State.S.Value--;  }  else if (cycle == 1) {  	cpu.Memory.Write (cpu.State.S.Value' (byte)((cpu.State.PC.Value - 1)));  	cpu.State.S.Value--;  }  else  	cpu.State.PC.Value = cpu.Target.Address;  
Magic Number,CPU,JSR,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: cpu.Memory.Write (cpu.State.S.Value' (byte)((cpu.State.PC.Value - 1) >> 8));  
Magic Number,CPU,ROR,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: tmp = (byte)((tmp >> 1) | (carry << 7));  
Magic Number,CPU,RTI,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	cpu.State.S.Value++;  	cpu.State.P.Value = cpu.Memory.Read (cpu.State.S.Value);  }  else if (cycle == 1) {  	cpu.State.S.Value++;  	cpu.Result = cpu.Memory.Read (cpu.State.S.Value);  }  else if (cycle == 2) {  	cpu.State.S.Value++;  	cpu.State.PC.Value = (ushort)(cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8));  }  
Magic Number,CPU,RTI,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 0) {  	cpu.State.S.Value++;  	cpu.State.P.Value = cpu.Memory.Read (cpu.State.S.Value);  }  else if (cycle == 1) {  	cpu.State.S.Value++;  	cpu.Result = cpu.Memory.Read (cpu.State.S.Value);  }  else if (cycle == 2) {  	cpu.State.S.Value++;  	cpu.State.PC.Value = (ushort)(cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8));  }  
Magic Number,CPU,RTI,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	cpu.State.S.Value++;  	cpu.Result = cpu.Memory.Read (cpu.State.S.Value);  }  else if (cycle == 2) {  	cpu.State.S.Value++;  	cpu.State.PC.Value = (ushort)(cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8));  }  
Magic Number,CPU,RTI,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	cpu.State.S.Value++;  	cpu.Result = cpu.Memory.Read (cpu.State.S.Value);  }  else if (cycle == 2) {  	cpu.State.S.Value++;  	cpu.State.PC.Value = (ushort)(cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8));  }  
Magic Number,CPU,RTI,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	cpu.State.S.Value++;  	cpu.State.PC.Value = (ushort)(cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8));  }  
Magic Number,CPU,RTI,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	cpu.State.S.Value++;  	cpu.State.PC.Value = (ushort)(cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8));  }  
Magic Number,CPU,RTI,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: cpu.State.PC.Value = (ushort)(cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8));  
Magic Number,CPU,RTS,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	cpu.State.S.Value++;  	cpu.Result = cpu.Memory.Read (cpu.State.S.Value);  }  else if (cycle == 2) {  	cpu.State.S.Value++;  	cpu.State.PC.Value = (ushort)((cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8)) + 1);  }  
Magic Number,CPU,RTS,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 1) {  	cpu.State.S.Value++;  	cpu.Result = cpu.Memory.Read (cpu.State.S.Value);  }  else if (cycle == 2) {  	cpu.State.S.Value++;  	cpu.State.PC.Value = (ushort)((cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8)) + 1);  }  
Magic Number,CPU,RTS,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	cpu.State.S.Value++;  	cpu.State.PC.Value = (ushort)((cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8)) + 1);  }  
Magic Number,CPU,RTS,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cycle == 2) {  	cpu.State.S.Value++;  	cpu.State.PC.Value = (ushort)((cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8)) + 1);  }  
Magic Number,CPU,RTS,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: cpu.State.PC.Value = (ushort)((cpu.Result | (cpu.Memory.Read (cpu.State.S.Value) << 8)) + 1);  
Magic Number,CPU,SBC,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: if (cpu.State.P.Decimal) {  	tmp = (a & 0x0f) - (mem & 0x0f) - (1 - cpu.State.P.CarryValue);  	tmp = (tmp & 0x10) != 0 ? ((tmp - 6) & 0x0f) | ((a & 0xf0) - (mem & 0xf0) - 0x10) : tmp | ((a & 0xf0) - (mem & 0xf0));  	vCheck = tmp;  	if ((tmp & 0xff00) != 0)  		tmp -= 0x60;  	cpu.State.P.Carry = (tmp & 0xff00) == 0;  }  else {  	vCheck = tmp = a - mem - (1 - cpu.State.P.CarryValue);  	cpu.State.P.Carry = (tmp & 0xff00) == 0;  }  
Magic Number,CPU,SBC,C:\repos\RonFields72_C64Emulator\c64_cpu\InstructionSet.cs,Execute,The following statement contains a magic number: tmp = (tmp & 0x10) != 0 ? ((tmp - 6) & 0x0f) | ((a & 0xf0) - (mem & 0xf0) - 0x10) : tmp | ((a & 0xf0) - (mem & 0xf0));  
Missing Default,CPU,MOS6502_OpFactory,C:\repos\RonFields72_C64Emulator\c64_cpu\6502.cs,CreateFromStateFile,The following switch statement is missing a default case: switch (stateFile.ReadByte ()) {  case (byte)Ops.Stall:  	return new Clock.StallOp ();  case (byte)Ops.DecodeOpcode:  	return new DecodeOpcodeOp (_cpu);  case (byte)Ops.DecodeAddressing:  	return new DecodeAddressOp (_cpu' stateFile);  case (byte)Ops.ExecuteOpcode:  	return new ExecuteOpcodeOp (_cpu' stateFile);  case (byte)Ops.WriteResult:  	return new WriteResultOp (_cpu);  case (byte)Ops.Interrupt:  	return new InterruptOp (_cpu' stateFile);  case (byte)Ops.Reset:  	return new ResetOp (_cpu' stateFile);  }  
Missing Default,CPU,TargetFactory,C:\repos\RonFields72_C64Emulator\c64_cpu\Addressing.cs,ReadTargetFromStateFile,The following switch statement is missing a default case: switch (stateFile.ReadByte ()) {  case (byte)TargetTypes.ReadableTarget:  	return new ReadableTarget (cpu' stateFile);  case (byte)TargetTypes.WritableTarget:  	return new WritableTarget (cpu' stateFile);  case (byte)TargetTypes.IndirectTarget:  	return new IndirectTarget (cpu' stateFile);  case (byte)TargetTypes.AccumulatorTarget:  	return new AccAddressing.Target (cpu);  case (byte)TargetTypes.ImmediateTarget:  	return new ImmAddressing.Target (cpu' stateFile);  }  
