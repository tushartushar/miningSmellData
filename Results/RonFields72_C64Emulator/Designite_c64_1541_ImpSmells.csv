Implementation smell,Namespace,Class,File,Method,Description
Complex Method,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Read,Cyclomatic complexity of the method is 19
Complex Method,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Write,Cyclomatic complexity of the method is 69
Long Parameter List,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,ConvertSectorToGCR,The method has 6 parameters.
Long Statement,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,ReadPortA,The length of the statement  "	byte value = (_latchPortA && (_interruptFlagRegister & (byte)IR.CA1) != 0) ? _latchedValueA : (byte)(_portA.Input | (_portA.Output & _portA.Direction)); " is 152.
Long Statement,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,ReadPortB,The length of the statement  "	byte value = (_latchPortB && (_interruptFlagRegister & (byte)IR.CB1) != 0) ? _latchedValueB : (byte)(_portB.Input | (_portB.Output & _portB.Direction)); " is 152.
Magic Number,DiskDrive,CBM1541,C:\repos\RonFields72_C64Emulator\c64_1541ii\CBM1541.cs,CBM1541,The following statement contains a magic number: _driveVias = new VIA[2] {  	new VIA ((ushort)Map.Via1RegistersAddress' (ushort)Map.Via1RegistersSize' _driveCpu.IRQ)'  	new VIA ((ushort)Map.Via2RegistersAddress' (ushort)Map.Via2RegistersSize' _driveCpu.IRQ)  };  
Magic Number,DiskDrive,CBM1541,C:\repos\RonFields72_C64Emulator\c64_1541ii\CBM1541.cs,CBM1541,The following statement contains a magic number: _driveClock.QueueOpsStart (_driveVias [1].CreateOps ()' 2);  
Magic Number,DiskDrive,CBM1541,C:\repos\RonFields72_C64Emulator\c64_1541ii\CBM1541.cs,CBM1541,The following statement contains a magic number: _driveClock.QueueOpsStart (_drive.CreateOps ()' 3);  
Magic Number,DiskDrive,Drive,C:\repos\RonFields72_C64Emulator\c64_1541ii\Drive.cs,ControlPort_OnPortOut,The following statement contains a magic number: MoveHead ((byte)(states & 3));  
Magic Number,DiskDrive,Drive,C:\repos\RonFields72_C64Emulator\c64_1541ii\Drive.cs,ControlPort_OnPortOut,The following statement contains a magic number: _density = GCRImage.DEN [(byte)((states >> 5) & 3)];  
Magic Number,DiskDrive,Drive,C:\repos\RonFields72_C64Emulator\c64_1541ii\Drive.cs,ControlPort_OnPortOut,The following statement contains a magic number: _density = GCRImage.DEN [(byte)((states >> 5) & 3)];  
Magic Number,DiskDrive,Drive,C:\repos\RonFields72_C64Emulator\c64_1541ii\Drive.cs,ControlPort_OnPortOut,The following statement contains a magic number: _spinning = (states & 4) != 0;  
Magic Number,DiskDrive,Drive,C:\repos\RonFields72_C64Emulator\c64_1541ii\Drive.cs,MoveHead,The following statement contains a magic number: if (_lastHeadDirection != headDirection) {  	if (((_lastHeadDirection - 1) & 3) == headDirection) {  		if (_headTrackPos > 0)  			_headTrackPos--;  	}  	else if (((_lastHeadDirection + 1) & 3) == headDirection) {  		if (_headTrackPos < GCRImage.TRACK_COUNT - 1)  			_headTrackPos++;  	}  	_headSectorPos %= (ushort)_attachedImage.Tracks [_headTrackPos].Length;  	_lastHeadDirection = headDirection;  }  
Magic Number,DiskDrive,Drive,C:\repos\RonFields72_C64Emulator\c64_1541ii\Drive.cs,MoveHead,The following statement contains a magic number: if (_lastHeadDirection != headDirection) {  	if (((_lastHeadDirection - 1) & 3) == headDirection) {  		if (_headTrackPos > 0)  			_headTrackPos--;  	}  	else if (((_lastHeadDirection + 1) & 3) == headDirection) {  		if (_headTrackPos < GCRImage.TRACK_COUNT - 1)  			_headTrackPos++;  	}  	_headSectorPos %= (ushort)_attachedImage.Tracks [_headTrackPos].Length;  	_lastHeadDirection = headDirection;  }  
Magic Number,DiskDrive,Drive,C:\repos\RonFields72_C64Emulator\c64_1541ii\Drive.cs,MoveHead,The following statement contains a magic number: if (((_lastHeadDirection - 1) & 3) == headDirection) {  	if (_headTrackPos > 0)  		_headTrackPos--;  }  else if (((_lastHeadDirection + 1) & 3) == headDirection) {  	if (_headTrackPos < GCRImage.TRACK_COUNT - 1)  		_headTrackPos++;  }  
Magic Number,DiskDrive,Drive,C:\repos\RonFields72_C64Emulator\c64_1541ii\Drive.cs,MoveHead,The following statement contains a magic number: if (((_lastHeadDirection - 1) & 3) == headDirection) {  	if (_headTrackPos > 0)  		_headTrackPos--;  }  else if (((_lastHeadDirection + 1) & 3) == headDirection) {  	if (_headTrackPos < GCRImage.TRACK_COUNT - 1)  		_headTrackPos++;  }  
Magic Number,DiskDrive,Drive,C:\repos\RonFields72_C64Emulator\c64_1541ii\Drive.cs,MoveHead,The following statement contains a magic number: if (((_lastHeadDirection + 1) & 3) == headDirection) {  	if (_headTrackPos < GCRImage.TRACK_COUNT - 1)  		_headTrackPos++;  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int i = 0' j = encodeStart; i < data.Length; i++) {  	byte b = data [i];  	b = (byte)((b >> 4) | (b << 4));  	for (int k = 2; k > 0; k--) {  		e |= (ulong)TO_GCR [b & 0x0f] << shift;  		b >>= 4;  		shift -= 5;  	}  	if (i % 4 == 3) {  		byte[] buffer = System.BitConverter.GetBytes (e);  		for (short k = 7; k > 2; k--)  			encoded [encodeStart++] = buffer [k];  		shift = 63 - 4;  		e = 0;  	}  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: b = (byte)((b >> 4) | (b << 4));  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: b = (byte)((b >> 4) | (b << 4));  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int k = 2; k > 0; k--) {  	e |= (ulong)TO_GCR [b & 0x0f] << shift;  	b >>= 4;  	shift -= 5;  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int k = 2; k > 0; k--) {  	e |= (ulong)TO_GCR [b & 0x0f] << shift;  	b >>= 4;  	shift -= 5;  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (int k = 2; k > 0; k--) {  	e |= (ulong)TO_GCR [b & 0x0f] << shift;  	b >>= 4;  	shift -= 5;  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: b >>= 4;  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: shift -= 5;  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: if (i % 4 == 3) {  	byte[] buffer = System.BitConverter.GetBytes (e);  	for (short k = 7; k > 2; k--)  		encoded [encodeStart++] = buffer [k];  	shift = 63 - 4;  	e = 0;  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: if (i % 4 == 3) {  	byte[] buffer = System.BitConverter.GetBytes (e);  	for (short k = 7; k > 2; k--)  		encoded [encodeStart++] = buffer [k];  	shift = 63 - 4;  	e = 0;  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: if (i % 4 == 3) {  	byte[] buffer = System.BitConverter.GetBytes (e);  	for (short k = 7; k > 2; k--)  		encoded [encodeStart++] = buffer [k];  	shift = 63 - 4;  	e = 0;  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: if (i % 4 == 3) {  	byte[] buffer = System.BitConverter.GetBytes (e);  	for (short k = 7; k > 2; k--)  		encoded [encodeStart++] = buffer [k];  	shift = 63 - 4;  	e = 0;  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: if (i % 4 == 3) {  	byte[] buffer = System.BitConverter.GetBytes (e);  	for (short k = 7; k > 2; k--)  		encoded [encodeStart++] = buffer [k];  	shift = 63 - 4;  	e = 0;  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: if (i % 4 == 3) {  	byte[] buffer = System.BitConverter.GetBytes (e);  	for (short k = 7; k > 2; k--)  		encoded [encodeStart++] = buffer [k];  	shift = 63 - 4;  	e = 0;  }  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (short k = 7; k > 2; k--)  	encoded [encodeStart++] = buffer [k];  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: for (short k = 7; k > 2; k--)  	encoded [encodeStart++] = buffer [k];  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: shift = 63 - 4;  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,EncodeGCR,The following statement contains a magic number: shift = 63 - 4;  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [2] = sector;  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [3] = track;  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [4] = (byte)id;  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [5] = (byte)(id >> 8);  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [5] = (byte)(id >> 8);  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [1] = (byte)(header [2] ^ header [3] ^ header [4] ^ header [5]);  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [1] = (byte)(header [2] ^ header [3] ^ header [4] ^ header [5]);  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [1] = (byte)(header [2] ^ header [3] ^ header [4] ^ header [5]);  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [1] = (byte)(header [2] ^ header [3] ^ header [4] ^ header [5]);  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [6] = header [7] = 0x0f;  
Magic Number,DiskDrive,GCRImage,C:\repos\RonFields72_C64Emulator\c64_1541ii\GCR.cs,CreateSectorHeader,The following statement contains a magic number: header [6] = header [7] = 0x0f;  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Read,The following statement contains a magic number: switch (address) {  case (ushort)Registers.ORB:  	return ReadPortB ();  case (ushort)Registers.ORA:  	return ReadPortA (true);  case (ushort)Registers.DDRB:  	return _portB.Direction;  case (ushort)Registers.DDRA:  	return _portA.Direction;  case (ushort)Registers.T1_CL:  	ClearInterrupt (IR.T1);  	return (byte)_t1Counter;  case (ushort)Registers.T1_CH:  	return (byte)(_t1Counter >> 8);  case (ushort)Registers.T1_LL:  	return (byte)_t1Latch;  case (ushort)Registers.T1_LH:  	return (byte)(_t1Latch >> 8);  case (ushort)Registers.T2_CL:  	ClearInterrupt (IR.T2);  	return (byte)_t2Counter;  case (ushort)Registers.T2_CH:  	return (byte)(_t2Counter >> 8);  case (ushort)Registers.SR:  	break;  case (ushort)Registers.ACR:  	return _auxiliaryControlRegister;  case (ushort)Registers.FCR:  	return _functionControlRegister;  case (ushort)Registers.IFR:  	return _interruptFlagRegister;  case (ushort)Registers.IER:  	return _interruptEnabledRegister;  case (ushort)Registers.ORA_NH:  	return ReadPortA (false);  }  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Read,The following statement contains a magic number: switch (address) {  case (ushort)Registers.ORB:  	return ReadPortB ();  case (ushort)Registers.ORA:  	return ReadPortA (true);  case (ushort)Registers.DDRB:  	return _portB.Direction;  case (ushort)Registers.DDRA:  	return _portA.Direction;  case (ushort)Registers.T1_CL:  	ClearInterrupt (IR.T1);  	return (byte)_t1Counter;  case (ushort)Registers.T1_CH:  	return (byte)(_t1Counter >> 8);  case (ushort)Registers.T1_LL:  	return (byte)_t1Latch;  case (ushort)Registers.T1_LH:  	return (byte)(_t1Latch >> 8);  case (ushort)Registers.T2_CL:  	ClearInterrupt (IR.T2);  	return (byte)_t2Counter;  case (ushort)Registers.T2_CH:  	return (byte)(_t2Counter >> 8);  case (ushort)Registers.SR:  	break;  case (ushort)Registers.ACR:  	return _auxiliaryControlRegister;  case (ushort)Registers.FCR:  	return _functionControlRegister;  case (ushort)Registers.IFR:  	return _interruptFlagRegister;  case (ushort)Registers.IER:  	return _interruptEnabledRegister;  case (ushort)Registers.ORA_NH:  	return ReadPortA (false);  }  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Read,The following statement contains a magic number: switch (address) {  case (ushort)Registers.ORB:  	return ReadPortB ();  case (ushort)Registers.ORA:  	return ReadPortA (true);  case (ushort)Registers.DDRB:  	return _portB.Direction;  case (ushort)Registers.DDRA:  	return _portA.Direction;  case (ushort)Registers.T1_CL:  	ClearInterrupt (IR.T1);  	return (byte)_t1Counter;  case (ushort)Registers.T1_CH:  	return (byte)(_t1Counter >> 8);  case (ushort)Registers.T1_LL:  	return (byte)_t1Latch;  case (ushort)Registers.T1_LH:  	return (byte)(_t1Latch >> 8);  case (ushort)Registers.T2_CL:  	ClearInterrupt (IR.T2);  	return (byte)_t2Counter;  case (ushort)Registers.T2_CH:  	return (byte)(_t2Counter >> 8);  case (ushort)Registers.SR:  	break;  case (ushort)Registers.ACR:  	return _auxiliaryControlRegister;  case (ushort)Registers.FCR:  	return _functionControlRegister;  case (ushort)Registers.IFR:  	return _interruptFlagRegister;  case (ushort)Registers.IER:  	return _interruptEnabledRegister;  case (ushort)Registers.ORA_NH:  	return ReadPortA (false);  }  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Read,The following statement contains a magic number: return (byte)(_t1Counter >> 8);  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Read,The following statement contains a magic number: return (byte)(_t1Latch >> 8);  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Read,The following statement contains a magic number: return (byte)(_t2Counter >> 8);  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.ORB:  	WritePortB (value);  	break;  case (ushort)Registers.ORA:  	WritePortA (value' true);  	break;  case (ushort)Registers.DDRB:  	_portB.Direction = value;  	break;  case (ushort)Registers.DDRA:  	_portA.Direction = value;  	break;  case (ushort)Registers.T1_CL:  	_t1Latch = (ushort)((_t1Latch & 0xff00) | value);  	break;  case (ushort)Registers.T1_CH:  	_t1Latch = (ushort)((_t1Latch & 0xff) | (value << 8));  	_t1Counter = _t1Latch;  	_t1Count = true;  	ClearInterrupt (IR.T1);  	break;  case (ushort)Registers.T1_LL:  	_t1Latch = (ushort)((_t1Latch & 0xff00) | value);  	break;  case (ushort)Registers.T1_LH:  	_t1Latch = (ushort)((_t1Latch & 0xff) | (value << 8));  	ClearInterrupt (IR.T1);  	break;  case (ushort)Registers.T2_CL:  	_t2Latch = value;  	ClearInterrupt (IR.T2);  	break;  case (ushort)Registers.T2_CH:  	_t2Counter = (ushort)((value << 8) | _t1Latch);  	_t2Count = true;  	ClearInterrupt (IR.T2);  	break;  case (ushort)Registers.SR:  	break;  case (ushort)Registers.ACR:  	_auxiliaryControlRegister = value;  	_latchPortA = (value & (byte)ACR.PA_L) != 0;  	_latchPortB = (value & (byte)ACR.PB_L) != 0;  	_t1FreeRun = (value & (byte)ACR.T1_FM) != 0;  	_t1OutPB = (value & (byte)ACR.T1_OM) != 0;  	_t2InPB = (value & (byte)ACR.T2_IM) != 0;  	break;  case (ushort)Registers.FCR:  	_functionControlRegister = value;  	if ((value & (byte)FCR.CA2_IO) == (byte)FCR.CA2_IO) {  		_pulseCA2 = (value & (byte)(FCR.CA2_OM | FCR.CA2_OL)) == (byte)FCR.CA2_OL;  		_ca2 = !_pulseCA2 && (value & (byte)(FCR.CA2_OM | FCR.CA2_OL)) == (byte)(FCR.CA2_OM | FCR.CA2_OL);  	}  	if ((value & (byte)FCR.CB2_IO) == (byte)FCR.CB2_IO) {  		_pulseCB2 = (value & (byte)(FCR.CB2_OM | FCR.CB2_OL)) == (byte)FCR.CB2_OL;  		_cb2 = !_pulseCB2 && (value & (byte)(FCR.CB2_OM | FCR.CB2_OL)) == (byte)(FCR.CB2_OM | FCR.CB2_OL);  	}  	break;  case (ushort)Registers.IFR:  	clear = (byte)IR.IRQ;  	ClearInterrupt ((IR)(value & ~clear));  	break;  case (ushort)Registers.IER:  	if ((value & (byte)IR.IRQ) != 0) {  		clear = (byte)IR.IRQ;  		_interruptEnabledRegister |= (byte)(value & ~clear);  	}  	else  		_interruptEnabledRegister &= value;  	byte newInnteruptState = (byte)(_interruptFlagRegister & (_interruptEnabledRegister | (byte)IR.IRQ));  	if (newInnteruptState == (byte)IR.IRQ) {  		clear = (byte)IR.IRQ;  		_interruptFlagRegister &= (byte)~clear;  		_irqLine.Lower ();  	}  	else if (newInnteruptState != 0 && (_interruptFlagRegister & (byte)IR.IRQ) == 0) {  		_interruptFlagRegister |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	break;  case (ushort)Registers.ORA_NH:  	WritePortA (value' false);  	break;  }  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.ORB:  	WritePortB (value);  	break;  case (ushort)Registers.ORA:  	WritePortA (value' true);  	break;  case (ushort)Registers.DDRB:  	_portB.Direction = value;  	break;  case (ushort)Registers.DDRA:  	_portA.Direction = value;  	break;  case (ushort)Registers.T1_CL:  	_t1Latch = (ushort)((_t1Latch & 0xff00) | value);  	break;  case (ushort)Registers.T1_CH:  	_t1Latch = (ushort)((_t1Latch & 0xff) | (value << 8));  	_t1Counter = _t1Latch;  	_t1Count = true;  	ClearInterrupt (IR.T1);  	break;  case (ushort)Registers.T1_LL:  	_t1Latch = (ushort)((_t1Latch & 0xff00) | value);  	break;  case (ushort)Registers.T1_LH:  	_t1Latch = (ushort)((_t1Latch & 0xff) | (value << 8));  	ClearInterrupt (IR.T1);  	break;  case (ushort)Registers.T2_CL:  	_t2Latch = value;  	ClearInterrupt (IR.T2);  	break;  case (ushort)Registers.T2_CH:  	_t2Counter = (ushort)((value << 8) | _t1Latch);  	_t2Count = true;  	ClearInterrupt (IR.T2);  	break;  case (ushort)Registers.SR:  	break;  case (ushort)Registers.ACR:  	_auxiliaryControlRegister = value;  	_latchPortA = (value & (byte)ACR.PA_L) != 0;  	_latchPortB = (value & (byte)ACR.PB_L) != 0;  	_t1FreeRun = (value & (byte)ACR.T1_FM) != 0;  	_t1OutPB = (value & (byte)ACR.T1_OM) != 0;  	_t2InPB = (value & (byte)ACR.T2_IM) != 0;  	break;  case (ushort)Registers.FCR:  	_functionControlRegister = value;  	if ((value & (byte)FCR.CA2_IO) == (byte)FCR.CA2_IO) {  		_pulseCA2 = (value & (byte)(FCR.CA2_OM | FCR.CA2_OL)) == (byte)FCR.CA2_OL;  		_ca2 = !_pulseCA2 && (value & (byte)(FCR.CA2_OM | FCR.CA2_OL)) == (byte)(FCR.CA2_OM | FCR.CA2_OL);  	}  	if ((value & (byte)FCR.CB2_IO) == (byte)FCR.CB2_IO) {  		_pulseCB2 = (value & (byte)(FCR.CB2_OM | FCR.CB2_OL)) == (byte)FCR.CB2_OL;  		_cb2 = !_pulseCB2 && (value & (byte)(FCR.CB2_OM | FCR.CB2_OL)) == (byte)(FCR.CB2_OM | FCR.CB2_OL);  	}  	break;  case (ushort)Registers.IFR:  	clear = (byte)IR.IRQ;  	ClearInterrupt ((IR)(value & ~clear));  	break;  case (ushort)Registers.IER:  	if ((value & (byte)IR.IRQ) != 0) {  		clear = (byte)IR.IRQ;  		_interruptEnabledRegister |= (byte)(value & ~clear);  	}  	else  		_interruptEnabledRegister &= value;  	byte newInnteruptState = (byte)(_interruptFlagRegister & (_interruptEnabledRegister | (byte)IR.IRQ));  	if (newInnteruptState == (byte)IR.IRQ) {  		clear = (byte)IR.IRQ;  		_interruptFlagRegister &= (byte)~clear;  		_irqLine.Lower ();  	}  	else if (newInnteruptState != 0 && (_interruptFlagRegister & (byte)IR.IRQ) == 0) {  		_interruptFlagRegister |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	break;  case (ushort)Registers.ORA_NH:  	WritePortA (value' false);  	break;  }  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Write,The following statement contains a magic number: switch (address) {  case (ushort)Registers.ORB:  	WritePortB (value);  	break;  case (ushort)Registers.ORA:  	WritePortA (value' true);  	break;  case (ushort)Registers.DDRB:  	_portB.Direction = value;  	break;  case (ushort)Registers.DDRA:  	_portA.Direction = value;  	break;  case (ushort)Registers.T1_CL:  	_t1Latch = (ushort)((_t1Latch & 0xff00) | value);  	break;  case (ushort)Registers.T1_CH:  	_t1Latch = (ushort)((_t1Latch & 0xff) | (value << 8));  	_t1Counter = _t1Latch;  	_t1Count = true;  	ClearInterrupt (IR.T1);  	break;  case (ushort)Registers.T1_LL:  	_t1Latch = (ushort)((_t1Latch & 0xff00) | value);  	break;  case (ushort)Registers.T1_LH:  	_t1Latch = (ushort)((_t1Latch & 0xff) | (value << 8));  	ClearInterrupt (IR.T1);  	break;  case (ushort)Registers.T2_CL:  	_t2Latch = value;  	ClearInterrupt (IR.T2);  	break;  case (ushort)Registers.T2_CH:  	_t2Counter = (ushort)((value << 8) | _t1Latch);  	_t2Count = true;  	ClearInterrupt (IR.T2);  	break;  case (ushort)Registers.SR:  	break;  case (ushort)Registers.ACR:  	_auxiliaryControlRegister = value;  	_latchPortA = (value & (byte)ACR.PA_L) != 0;  	_latchPortB = (value & (byte)ACR.PB_L) != 0;  	_t1FreeRun = (value & (byte)ACR.T1_FM) != 0;  	_t1OutPB = (value & (byte)ACR.T1_OM) != 0;  	_t2InPB = (value & (byte)ACR.T2_IM) != 0;  	break;  case (ushort)Registers.FCR:  	_functionControlRegister = value;  	if ((value & (byte)FCR.CA2_IO) == (byte)FCR.CA2_IO) {  		_pulseCA2 = (value & (byte)(FCR.CA2_OM | FCR.CA2_OL)) == (byte)FCR.CA2_OL;  		_ca2 = !_pulseCA2 && (value & (byte)(FCR.CA2_OM | FCR.CA2_OL)) == (byte)(FCR.CA2_OM | FCR.CA2_OL);  	}  	if ((value & (byte)FCR.CB2_IO) == (byte)FCR.CB2_IO) {  		_pulseCB2 = (value & (byte)(FCR.CB2_OM | FCR.CB2_OL)) == (byte)FCR.CB2_OL;  		_cb2 = !_pulseCB2 && (value & (byte)(FCR.CB2_OM | FCR.CB2_OL)) == (byte)(FCR.CB2_OM | FCR.CB2_OL);  	}  	break;  case (ushort)Registers.IFR:  	clear = (byte)IR.IRQ;  	ClearInterrupt ((IR)(value & ~clear));  	break;  case (ushort)Registers.IER:  	if ((value & (byte)IR.IRQ) != 0) {  		clear = (byte)IR.IRQ;  		_interruptEnabledRegister |= (byte)(value & ~clear);  	}  	else  		_interruptEnabledRegister &= value;  	byte newInnteruptState = (byte)(_interruptFlagRegister & (_interruptEnabledRegister | (byte)IR.IRQ));  	if (newInnteruptState == (byte)IR.IRQ) {  		clear = (byte)IR.IRQ;  		_interruptFlagRegister &= (byte)~clear;  		_irqLine.Lower ();  	}  	else if (newInnteruptState != 0 && (_interruptFlagRegister & (byte)IR.IRQ) == 0) {  		_interruptFlagRegister |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	break;  case (ushort)Registers.ORA_NH:  	WritePortA (value' false);  	break;  }  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Write,The following statement contains a magic number: _t1Latch = (ushort)((_t1Latch & 0xff) | (value << 8));  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Write,The following statement contains a magic number: _t1Latch = (ushort)((_t1Latch & 0xff) | (value << 8));  
Magic Number,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Write,The following statement contains a magic number: _t2Counter = (ushort)((value << 8) | _t1Latch);  
Missing Default,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Read,The following switch statement is missing a default case: switch (address) {  case (ushort)Registers.ORB:  	return ReadPortB ();  case (ushort)Registers.ORA:  	return ReadPortA (true);  case (ushort)Registers.DDRB:  	return _portB.Direction;  case (ushort)Registers.DDRA:  	return _portA.Direction;  case (ushort)Registers.T1_CL:  	ClearInterrupt (IR.T1);  	return (byte)_t1Counter;  case (ushort)Registers.T1_CH:  	return (byte)(_t1Counter >> 8);  case (ushort)Registers.T1_LL:  	return (byte)_t1Latch;  case (ushort)Registers.T1_LH:  	return (byte)(_t1Latch >> 8);  case (ushort)Registers.T2_CL:  	ClearInterrupt (IR.T2);  	return (byte)_t2Counter;  case (ushort)Registers.T2_CH:  	return (byte)(_t2Counter >> 8);  case (ushort)Registers.SR:  	break;  case (ushort)Registers.ACR:  	return _auxiliaryControlRegister;  case (ushort)Registers.FCR:  	return _functionControlRegister;  case (ushort)Registers.IFR:  	return _interruptFlagRegister;  case (ushort)Registers.IER:  	return _interruptEnabledRegister;  case (ushort)Registers.ORA_NH:  	return ReadPortA (false);  }  
Missing Default,DiskDrive,VIA,C:\repos\RonFields72_C64Emulator\c64_1541ii\VIA.cs,Write,The following switch statement is missing a default case: switch (address) {  case (ushort)Registers.ORB:  	WritePortB (value);  	break;  case (ushort)Registers.ORA:  	WritePortA (value' true);  	break;  case (ushort)Registers.DDRB:  	_portB.Direction = value;  	break;  case (ushort)Registers.DDRA:  	_portA.Direction = value;  	break;  case (ushort)Registers.T1_CL:  	_t1Latch = (ushort)((_t1Latch & 0xff00) | value);  	break;  case (ushort)Registers.T1_CH:  	_t1Latch = (ushort)((_t1Latch & 0xff) | (value << 8));  	_t1Counter = _t1Latch;  	_t1Count = true;  	ClearInterrupt (IR.T1);  	break;  case (ushort)Registers.T1_LL:  	_t1Latch = (ushort)((_t1Latch & 0xff00) | value);  	break;  case (ushort)Registers.T1_LH:  	_t1Latch = (ushort)((_t1Latch & 0xff) | (value << 8));  	ClearInterrupt (IR.T1);  	break;  case (ushort)Registers.T2_CL:  	_t2Latch = value;  	ClearInterrupt (IR.T2);  	break;  case (ushort)Registers.T2_CH:  	_t2Counter = (ushort)((value << 8) | _t1Latch);  	_t2Count = true;  	ClearInterrupt (IR.T2);  	break;  case (ushort)Registers.SR:  	break;  case (ushort)Registers.ACR:  	_auxiliaryControlRegister = value;  	_latchPortA = (value & (byte)ACR.PA_L) != 0;  	_latchPortB = (value & (byte)ACR.PB_L) != 0;  	_t1FreeRun = (value & (byte)ACR.T1_FM) != 0;  	_t1OutPB = (value & (byte)ACR.T1_OM) != 0;  	_t2InPB = (value & (byte)ACR.T2_IM) != 0;  	break;  case (ushort)Registers.FCR:  	_functionControlRegister = value;  	if ((value & (byte)FCR.CA2_IO) == (byte)FCR.CA2_IO) {  		_pulseCA2 = (value & (byte)(FCR.CA2_OM | FCR.CA2_OL)) == (byte)FCR.CA2_OL;  		_ca2 = !_pulseCA2 && (value & (byte)(FCR.CA2_OM | FCR.CA2_OL)) == (byte)(FCR.CA2_OM | FCR.CA2_OL);  	}  	if ((value & (byte)FCR.CB2_IO) == (byte)FCR.CB2_IO) {  		_pulseCB2 = (value & (byte)(FCR.CB2_OM | FCR.CB2_OL)) == (byte)FCR.CB2_OL;  		_cb2 = !_pulseCB2 && (value & (byte)(FCR.CB2_OM | FCR.CB2_OL)) == (byte)(FCR.CB2_OM | FCR.CB2_OL);  	}  	break;  case (ushort)Registers.IFR:  	clear = (byte)IR.IRQ;  	ClearInterrupt ((IR)(value & ~clear));  	break;  case (ushort)Registers.IER:  	if ((value & (byte)IR.IRQ) != 0) {  		clear = (byte)IR.IRQ;  		_interruptEnabledRegister |= (byte)(value & ~clear);  	}  	else  		_interruptEnabledRegister &= value;  	byte newInnteruptState = (byte)(_interruptFlagRegister & (_interruptEnabledRegister | (byte)IR.IRQ));  	if (newInnteruptState == (byte)IR.IRQ) {  		clear = (byte)IR.IRQ;  		_interruptFlagRegister &= (byte)~clear;  		_irqLine.Lower ();  	}  	else if (newInnteruptState != 0 && (_interruptFlagRegister & (byte)IR.IRQ) == 0) {  		_interruptFlagRegister |= (byte)IR.IRQ;  		_irqLine.Raise ();  	}  	break;  case (ushort)Registers.ORA_NH:  	WritePortA (value' false);  	break;  }  
