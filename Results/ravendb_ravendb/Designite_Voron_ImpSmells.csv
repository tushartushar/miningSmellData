Implementation smell,Namespace,Class,File,Method,Description
Long Method,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,DirectAdd,The method has 102 lines of code.
Long Method,Voron.Data.BTrees,TreePageSplitter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePageSplitter.cs,SplitPageInHalf,The method has 124 lines of code.
Long Method,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RebalancePage,The method has 153 lines of code.
Long Method,Voron.Impl.Backup,FullBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\FullBackup.cs,Backup,The method has 121 lines of code.
Long Method,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,Incremental_Backup,The method has 104 lines of code.
Long Method,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The method has 119 lines of code.
Long Method,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionToDataFile,The method has 112 lines of code.
Long Method,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The method has 142 lines of code.
Long Method,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The method has 124 lines of code.
Complex Method,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,DirectAdd,Cyclomatic complexity of the method is 11
Complex Method,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,SearchForPage,Cyclomatic complexity of the method is 9
Complex Method,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,MultiAdd,Cyclomatic complexity of the method is 13
Complex Method,Voron.Data.BTrees,TreeIterator,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeIterator.cs,MovePrev,Cyclomatic complexity of the method is 9
Complex Method,Voron.Data.BTrees,TreeIterator,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeIterator.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,Voron.Data.BTrees,TreePage,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePage.cs,Search,Cyclomatic complexity of the method is 10
Complex Method,Voron.Impl,Transaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Transaction.cs,PrepareForCommit,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl,Transaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Transaction.cs,DeleteTree,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl,Transaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Transaction.cs,Dispose,Cyclomatic complexity of the method is 9
Complex Method,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,ValidateTree_Forced,Cyclomatic complexity of the method is 9
Complex Method,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,DeleteRangeLarge,Cyclomatic complexity of the method is 13
Complex Method,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RemoveRangeFromPage,Cyclomatic complexity of the method is 10
Complex Method,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RebalancePage,Cyclomatic complexity of the method is 10
Complex Method,Voron.Data.Fixed,LargeIterator,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,MovePrev,Cyclomatic complexity of the method is 8
Complex Method,Voron.Data.Fixed,LargeIterator,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,MoveNext,Cyclomatic complexity of the method is 9
Complex Method,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,TryAllocate,Cyclomatic complexity of the method is 8
Complex Method,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,Delete,Cyclomatic complexity of the method is 9
Complex Method,Voron.Data.Tables,TableSchema,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableSchema.cs,Validate,Cyclomatic complexity of the method is 9
Complex Method,Voron,GlobalFlushingBehavior,C:\repos\ravendb_ravendb\src\Voron\GlobalFlushingBehavior.cs,FlushEnvironments,Cyclomatic complexity of the method is 8
Complex Method,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,IsStorageSupportingO_Direct,Cyclomatic complexity of the method is 9
Complex Method,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,TransactionCompleted,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl.FileHeaders,HeaderAccessor,C:\repos\ravendb_ravendb\src\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,Cyclomatic complexity of the method is 11
Complex Method,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionToDataFile,Cyclomatic complexity of the method is 15
Complex Method,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,TryReadAndValidateHeader,Cyclomatic complexity of the method is 12
Complex Method,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,Cyclomatic complexity of the method is 9
Complex Method,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,Cyclomatic complexity of the method is 10
Complex Method,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,Cyclomatic complexity of the method is 20
Complex Method,Voron.Impl.Journal,SyncOperation,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,TryGatherInformationToStartSync,Cyclomatic complexity of the method is 10
Complex Method,Voron.Impl.Scratch,ScratchBufferPool,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferPool.cs,Free,Cyclomatic complexity of the method is 8
Complex Method,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,WindowsMemoryMapPager,Cyclomatic complexity of the method is 8
Complex Method,Voron.Util,PtrSize,C:\repos\ravendb_ravendb\src\Voron\Util\PtrSize.cs,Create,Cyclomatic complexity of the method is 12
Long Parameter List,Voron.Data.BTrees,ParentPageAction,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\ParentPageAction.cs,ParentPageAction,The method has 5 parameters. Parameters: parentPage' currentPage' tree' cursor' tx
Long Parameter List,Voron.Data.BTrees,FoundTreePage,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\RecentlyFoundTreePages.cs,FoundTreePage,The method has 7 parameters. Parameters: number' page' firstKey' lastKey' cursorPath' firstScope' lastScope
Long Parameter List,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,Tree,The method has 6 parameters. Parameters: llt' tx' root' name' isIndexTree' newPageAllocator
Long Parameter List,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,Open,The method has 7 parameters. Parameters: llt' tx' name' header' type' isIndexTree' newPageAllocator
Long Parameter List,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,Create,The method has 7 parameters. Parameters: llt' tx' name' flags' type' isIndexTree' newPageAllocator
Long Parameter List,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,SearchForPage,The method has 5 parameters. Parameters: key' allowCompressed' cursorConstructor' node' addToRecentlyFoundPages
Long Parameter List,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,ExpandMultiTreeNestedPageSize,The method has 5 parameters. Parameters: key' value' nestedPagePtr' newSize' currentSize
Long Parameter List,Voron.Data.BTrees,TreeCursorConstructor,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeCursorHandler.cs,TreeCursorConstructor,The method has 5 parameters. Parameters: llt' tree' pageCopy' cursorPath' lastFoundPageNumber
Long Parameter List,Voron.Data.BTrees,TreePageSplitter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePageSplitter.cs,TreePageSplitter,The method has 7 parameters. Parameters: tx' tree' newKey' len' pageNumber' nodeType' cursor
Long Parameter List,Voron.Data.BTrees,TreePageSplitter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePageSplitter.cs,GatherDetailedDebugInfo,The method has 6 parameters. Parameters: rightPage' currentKey' seperatorKey' currentIndex' splitIndex' toRight
Long Parameter List,Voron.Data.BTrees,TreeRebalancer,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeRebalancer.cs,AddSeparatorToParentPage,The method has 5 parameters. Parameters: childPage' parentPage' pageNumber' seperatorKey' separatorKeyPosition
Long Parameter List,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,LowLevelTransaction,The method has 6 parameters. Parameters: env' id' transactionPersistentContext' flags' freeSpaceHandling' context
Long Parameter List,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,AllocateOverflowRawPage,The method has 5 parameters. Parameters: overflowSize' numberOfPages' pageNumber' previousPage' zeroPage
Long Parameter List,Voron.Impl,PagePosition,C:\repos\ravendb_ravendb\src\Voron\Impl\PagePosition.cs,PagePosition,The method has 5 parameters. Parameters: scratchPos' transactionId' journalNumber' scratchNumber' isFreedPageMarker
Long Parameter List,Voron.Impl,Transaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Transaction.cs,CreateTree,The method has 5 parameters. Parameters: name' type' flags' isIndexTree' newPageAllocator
Long Parameter List,Voron.Impl,Transaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Transaction.cs,CreateTree,The method has 5 parameters. Parameters: name' type' flags' isIndexTree' newPageAllocator
Long Parameter List,Voron.Data.Compression,DecompressedLeafPage,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressedLeafPage.cs,DecompressedLeafPage,The method has 5 parameters. Parameters: basePtr' pageSize' usage' original' tempPage
Long Parameter List,Voron.Data.Compression,DecompressionBuffer,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressionBuffersPool.cs,DecompressionBuffer,The method has 6 parameters. Parameters: pager' position' size' pool' index' tx
Long Parameter List,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,FixedSizeTree,The method has 7 parameters. Parameters: tx' parent' treeName' valSize' clone' isIndexTree' newPageAllocator
Long Parameter List,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,CopyEmbeddedContentToTempPage,The method has 5 parameters. Parameters: key' tmp' isNew' newSize' srcCopyStart
Long Parameter List,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,Table,The method has 6 parameters. Parameters: schema' name' tx' tableTree' tableType' doSchemaValidation
Long Parameter List,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,DeleteForwardFrom,The method has 5 parameters. Parameters: index' value' startsWith' numberOfEntriesToDelete' beforeDelete
Long Parameter List,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,DeleteForwardFrom,The method has 5 parameters. Parameters: index' value' startsWith' numberOfEntriesToDelete' beforeDelete
Long Parameter List,Voron.Debugging,DebugStuff,C:\repos\ravendb_ravendb\src\Voron\Debugging\DebugStuff.cs,RenderFixedSizeTreePage,The method has 6 parameters. Parameters: tx' page' sw' header' text' open
Long Parameter List,Voron.Debugging,DebugStuff,C:\repos\ravendb_ravendb\src\Voron\Debugging\DebugStuff.cs,RenderPage,The method has 5 parameters. Parameters: tree' page' sw' text' open
Long Parameter List,Voron,Slice,C:\repos\ravendb_ravendb\src\Voron\Slice.cs,From,The method has 6 parameters. Parameters: context' value' offset' count' type' str
Long Parameter List,Voron,Slice,C:\repos\ravendb_ravendb\src\Voron\Slice.cs,From,The method has 5 parameters. Parameters: context' value' size' type' str
Long Parameter List,Voron,Slice,C:\repos\ravendb_ravendb\src\Voron\Slice.cs,External,The method has 5 parameters. Parameters: context' value' offset' size' slice
Long Parameter List,Voron,Slice,C:\repos\ravendb_ravendb\src\Voron\Slice.cs,External,The method has 5 parameters. Parameters: context' value' size' type' slice
Long Parameter List,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,UnlikelyValidatePage,The method has 5 parameters. Parameters: pageNumber' current' index' old' bitToSet
Long Parameter List,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,ForPath,The method has 5 parameters. Parameters: path' tempPath' journalPath' ioChangesNotifications' catastrophicFailureNotification
Long Parameter List,Voron,DirectoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,DirectoryStorageEnvironmentOptions,The method has 5 parameters. Parameters: basePath' tempPath' journalPath' ioChangesNotifications' catastrophicFailureNotification
Long Parameter List,Voron,DirectoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,GetMemoryMapPager,The method has 5 parameters. Parameters: options' initialSize' file' deleteOnClose' usePageProtection
Long Parameter List,Voron,DirectoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,GetMemoryMapPagerInternal,The method has 5 parameters. Parameters: options' initialSize' file' deleteOnClose' usePageProtection
Long Parameter List,Voron.Impl.Backup,FullBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\FullBackup.cs,ToFile,The method has 5 parameters. Parameters: env' backupPath' compression' infoNotify' backupStarted
Long Parameter List,Voron.Impl.Backup,FullBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\FullBackup.cs,ToFile,The method has 5 parameters. Parameters: envs' package' compression' infoNotify' backupStarted
Long Parameter List,Voron.Impl.Backup,FullBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\FullBackup.cs,Backup,The method has 8 parameters. Parameters: env' compression' infoNotify' backupStarted' dataPager' package' basePath' copier
Long Parameter List,Voron.Impl.Backup,FullBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\FullBackup.cs,Restore,The method has 7 parameters. Parameters: backupPath' voronDataDir' journalDir' settingsKey' onSettings' onProgress' cancellationToken
Long Parameter List,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,The method has 5 parameters. Parameters: env' backupPath' compression' infoNotify' backupStarted
Long Parameter List,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,The method has 5 parameters. Parameters: envs' backupPath' compression' infoNotify' backupStarted
Long Parameter List,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,Incremental_Backup,The method has 7 parameters. Parameters: env' compression' infoNotify' backupStarted' package' basePath' copier
Long Parameter List,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,Restore,The method has 5 parameters. Parameters: env' entries' tempDir' toDispose' txw
Long Parameter List,Voron.Impl.Backup,VoronBackupUtil,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\VoronBackupUtil.cs,CopyHeaders,The method has 5 parameters. Parameters: compression' package' copier' storageEnvironmentOptions' basePath
Long Parameter List,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyFixedSizeTrees,The method has 9 parameters. Parameters: compactedEnv' progressReport' txr' rootIterator' treeName' copiedTrees' totalTreesCount' context' token
Long Parameter List,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyVariableSizeTree,The method has 8 parameters. Parameters: compactedEnv' progressReport' txr' treeName' copiedTrees' totalTreesCount' context' token
Long Parameter List,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The method has 8 parameters. Parameters: compactedEnv' progressReport' txr' treeName' copiedTrees' totalTreesCount' context' token
Long Parameter List,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,Report,The method has 7 parameters. Parameters: globalProgress' globalTotal' objectProgress' objectTotal' progressReport' message' treeName
Long Parameter List,Voron.Impl.FreeSpace,FreeSpaceHandling,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\FreeSpaceHandling.cs,TryFindContinuousRange,The method has 7 parameters. Parameters: tx' freeSpaceTree' it' num' current' currentSectionId' page
Long Parameter List,Voron.Impl.FreeSpace,FreeSpaceHandling,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\FreeSpaceHandling.cs,TryFindSmallValueMergingTwoSections,The method has 6 parameters. Parameters: tx' freeSpacetree' currentSectionId' num' current' result
Long Parameter List,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,JournalReader,The method has 5 parameters. Parameters: journalPager' dataPager' recoveryPager' lastSyncedTransactionId' previous
Long Parameter List,Voron.Impl.Paging,Windows32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,Windows32BitsMemoryMapPager,The method has 6 parameters. Parameters: options' file' initialFileSize' fileAttributes' access' usePageProtection
Long Parameter List,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,Win32FileJournalWriter,The method has 5 parameters. Parameters: options' filename' journalSize' access' shareMode
Long Parameter List,Voron.Platform.Win32,Win32NativeFileMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,WriteFileGather,The method has 5 parameters. Parameters: hFile' aSegmentArray' nNumberOfBytesToWrite' lpReserved' lpOverlapped
Long Parameter List,Voron.Platform.Win32,Win32NativeFileMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,WriteFileEx,The method has 5 parameters. Parameters: hFile' lpBuffer' nNumberOfBytesToWrite' lpOverlapped' lpCompletionRoutine
Long Parameter List,Voron.Platform.Win32,Win32NativeFileMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,WriteFile,The method has 5 parameters. Parameters: hFile' lpBuffer' nNumberOfBytesToWrite' lpNumberOfBytesWritten' lpOverlapped
Long Parameter List,Voron.Platform.Win32,Win32NativeFileMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,WriteFile,The method has 5 parameters. Parameters: hFile' lpBuffer' nNumberOfBytesToWrite' lpNumberOfBytesWritten' lpOverlapped
Long Parameter List,Voron.Platform.Win32,Win32NativeFileMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,ReadFile,The method has 5 parameters. Parameters: hFile' pBuffer' numBytesToRead' pNumberOfBytesRead' lpOverlapped
Long Parameter List,Voron.Platform.Win32,Win32NativeFileMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,Voron.Platform.Win32,Win32MemoryMapNativeMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,CreateFileMapping,The method has 6 parameters. Parameters: hFile' lpFileMappingAttributes' flProtect' dwMaximumSizeHigh' dwMaximumSizeLow' lpName
Long Parameter List,Voron.Platform.Win32,Win32MemoryMapNativeMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,MapViewOfFileEx,The method has 6 parameters. Parameters: hFileMappingObject' dwDesiredAccess' dwFileOffsetHigh' dwFileOffsetLow' dwNumberOfBytesToMap' lpBaseAddress
Long Parameter List,Voron.Platform.Win32,Win32NativeMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,DeviceIoControl,The method has 8 parameters. Parameters: hDevice' IoControlCode' InMediaRemoval' InBufferSize' OutBuffer' OutBufferSize' BytesReturned' Overlapped
Long Parameter List,Voron.Platform.Win32,Win32NativeMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,CreateFile,The method has 7 parameters. Parameters: FileName' DesiredAccess' ShareMode' lpSecurityAttributes' CreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,WindowsMemoryMapPager,The method has 6 parameters. Parameters: options' file' initialFileSize' fileAttributes' access' usePageProtection
Long Parameter List,Voron.Util,DataCopier,C:\repos\ravendb_ravendb\src\Voron\Util\DataCopier.cs,ToStream,The method has 5 parameters. Parameters: env' journal' start4Kb' numberOf4KbsToCopy' output
Long Identifier,Voron.Global,Constants,C:\repos\ravendb_ravendb\src\Voron\Constants.cs,,The length of the parameter DatabaseRecordFileNameInBackup is 30.
Long Identifier,Voron.Global,Constants,C:\repos\ravendb_ravendb\src\Voron\Constants.cs,,The length of the parameter DefaultMaxLogLengthBeforeCompaction is 35.
Long Identifier,Voron.Data.BTrees,ParentPageAction,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\ParentPageAction.cs,AddSeparator,The length of the parameter originalLastSearchPositionOfParent is 34.
Long Identifier,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,,The length of the parameter AlreadyAllowedDisposeWithLazyTransactionRunning is 47.
Long Identifier,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,,The length of the parameter LocalPossibleOldestReadTransaction is 34.
Long Identifier,Voron.Data.Compression,DecompressionBuffersPool,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressionBuffersPool.cs,,The length of the parameter _maxNumberOfPagesInScratchBufferPool is 36.
Long Identifier,Voron.Data.Compression,LeafPageCompressor,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\LeafPageCompressor.cs,TryGetCompressedTempPage,The length of the parameter sizeLeftForUncompressedEntries is 30.
Long Identifier,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RebalancePage,The length of the parameter minNumberOfEntriesBeforeRebalance is 33.
Long Identifier,Voron,GlobalFlushingBehavior,C:\repos\ravendb_ravendb\src\Voron\GlobalFlushingBehavior.cs,FlushEnvironments,The length of the parameter sizeOfUnflushedTransactionsInJournalFile is 40.
Long Identifier,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,,The length of the parameter SizeOfUnflushedTransactionsInJournalFile is 40.
Long Identifier,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,,The length of the parameter NumOfConcurrentSyncsPerPhysDrive is 32.
Long Identifier,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The length of the parameter catastrophicFailureNotification is 31.
Long Identifier,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,CreateMemoryOnly,The length of the parameter catastrophicFailureNotification is 31.
Long Identifier,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,ForPath,The length of the parameter catastrophicFailureNotification is 31.
Long Identifier,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,,The length of the parameter RecyclableJournalFileNamePrefix is 31.
Long Identifier,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,,The length of the parameter _catastrophicFailureNotification is 32.
Long Identifier,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,,The length of the parameter _numOfConcurrentSyncsPerPhysDrive is 33.
Long Identifier,Voron,DirectoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,DirectoryStorageEnvironmentOptions,The length of the parameter catastrophicFailureNotification is 31.
Long Identifier,Voron,PureMemoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,PureMemoryStorageEnvironmentOptions,The length of the parameter catastrophicFailureNotification is 31.
Long Identifier,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTrees,The length of the parameter globalTableIndexesToSkipCopying is 31.
Long Identifier,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,,The length of the parameter CannotCompactBecauseOfIncrementalBackup is 39.
Long Identifier,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,,The length of the parameter _journalPagerNumberOfAllocated4Kb is 33.
Long Identifier,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The length of the parameter pagesCountIncludingAllOverflowPages is 35.
Long Identifier,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ShouldReduceSizeOfCompressionPager,The length of the parameter shouldReduceSizeOfCompressionPager is 34.
Long Identifier,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,,The length of the parameter _maxNumberOfPagesRequiredForCompressionBuffer is 45.
Long Identifier,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,,The length of the parameter CurrentFlushingInProgressHolder is 31.
Long Identifier,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,,The length of the parameter _lastCompressionBufferReduceCheck is 33.
Long Identifier,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,,The length of the parameter _lastCompressionAccelerationInfo is 32.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The length of the parameter previousJournalMaxTransactionId is 31.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The length of the parameter currentJournalMaxTransactionId is 30.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ThrowReadByeondOldestActiveTransaction,The length of the parameter currentJournalMaxTransactionId is 30.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ThrowReadByeondOldestActiveTransaction,The length of the parameter previousJournalMaxTransactionId is 31.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,,The length of the parameter _waitForJournalStateUpdateUnderTx is 33.
Long Identifier,Voron.Impl.Paging,Windows32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,,The length of the parameter NumberOfPagesInAllocationGranularity is 36.
Long Identifier,Voron.Impl.Scratch,ScratchBufferFile,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferFile.cs,,The length of the parameter _freePagesBySizeAvailableImmediately is 36.
Long Identifier,Voron.Impl.Scratch,ScratchBufferFile,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferFile.cs,,The length of the parameter _txIdAfterWhichLatestFreePagesBecomeAvailable is 45.
Long Identifier,Voron.Impl.Scratch,ScratchBufferPool,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferPool.cs,Cleanup,The length of the parameter txIdAllowingToReleaseOldScratches is 33.
Long Identifier,Voron.Platform.Posix,Posix32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,,The length of the parameter NumberOfPagesInAllocationGranularity is 36.
Long Identifier,Voron.Util,EndOfDiskSpaceEvent,C:\repos\ravendb_ravendb\src\Voron\Util\EndOfDiskSpaceEvent.cs,,The length of the parameter _availableSpaceWhenEventOccurred is 32.
Long Statement,Voron.Data.BTrees,ParentPageAction,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\ParentPageAction.cs,AddSeparator,The length of the statement  "                    // the above page split has modified the cursor that its first page points to the parent of the leaf where 'separatorKey' was inserted " is 134.
Long Statement,Voron.Data.BTrees,ParentPageAction,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\ParentPageAction.cs,AddSeparator,The length of the statement  "                Debug.Assert(_cursor.CurrentPage.GetNode(_cursor.CurrentPage.LastSearchPosition)->PageNumber == _currentPage.PageNumber'  " is 120.
Long Statement,Voron.Data.BTrees,ParentPageAction,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\ParentPageAction.cs,AddSeparator,The length of the statement  "                Debug.Assert(Enumerable.Range(0' parentToValidate.NumberOfEntries).Any(i => parentToValidate.GetNode(i)->PageNumber == pageRefNumber)' " is 134.
Long Statement,Voron.Data.BTrees,ParentPageAction,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\ParentPageAction.cs,EnsureValidLastSearchPosition,The length of the statement  "            if (page.NumberOfEntries <= originalLastSearchPosition || page.GetNode(originalLastSearchPosition)->PageNumber != referencedPageNumber) " is 135.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,TryCompressPageNodes,The length of the statement  "                pageToCompress = DecompressPage(page' usage: DecompressionUsage.Write); // no need to dispose' it's going to be cached anyway " is 125.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,TryCompressPageNodes,The length of the statement  "            using (LeafPageCompressor.TryGetCompressedTempPage(_llt' pageToCompress' out result' defrag: alreadyCompressed == false)) " is 121.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,TryCompressPageNodes,The length of the statement  "                    // since we put compressed entries at the beginning of that page (temporarily) then props like NumberOfEntries and KeysOffsets " is 126.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,DirectAdd,The length of the statement  "            var foundPage = FindPageFor(key' node: out TreeNodeHeader* node' cursor: out TreeCursorConstructor cursorConstructor' allowCompressed: true); " is 141.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,ThrowInvalidKeySize,The length of the statement  "                $"Key size is too big' must be at most {AbstractPager.MaxKeySize} bytes' but was {(key.Size + AbstractPager.RequiredSpaceForNewNode)}"' " is 135.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,ThrowOnCompressedPage,The length of the statement  "            throw new PageCompressedException($"Page {p} is compressed. You need to decompress it to be able to access its content."); " is 122.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,AddToRecentlyFoundPages,The length of the statement  "            var foundPage = new RecentlyFoundTreePages.FoundTreePage(p.PageNumber' p' firstKey' lastKey' c.ToArray()' firstScope' lastScope); " is 129.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,AddToRecentlyFoundPages,The length of the statement  "            var foundPage = new RecentlyFoundTreePages.FoundTreePage(p.PageNumber' p' firstKey' lastKey' cursorPath' firstScope' lastScope); " is 128.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,ThrowAttemptToFreeIndexPageToFreeSpaceHandling,The length of the statement  "            throw new InvalidOperationException($"Attempting to free page #{pageNumber} of '{treeName}' index tree to the free space handling. The page was allocated by {nameof(NewPageAllocator)} so it needs to be returned there."); " is 220.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,ThrowAttemptToFreePageToNewPageAllocator,The length of the statement  "            throw new InvalidOperationException($"Attempting to free page #{pageNumber} of '{treeName}' tree to {nameof(NewPageAllocator)} while it wasn't allocated by it"); " is 161.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,GetParentPageOf,The length of the statement  "                            $"Could not find a page containing {key} when looking for a parent of {page}. Page {p} was found' last match: {p.LastMatch}."); " is 127.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,MultiAdd,The length of the statement  "                throw new ArgumentException("Cannot add a value to child tree that is over " + maxNodeSize + " bytes in size"' nameof(value)); " is 126.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,MultiAdd,The length of the statement  "                    // ... and it won't require to create an overflow' so we can just expand the current value' no need to create a nested tree yet " is 127.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,MultiAddOnNewValue,The length of the statement  "            var actualPageSize = (ushort)Math.Min(Bits.NextPowerOf2(requiredPageSize)' maxNodeSize - Constants.Tree.NodeHeaderSize); " is 120.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,MultiCount,The length of the statement  "                    VoronUnrecoverableErrorException.Raise(_llt.Environment' "Was unable to retrieve the correct node. Data corruption possible"); " is 126.
Long Statement,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,MultiRead,The length of the statement  "                    VoronUnrecoverableErrorException.Raise(_llt.Environment' "Was unable to retrieve the correct node. Data corruption possible"); " is 126.
Long Statement,Voron.Data.BTrees,TreeIterator,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeIterator.cs,Seek,The length of the statement  "            _currentPage = _tree.FindPageFor(key' node: out node' cursor: out constructor' allowCompressed: _tree.IsLeafCompressionSupported); " is 130.
Long Statement,Voron.Data.BTrees,TreeNodeHeader,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeNodeHeader.cs,ToSlice,The length of the statement  "            var scope = context.From((byte*)node + Constants.Tree.NodeHeaderSize' node->KeySize' type | (ByteStringType) SliceOptions.Key' out byteString); " is 143.
Long Statement,Voron.Data.BTrees,TreeNodeHeader,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeNodeHeader.cs,ToSlicePtr,The length of the statement  "            var scope = context.FromPtr((byte*)node + Constants.Tree.NodeHeaderSize' node->KeySize' ByteStringType.Mutable | (ByteStringType)SliceOptions.Key' out str); " is 156.
Long Statement,Voron.Data.BTrees,TreeNodeHeader,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeNodeHeader.cs,GetData,The length of the statement  "                return Slice.External(tx.Allocator' overFlowPage.Pointer + Constants.Tree.PageHeaderSize' (ushort)overFlowPage.OverflowSize' out slice); " is 136.
Long Statement,Voron.Data.BTrees,TreeNodeHeader,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeNodeHeader.cs,GetData,The length of the statement  "            return Slice.External(tx.Allocator' (byte*)node + node->KeySize + Constants.Tree.NodeHeaderSize' (ushort) node->DataSize' out slice); " is 133.
Long Statement,Voron.Data.BTrees,TreePage,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePage.cs,ThrowNotSupportedException,The length of the statement  "            throw new NotSupportedException("This SliceOptions is not supported. Make sure you have updated this code when adding a new one."); " is 131.
Long Statement,Voron.Data.BTrees,TreePage,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePage.cs,CreateNode,The length of the statement  "                throw new InvalidOperationException(string.Format("The page is full and cannot add an entry' this is probably a bug. Key: {0}' data length: {1}' size left: {2}"' key' len' SizeLeft)); " is 183.
Long Statement,Voron.Data.BTrees,TreePage,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePage.cs,ToString,The length of the statement  "                result += $" Compressed ({CompressionHeader->NumberOfCompressedEntries} entries [uncompressed/compressed: {CompressionHeader->UncompressedSize}/{CompressionHeader->CompressedSize}]"; " is 182.
Long Statement,Voron.Data.BTrees,TreePageSplitter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePageSplitter.cs,SplitPageInHalf,The length of the statement  "                    rightDecompressed = _tx.Environment.DecompressionBuffers.GetPage(_tx' _pageDecompressed.PageSize' DecompressionUsage.Write' rightPage); " is 135.
Long Statement,Voron.Data.BTrees,TreePageSplitter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePageSplitter.cs,SplitPageInHalf,The length of the statement  "                        // _newKey needs to be inserted as first key (BeforeAllKeys) to the right page' so we need to add it before we move entries from the current page " is 145.
Long Statement,Voron.Data.BTrees,TreePageSplitter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePageSplitter.cs,GatherDetailedDebugInfo,The length of the statement  "            debugInfo.AppendFormat("_newKey: {0}' _len: {1}' needed space: {2}\r\n"' _newKey' _len' _page.GetRequiredSpace(_newKey' _len)); " is 127.
Long Statement,Voron.Data.BTrees,TreePageSplitter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePageSplitter.cs,GatherDetailedDebugInfo,The length of the statement  "            debugInfo.AppendFormat("_page info: flags - {0}' # of entries {1}' size left: {2}' calculated size left: {3}\r\n"' _page.TreeFlags' _page.NumberOfEntries' _page.SizeLeft' _page.CalcSizeLeft()); " is 193.
Long Statement,Voron.Data.BTrees,TreePageSplitter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePageSplitter.cs,GatherDetailedDebugInfo,The length of the statement  "            debugInfo.AppendFormat("rightPage info: flags - {0}' # of entries {1}' size left: {2}' calculated size left: {3}\r\n"' rightPage.TreeFlags' rightPage.NumberOfEntries' rightPage.SizeLeft' rightPage.CalcSizeLeft()); " is 213.
Long Statement,Voron.Data.BTrees,TreeRebalancer,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeRebalancer.cs,TryMergePages,The length of the statement  "                        if (mergedPage.HasSpaceFor(_tx' TreeSizeOf.NodeEntryWithAnotherKey(node' key) + Constants.Tree.NodeOffsetSize) == false) " is 120.
Long Statement,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,ModifyPageInternal,The length of the statement  "                newPage = AllocateOverflowRawPage(currentPage.OverflowSize' out numberOfAllocatedPages' num' currentPage' zeroPage: false); " is 123.
Long Statement,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,ModifyPageInternal,The length of the statement  "                newPage = AllocatePage(1' num' currentPage' zeroPage: false); // allocate new page in a log file but with the same number			 " is 121.
Long Statement,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,GetPageInternal,The length of the statement  "            if (_scratchPagesTable != null && _scratchPagesTable.TryGetValue(pageNumber' out value)) // Scratch Pages Table will be null in read transactions " is 145.
Long Statement,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,GetPageInternal,The length of the statement  "                Debug.Assert(p.PageNumber == pageNumber' string.Format("Requested ReadOnly page #{0}. Got #{1} from scratch"' pageNumber' p.PageNumber)); " is 137.
Long Statement,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,GetPageInternal,The length of the statement  "                    Debug.Assert(p.PageNumber == pageNumber' string.Format("Requested ReadOnly page #{0}. Got #{1} from journal"' pageNumber' p.PageNumber)); " is 137.
Long Statement,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,GetPageInternal,The length of the statement  "                    Debug.Assert(p.PageNumber == pageNumber' string.Format("Requested ReadOnly page #{0}. Got #{1} from data file"' pageNumber' p.PageNumber)); " is 139.
Long Statement,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,ThrowQuotaExceededException,The length of the statement  "                    "Currently configured storage quota is allowing to allocate the following maximum page number {1}' while the requested page number is {2}. " + " is 142.
Long Statement,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,BreakLargeAllocationToSeparatePages,The length of the statement  "                var pageFromScratchBuffer = new PageFromScratchBuffer(value.ScratchFileNumber' value.PositionInScratchBuffer + i' 1' 1); " is 120.
Long Statement,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,EnsurePagerStateReference,The length of the statement  "            state = state.CurrentPager.GetPagerStateAndAddRefAtomically(); // state might hold released pagerState' and we want to add ref to the current (i.e. data file was re-allocated and a new state is now available). RavenDB-6950 " is 222.
Long Statement,Voron.Impl,PagePositionEqualityComparer,C:\repos\ravendb_ravendb\src\Voron\Impl\PagePosition.cs,Equals,The length of the statement  "            return x.ScratchPage == y.ScratchPage && x.TransactionId == y.TransactionId && x.JournalNumber == y.JournalNumber && x.IsFreedPageMarker == y.IsFreedPageMarker && x.ScratchNumber == y.ScratchNumber; " is 198.
Long Statement,Voron.Impl,PagePosition,C:\repos\ravendb_ravendb\src\Voron\Impl\PagePosition.cs,ToString,The length of the statement  "            return $"ScratchPos: {ScratchPage}' TransactionId: {TransactionId}' JournalNumber: {JournalNumber}' ScratchNumber: {ScratchNumber}' IsFreedPageMarker: {IsFreedPageMarker}"; " is 172.
Long Statement,Voron.Impl,AllocationInfo,C:\repos\ravendb_ravendb\src\Voron\Impl\PagerState.cs,ToString,The length of the statement  "                return $"{nameof(BaseAddress)}: {new IntPtr(BaseAddress).ToString("x")} - {new IntPtr(BaseAddress + Size).ToString("x")} {nameof(Size)}: {Size}"; " is 145.
Long Statement,Voron.Data.Compression,DecompressedLeafPage,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressedLeafPage.cs,ThrowCouldNotCompressDecompressedPage,The length of the statement  "            throw new InvalidOperationException($"Decompressed page #{pageNumber} could not be compressed back. Should never happen"); " is 122.
Long Statement,Voron.Data.Compression,DecompressedPagesCache,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressedPagesCache.cs,TryFindPageForReading,The length of the statement  "                if (page == null || page.Usage != DecompressionUsage.Read || page.NumberOfEntries == 0) // decompressed page can has 0 entries if each compressed entry had a tombstone marker " is 174.
Long Statement,Voron.Data.Compression,DecompressionBuffersPool,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressionBuffersPool.cs,ThrowPageSizeTooBig,The length of the statement  "            throw new ArgumentException($"Max page size is {Constants.Compression.MaxPageSize} while you requested {pageSize} bytes"); " is 122.
Long Statement,Voron.Data.Compression,LeafPageCompressor,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\LeafPageCompressor.cs,TryGetCompressedTempPage,The length of the statement  "            var compressionResult = tempPage.Base + Constants.Tree.PageHeaderSize + Constants.Compression.HeaderSize; // temp compression result has compressed values at the beginning of the page " is 183.
Long Statement,Voron.Data.Compression,LeafPageCompressor,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\LeafPageCompressor.cs,TryGetCompressedTempPage,The length of the statement  "            var sizeLeftForUncompressedEntries = Constants.Storage.PageSize - (Constants.Tree.PageHeaderSize + Constants.Compression.HeaderSize + compressionSectionSize); " is 158.
Long Statement,Voron.Data.Compression,LeafPageCompressor,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\LeafPageCompressor.cs,CopyToPage,The length of the statement  "            Memory.Copy(writePtr' compressed.CompressionOutputPtr' compressed.Header.CompressedSize + header->NumberOfCompressedEntries * Constants.Tree.NodeOffsetSize); " is 157.
Long Statement,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,GetValueSize,The length of the statement  "                    throw new ArgumentOutOfRangeException("Tried to open '" + treeName + "' as FixedSizeTree' but is actually " + header->RootObjectType); " is 134.
Long Statement,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,ValidateTree_Forced,The length of the statement  "                throw new InvalidOperationException($"Expected number of entries {header->NumberOfEntries}' actual {numberOfEntriesInTree}"); " is 125.
Long Statement,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,BinarySearch,The length of the statement  "            page.LastSearchPosition = BinarySearch(page.Pointer + page.StartPosition' page.NumberOfEntries' val' page.IsLeaf ? _entrySize : BranchEntrySize); " is 145.
Long Statement,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,DeleteRangeEmbedded,The length of the statement  "                Memory.Copy(newData + srcCopyStart' ptr + srcCopyStart + (_entrySize * entriesDeleted)' (header->NumberOfEntries - endPos) * _entrySize); " is 137.
Long Statement,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RemoveEmbeddedEntry,The length of the statement  "                Memory.Copy(tmp.TempPagePointer + srcCopyStart' ptr + srcCopyStart + _entrySize' (header->NumberOfEntries - pos - 1) * _entrySize); " is 131.
Long Statement,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,Read,The length of the statement  "                    return Slice.External(_tx.Allocator' dataStart + (page.LastSearchPosition * _entrySize) + sizeof(long)' _valSize' out slice); " is 125.
Long Statement,Voron.Data.Fixed,LargeIterator,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,CreateReaderForCurrent,The length of the statement  "                return new ValueReader(_currentPage.Pointer + _currentPage.StartPosition + (_parent._entrySize * _currentPage.LastSearchPosition) + sizeof(long)' _parent._valSize); " is 164.
Long Statement,Voron.Data.Fixed,FixedSizeTreePage,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeTreePage.cs,GetEntry,The length of the statement  "            Debug.Assert(position >= 0 && ((position == 0 && NumberOfEntries == 0) || position < NumberOfEntries) '$"FixedSizeTreePage: Requested an out of range entry {position} from [0-{NumberOfEntries-1}]"); " is 198.
Long Statement,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,TryAllocate,The length of the statement  "                throw new ArgumentException($"Cannot allocate an item of {size} bytes in a small data section. Maximum is: {MaxItemSize}"); " is 123.
Long Statement,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,DefragPage,The length of the statement  "                        VoronUnrecoverableErrorException.Raise(_tx.Environment' $"Allocated size cannot be zero or negative' but was {oldSize->AllocatedSize} in page {pageHeader->PageNumber}"); " is 169.
Long Statement,Voron.Data.RawData,RawDataSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\RawDataSection.cs,GetAllIdsInSectionContaining,The length of the statement  "                        $"Cannot get all ids in section containing {id} because the raw data section starting in {sectionPageNumber} belongs to a different owner"); " is 140.
Long Statement,Voron.Data.RawData,RawDataSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\RawDataSection.cs,TryWriteDirect,The length of the statement  "                VoronUnrecoverableErrorException.Raise(_tx.Environment' $"Asked to load a past the allocated values: {id} from page {pageHeader->PageNumber}"); " is 143.
Long Statement,Voron.Data.RawData,RawDataSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\RawDataSection.cs,TryWriteDirect,The length of the statement  "                VoronUnrecoverableErrorException.Raise(_tx.Environment' $"Asked to load a value that was already freed: {id} from page {pageHeader->PageNumber}"); " is 146.
Long Statement,Voron.Data.RawData,RawDataSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\RawDataSection.cs,DirectRead,The length of the statement  "                    $"Asked to load a value that where the allocated size is smaller than the used size: {id} from page {pageHeader->PageNumber}"); " is 127.
Long Statement,Voron.Data.RawData,RawDataSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\RawDataSection.cs,Free,The length of the statement  "                    VoronUnrecoverableErrorException.Raise(_tx.Environment' $"Cannot delete {id} because the raw data section starting in {sectionPageNumber} with size {actualSection.AllocatedSize} doesn't own it. Possible data corruption?"); " is 222.
Long Statement,Voron.Data.RawData,RawDataSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\RawDataSection.cs,Free,The length of the statement  "                VoronUnrecoverableErrorException.Raise(_tx.Environment' $"Asked to load a past the allocated values: {id} from page {pageHeader->PageNumber}"); " is 143.
Long Statement,Voron.Data.RawData,RawDataSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\RawDataSection.cs,Free,The length of the statement  "                VoronUnrecoverableErrorException.Raise(_tx.Environment' $"Asked to free a value that was already freed: {id} from page {pageHeader->PageNumber}"); " is 146.
Long Statement,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,AssertNoReferenceToThisPage,The length of the statement  "                            "Invalid attempt to insert data with the source equals to the range we are modifying. This is not permitted since it can cause data corruption when table defrag happens"); " is 171.
Long Statement,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,AssertNoReferenceToOldData,The length of the statement  "                            "Invalid attempt to update data with the source equals to the range we are modifying. This is not permitted since it can cause data corruption when table defrag happens"); " is 171.
Long Statement,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,Insert,The length of the statement  "                    throw new InvalidOperationException($"After successfully allocating {size:#'#;;0} bytes' failed to write them on {Name}"); " is 122.
Long Statement,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,GetFixedSizeTree,The length of the statement  "                return _tx.GetGlobalFixedSizeTree(indexDef.Name' sizeof(long)' isIndexTree: true' newPageAllocator: _globalPageAllocator); " is 122.
Long Statement,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,GetFixedSizeTree,The length of the statement  "                var fixedSizeTree = new FixedSizeTree(_tx.LowLevelTransaction' parent' name' valSize' isIndexTree: isIndexTree | parent.IsIndexTree' newPageAllocator: _tablePageAllocator); " is 172.
Long Statement,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,AllocateFromSmallActiveSection,The length of the statement  "                _activeDataSmallSection = ActiveRawDataSmallSection.Create(_tx.LowLevelTransaction' Name' _tableType' newNumberOfPages); " is 120.
Long Statement,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,GetTree,The length of the statement  "            tree = Tree.Open(_tx.LowLevelTransaction' _tx' name' (TreeRootHeader*)treeHeader' isIndexTree: isIndexTree' newPageAllocator: _tablePageAllocator); " is 147.
Long Statement,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,ThrowInconsistentItemsCountInIndexes,The length of the statement  "            throw new InvalidOperationException($"Inconsistent index items count detected! Index name: {indexName} expected size: {expectedSize} actual size: {actualSize}"); " is 161.
Long Statement,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,AssertWritableTable,The length of the statement  "                throw new InvalidOperationException("Table is meant to be used for global reads only while it attempted to modify the data"); " is 125.
Long Statement,Voron.Data.Tables,TableSchema,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableSchema.cs,Create,The length of the statement  "            using (var rawDataActiveSection = ActiveRawDataSmallSection.Create(tx.LowLevelTransaction' name' TableType' sizeInPages)) " is 121.
Long Statement,Voron.Data.Tables,TableSchema,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableSchema.cs,Create,The length of the statement  "                        using (var indexTree = Tree.Create(tx.LowLevelTransaction' tx' _primaryKey.Name' isIndexTree:true' newPageAllocator: tablePageAllocator)) " is 137.
Long Statement,Voron.Data.Tables,TableSchema,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableSchema.cs,Create,The length of the statement  "                        using (var indexTree = Tree.Create(tx.LowLevelTransaction' tx' indexDef.Name' isIndexTree:true' newPageAllocator: tablePageAllocator)) " is 134.
Long Statement,Voron.Debugging,DebugStuff,C:\repos\ravendb_ravendb\src\Voron\Debugging\DebugStuff.cs,RenderAndShow_FixedSizeTree,The length of the statement  "                    writer.WriteLine("<p>Number of entries: {0:#'#;;0}' val size: {1:#'#;;0}.</p>"' header->NumberOfEntries' header->ValueSize); " is 124.
Long Statement,Voron.Debugging,DebugStuff,C:\repos\ravendb_ravendb\src\Voron\Debugging\DebugStuff.cs,RenderAndShow_FixedSizeTree,The length of the statement  "                    writer.WriteLine("<p>Number of entries: {0:#'#;;0}' val size: {1:#'#;;0}.</p>"' header->NumberOfEntries' header->ValueSize); " is 124.
Long Statement,Voron.Debugging,DebugStuff,C:\repos\ravendb_ravendb\src\Voron\Debugging\DebugStuff.cs,RenderFixedSizeTreePage,The length of the statement  "                "<ul><li><input type='checkbox' id='page-{0}' {3} /><label for='page-{0}'>{4}: Page {0:#'#;;0} - {1} - {2:#'#;;0} entries</label><ul>"' " is 135.
Long Statement,Voron.Debugging,DebugStuff,C:\repos\ravendb_ravendb\src\Voron\Debugging\DebugStuff.cs,RenderFixedSizeTreePage,The length of the statement  "                    RenderFixedSizeTreePage(tx' new FixedSizeTreePage(fstPage.Pointer' header->ValueSize + sizeof(long)' Constants.Storage.PageSize)' sw' header' s' false); " is 152.
Long Statement,Voron.Debugging,DebugStuff,C:\repos\ravendb_ravendb\src\Voron\Debugging\DebugStuff.cs,RenderPage,The length of the statement  "               "<ul><li><input type='checkbox' id='page-{0}' {3} /><label for='page-{0}'>{4}: Page {0:#'#;;0} - {1} - {2:#'#;;0} entries</label><ul>"' " is 135.
Long Statement,Voron.Debugging,StorageReportGenerator,C:\repos\ravendb_ravendb\src\Voron\Debugging\StorageReportGenerator.cs,CreateStreamsReport,The length of the statement  "                    long numberOfAllocatedPages = VirtualPagerLegacyExtensions.GetNumberOfOverflowPages(info.TotalSize + info.TagSize + Tree.StreamInfo.SizeOf); " is 140.
Long Statement,Voron.Debugging,StorageReportGenerator,C:\repos\ravendb_ravendb\src\Voron\Debugging\StorageReportGenerator.cs,CreateMultiValuesReport,The length of the statement  "                                    var multiValueTreeHeader = (TreeRootHeader*)((byte*)currentNode + currentNode->KeySize + Constants.Tree.NodeHeaderSize); " is 120.
Long Statement,Voron.Debugging,StorageReportGenerator,C:\repos\ravendb_ravendb\src\Voron\Debugging\StorageReportGenerator.cs,CreateMultiValuesReport,The length of the statement  "                                VoronUnrecoverableErrorException.Raise(tree.Llt.Environment' "currentNode->FixedTreeFlags has value of " + currentNode->Flags); " is 127.
Long Statement,Voron.Debugging,StorageReportGenerator,C:\repos\ravendb_ravendb\src\Voron\Debugging\StorageReportGenerator.cs,GetReport,The length of the statement  "                AllocatedSpaceInBytes = (buffersReport.NumberOfFreePages + allocationTreeReport.PageCount) * Constants.Storage.PageSize' " is 120.
Long Statement,Voron.Debugging,StorageReportGenerator,C:\repos\ravendb_ravendb\src\Voron\Debugging\StorageReportGenerator.cs,GetReport,The length of the statement  "                OriginallyAllocatedSpaceInBytes = (buffersReport.NumberOfOriginallyAllocatedPages + allocationTreeReport.PageCount) * Constants.Storage.PageSize " is 144.
Long Statement,Voron.Debugging,StorageReportGenerator,C:\repos\ravendb_ravendb\src\Voron\Debugging\StorageReportGenerator.cs,GetPageDensities,The length of the statement  "                    densities.Add(((double)(page.OverflowSize + Constants.Tree.PageHeaderSize)) / (numberOfPages * Constants.Storage.PageSize)); " is 124.
Long Statement,Voron,GlobalFlushingBehavior,C:\repos\ravendb_ravendb\src\Voron\GlobalFlushingBehavior.cs,VoronEnvironmentFlushing,The length of the statement  "                        _log.Info($"Starting desired sync with {_maybeNeedToSync.Count:#'#} items to sync after {millisecondsTimeout:#'#} ms with no activity"); " is 136.
Long Statement,Voron,GlobalFlushingBehavior,C:\repos\ravendb_ravendb\src\Voron\GlobalFlushingBehavior.cs,SyncDesiredEnvironments,The length of the statement  "                int parallelSyncsPerIo = Math.Min(StorageEnvironment.NumOfConcurrentSyncsPerPhysDrive' mountPoint.Value.StorageEnvironments.Count); " is 131.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,IsStorageSupportingO_Direct,The length of the statement  "                            $"Failed to create test file at \'{filename}\'. Cannot determine if O_DIRECT supported by the file system. Assuming it is"); " is 124.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,IsStorageSupportingO_Direct,The length of the statement  "                            $"Failed to allocate test file at \'{filename}\'. (rc = {result}) but had success with pwrite. New file allocations will take longer time with pwrite"); " is 152.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,IsStorageSupportingO_Direct,The length of the statement  "                            $"Cannot allocate (rc = EINVAL) to a file \'{filename}\' opened using O_DIRECT. Assuming O_DIRECT is not supported by this file system"); " is 137.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,IsStorageSupportingO_Direct,The length of the statement  "                            $"Failed to allocate test file at \'{filename}\'. (rc = {result}). Cannot determine if O_DIRECT supported by the file system. Assuming it is"); " is 143.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,LoadExistingDatabase,The length of the statement  "                var message = _journal.Files.Count == 0 ? "Unrecoverable database" : "Database recovered partially. Some data was lost."; " is 121.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,LoadExistingDatabase,The length of the statement  "            Interlocked.Exchange(ref _transactionsCounter' header->TransactionId == 0 ? entry.TransactionId : header->TransactionId); " is 121.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,LoadExistingDatabase,The length of the statement  "            using (var root = Tree.Open(tx' null' Constants.RootTreeNameSlice' header->TransactionId == 0 ? &entry.Root : &header->Root)) " is 125.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,UpgradeSchemaIfRequired,The length of the statement  "                        VoronUnrecoverableErrorException.Raise(this' "Could not find schema version in metadata tree' possible mismatch / corruption?"); " is 128.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,UpgradeSchemaIfRequired,The length of the statement  "                        ThrowSchemaUpgradeRequired(schemaVersionVal' "You need to upgrade the schema but there is no schema uprader provided."); " is 120.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,ThrowInvalidDisposeDuringActiveTransactions,The length of the statement  "                $"Could not dispose the environment {Options.BasePath} after {Options.DisposeWaitTime} because there are running transaction.{Environment.NewLine}" + " is 149.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,ThrowInvalidDisposeDuringActiveTransactions,The length of the statement  "                $"Either you have long running transactions or hung transactions. Can\'t dispose the environment because that would invalid memory regions{Environment.NewLine}" + " is 162.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,WriteTransaction,The length of the statement  "            var writeTransaction = new Transaction(NewLowLevelTransaction(transactionPersistentContext' TransactionFlags.ReadWrite' context' null)); " is 136.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,WriteTransaction,The length of the statement  "            var newLowLevelTransaction = NewLowLevelTransaction(transactionPersistentContext' TransactionFlags.ReadWrite' context' timeout); " is 128.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,GenerateReport,The length of the statement  "            var numberOfAllocatedPages = Math.Max(_dataPager.NumberOfAllocatedPages' NextPageNumber - 1); // async apply to data file task " is 126.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,GenerateDetailedReport,The length of the statement  "            var numberOfAllocatedPages = Math.Max(_dataPager.NumberOfAllocatedPages' NextPageNumber - 1); // async apply to data file task " is 126.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,GenerateDetailedReport,The length of the statement  "                                if (SliceComparer.AreEqual(currentKey' NewPageAllocator.AllocationStorage)) // will be counted inside pre allocated buffers report " is 130.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,Stats,The length of the statement  "                var numberOfAllocatedPages = Math.Max(_dataPager.NumberOfAllocatedPages' State.NextPageNumber - 1); // async apply to data file task " is 132.
Long Statement,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,ThrowInvalidChecksum,The length of the statement  "                $"Invalid checksum for page {pageNumber}' data file {_options.DataPager} might be corrupted' expected hash to be {current->Checksum} but was {checksum}"); " is 154.
Long Statement,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,InvokeNonDurableFileSystemError,The length of the statement  "                                               "An exception has been thrown because there isn't a listener to the OnNonDurableFileSystemError event on the storage options."' " is 127.
Long Statement,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,CreateMemoryOnly,The length of the statement  "            return new PureMemoryStorageEnvironmentOptions(name' tempPathSetting' ioChangesNotifications' catastrophicFailureNotification); " is 127.
Long Statement,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,ForPath,The length of the statement  "            return new DirectoryStorageEnvironmentOptions(pathSetting' tempPathSetting' journalPathSetting' ioChangesNotifications' catastrophicFailureNotification); " is 153.
Long Statement,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,SetPosixOptions,The length of the statement  "                var details = $"Storage type '{PosixHelper.GetFileSystemOfPath(BasePath.FullPath)}' doesn't support direct write to disk (non durable file system)"; " is 148.
Long Statement,Voron,DirectoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,GetMemoryMapPagerInternal,The length of the statement  "                    ? Win32NativeFileAttributes.DeleteOnClose | Win32NativeFileAttributes.Temporary | Win32NativeFileAttributes.RandomAccess " is 120.
Long Statement,Voron,PureMemoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,GetTempMemoryMapPager,The length of the statement  "                    Win32NativeFileAttributes.RandomAccess | Win32NativeFileAttributes.DeleteOnClose | Win32NativeFileAttributes.Temporary); " is 120.
Long Statement,Voron,PureMemoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,GetTempMemoryMapPagerInternal,The length of the statement  "                        Win32NativeFileAttributes.RandomAccess | Win32NativeFileAttributes.DeleteOnClose | Win32NativeFileAttributes.Temporary); " is 120.
Long Statement,Voron,PureMemoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,GetTempMemoryMapPagerInternal,The length of the statement  "                        Win32NativeFileAttributes.RandomAccess | Win32NativeFileAttributes.DeleteOnClose | Win32NativeFileAttributes.Temporary); " is 120.
Long Statement,Voron,PureMemoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,CreateScratchPager,The length of the statement  "                return GetTempMemoryMapPager(this' TempPath.Combine(filename)' initialSize' Win32NativeFileAttributes.RandomAccess | Win32NativeFileAttributes.DeleteOnClose | Win32NativeFileAttributes.Temporary); " is 196.
Long Statement,Voron,PureMemoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,CreateTemporaryBufferPager,The length of the statement  "                return GetTempMemoryMapPagerInternal(this' TempPath.Combine(filename)' initialSize' Win32NativeFileAttributes.RandomAccess | Win32NativeFileAttributes.DeleteOnClose | Win32NativeFileAttributes.Temporary); " is 204.
Long Statement,Voron.Impl.Backup,FullBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\FullBackup.cs,Backup,The length of the statement  "                using (var txw = env.NewLowLevelTransaction(writePesistentContext' TransactionFlags.ReadWrite)) // so we can snapshot the headers safely " is 136.
Long Statement,Voron.Impl.Backup,FullBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\FullBackup.cs,Backup,The length of the statement  "                            if (journalFile.Number < lastWrittenLogFile &&  // prevent deletion of the current journal and journals with a greater number " is 125.
Long Statement,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,GetJournalFile,The length of the statement  "            var journalFile = env.Journal.Files.FirstOrDefault(x => x.Number == journalNum); // first check journal files currently being in use " is 132.
Long Statement,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,GetJournalFile,The length of the statement  "                if (backupInfo.LastBackedUpJournal == -1 && journalNum == 0 && e.Message.StartsWith("No such journal"' StringComparison.Ordinal)) " is 129.
Long Statement,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,GetJournalFile,The length of the statement  "                                                        "In order to create backups incrementally the storage must be created with IncrementalBackupEnabled option set to 'true'."' e); " is 127.
Long Statement,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,Restore,The length of the statement  "                                env.Options.CreateTemporaryBufferPager(Path.Combine(tempDir.Combine(StorageEnvironmentOptions.JournalRecoveryName(journalNumber)).FullPath)' " is 140.
Long Statement,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,Restore,The length of the statement  "                    // this is just a temporary directory' the worst case scenario is that we dont reclaim the space from the OS temp directory " is 123.
Long Statement,Voron.Impl.Backup,VoronBackupUtil,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\VoronBackupUtil.cs,CopyHeaders,The length of the statement  "                throw new InvalidDataException($"Failed to read both file headers (headers.one & headers.two) from path: {basePath}' possible corruption."); " is 140.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,Execute,The length of the statement  "            using (var compactedDataFile = new FileStream(compactOptions.BasePath.Combine(Constants.DatabaseFilename).FullPath' FileMode.Open' FileAccess.ReadWrite)) " is 153.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTrees,The length of the statement  "                var totalTreesCount = txr.LowLevelTransaction.RootObjects.State.NumberOfEntries - globalTableIndexesToSkipCopying.Count; " is 120.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTrees,The length of the statement  "                            copiedTrees = CopyVariableSizeTree(compactedEnv' progressReport' txr' treeName' copiedTrees' totalTreesCount' context' token); " is 126.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTrees,The length of the statement  "                            copiedTrees = CopyFixedSizeTrees(compactedEnv' progressReport' txr' rootIterator' treeName' copiedTrees' totalTreesCount' context' token); " is 138.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyFixedSizeTrees,The length of the statement  "            Report(copiedTrees' totalTreesCount' 0' fst.NumberOfEntries' progressReport' $"Copying fixed size tree '{treeName}'. Progress: 0/{fst.NumberOfEntries} entries."' treeName); " is 172.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyFixedSizeTrees,The length of the statement  "                                Report(copiedTrees' totalTreesCount' copiedEntries' fst.NumberOfEntries' progressReport' $"Copying fixed size tree '{treeName}'. Progress: {copiedEntries}/{fst.NumberOfEntries} entries."' treeName); " is 198.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyFixedSizeTrees,The length of the statement  "                        Report(copiedTrees' totalTreesCount' copiedEntries' fst.NumberOfEntries' progressReport' $"Finished copying fixed size tree '{treeName}'. Progress: {copiedEntries}/{fst.NumberOfEntries} entries."' treeName); " is 207.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyVariableSizeTree,The length of the statement  "            Report(copiedTrees' totalTreesCount' 0' existingTree.State.NumberOfEntries' progressReport' $"Copying variable size tree '{treeName}'. Progress: 0/{existingTree.State.NumberOfEntries} entries."' treeName); " is 205.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyVariableSizeTree,The length of the statement  "                                Report(copiedTrees' totalTreesCount' copiedEntries' existingTree.State.NumberOfEntries' progressReport' $"Copying variable size tree '{treeName}'. Progress: {copiedEntries}/{existingTree.State.NumberOfEntries} entries."' treeName); " is 231.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyVariableSizeTree,The length of the statement  "                        Report(copiedTrees' totalTreesCount' copiedEntries' existingTree.State.NumberOfEntries' progressReport' $"Finished copying variable size tree '{treeName}'. Progress: {copiedEntries}/{existingTree.State.NumberOfEntries} entries."' treeName); " is 240.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The length of the statement  "            Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName); " is 207.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The length of the statement  "                schema.Create(txw' treeName' Math.Max((ushort)inputTable.ActiveDataSmallSection.NumberOfPages' (ushort)((ushort.MaxValue + 1) / Constants.Storage.PageSize))); " is 158.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The length of the statement  "                                    Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName); " is 207.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The length of the statement  "                                throw new InvalidOperationException("Cannot compact table " + inputTable.Name + " because is has no local indexes' only global ones"); " is 134.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The length of the statement  "                                    Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName); " is 207.
Long Statement,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The length of the statement  "                    Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Finished copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName); " is 216.
Long Statement,Voron.Impl.FileHeaders,HeaderAccessor,C:\repos\ravendb_ravendb\src\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,The length of the statement  "                    throw new InvalidDataException("None of the header files start with the magic marker' probably not db files or fatal corruption on " + _env.Options.BasePath); " is 158.
Long Statement,Voron.Impl.FileHeaders,HeaderAccessor,C:\repos\ravendb_ravendb\src\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,The length of the statement  "                    throw new InvalidDataException("None of the header files have a valid hash' possible corruption on " + _env.Options.BasePath); " is 126.
Long Statement,Voron.Impl.FileHeaders,HeaderAccessor,C:\repos\ravendb_ravendb\src\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,The length of the statement  "                        $"The db file is for version {f1->Version}' which is not compatible with the current version {Constants.CurrentVersion} on {_env.Options.BasePath}"); " is 149.
Long Statement,Voron.Impl.FileHeaders,HeaderAccessor,C:\repos\ravendb_ravendb\src\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,The length of the statement  "                    var message = string.Format("PageSize mismatch' configured to be {0:#'#} but was {1:#'#}' using the actual value in the file {1:#'#}"' " is 134.
Long Statement,Voron.Impl.FileHeaders,HeaderAccessor,C:\repos\ravendb_ravendb\src\Voron\Impl\FileHeaders\HeaderAccessor.cs,CalculateFileHeaderHash,The length of the statement  "                Hashing.Streamed.XXHash64.Process(ctx' (byte*)header + FileHeader.HashOffset + sizeof(ulong)' secondPartOfHeaderLength); " is 120.
Long Statement,Voron.Impl.Journal,JournalFile,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalFile.cs,Write,The length of the statement  "                Debug.Assert(!_unusedPages.Any(_unusedPagesHashSetPool.Contains)); // We ensure there cannot be duplicates here (disjoint sets).  " is 128.
Long Statement,Voron.Impl.Journal,JournalFile,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalFile.cs,Write,The length of the statement  "            if (tx.IsLazyTransaction == false && (lazyTransactionScratch == null || lazyTransactionScratch.HasDataInBuffer() == false)) " is 123.
Long Statement,Voron.Impl.Journal,JournalFile,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalFile.cs,Write,The length of the statement  "                    throw new InvalidOperationException("lazyTransactionScratch cannot be null if the transaction is lazy (or a previous one was)"); " is 128.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionToDataFile,The length of the statement  "                throw new InvalidDataException($"Attempted to read position {totalRead} from transaction data while the transaction is size {current->UncompressedSize}"); " is 154.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionToDataFile,The length of the statement  "                    throw new InvalidDataException($"Transaction {current->TransactionId} contains refeence to page {pageInfoPtr[i].PageNumber} which is after the last allocated page {current->LastPageNumber}"); " is 191.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionToDataFile,The length of the statement  "                    throw new InvalidDataException($"Attempted to read position {totalRead} from transaction data while the transaction is size {current->UncompressedSize}"); " is 154.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,TryReadAndValidateHeader,The length of the statement  "            // * TxId >  current Id + 1  ::  if hash is invalid we can ignore reused/random' but if hash valid then we might missed TXs  " is 123.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,TryReadAndValidateHeader,The length of the statement  "                // if the header marker is zero or garbage' we are probably in the area at the end of the log file' and have no additional log records " is 134.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,TryReadAndValidateHeader,The length of the statement  "                            $"Transaction has valid(!) hash with invalid transaction id {current->TransactionId}' the last valid transaction id is {LastTransactionHeader->TransactionId}." + " is 161.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,ValidatePagesHash,The length of the statement  "                options.InvokeRecoveryError(this' $"Size {size} ({compressLabel}) is too big for the journal size {_journalPagerNumberOfAllocated4Kb * 4 * Constants.Size.Kilobyte}"' null); " is 172.
Long Statement,Voron.Impl.Journal,TransactionHeader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\TransactionHeader.cs,ToString,The length of the statement  "            return $"HeaderMarker: {validMarker}' TransactionId: {TransactionId}' NextPageNumber: {NextPageNumber}' LastPageNumber: {LastPageNumber}' " + " is 141.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,The length of the statement  "                    "First transaction initializing the structure of Voron database is corrupted. Cannot access internal database metadata. Create a new database to recover."); " is 156.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ReadPage,The length of the statement  "                        var page = _env.ScratchBufferPool.ReadPage(tx' value.ScratchNumber' value.ScratchPage' scratchPagerStates[value.ScratchNumber]); " is 128.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,WriteToJournal,The length of the statement  "                    _logger.Info($"Preparing to write tx {tx.Id} to journal with {journalEntry.NumberOfUncompressedPages:#'#} pages ({(journalEntry.NumberOfUncompressedPages * Constants.Storage.PageSize) / Constants.Size.Kilobyte:#'#} kb) in {sp.Elapsed} with {Math.Round(journalEntry.NumberOf4Kbs * 4d' 1):#'#.#;;0} kb compressed."); " is 314.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The length of the statement  "            var performCompression = pagesCountIncludingAllOverflowPages > _env.Options.CompressTxAboveSizeInBytes / Constants.Storage.PageSize; " is 132.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The length of the statement  "            var overheadInPages = checked((int)(overhead / Constants.Storage.PageSize + (overhead % Constants.Storage.PageSize == 0 ? 0 : 1))); " is 131.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The length of the statement  "                var scratchPage = tx.Environment.ScratchBufferPool.AcquirePagePointerWithOverflowHandling(tx' txPage.ScratchFileNumber' txPage.PositionInScratchBuffer); " is 152.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The length of the statement  "                    pageHeader->Checksum = StorageEnvironment.CalculatePageChecksum(scratchPage' pageHeader->PageNumber' pageHeader->Flags' pageHeader->OverflowSize); " is 146.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The length of the statement  "                    // written when we crashed? We cannot decrypt partial data' therefore we cannot compare the diff to the plaintext on disk. " is 122.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The length of the statement  "                _maxNumberOfPagesRequiredForCompressionBuffer = Math.Max(pagesRequired + outputBufferInPages' _maxNumberOfPagesRequiredForCompressionBuffer); " is 141.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The length of the statement  "                var path = CurrentFile?.JournalWriter?.FileName?.FullPath ?? _env.Options.GetJournalPath(Math.Max(0' _journalIndex))?.FullPath; " is 127.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The length of the statement  "                using (var metrics = _env.Options.IoMetrics.MeterIoRate(path' IoMetrics.MeterType.Compression' 0)) // Note that the last journal may be replaced if we switch journals' however it doesn't affect web graph " is 203.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The length of the statement  "                txHeader->Hash = Hashing.XXHash64.Calculate(txHeaderPtr + sizeof(TransactionHeader)' (ulong)compressedLen' (ulong)txHeader->TransactionId); " is 139.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ReduceSizeOfCompressionBufferIfNeeded,The length of the statement  "                    $"Compression buffer: {_compressionPager} has reached size {(_compressionPager.NumberOfAllocatedPages * Constants.Storage.PageSize) / Constants.Size.Kilobyte:#'#0} kb which is more than the limit " + " is 199.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ReduceSizeOfCompressionBufferIfNeeded,The length of the statement  "                    $"of {_env.Options.MaxScratchBufferSize / 1024:#'#0} kb. Will trim it now to the max size allowed. If this is happen on a regular basis'" + " is 139.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ShouldReduceSizeOfCompressionPager,The length of the statement  "            var shouldReduceSizeOfCompressionPager = _maxNumberOfPagesRequiredForCompressionBuffer < _compressionPager.NumberOfAllocatedPages / 2; " is 134.
Long Statement,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The length of the statement  "                    throw new InvalidJournalFlushRequestException("Applying journals to the data file has been already requested on the same thread"); " is 130.
Long Statement,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The length of the statement  "                                    ThrowReadByeondOldestActiveTransaction(currentJournalMaxTransactionId' previousJournalMaxTransactionId' oldestActiveTransaction); " is 129.
Long Statement,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyPagesToDataFileFromScratch,The length of the statement  "                    using (var meter = _waj._dataPager.Options.IoMetrics.MeterIoRate(_waj._dataPager.FileName.FullPath' IoMetrics.MeterType.DataFlush' 0)) " is 134.
Long Statement,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyPagesToDataFileFromScratch,The length of the statement  "                        _waj._logger.Info($"Flushed {pagesToWrite.Count:#'#} pages to { _waj._dataPager.FileName} with {written / Constants.Size.Kilobyte:#'#} kb in {sp.Elapsed}"); " is 156.
Long Statement,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,SetLastReadTxHeader,The length of the statement  "                    var totalSize = readTxHeader->CompressedSize != -1 ? readTxHeader->CompressedSize + sizeof(TransactionHeader) : readTxHeader->UncompressedSize + sizeof(TransactionHeader); " is 171.
Long Statement,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,DeleteCurrentAlreadyFlushedJournal,The length of the statement  "                    throw new InvalidOperationException(string.Format("Cannot delete current journal because it isn't last synced file. Current journal number: {0}' the last one which was synced {1}"' _waj.CurrentFile?.Number ?? -1' _lastFlushedJournalId)); " is 237.
Long Statement,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,DeleteCurrentAlreadyFlushedJournal,The length of the statement  "                    throw new InvalidOperationException("Cannot delete current journal because it hasn't synced everything up to the last write transaction"); " is 138.
Long Statement,Voron.Impl.Journal,SyncOperation,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,CallPagerSync,The length of the statement  "                            _parent._waj._logger.Info($"Sync of {sizeInKb:#'#0} kb file with {_currentTotalWrittenBytes / Constants.Size.Kilobyte:#'#0} kb dirty in {sp.Elapsed}"); " is 151.
Long Statement,Voron.Impl.Journal,SyncOperation,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,TryGatherInformationToStartSync,The length of the statement  "                                    $"Asking for required sync on {_parent._waj._dataPager.FileName} because started a sync and aborted because we couldn't get the flushing lock"); " is 144.
Long Statement,Voron.Impl.Journal,SyncOperation,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,TryGatherInformationToStartSync,The length of the statement  "                                $"Error syncing the data file. The last sync tx is {_lastSyncedTransactionId}' but the journal's last tx id is {_transactionHeader.TransactionId}' possible file corruption?" " is 173.
Long Statement,Voron.Impl.Paging,VirtualPagerLegacyExtensions,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPagerExtensions.cs,AcquirePagePointerWithOverflowHandling,The length of the statement  "            // Case 3: Page is overflow and was ensuredMapped above' view was re-mapped so we need to acquire a pointer to the new mapping. " is 127.
Long Statement,Voron.Impl.Paging,VirtualPagerLegacyExtensions,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPagerExtensions.cs,AcquirePagePointerWithOverflowHandling,The length of the statement  "            // Case 3: Page is overflow and was ensuredMapped above' view was re-mapped so we need to acquire a pointer to the new mapping. " is 127.
Long Statement,Voron.Impl.Paging,Windows32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,EnsureMapped,The length of the statement  "            var ammountToMapInBytes = NearestSizeToAllocationGranularity((distanceFromStart + numberOfPages) * Constants.Storage.PageSize); " is 127.
Long Statement,Voron.Impl.Paging,Windows32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,CopyPage,The length of the statement  "            var offset = new WindowsMemoryMapPager.SplitValue { Value = (ulong)allocationStartPosition * (ulong)Constants.Storage.PageSize }; " is 129.
Long Statement,Voron.Impl.Paging,Windows32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,CopyPage,The length of the statement  "                    throw new Win32Exception($"Unable to map (default view size) {AllocationGranularity / Constants.Size.Kilobyte:#'#0} kb for page {pageNumber} starting at {allocationStartPosition} on {FileName}"' " is 194.
Long Statement,Voron.Impl.Paging,Windows32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,CopyPage,The length of the statement  "                        throw new Win32Exception($"Unable to map {newSize / Constants.Size.Kilobyte:#'#0} kb for page {pageNumber} starting at {allocationStartPosition} on {FileName}"' " is 160.
Long Statement,Voron.Impl.Paging,Windows32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,ThrowInvalidMappingRequested,The length of the statement  "                $"Was asked to map page {startPage} + {size / 1024:#'#0} kb' but the file size is only {_fileStreamLength}' can't do that."); " is 125.
Long Statement,Voron.Impl.Paging,Windows32Bit4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,Write,The length of the statement  "                var ammountToMapInBytes = _parent.NearestSizeToAllocationGranularity((distanceFromStart + numberOfPages) * Constants.Storage.PageSize); " is 135.
Long Statement,Voron.Impl.Scratch,PageFromScratchBufferEqualityComparer,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\PageFromScratchBuffer.cs,Equals,The length of the statement  "            return x.PositionInScratchBuffer == y.PositionInScratchBuffer && x.Size == y.Size && x.NumberOfPages == y.NumberOfPages && x.ScratchFileNumber == y.ScratchFileNumber; " is 166.
Long Statement,Voron.Impl.Scratch,PageFromScratchBuffer,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\PageFromScratchBuffer.cs,ToString,The length of the statement  "                $"PositionInScratchBuffer: {PositionInScratchBuffer}' ScratchFileNumber: {ScratchFileNumber}'  Size: {Size}' NumberOfPages: {NumberOfPages}"; " is 141.
Long Statement,Voron.Impl.Scratch,ScratchBufferFile,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferFile.cs,TryGettingFromAllocatedBuffer,The length of the statement  "            if (_freePagesBySizeAvailableImmediately.TryGetValue(size' out listOfAvailableImmediately) && listOfAvailableImmediately.Count > 0) " is 131.
Long Statement,Voron.Impl.Scratch,ScratchBufferFile,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferFile.cs,Free,The length of the statement  "                    ulong pageSize = (ulong) (page.IsOverflow ? VirtualPagerLegacyExtensions.GetNumberOfOverflowPages(page.OverflowSize) : 1) * Constants.Storage.PageSize; " is 151.
Long Statement,Voron.Impl.Scratch,ScratchBufferFile,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferFile.cs,InvalidAttemptToShrinkPageThatWasntAllocated,The length of the statement  "            throw new InvalidOperationException($"Attempt to shrink a page that wasn't currently allocated: {value.PositionInScratchBuffer}"); " is 130.
Long Statement,Voron.Impl.Scratch,ScratchBufferPool,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferPool.cs,InfoForDebug,The length of the statement  "                    CanBeDeleted = scratchBufferItem != current && scratchBufferItem.File.HasActivelyUsedBytes(oldestActiveTransaction) == false' " is 125.
Long Statement,Voron.Platform.Posix,Posix32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,EnsureMapped,The length of the statement  "            var ammountToMapInBytes = NearestSizeToAllocationGranularity((distanceFromStart + numberOfPages) * Constants.Storage.PageSize); " is 127.
Long Statement,Voron.Platform.Posix,Posix32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,CopyPage,The length of the statement  "                        $"Unable to map (default view size) {sizeToMap/Constants.Size.Kilobyte:#'#0} kb for page {pageNumber} starting at {allocationStartPosition} on {FileName}"); " is 156.
Long Statement,Voron.Platform.Posix,Posix32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,CopyPage,The length of the statement  "                            $"Unable to map {sizeToMap/Constants.Size.Kilobyte:#'#0} kb for page {pageNumber} starting at {allocationStartPosition} on {FileName}"); " is 136.
Long Statement,Voron.Platform.Posix,Posix32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,ThrowInvalidMappingRequested,The length of the statement  "                $"Was asked to map page {startPage} + {size / 1024:#'#0} kb' but the file size is only {_totalAllocationSize}' can't do that."); " is 128.
Long Statement,Voron.Platform.Posix,Posix32Bit4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,Write,The length of the statement  "                var ammountToMapInBytes = _parent.NearestSizeToAllocationGranularity((distanceFromStart + numberOfPages) * Constants.Storage.PageSize); " is 135.
Long Statement,Voron.Platform.Posix,Posix32Bit4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,Dispose,The length of the statement  "                    var result = Syscall.msync(new IntPtr(loadedPage.Pointer)' (UIntPtr)(loadedPage.NumberOfPages * Constants.Storage.PageSize)' MsyncFlags.MS_SYNC); " is 145.
Long Statement,Voron.Platform.Posix,PosixAbstractPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixAbstractPager.cs,PrefetchRanges,The length of the statement  "                if (Syscall.madvise(new IntPtr(range.VirtualAddress)' (UIntPtr)range.NumberOfBytes.ToPointer()' MAdvFlags.MADV_WILLNEED) == -1) " is 127.
Long Statement,Voron.Platform.Posix,PosixJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixJournalWriter.cs,WriteFile,The length of the statement  "            using (_options.IoMetrics.MeterIoRate(_filename.FullPath' IoMetrics.MeterType.JournalWrite' (long)nNumberOfBytesToWrite)) " is 121.
Long Statement,Voron.Platform.Posix,PosixJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixJournalWriter.cs,WriteFile,The length of the statement  "                throw new IOException($"pwrite reported zero bytes written' after write of {actuallyWritten} bytes out of {nNumberOfBytesToWrite}. lastErrNo={err} on {_filename}"); " is 164.
Long Statement,Voron.Platform.Posix,PosixJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixJournalWriter.cs,WriteFile,The length of the statement  "                throw new IOException($"pwrite couln't write {nNumberOfBytesToWrite} to file. only {actuallyWritten} written. lastErrNo={err} on {_filename}"); " is 143.
Long Statement,Voron.Platform.Posix,PosixMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixMemoryMapPager.cs,AllocateMorePages,The length of the statement  "                    "Unable to allocate more pages - unsuccessfully tried to allocate continuous block of virtual memory with size = {0:##'###;;0} bytes"' " is 134.
Long Statement,Voron.Platform.Posix,PosixTempMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixTempMemoryMapPager.cs,AllocateMorePages,The length of the statement  "                    "Unable to allocate more pages - unsuccessfully tried to allocate continuous block of virtual memory with size = {0:##'###;;0} bytes"' " is 134.
Long Statement,Voron.Platform.Win32,Win32Helper,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32Helper.cs,WriteFileHeader,The length of the statement  "            using (var fs = new FileStream(path.FullPath' FileMode.Create' FileAccess.ReadWrite' FileShare.Read' 4096' FileOptions.None)) " is 125.
Long Statement,Voron.Platform.Win32,Win32Helper,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32Helper.cs,TryReadFileHeader,The length of the statement  "            using (var fs = new FileStream(path.FullPath' FileMode.Open' FileAccess.ReadWrite' FileShare.Read' 4096' FileOptions.None)) " is 123.
Long Statement,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,WriteFile,The length of the statement  "            using (var metrics = _options.IoMetrics.MeterIoRate(_filename.FullPath' IoMetrics.MeterType.JournalWrite' nNumberOfBytesToWrite)) " is 129.
Long Statement,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,Read,The length of the statement  "                    if (Win32NativeFileMethods.ReadFile(_readHandle' buffer' (int)Math.Min(numOfBytes' int.MaxValue)' out int read' nativeOverlapped) == false) " is 139.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,GetPhysicalDriveId,The length of the statement  "            var driveHandle = CreateFile(@"\\.\" + drive' 0' 0' IntPtr.Zero' (uint)CreationDisposition.OPEN_EXISTING' 0' IntPtr.Zero); " is 122.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,TryAllocateMoreContinuousPages,The length of the statement  "            var allocationInfo = RemapViewOfFileAtAddress(allocationSize' (ulong)_totalAllocationSize' PagerState.MapBase + _totalAllocationSize); " is 134.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,TryAllocateMoreContinuousPages,The length of the statement  "                // We are asking to allocate pages. It is a good idea that they should be already in memory to only cause a single page fault (as they are continuous). " is 151.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,RemapViewOfFileAtAddress,The length of the statement  "            var newMappingBaseAddress = Win32MemoryMapNativeMethods.MapViewOfFileEx(mmf.SafeMemoryMappedFileHandle.DangerousGetHandle()' " is 124.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,CreatePagerState,The length of the statement  "                    "Unable to allocate more pages - unsuccessfully tried to allocate continuous block of virtual memory with size = {0:##'###;;0} bytes"' " is 134.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,ProtectPageRange,The length of the statement  "                Win32MemoryProtectMethods.MEMORY_BASIC_INFORMATION memoryInfo1 = new Win32MemoryProtectMethods.MEMORY_BASIC_INFORMATION(); " is 122.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,ProtectPageRange,The length of the statement  "                bool status = Win32MemoryProtectMethods.VirtualProtect(start' new UIntPtr(size)' Win32MemoryProtectMethods.MemoryProtection.READONLY' out oldProtection); " is 153.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,ProtectPageRange,The length of the statement  "                    Win32MemoryProtectMethods.MEMORY_BASIC_INFORMATION memoryInfo2 = new Win32MemoryProtectMethods.MEMORY_BASIC_INFORMATION(); " is 122.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,UnprotectPageRange,The length of the statement  "                Win32MemoryProtectMethods.MEMORY_BASIC_INFORMATION memoryInfo1 = new Win32MemoryProtectMethods.MEMORY_BASIC_INFORMATION(); " is 122.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,UnprotectPageRange,The length of the statement  "                bool status = Win32MemoryProtectMethods.VirtualProtect(start' new UIntPtr(size)' Win32MemoryProtectMethods.MemoryProtection.READWRITE' out oldProtection); " is 154.
Long Statement,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,UnprotectPageRange,The length of the statement  "                    Win32MemoryProtectMethods.MEMORY_BASIC_INFORMATION memoryInfo2 = new Win32MemoryProtectMethods.MEMORY_BASIC_INFORMATION(); " is 122.
Long Statement,Voron.Util.Settings,PathSettingBase<T>,C:\repos\ravendb_ravendb\src\Voron\Util\Settings\PathSettingBase.cs,ValidatePath,The length of the statement  "                throw new ArgumentException($"The path '{path}' is illegal! Paths in RavenDB can't start with 'appdrive:'' '~' or '$home'"); " is 124.
Complex Conditional,Voron.Util.Settings,PathSettingBase<T>,C:\repos\ravendb_ravendb\src\Voron\Util\Settings\PathSettingBase.cs,ValidatePath,The conditional expression  "path!= null &&                   (path.StartsWith("appdrive:"' StringComparison.InvariantCultureIgnoreCase) ||                   path.StartsWith("~") ||                   path.StartsWith("$home"' StringComparison.InvariantCultureIgnoreCase))"  is complex.
Complex Conditional,Voron.Util.Settings,PathSettingBase<T>,C:\repos\ravendb_ravendb\src\Voron\Util\Settings\PathSettingBase.cs,ToFullPath,The conditional expression  "PlatformDetails.RunningOnPosix == false && path.StartsWith(@"\") == false ||                  PlatformDetails.RunningOnPosix && path.StartsWith(@"/") == false"  is complex.
Virtual Method Call from Constructor,Voron.Data.Compression,DecompressionBuffersPool,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressionBuffersPool.cs,DecompressionBuffersPool,The constructor "DecompressionBuffersPool" calls a virtual method "Dispose".
Virtual Method Call from Constructor,Voron.Data.Compression,DecompressionBuffersPool,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressionBuffersPool.cs,DecompressionBuffersPool,The constructor "DecompressionBuffersPool" calls a virtual method "Dispose".
Virtual Method Call from Constructor,Voron.Data.Compression,DecompressionBuffer,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressionBuffersPool.cs,DecompressionBuffer,The constructor "DecompressionBuffer" calls a virtual method "EnsureMapped".
Virtual Method Call from Constructor,Voron.Data.Compression,DecompressionBuffer,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressionBuffersPool.cs,DecompressionBuffer,The constructor "DecompressionBuffer" calls a virtual method "AcquirePagePointer".
Virtual Method Call from Constructor,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,StorageEnvironment,The constructor "StorageEnvironment" calls a virtual method "SetPosixOptions".
Virtual Method Call from Constructor,Voron.Impl.Journal,LazyTransactionBuffer,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\LazyTransactionBuffer.cs,LazyTransactionBuffer,The constructor "LazyTransactionBuffer" calls a virtual method "CreateTemporaryBufferPager".
Virtual Method Call from Constructor,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,WriteAheadJournal,The constructor "WriteAheadJournal" calls a virtual method "Dispose".
Virtual Method Call from Constructor,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,AbstractPager,The constructor "AbstractPager" calls a virtual method "DisposeInternal".
Empty Catch Block,Voron.Data.Compression,DecompressionBuffersPool,C:\repos\ravendb_ravendb\src\Voron\Data\Compression\DecompressionBuffersPool.cs,GetTemporaryPage,The method has an empty catch block.
Empty Catch Block,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,BackgroundFlushWritesToDataFile,The method has an empty catch block.
Empty Catch Block,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,BackgroundFlushWritesToDataFile,The method has an empty catch block.
Empty Catch Block,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,TryStoreJournalForReuse,The method has an empty catch block.
Empty Catch Block,Voron,DirectoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,Disposing,The method has an empty catch block.
Empty Catch Block,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,Restore,The method has an empty catch block.
Empty Catch Block,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,Win32FileJournalWriter,The method has an empty catch block.
Magic Number,Voron.Global,Storage,C:\repos\ravendb_ravendb\src\Voron\Constants.cs,Storage,The following statement contains a magic number: GC.KeepAlive(new int[                      // this is a way to have static assert                      PageSize > ushort.MaxValue || PageSize < 4*Constants.Size.Kilobyte ||                      PageSize% Size.Sector != 0                          ? -1                          : 0                      ]);
Magic Number,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,Tree,The following statement contains a magic number: _recentlyFoundPages = new RecentlyFoundTreePages(llt.Flags == TransactionFlags.Read ? 8 : 2);
Magic Number,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,Tree,The following statement contains a magic number: _recentlyFoundPages = new RecentlyFoundTreePages(llt.Flags == TransactionFlags.Read ? 8 : 2);
Magic Number,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,Tree,The following statement contains a magic number: _recentlyFoundPages = new RecentlyFoundTreePages(llt.Flags == TransactionFlags.Read ? 8 : 2);
Magic Number,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,Tree,The following statement contains a magic number: _recentlyFoundPages = new RecentlyFoundTreePages(llt.Flags == TransactionFlags.Read ? 8 : 2);
Magic Number,Voron.Data.BTrees,Tree,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Compressed.cs,ValidateTree_Forced,The following statement contains a magic number: while (stack.Count > 0)              {                  var p = stack.Pop();                    using (p.IsCompressed ? (DecompressedLeafPage)(p = DecompressPage(p' skipCache: true)) : null)                  {                      if (p.NumberOfEntries == 0 && p != root)                      {                          DebugStuff.RenderAndShowTree(this' rootPageNumber);                          throw new InvalidOperationException("The page " + p.PageNumber + " is empty");                        }                      p.DebugValidate(this' rootPageNumber);                      if (p.IsBranch == false)                          continue;                        if (p.NumberOfEntries < 2)                      {                          throw new InvalidOperationException("The branch page " + p.PageNumber + " has " +                                                              p.NumberOfEntries + " entry");                      }                        for (int i = 0; i < p.NumberOfEntries; i++)                      {                          var page = p.GetNode(i)->PageNumber;                          if (pages.Add(page) == false)                          {                              DebugStuff.RenderAndShowTree(this' rootPageNumber);                              throw new InvalidOperationException("The page " + page + " already appeared in the tree!");                          }                          stack.Push(GetReadOnlyTreePage(page));                      }                  }              }
Magic Number,Voron.Data.BTrees,StreamToPageWriter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Stream.cs,Write,The following statement contains a magic number: if (_localBuffer == null)                      _localBuffer = new byte[4 * Constants.Storage.PageSize];
Magic Number,Voron.Data.BTrees,StreamToPageWriter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Stream.cs,AllocateNextPage,The following statement contains a magic number: _numberOfPagesPerChunk = Math.Min(_numberOfPagesPerChunk * 2' 4096);
Magic Number,Voron.Data.BTrees,StreamToPageWriter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\Tree.Stream.cs,AllocateNextPage,The following statement contains a magic number: _numberOfPagesPerChunk = Math.Min(_numberOfPagesPerChunk * 2' 4096);
Magic Number,Voron.Data.BTrees,TreeMutableState,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeMutableState.cs,ToString,The following statement contains a magic number: return string.Format(@" Pages: {1:#'#}' Entries: {2:#'#}      Depth: {0}' FixedTreeFlags: {3}      Root Page: {4}      Leafs: {5:#'#} Overflow: {6:#'#} Branches: {7:#'#}      Size: {8:F2} Mb"' Depth' PageCount' NumberOfEntries' Flags' RootPageNumber' LeafPages' OverflowPages' BranchPages'       ((float)(PageCount * Constants.Storage.PageSize) / (1024 * 1024)));
Magic Number,Voron.Data.BTrees,TreeMutableState,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeMutableState.cs,ToString,The following statement contains a magic number: return string.Format(@" Pages: {1:#'#}' Entries: {2:#'#}      Depth: {0}' FixedTreeFlags: {3}      Root Page: {4}      Leafs: {5:#'#} Overflow: {6:#'#} Branches: {7:#'#}      Size: {8:F2} Mb"' Depth' PageCount' NumberOfEntries' Flags' RootPageNumber' LeafPages' OverflowPages' BranchPages'       ((float)(PageCount * Constants.Storage.PageSize) / (1024 * 1024)));
Magic Number,Voron.Data.BTrees,TreePage,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePage.cs,DebugValidate,The following statement contains a magic number: if (IsBranch && NumberOfEntries < 2)              {                  throw new InvalidOperationException("The branch page " + PageNumber + " has " + NumberOfEntries + " entry");              }
Magic Number,Voron.Data.BTrees,TreePageSplitter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePageSplitter.cs,OptimizedOnlyMoveNewValueToTheRightPage,The following statement contains a magic number: if (_page.IsBranch)              {                  if (_page.NumberOfEntries > 2)                  {                      // here we steal the last entry from the current page so we maintain the implicit null left entry                        TreeNodeHeader* node = _page.GetNode(_page.NumberOfEntries - 1);                      Debug.Assert(node->Flags == TreeNodeFlags.PageRef);                      rightPage.AddPageRefNode(0' Slices.BeforeAllKeys' node->PageNumber);                      pos = AddNodeToPage(rightPage' 1);                        Slice separatorKey;                      using (TreeNodeHeader.ToSlicePtr(_tx.Allocator' node' out separatorKey))                      {                          AddSeparatorToParentPage(rightPage.PageNumber' separatorKey' out branchOfSeparator);                      }                        _page.RemoveNode(_page.NumberOfEntries - 1);                  }                  else                  {                      _tree.FreePage(rightPage); // return the unnecessary right page                      pos = AddSeparatorToParentPage(_pageNumber' _newKey' out branchOfSeparator);                        if (_cursor.CurrentPage.PageNumber != branchOfSeparator.PageNumber)                          _cursor.Push(branchOfSeparator);                        return pos;                  }              }              else              {                  AddSeparatorToParentPage(rightPage.PageNumber' _newKey' out branchOfSeparator);                  pos = AddNodeToPage(rightPage' 0);              }
Magic Number,Voron.Data.BTrees,TreePageSplitter,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreePageSplitter.cs,SplitPageInHalf,The following statement contains a magic number: var splitIndex = _page.NumberOfEntries / 2;
Magic Number,Voron.Data.BTrees,TreeRebalancer,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeRebalancer.cs,Execute,The following statement contains a magic number: using (DisableFreeSpaceUsageIfSplittingRootTree())              {                  _tree.ClearPagesCache();                  if (_cursor.PageCount <= 1) // the root page                  {                      RebalanceRoot(page);                      return null;                  }                    _cursor.Pop();                    var parentPage = _tree.ModifyPage(_cursor.CurrentPage);                  _cursor.Update(_cursor.Pages' parentPage);                    if (page.NumberOfEntries == 0) // empty page' just delete it and fixup parent                  {                      // need to change the implicit left page                      if (parentPage.LastSearchPosition == 0 && parentPage.NumberOfEntries > 2)                      {                          var newImplicit = parentPage.GetNode(1)->PageNumber;                          parentPage.RemoveNode(0);                          parentPage.ChangeImplicitRefPageNode(newImplicit);                      }                      else // will be set to rights by the next rebalance call                      {                          parentPage.RemoveNode(parentPage.LastSearchPositionOrLastEntry);                      }                        _tree.FreePage(page);                        return parentPage;                  }                    if (page.IsBranch && page.NumberOfEntries == 1)                  {                      RemoveBranchWithOneEntry(page' parentPage);                        return parentPage;                  }                    var minKeys = page.IsBranch ? 2 : 1;                  if ((page.UseMoreSizeThan(_tx.DataPager.PageMinSpace)) && page.NumberOfEntries >= minKeys)                      return null; // above space/keys thresholds                    Debug.Assert(parentPage.NumberOfEntries >= 2); // if we have less than 2 entries in the parent' the tree is invalid                    var sibling = SetupMoveOrMerge(page' parentPage);                  Debug.Assert(sibling.PageNumber != page.PageNumber);                    if (page.TreeFlags != sibling.TreeFlags)                      return null;                    if (sibling.IsCompressed)                      return null;                                    Debug.Assert(page.IsCompressed == false);                    minKeys = sibling.IsBranch ? 2 : 1; // branch must have at least 2 keys                  if (sibling.UseMoreSizeThan(_tx.DataPager.PageMinSpace) &&                      sibling.NumberOfEntries > minKeys)                  {                      // neighbor is over the min size and has enough key' can move just one key to  the current page                      if (page.IsBranch)                          MoveBranchNode(parentPage' sibling' page);                      else                          MoveLeafNode(parentPage' sibling' page);                        return parentPage;                  }                                    if (page.LastSearchPosition == 0) // this is the right page' merge left                  {                      if (TryMergePages(parentPage' sibling' page) == false)                          return null;                  }                  else // this is the left page' merge right                  {                      if (TryMergePages(parentPage' page' sibling) == false)                          return null;                  }                    return parentPage;              }
Magic Number,Voron.Data.BTrees,TreeRebalancer,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeRebalancer.cs,Execute,The following statement contains a magic number: using (DisableFreeSpaceUsageIfSplittingRootTree())              {                  _tree.ClearPagesCache();                  if (_cursor.PageCount <= 1) // the root page                  {                      RebalanceRoot(page);                      return null;                  }                    _cursor.Pop();                    var parentPage = _tree.ModifyPage(_cursor.CurrentPage);                  _cursor.Update(_cursor.Pages' parentPage);                    if (page.NumberOfEntries == 0) // empty page' just delete it and fixup parent                  {                      // need to change the implicit left page                      if (parentPage.LastSearchPosition == 0 && parentPage.NumberOfEntries > 2)                      {                          var newImplicit = parentPage.GetNode(1)->PageNumber;                          parentPage.RemoveNode(0);                          parentPage.ChangeImplicitRefPageNode(newImplicit);                      }                      else // will be set to rights by the next rebalance call                      {                          parentPage.RemoveNode(parentPage.LastSearchPositionOrLastEntry);                      }                        _tree.FreePage(page);                        return parentPage;                  }                    if (page.IsBranch && page.NumberOfEntries == 1)                  {                      RemoveBranchWithOneEntry(page' parentPage);                        return parentPage;                  }                    var minKeys = page.IsBranch ? 2 : 1;                  if ((page.UseMoreSizeThan(_tx.DataPager.PageMinSpace)) && page.NumberOfEntries >= minKeys)                      return null; // above space/keys thresholds                    Debug.Assert(parentPage.NumberOfEntries >= 2); // if we have less than 2 entries in the parent' the tree is invalid                    var sibling = SetupMoveOrMerge(page' parentPage);                  Debug.Assert(sibling.PageNumber != page.PageNumber);                    if (page.TreeFlags != sibling.TreeFlags)                      return null;                    if (sibling.IsCompressed)                      return null;                                    Debug.Assert(page.IsCompressed == false);                    minKeys = sibling.IsBranch ? 2 : 1; // branch must have at least 2 keys                  if (sibling.UseMoreSizeThan(_tx.DataPager.PageMinSpace) &&                      sibling.NumberOfEntries > minKeys)                  {                      // neighbor is over the min size and has enough key' can move just one key to  the current page                      if (page.IsBranch)                          MoveBranchNode(parentPage' sibling' page);                      else                          MoveLeafNode(parentPage' sibling' page);                        return parentPage;                  }                                    if (page.LastSearchPosition == 0) // this is the right page' merge left                  {                      if (TryMergePages(parentPage' sibling' page) == false)                          return null;                  }                  else // this is the left page' merge right                  {                      if (TryMergePages(parentPage' page' sibling) == false)                          return null;                  }                    return parentPage;              }
Magic Number,Voron.Data.BTrees,TreeRebalancer,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeRebalancer.cs,Execute,The following statement contains a magic number: using (DisableFreeSpaceUsageIfSplittingRootTree())              {                  _tree.ClearPagesCache();                  if (_cursor.PageCount <= 1) // the root page                  {                      RebalanceRoot(page);                      return null;                  }                    _cursor.Pop();                    var parentPage = _tree.ModifyPage(_cursor.CurrentPage);                  _cursor.Update(_cursor.Pages' parentPage);                    if (page.NumberOfEntries == 0) // empty page' just delete it and fixup parent                  {                      // need to change the implicit left page                      if (parentPage.LastSearchPosition == 0 && parentPage.NumberOfEntries > 2)                      {                          var newImplicit = parentPage.GetNode(1)->PageNumber;                          parentPage.RemoveNode(0);                          parentPage.ChangeImplicitRefPageNode(newImplicit);                      }                      else // will be set to rights by the next rebalance call                      {                          parentPage.RemoveNode(parentPage.LastSearchPositionOrLastEntry);                      }                        _tree.FreePage(page);                        return parentPage;                  }                    if (page.IsBranch && page.NumberOfEntries == 1)                  {                      RemoveBranchWithOneEntry(page' parentPage);                        return parentPage;                  }                    var minKeys = page.IsBranch ? 2 : 1;                  if ((page.UseMoreSizeThan(_tx.DataPager.PageMinSpace)) && page.NumberOfEntries >= minKeys)                      return null; // above space/keys thresholds                    Debug.Assert(parentPage.NumberOfEntries >= 2); // if we have less than 2 entries in the parent' the tree is invalid                    var sibling = SetupMoveOrMerge(page' parentPage);                  Debug.Assert(sibling.PageNumber != page.PageNumber);                    if (page.TreeFlags != sibling.TreeFlags)                      return null;                    if (sibling.IsCompressed)                      return null;                                    Debug.Assert(page.IsCompressed == false);                    minKeys = sibling.IsBranch ? 2 : 1; // branch must have at least 2 keys                  if (sibling.UseMoreSizeThan(_tx.DataPager.PageMinSpace) &&                      sibling.NumberOfEntries > minKeys)                  {                      // neighbor is over the min size and has enough key' can move just one key to  the current page                      if (page.IsBranch)                          MoveBranchNode(parentPage' sibling' page);                      else                          MoveLeafNode(parentPage' sibling' page);                        return parentPage;                  }                                    if (page.LastSearchPosition == 0) // this is the right page' merge left                  {                      if (TryMergePages(parentPage' sibling' page) == false)                          return null;                  }                  else // this is the left page' merge right                  {                      if (TryMergePages(parentPage' page' sibling) == false)                          return null;                  }                    return parentPage;              }
Magic Number,Voron.Data.BTrees,TreeRebalancer,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeRebalancer.cs,Execute,The following statement contains a magic number: using (DisableFreeSpaceUsageIfSplittingRootTree())              {                  _tree.ClearPagesCache();                  if (_cursor.PageCount <= 1) // the root page                  {                      RebalanceRoot(page);                      return null;                  }                    _cursor.Pop();                    var parentPage = _tree.ModifyPage(_cursor.CurrentPage);                  _cursor.Update(_cursor.Pages' parentPage);                    if (page.NumberOfEntries == 0) // empty page' just delete it and fixup parent                  {                      // need to change the implicit left page                      if (parentPage.LastSearchPosition == 0 && parentPage.NumberOfEntries > 2)                      {                          var newImplicit = parentPage.GetNode(1)->PageNumber;                          parentPage.RemoveNode(0);                          parentPage.ChangeImplicitRefPageNode(newImplicit);                      }                      else // will be set to rights by the next rebalance call                      {                          parentPage.RemoveNode(parentPage.LastSearchPositionOrLastEntry);                      }                        _tree.FreePage(page);                        return parentPage;                  }                    if (page.IsBranch && page.NumberOfEntries == 1)                  {                      RemoveBranchWithOneEntry(page' parentPage);                        return parentPage;                  }                    var minKeys = page.IsBranch ? 2 : 1;                  if ((page.UseMoreSizeThan(_tx.DataPager.PageMinSpace)) && page.NumberOfEntries >= minKeys)                      return null; // above space/keys thresholds                    Debug.Assert(parentPage.NumberOfEntries >= 2); // if we have less than 2 entries in the parent' the tree is invalid                    var sibling = SetupMoveOrMerge(page' parentPage);                  Debug.Assert(sibling.PageNumber != page.PageNumber);                    if (page.TreeFlags != sibling.TreeFlags)                      return null;                    if (sibling.IsCompressed)                      return null;                                    Debug.Assert(page.IsCompressed == false);                    minKeys = sibling.IsBranch ? 2 : 1; // branch must have at least 2 keys                  if (sibling.UseMoreSizeThan(_tx.DataPager.PageMinSpace) &&                      sibling.NumberOfEntries > minKeys)                  {                      // neighbor is over the min size and has enough key' can move just one key to  the current page                      if (page.IsBranch)                          MoveBranchNode(parentPage' sibling' page);                      else                          MoveLeafNode(parentPage' sibling' page);                        return parentPage;                  }                                    if (page.LastSearchPosition == 0) // this is the right page' merge left                  {                      if (TryMergePages(parentPage' sibling' page) == false)                          return null;                  }                  else // this is the left page' merge right                  {                      if (TryMergePages(parentPage' page' sibling) == false)                          return null;                  }                    return parentPage;              }
Magic Number,Voron.Data.BTrees,TreeRebalancer,C:\repos\ravendb_ravendb\src\Voron\Data\BTrees\TreeRebalancer.cs,MoveBranchNode,The following statement contains a magic number: if (from.LastSearchPositionOrLastEntry == 0)              {                  var rightPageNumber = from.GetNode(1)->PageNumber;                  from.RemoveNode(0); // remove the original implicit node                  from.ChangeImplicitRefPageNode(rightPageNumber); // setup the new implicit node                  Debug.Assert(from.NumberOfEntries >= 2);              }              else              {                  from.RemoveNode(from.LastSearchPositionOrLastEntry);              }
Magic Number,Voron.Impl,EncryptionBuffersPool,C:\repos\ravendb_ravendb\src\Voron\Impl\EncryptionBuffersPool.cs,EncryptionBuffersPool,The following statement contains a magic number: _items = new ConcurrentStack<NativeAllocation>[32];
Magic Number,Voron.Impl,EncryptionBuffersPool,C:\repos\ravendb_ravendb\src\Voron\Impl\EncryptionBuffersPool.cs,Get,The following statement contains a magic number: if (size > Constants.Size.Megabyte * 16)              {                  // We don't want to pool large buffers                  return NativeMemory.Allocate4KbAlignedMemory(size' out thread);              }
Magic Number,Voron.Impl,EncryptionBuffersPool,C:\repos\ravendb_ravendb\src\Voron\Impl\EncryptionBuffersPool.cs,Return,The following statement contains a magic number: if (size > Constants.Size.Megabyte * 16)              {                  // We don't want to pool large buffers                  NativeMemory.Free4KbAlignedMemory(ptr' size' allocatingThread);                  return;              }
Magic Number,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,AllocateOverflowRawPage,The following statement contains a magic number: if (overflowSize > int.MaxValue - 1)                  throw new InvalidOperationException($"Cannot allocate chunks bigger than { int.MaxValue / 1024 * 1024 } Mb.");
Magic Number,Voron.Impl,LowLevelTransaction,C:\repos\ravendb_ravendb\src\Voron\Impl\LowLevelTransaction.cs,AllocateOverflowRawPage,The following statement contains a magic number: if (overflowSize > int.MaxValue - 1)                  throw new InvalidOperationException($"Cannot allocate chunks bigger than { int.MaxValue / 1024 * 1024 } Mb.");
Magic Number,Voron.Impl,TreeAndSliceComparer,C:\repos\ravendb_ravendb\src\Voron\Impl\TreeAndSliceComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Item1.GetHashCode() ^ 397 * obj.Item2.GetHashCode();
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,FixedSizeTree,The following statement contains a magic number: _maxEmbeddedEntries = (Constants.Storage.PageSize / 8) / _entrySize;
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,ThrowInvalidFixedTreeValueSize,The following statement contains a magic number: throw new ArgumentException("The value size must be small than " + (Constants.Storage.PageSize / 8));
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,PageSplit,The following statement contains a magic number: if (page.IsLeaf) // simple case of splitting a leaf pageNum              {                  var newPage = NewPage(FixedSizeTreePageFlags.Leaf' page.PageNumber);                  newPage.StartPosition = (ushort)Constants.FixedSizeTree.PageHeaderSize;                  newPage.ValueSize = _valSize;                  newPage.NumberOfEntries = 0;                    long separatorKey;                  FixedSizeTreeHeader.Large* largePtr;                  using (ModifyLargeHeader(out largePtr))                  {                      largePtr->PageCount++;                        // need to add past end of pageNum' optimized                      if (page.LastSearchPosition >= page.NumberOfEntries)                      {                          AddLeafKey(newPage' 0' key);                          largePtr->NumberOfEntries++;                            separatorKey = key;                      }                      else // not at end' random inserts' split page 3/4 to 1/4                      {                          var entriesToMove = (ushort)(page.NumberOfEntries / 4);                          newPage.NumberOfEntries = entriesToMove;                          page.NumberOfEntries -= entriesToMove;                          Memory.Copy(newPage.Pointer + newPage.StartPosition'                              page.Pointer + page.StartPosition + (page.NumberOfEntries * _entrySize)'                              newPage.NumberOfEntries * _entrySize                          );                            separatorKey = newPage.GetKey(0);                      }                  }                    AddSeparatorToParentPage(parentPage' parentPage.LastSearchPosition + 1' separatorKey' newPage.PageNumber);                  return null; // we don't care about it for leaf pages              }              else // branch page              {                  var newPage = NewPage(FixedSizeTreePageFlags.Branch' page.PageNumber);                  newPage.StartPosition = (ushort)Constants.FixedSizeTree.PageHeaderSize;                  newPage.ValueSize = _valSize;                  newPage.NumberOfEntries = 0;                    FixedSizeTreeHeader.Large* largePtr;                  using (ModifyLargeHeader(out largePtr))                  {                      largePtr->PageCount++;                  }                    if (page.LastMatch > 0)                      page.LastSearchPosition++;                    // need to add past end of pageNum' optimized                  if (page.LastSearchPosition >= page.NumberOfEntries)                  {                      // here we steal the last entry from the current page so we maintain the implicit null left entry                      var entry = newPage.GetEntry(0);                      *entry = *page.GetEntry(page.NumberOfEntries - 1);                        newPage.NumberOfEntries++;                      page.NumberOfEntries--;                        AddSeparatorToParentPage(parentPage' parentPage.LastSearchPosition + 1' entry->Key'                          newPage.PageNumber);                        return newPage; // this is where the new entry needs to go                  }                  // not at end' random inserts' split page 3/4 to 1/4                    var entriesToMove = (ushort)(page.NumberOfEntries / 4);                  newPage.NumberOfEntries = entriesToMove;                  page.NumberOfEntries -= entriesToMove;                  Memory.Copy(newPage.Pointer + newPage.StartPosition'                      page.Pointer + page.StartPosition + (page.NumberOfEntries * BranchEntrySize)'                      newPage.NumberOfEntries * BranchEntrySize                      );                    var newKey = newPage.GetKey(0);                    AddSeparatorToParentPage(parentPage' parentPage.LastSearchPosition + 1' newKey' newPage.PageNumber);                    return (newKey > key) ? page : newPage;              }
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,PageSplit,The following statement contains a magic number: if (page.IsLeaf) // simple case of splitting a leaf pageNum              {                  var newPage = NewPage(FixedSizeTreePageFlags.Leaf' page.PageNumber);                  newPage.StartPosition = (ushort)Constants.FixedSizeTree.PageHeaderSize;                  newPage.ValueSize = _valSize;                  newPage.NumberOfEntries = 0;                    long separatorKey;                  FixedSizeTreeHeader.Large* largePtr;                  using (ModifyLargeHeader(out largePtr))                  {                      largePtr->PageCount++;                        // need to add past end of pageNum' optimized                      if (page.LastSearchPosition >= page.NumberOfEntries)                      {                          AddLeafKey(newPage' 0' key);                          largePtr->NumberOfEntries++;                            separatorKey = key;                      }                      else // not at end' random inserts' split page 3/4 to 1/4                      {                          var entriesToMove = (ushort)(page.NumberOfEntries / 4);                          newPage.NumberOfEntries = entriesToMove;                          page.NumberOfEntries -= entriesToMove;                          Memory.Copy(newPage.Pointer + newPage.StartPosition'                              page.Pointer + page.StartPosition + (page.NumberOfEntries * _entrySize)'                              newPage.NumberOfEntries * _entrySize                          );                            separatorKey = newPage.GetKey(0);                      }                  }                    AddSeparatorToParentPage(parentPage' parentPage.LastSearchPosition + 1' separatorKey' newPage.PageNumber);                  return null; // we don't care about it for leaf pages              }              else // branch page              {                  var newPage = NewPage(FixedSizeTreePageFlags.Branch' page.PageNumber);                  newPage.StartPosition = (ushort)Constants.FixedSizeTree.PageHeaderSize;                  newPage.ValueSize = _valSize;                  newPage.NumberOfEntries = 0;                    FixedSizeTreeHeader.Large* largePtr;                  using (ModifyLargeHeader(out largePtr))                  {                      largePtr->PageCount++;                  }                    if (page.LastMatch > 0)                      page.LastSearchPosition++;                    // need to add past end of pageNum' optimized                  if (page.LastSearchPosition >= page.NumberOfEntries)                  {                      // here we steal the last entry from the current page so we maintain the implicit null left entry                      var entry = newPage.GetEntry(0);                      *entry = *page.GetEntry(page.NumberOfEntries - 1);                        newPage.NumberOfEntries++;                      page.NumberOfEntries--;                        AddSeparatorToParentPage(parentPage' parentPage.LastSearchPosition + 1' entry->Key'                          newPage.PageNumber);                        return newPage; // this is where the new entry needs to go                  }                  // not at end' random inserts' split page 3/4 to 1/4                    var entriesToMove = (ushort)(page.NumberOfEntries / 4);                  newPage.NumberOfEntries = entriesToMove;                  page.NumberOfEntries -= entriesToMove;                  Memory.Copy(newPage.Pointer + newPage.StartPosition'                      page.Pointer + page.StartPosition + (page.NumberOfEntries * BranchEntrySize)'                      newPage.NumberOfEntries * BranchEntrySize                      );                    var newKey = newPage.GetKey(0);                    AddSeparatorToParentPage(parentPage' parentPage.LastSearchPosition + 1' newKey' newPage.PageNumber);                    return (newKey > key) ? page : newPage;              }
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RebalancePage,The following statement contains a magic number: var minNumberOfEntriesBeforeRebalance = (Constants.Storage.PageSize / sizeOfEntryInPage) / 4;
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RebalancePage,The following statement contains a magic number: if (page.NumberOfEntries == 0)// empty page' delete it and fixup the parent              {                  // fixup the implicit less than ref                  if (parentPage.LastSearchPosition == 0                      // if we are 2 or less' we'll remove our entry and the parent page                       // page will rebalance in turn' so we shouldn't modify the relevant                      // entry                      && parentPage.NumberOfEntries > 2)                   {                      parentPage.NumberOfEntries--;                      // remove the first value                      parentPage.StartPosition += BranchEntrySize;                      // set the next value (now the first)' to be smaller than everything                      parentPage.SetKey(long.MinValue' 0);                  }                  else                  {                      // need to remove from midway through. At any rate' we'll rebalance on next call                      parentPage.RemoveEntry(parentPage.LastSearchPosition);                  }                  FreePage(page.PageNumber);                                    return parentPage;              }
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RebalancePage,The following statement contains a magic number: System.Diagnostics.Debug.Assert(parentPage.NumberOfEntries >= 2);
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RebalancePage,The following statement contains a magic number: if (parentPage.LastSearchPosition == 0)              {                  // the current page is the leftmost one' so let us try steal some data                  // from the one on the right                  var siblingNum = parentPage.GetEntry(1)->PageNumber;                  var siblingPage = GetReadOnlyPage(siblingNum);                  if (siblingPage.FixedTreeFlags != page.FixedTreeFlags)                      return null; // we cannot steal from a leaf sibling if we are branch' or vice versa                    siblingPage = ModifyPage(siblingPage);                    if (siblingPage.NumberOfEntries <= minNumberOfEntriesBeforeRebalance * 2)                  {                      // we can merge both pages into a single one and still have enough over                      page.ResetStartPosition();                      Memory.Copy(                          page.Pointer + page.StartPosition + (page.NumberOfEntries * sizeOfEntryInPage)'                          siblingPage.Pointer + siblingPage.StartPosition'                          siblingPage.NumberOfEntries * sizeOfEntryInPage                          );                      page.NumberOfEntries += siblingPage.NumberOfEntries;                        FreePage(siblingNum);                        // now fix parent ref' in this case' just removing it is enough                      parentPage.RemoveEntry(1);                        return parentPage;                  }                  // too big to just merge' let just take half of the sibling and move on                  var entriesToTake = (siblingPage.NumberOfEntries / 2);                  page.ResetStartPosition();                  Memory.Copy(                      page.Pointer + page.StartPosition + (page.NumberOfEntries * sizeOfEntryInPage)'                      siblingPage.Pointer + siblingPage.StartPosition'                      entriesToTake * sizeOfEntryInPage                      );                  page.NumberOfEntries += (ushort)entriesToTake;                  siblingPage.NumberOfEntries -= (ushort)entriesToTake;                  siblingPage.StartPosition += (ushort)(sizeOfEntryInPage * entriesToTake);                    // now update the new separator in the sibling position in the parent                  var newSeparator = siblingPage.GetKey(0);                  parentPage.SetKey(newSeparator' 1);                    return parentPage;              }              else // we aren't the leftmost item' so we will take from the page on our left              {                  var siblingNum = parentPage.GetEntry(parentPage.LastSearchPosition - 1)->PageNumber;                  var siblingPage = GetReadOnlyPage(siblingNum);                  siblingPage = ModifyPage(siblingPage);                  if (siblingPage.FixedTreeFlags != page.FixedTreeFlags)                      return null; // we cannot steal from a leaf sibling if we are branch' or vice versa                    if (siblingPage.NumberOfEntries <= minNumberOfEntriesBeforeRebalance * 2)                  {                      // we can merge both pages into a single one and still have enough over                      siblingPage.ResetStartPosition();                      Memory.Copy(                          siblingPage.Pointer + siblingPage.StartPosition + (siblingPage.NumberOfEntries * sizeOfEntryInPage)'                          page.Pointer + page.StartPosition'                          page.NumberOfEntries * sizeOfEntryInPage                          );                      siblingPage.NumberOfEntries += page.NumberOfEntries;                        FreePage(page.PageNumber);                        // now fix parent ref' in this case' just removing it is enough                      parentPage.RemoveEntry(parentPage.LastSearchPosition);                        return parentPage;                  }                  // too big to just merge' let just take half of the sibling and move on                  var entriesToTake = (siblingPage.NumberOfEntries / 2);                  page.ResetStartPosition();                    if (page.IsBranch)                  {                      // if we are a branch page and we copy items from our left we need to make                      // sure that the implicit left entry is fixed. We do that by copying the                      // entry our parent has for us as the leftmost entry for our current state                      // and then we copy the entries to our left                      page.SetKey(parentPage.GetKey(parentPage.LastSearchPosition)'0);                  }                                    UnmanagedMemory.Move(page.Pointer + page.StartPosition + (entriesToTake * sizeOfEntryInPage)'                      page.Pointer + page.StartPosition'                      entriesToTake * sizeOfEntryInPage);                    Memory.Copy(                      page.Pointer + page.StartPosition'                      siblingPage.Pointer + siblingPage.StartPosition + ((siblingPage.NumberOfEntries - entriesToTake) * sizeOfEntryInPage)'                      entriesToTake * sizeOfEntryInPage                      );                  page.NumberOfEntries += (ushort)entriesToTake;                  siblingPage.NumberOfEntries -= (ushort)entriesToTake;                    // now update the new separator in the parent                    var newSeparator = page.GetKey(0);                  parentPage.SetKey(newSeparator' parentPage.LastSearchPosition);                    return parentPage;              }
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RebalancePage,The following statement contains a magic number: if (parentPage.LastSearchPosition == 0)              {                  // the current page is the leftmost one' so let us try steal some data                  // from the one on the right                  var siblingNum = parentPage.GetEntry(1)->PageNumber;                  var siblingPage = GetReadOnlyPage(siblingNum);                  if (siblingPage.FixedTreeFlags != page.FixedTreeFlags)                      return null; // we cannot steal from a leaf sibling if we are branch' or vice versa                    siblingPage = ModifyPage(siblingPage);                    if (siblingPage.NumberOfEntries <= minNumberOfEntriesBeforeRebalance * 2)                  {                      // we can merge both pages into a single one and still have enough over                      page.ResetStartPosition();                      Memory.Copy(                          page.Pointer + page.StartPosition + (page.NumberOfEntries * sizeOfEntryInPage)'                          siblingPage.Pointer + siblingPage.StartPosition'                          siblingPage.NumberOfEntries * sizeOfEntryInPage                          );                      page.NumberOfEntries += siblingPage.NumberOfEntries;                        FreePage(siblingNum);                        // now fix parent ref' in this case' just removing it is enough                      parentPage.RemoveEntry(1);                        return parentPage;                  }                  // too big to just merge' let just take half of the sibling and move on                  var entriesToTake = (siblingPage.NumberOfEntries / 2);                  page.ResetStartPosition();                  Memory.Copy(                      page.Pointer + page.StartPosition + (page.NumberOfEntries * sizeOfEntryInPage)'                      siblingPage.Pointer + siblingPage.StartPosition'                      entriesToTake * sizeOfEntryInPage                      );                  page.NumberOfEntries += (ushort)entriesToTake;                  siblingPage.NumberOfEntries -= (ushort)entriesToTake;                  siblingPage.StartPosition += (ushort)(sizeOfEntryInPage * entriesToTake);                    // now update the new separator in the sibling position in the parent                  var newSeparator = siblingPage.GetKey(0);                  parentPage.SetKey(newSeparator' 1);                    return parentPage;              }              else // we aren't the leftmost item' so we will take from the page on our left              {                  var siblingNum = parentPage.GetEntry(parentPage.LastSearchPosition - 1)->PageNumber;                  var siblingPage = GetReadOnlyPage(siblingNum);                  siblingPage = ModifyPage(siblingPage);                  if (siblingPage.FixedTreeFlags != page.FixedTreeFlags)                      return null; // we cannot steal from a leaf sibling if we are branch' or vice versa                    if (siblingPage.NumberOfEntries <= minNumberOfEntriesBeforeRebalance * 2)                  {                      // we can merge both pages into a single one and still have enough over                      siblingPage.ResetStartPosition();                      Memory.Copy(                          siblingPage.Pointer + siblingPage.StartPosition + (siblingPage.NumberOfEntries * sizeOfEntryInPage)'                          page.Pointer + page.StartPosition'                          page.NumberOfEntries * sizeOfEntryInPage                          );                      siblingPage.NumberOfEntries += page.NumberOfEntries;                        FreePage(page.PageNumber);                        // now fix parent ref' in this case' just removing it is enough                      parentPage.RemoveEntry(parentPage.LastSearchPosition);                        return parentPage;                  }                  // too big to just merge' let just take half of the sibling and move on                  var entriesToTake = (siblingPage.NumberOfEntries / 2);                  page.ResetStartPosition();                    if (page.IsBranch)                  {                      // if we are a branch page and we copy items from our left we need to make                      // sure that the implicit left entry is fixed. We do that by copying the                      // entry our parent has for us as the leftmost entry for our current state                      // and then we copy the entries to our left                      page.SetKey(parentPage.GetKey(parentPage.LastSearchPosition)'0);                  }                                    UnmanagedMemory.Move(page.Pointer + page.StartPosition + (entriesToTake * sizeOfEntryInPage)'                      page.Pointer + page.StartPosition'                      entriesToTake * sizeOfEntryInPage);                    Memory.Copy(                      page.Pointer + page.StartPosition'                      siblingPage.Pointer + siblingPage.StartPosition + ((siblingPage.NumberOfEntries - entriesToTake) * sizeOfEntryInPage)'                      entriesToTake * sizeOfEntryInPage                      );                  page.NumberOfEntries += (ushort)entriesToTake;                  siblingPage.NumberOfEntries -= (ushort)entriesToTake;                    // now update the new separator in the parent                    var newSeparator = page.GetKey(0);                  parentPage.SetKey(newSeparator' parentPage.LastSearchPosition);                    return parentPage;              }
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RebalancePage,The following statement contains a magic number: if (parentPage.LastSearchPosition == 0)              {                  // the current page is the leftmost one' so let us try steal some data                  // from the one on the right                  var siblingNum = parentPage.GetEntry(1)->PageNumber;                  var siblingPage = GetReadOnlyPage(siblingNum);                  if (siblingPage.FixedTreeFlags != page.FixedTreeFlags)                      return null; // we cannot steal from a leaf sibling if we are branch' or vice versa                    siblingPage = ModifyPage(siblingPage);                    if (siblingPage.NumberOfEntries <= minNumberOfEntriesBeforeRebalance * 2)                  {                      // we can merge both pages into a single one and still have enough over                      page.ResetStartPosition();                      Memory.Copy(                          page.Pointer + page.StartPosition + (page.NumberOfEntries * sizeOfEntryInPage)'                          siblingPage.Pointer + siblingPage.StartPosition'                          siblingPage.NumberOfEntries * sizeOfEntryInPage                          );                      page.NumberOfEntries += siblingPage.NumberOfEntries;                        FreePage(siblingNum);                        // now fix parent ref' in this case' just removing it is enough                      parentPage.RemoveEntry(1);                        return parentPage;                  }                  // too big to just merge' let just take half of the sibling and move on                  var entriesToTake = (siblingPage.NumberOfEntries / 2);                  page.ResetStartPosition();                  Memory.Copy(                      page.Pointer + page.StartPosition + (page.NumberOfEntries * sizeOfEntryInPage)'                      siblingPage.Pointer + siblingPage.StartPosition'                      entriesToTake * sizeOfEntryInPage                      );                  page.NumberOfEntries += (ushort)entriesToTake;                  siblingPage.NumberOfEntries -= (ushort)entriesToTake;                  siblingPage.StartPosition += (ushort)(sizeOfEntryInPage * entriesToTake);                    // now update the new separator in the sibling position in the parent                  var newSeparator = siblingPage.GetKey(0);                  parentPage.SetKey(newSeparator' 1);                    return parentPage;              }              else // we aren't the leftmost item' so we will take from the page on our left              {                  var siblingNum = parentPage.GetEntry(parentPage.LastSearchPosition - 1)->PageNumber;                  var siblingPage = GetReadOnlyPage(siblingNum);                  siblingPage = ModifyPage(siblingPage);                  if (siblingPage.FixedTreeFlags != page.FixedTreeFlags)                      return null; // we cannot steal from a leaf sibling if we are branch' or vice versa                    if (siblingPage.NumberOfEntries <= minNumberOfEntriesBeforeRebalance * 2)                  {                      // we can merge both pages into a single one and still have enough over                      siblingPage.ResetStartPosition();                      Memory.Copy(                          siblingPage.Pointer + siblingPage.StartPosition + (siblingPage.NumberOfEntries * sizeOfEntryInPage)'                          page.Pointer + page.StartPosition'                          page.NumberOfEntries * sizeOfEntryInPage                          );                      siblingPage.NumberOfEntries += page.NumberOfEntries;                        FreePage(page.PageNumber);                        // now fix parent ref' in this case' just removing it is enough                      parentPage.RemoveEntry(parentPage.LastSearchPosition);                        return parentPage;                  }                  // too big to just merge' let just take half of the sibling and move on                  var entriesToTake = (siblingPage.NumberOfEntries / 2);                  page.ResetStartPosition();                    if (page.IsBranch)                  {                      // if we are a branch page and we copy items from our left we need to make                      // sure that the implicit left entry is fixed. We do that by copying the                      // entry our parent has for us as the leftmost entry for our current state                      // and then we copy the entries to our left                      page.SetKey(parentPage.GetKey(parentPage.LastSearchPosition)'0);                  }                                    UnmanagedMemory.Move(page.Pointer + page.StartPosition + (entriesToTake * sizeOfEntryInPage)'                      page.Pointer + page.StartPosition'                      entriesToTake * sizeOfEntryInPage);                    Memory.Copy(                      page.Pointer + page.StartPosition'                      siblingPage.Pointer + siblingPage.StartPosition + ((siblingPage.NumberOfEntries - entriesToTake) * sizeOfEntryInPage)'                      entriesToTake * sizeOfEntryInPage                      );                  page.NumberOfEntries += (ushort)entriesToTake;                  siblingPage.NumberOfEntries -= (ushort)entriesToTake;                    // now update the new separator in the parent                    var newSeparator = page.GetKey(0);                  parentPage.SetKey(newSeparator' parentPage.LastSearchPosition);                    return parentPage;              }
Magic Number,Voron.Data.Fixed,FixedSizeTree,C:\repos\ravendb_ravendb\src\Voron\Data\Fixed\FixedSizeIterators.cs,RebalancePage,The following statement contains a magic number: if (parentPage.LastSearchPosition == 0)              {                  // the current page is the leftmost one' so let us try steal some data                  // from the one on the right                  var siblingNum = parentPage.GetEntry(1)->PageNumber;                  var siblingPage = GetReadOnlyPage(siblingNum);                  if (siblingPage.FixedTreeFlags != page.FixedTreeFlags)                      return null; // we cannot steal from a leaf sibling if we are branch' or vice versa                    siblingPage = ModifyPage(siblingPage);                    if (siblingPage.NumberOfEntries <= minNumberOfEntriesBeforeRebalance * 2)                  {                      // we can merge both pages into a single one and still have enough over                      page.ResetStartPosition();                      Memory.Copy(                          page.Pointer + page.StartPosition + (page.NumberOfEntries * sizeOfEntryInPage)'                          siblingPage.Pointer + siblingPage.StartPosition'                          siblingPage.NumberOfEntries * sizeOfEntryInPage                          );                      page.NumberOfEntries += siblingPage.NumberOfEntries;                        FreePage(siblingNum);                        // now fix parent ref' in this case' just removing it is enough                      parentPage.RemoveEntry(1);                        return parentPage;                  }                  // too big to just merge' let just take half of the sibling and move on                  var entriesToTake = (siblingPage.NumberOfEntries / 2);                  page.ResetStartPosition();                  Memory.Copy(                      page.Pointer + page.StartPosition + (page.NumberOfEntries * sizeOfEntryInPage)'                      siblingPage.Pointer + siblingPage.StartPosition'                      entriesToTake * sizeOfEntryInPage                      );                  page.NumberOfEntries += (ushort)entriesToTake;                  siblingPage.NumberOfEntries -= (ushort)entriesToTake;                  siblingPage.StartPosition += (ushort)(sizeOfEntryInPage * entriesToTake);                    // now update the new separator in the sibling position in the parent                  var newSeparator = siblingPage.GetKey(0);                  parentPage.SetKey(newSeparator' 1);                    return parentPage;              }              else // we aren't the leftmost item' so we will take from the page on our left              {                  var siblingNum = parentPage.GetEntry(parentPage.LastSearchPosition - 1)->PageNumber;                  var siblingPage = GetReadOnlyPage(siblingNum);                  siblingPage = ModifyPage(siblingPage);                  if (siblingPage.FixedTreeFlags != page.FixedTreeFlags)                      return null; // we cannot steal from a leaf sibling if we are branch' or vice versa                    if (siblingPage.NumberOfEntries <= minNumberOfEntriesBeforeRebalance * 2)                  {                      // we can merge both pages into a single one and still have enough over                      siblingPage.ResetStartPosition();                      Memory.Copy(                          siblingPage.Pointer + siblingPage.StartPosition + (siblingPage.NumberOfEntries * sizeOfEntryInPage)'                          page.Pointer + page.StartPosition'                          page.NumberOfEntries * sizeOfEntryInPage                          );                      siblingPage.NumberOfEntries += page.NumberOfEntries;                        FreePage(page.PageNumber);                        // now fix parent ref' in this case' just removing it is enough                      parentPage.RemoveEntry(parentPage.LastSearchPosition);                        return parentPage;                  }                  // too big to just merge' let just take half of the sibling and move on                  var entriesToTake = (siblingPage.NumberOfEntries / 2);                  page.ResetStartPosition();                    if (page.IsBranch)                  {                      // if we are a branch page and we copy items from our left we need to make                      // sure that the implicit left entry is fixed. We do that by copying the                      // entry our parent has for us as the leftmost entry for our current state                      // and then we copy the entries to our left                      page.SetKey(parentPage.GetKey(parentPage.LastSearchPosition)'0);                  }                                    UnmanagedMemory.Move(page.Pointer + page.StartPosition + (entriesToTake * sizeOfEntryInPage)'                      page.Pointer + page.StartPosition'                      entriesToTake * sizeOfEntryInPage);                    Memory.Copy(                      page.Pointer + page.StartPosition'                      siblingPage.Pointer + siblingPage.StartPosition + ((siblingPage.NumberOfEntries - entriesToTake) * sizeOfEntryInPage)'                      entriesToTake * sizeOfEntryInPage                      );                  page.NumberOfEntries += (ushort)entriesToTake;                  siblingPage.NumberOfEntries -= (ushort)entriesToTake;                    // now update the new separator in the parent                    var newSeparator = page.GetKey(0);                  parentPage.SetKey(newSeparator' parentPage.LastSearchPosition);                    return parentPage;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,Create,The following statement contains a magic number: Debug.Assert((numberOfPagesInSmallSection * 2) + ReservedHeaderSpace <= Constants.Storage.PageSize);
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 32) // 256 MB               {                  // roughly 16 MB                  return (Constants.Storage.PageSize - ReservedHeaderSpace) / 2;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 32) // 256 MB               {                  // roughly 16 MB                  return (Constants.Storage.PageSize - ReservedHeaderSpace) / 2;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 32) // 256 MB               {                  // roughly 16 MB                  return (Constants.Storage.PageSize - ReservedHeaderSpace) / 2;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 16) // 64 MB              {                  // 8 MB                  return 1024;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 16) // 64 MB              {                  // 8 MB                  return 1024;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 16) // 64 MB              {                  // 8 MB                  return 1024;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 8) // 32 MB              {                  // 4 MB                  return 512;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 8) // 32 MB              {                  // 4 MB                  return 512;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 8) // 32 MB              {                  // 4 MB                  return 512;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 4) // 16 MB              {                  // 2 MB                  return 128;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 4) // 16 MB              {                  // 2 MB                  return 128;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: if (tx.DataPager.NumberOfAllocatedPages > 1024 * 4) // 16 MB              {                  // 2 MB                  return 128;              }
Magic Number,Voron.Data.RawData,ActiveRawDataSmallSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\ActiveRawDataSmallSection.cs,GetNumberOfPagesInSmallSection,The following statement contains a magic number: return 32;
Magic Number,Voron.Data.RawData,RawDataSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\RawDataSection.cs,FillAllIdsInPage,The following statement contains a magic number: while (offset + sizeof(RawDataEntrySizes) < Constants.Storage.PageSize)              {                  var sizes = (RawDataEntrySizes*)((byte*)pageHeader + offset);                  if (sizes->UsedSize != -1)                  {                      var currentId = (pageHeader->PageNumber * Constants.Storage.PageSize) + offset;                        var posInPage = (int)(currentId % Constants.Storage.PageSize);                        if (posInPage >= pageHeader->NextAllocation)                          break;                        ids.Add(currentId);                        if (ids.Count == _sectionHeader->NumberOfEntries)                          break;                  }                  offset += sizeof(short) * 2 + sizes->AllocatedSize;              }
Magic Number,Voron.Data.RawData,RawDataSection,C:\repos\ravendb_ravendb\src\Voron\Data\RawData\RawDataSection.cs,Free,The following statement contains a magic number: var sizeFreed = sizes->AllocatedSize + (sizeof(short) * 2);
Magic Number,Voron.Data.Tables,NewPageAllocator,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\NewPageAllocator.cs,AllocateSinglePage,The following statement contains a magic number: using (var it = fst.Iterate())              {                  Page page;                  if (it.Seek(nearbyPage)) // found a value >= from the nearby page                  {                      if (it.CurrentKey > nearbyPage)                      {                          // go back one step if we can                          if (it.MovePrev() == false)                              it.Seek(nearbyPage); // if we can't' go back to the original find                      }                  }                  else // probably it is on the last entry' after the first page' so we'll use the last entry                  {                      if (it.SeekToLast() == false)                      {                          // shouldn't actuallly happen' but same behavior as running out of space                          page = AllocateMoreSpace(fst);                          SetValue(fst' page.PageNumber' 0);                          return page;                      }                  }                  var startPage = it.CurrentKey;                  while (true)                  {                      Slice slice;                      using (it.Value(out slice))                      {                          var hasSpace = false;                          var buffer = (ulong*) (slice.Content.Ptr);                          for (int i = 0; i < BitmapSize / sizeof(ulong); i++)                          {                              if (buffer[i] != ulong.MaxValue)                              {                                  hasSpace = true;                                  break;                              }                          }                          if (hasSpace == false)                          {                              if (TryMoveNextCyclic(it' startPage) == false)                                  break;                          }                          for (int i = 0; i < BitmapSize*8; i++)                          {                              if (PtrBitVector.GetBitInPointer(buffer' i) == false)                              {                                  var currentSectionStart = it.CurrentKey;                                  SetValue(fst' currentSectionStart' i);                                                                    return _llt.ModifyPage(currentSectionStart + i);                              }                          }                          if (TryMoveNextCyclic(it' startPage) == false)                              break;                      }                  }                  page = AllocateMoreSpace(fst);                  SetValue(fst' page.PageNumber' 0);                  return page;              }
Magic Number,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,Delete,The following statement contains a magic number: if (ActiveDataSmallSection.Contains(id) || density > 0.5)                  return;
Magic Number,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,Delete,The following statement contains a magic number: if (density > 0.15)              {                  ActiveCandidateSection.Add(sectionPageNumber);                  return;              }
Magic Number,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,AllocateFromSmallActiveSection,The following statement contains a magic number: if (ActiveDataSmallSection.TryAllocate(size' out long id) == false)              {                  InactiveSections.Add(_activeDataSmallSection.PageNumber);                    using (var it = ActiveCandidateSection.Iterate())                  {                      if (it.Seek(long.MinValue))                      {                          do                          {                              var sectionPageNumber = it.CurrentKey;                              _activeDataSmallSection = new ActiveRawDataSmallSection(_tx.LowLevelTransaction'                                  sectionPageNumber);                              _activeDataSmallSection.DataMoved += OnDataMoved;                              if (_activeDataSmallSection.TryAllocate(size' out id))                              {                                  ActiveCandidateSection.Delete(sectionPageNumber);                                  return id;                              }                          } while (it.MoveNext());                        }                  }                    ushort maxSectionSizeInPages =                      _tx.LowLevelTransaction.Environment.Options.RunningOn32Bits                          ? (ushort)((1 * Constants.Size.Megabyte) / Constants.Storage.PageSize)                          : (ushort)((32 * Constants.Size.Megabyte) / Constants.Storage.PageSize);                    var newNumberOfPages = Math.Min(maxSectionSizeInPages'                      (ushort)(ActiveDataSmallSection.NumberOfPages * 2));                    _activeDataSmallSection = ActiveRawDataSmallSection.Create(_tx.LowLevelTransaction' Name' _tableType' newNumberOfPages);                  _activeDataSmallSection.DataMoved += OnDataMoved;                  var val = _activeDataSmallSection.PageNumber;                  using (Slice.External(_tx.Allocator' (byte*)&val' sizeof(long)' out Slice pageNumber))                  {                      _tableTree.Add(TableSchema.ActiveSectionSlice' pageNumber);                  }                    var allocationResult = _activeDataSmallSection.TryAllocate(size' out id);                    Debug.Assert(allocationResult);              }
Magic Number,Voron.Data.Tables,Table,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\Table.cs,AllocateFromSmallActiveSection,The following statement contains a magic number: if (ActiveDataSmallSection.TryAllocate(size' out long id) == false)              {                  InactiveSections.Add(_activeDataSmallSection.PageNumber);                    using (var it = ActiveCandidateSection.Iterate())                  {                      if (it.Seek(long.MinValue))                      {                          do                          {                              var sectionPageNumber = it.CurrentKey;                              _activeDataSmallSection = new ActiveRawDataSmallSection(_tx.LowLevelTransaction'                                  sectionPageNumber);                              _activeDataSmallSection.DataMoved += OnDataMoved;                              if (_activeDataSmallSection.TryAllocate(size' out id))                              {                                  ActiveCandidateSection.Delete(sectionPageNumber);                                  return id;                              }                          } while (it.MoveNext());                        }                  }                    ushort maxSectionSizeInPages =                      _tx.LowLevelTransaction.Environment.Options.RunningOn32Bits                          ? (ushort)((1 * Constants.Size.Megabyte) / Constants.Storage.PageSize)                          : (ushort)((32 * Constants.Size.Megabyte) / Constants.Storage.PageSize);                    var newNumberOfPages = Math.Min(maxSectionSizeInPages'                      (ushort)(ActiveDataSmallSection.NumberOfPages * 2));                    _activeDataSmallSection = ActiveRawDataSmallSection.Create(_tx.LowLevelTransaction' Name' _tableType' newNumberOfPages);                  _activeDataSmallSection.DataMoved += OnDataMoved;                  var val = _activeDataSmallSection.PageNumber;                  using (Slice.External(_tx.Allocator' (byte*)&val' sizeof(long)' out Slice pageNumber))                  {                      _tableTree.Add(TableSchema.ActiveSectionSlice' pageNumber);                  }                    var allocationResult = _activeDataSmallSection.TryAllocate(size' out id);                    Debug.Assert(allocationResult);              }
Magic Number,Voron.Data.Tables,SchemaIndexDef,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableSchema.cs,ReadFrom,The following statement contains a magic number: currentPtr = input.Read(2' out currentSize);
Magic Number,Voron.Data.Tables,SchemaIndexDef,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableSchema.cs,ReadFrom,The following statement contains a magic number: currentPtr = input.Read(3' out currentSize);
Magic Number,Voron.Data.Tables,SchemaIndexDef,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableSchema.cs,ReadFrom,The following statement contains a magic number: currentPtr = input.Read(4' out currentSize);
Magic Number,Voron.Data.Tables,FixedSizeSchemaIndexDef,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableSchema.cs,ReadFrom,The following statement contains a magic number: currentPtr = input.Read(2' out currentSize);
Magic Number,Voron.Data.Tables,TableValueBuilder,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableValueBuilder.cs,CopyTo,The following statement contains a magic number: switch (elementSize)              {                  case 1:                      var bytePtr = ptr;                      for (int i = 0; i < _values.Count; i++)                      {                          bytePtr[i] = (byte)pos;                          pos += _values[i].Size;                      }                      break;                  case 2:                      var shortPtr = (ushort*)ptr;                      for (int i = 0; i < _values.Count; i++)                      {                          shortPtr[i] = (ushort)pos;                          pos += _values[i].Size;                      }                      break;                  case 4:                      var intPtr = (int*)ptr;                      for (int i = 0; i < _values.Count; i++)                      {                          intPtr[i] = pos;                          pos += _values[i].Size;                      }                      break;                  default:                      throw new ArgumentOutOfRangeException(nameof(ElementSize)' "Unknown element size " + ElementSize);              }
Magic Number,Voron.Data.Tables,TableValueBuilder,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableValueBuilder.cs,CopyTo,The following statement contains a magic number: switch (elementSize)              {                  case 1:                      var bytePtr = ptr;                      for (int i = 0; i < _values.Count; i++)                      {                          bytePtr[i] = (byte)pos;                          pos += _values[i].Size;                      }                      break;                  case 2:                      var shortPtr = (ushort*)ptr;                      for (int i = 0; i < _values.Count; i++)                      {                          shortPtr[i] = (ushort)pos;                          pos += _values[i].Size;                      }                      break;                  case 4:                      var intPtr = (int*)ptr;                      for (int i = 0; i < _values.Count; i++)                      {                          intPtr[i] = pos;                          pos += _values[i].Size;                      }                      break;                  default:                      throw new ArgumentOutOfRangeException(nameof(ElementSize)' "Unknown element size " + ElementSize);              }
Magic Number,Voron.Data.Tables,TableValueReader,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableValueReader.cs,TableValueReader,The following statement contains a magic number: if (size > ushort.MaxValue)                  _elementSize = 4;              else if (size > byte.MaxValue)                  _elementSize = 2;              else                  _elementSize = 1;
Magic Number,Voron.Data.Tables,TableValueReader,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableValueReader.cs,TableValueReader,The following statement contains a magic number: if (size > ushort.MaxValue)                  _elementSize = 4;              else if (size > byte.MaxValue)                  _elementSize = 2;              else                  _elementSize = 1;
Magic Number,Voron.Data.Tables,TableValueReader,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableValueReader.cs,Read,The following statement contains a magic number: switch (_elementSize)              {                  case 1:                      position = _dataPtr[index];                      nextPos = hasNext ? _dataPtr[index + 1] : _dataSize;                      break;                  case 2:                      position = ((ushort*) _dataPtr)[index];                      nextPos = hasNext ? ((ushort*) _dataPtr)[index + 1] : _dataSize;                      break;                  case 4:                      position = ((int*) _dataPtr)[index];                      nextPos = hasNext ? ((int*) _dataPtr)[index + 1] : _dataSize;                      break;                  default:                      ThrowInvalidElementSize();                      goto case 1; // never hit              }
Magic Number,Voron.Data.Tables,TableValueReader,C:\repos\ravendb_ravendb\src\Voron\Data\Tables\TableValueReader.cs,Read,The following statement contains a magic number: switch (_elementSize)              {                  case 1:                      position = _dataPtr[index];                      nextPos = hasNext ? _dataPtr[index + 1] : _dataSize;                      break;                  case 2:                      position = ((ushort*) _dataPtr)[index];                      nextPos = hasNext ? ((ushort*) _dataPtr)[index + 1] : _dataSize;                      break;                  case 4:                      position = ((int*) _dataPtr)[index];                      nextPos = hasNext ? ((int*) _dataPtr)[index + 1] : _dataSize;                      break;                  default:                      ThrowInvalidElementSize();                      goto case 1; // never hit              }
Magic Number,Voron.Debugging,StorageReportGenerator,C:\repos\ravendb_ravendb\src\Voron\Debugging\StorageReportGenerator.cs,GenerateJournalsReport,The following statement contains a magic number: return journals.Select(journal => new JournalReport              {                  Number = journal.Number'                  AllocatedSpaceInBytes = (long)journal.JournalWriter.NumberOfAllocated4Kb * 4 * Constants.Size.Kilobyte              }).ToList();
Magic Number,Voron,GlobalFlushingBehavior,C:\repos\ravendb_ravendb\src\Voron\GlobalFlushingBehavior.cs,VoronEnvironmentFlushing,The following statement contains a magic number: while (true)              {                  _avoidDuplicates.Clear();                  var maybeNeedSync = _maybeNeedToSync.Count;                  var millisecondsTimeout = 15000 - maybeNeedSync;                  if (millisecondsTimeout <= 0 ||                      _flushWriterEvent.Wait(millisecondsTimeout) == false)                  {                      if (_maybeNeedToSync.Count == 0)                          continue;                        if (_log.IsInfoEnabled)                      {                          _log.Info($"Starting desired sync with {_maybeNeedToSync.Count:#'#} items to sync after {millisecondsTimeout:#'#} ms with no activity");                      }                        // sync after 5 seconds if no flushing occurred' or if there has been a LOT of                      // writes that we would like to run                      SyncDesiredEnvironments();                      continue;                  }                  _flushWriterEvent.Reset();                    FlushEnvironments();                    SyncRequiredEnvironments();              }
Magic Number,Voron,GlobalFlushingBehavior,C:\repos\ravendb_ravendb\src\Voron\GlobalFlushingBehavior.cs,FlushEnvironments,The following statement contains a magic number: while (                  // if there is high traffic into the queue' we want to abort after                   // we processed whatever was already in there' to avoid holding up                  // the rest of the operations                  limit-- > 0 &&                  _maybeNeedToFlush.TryDequeue(out envToFlush))              {                  if (_avoidDuplicates.Add(envToFlush) == false)                      continue; // avoid duplicates                  if (envToFlush.Disposed || envToFlush.Options.ManualFlushing)                      continue;                    var sizeOfUnflushedTransactionsInJournalFile = envToFlush.SizeOfUnflushedTransactionsInJournalFile;                    if (sizeOfUnflushedTransactionsInJournalFile == 0)                      continue; // nothing to do                      if (sizeOfUnflushedTransactionsInJournalFile < envToFlush.Options.MaxNumberOfPagesInJournalBeforeFlush)                  {                      // we haven't reached the point where we have to flush' but we might want to' if we have enough                       // resources available' if we have more than half the flushing capacity' we can do it now' otherwise' we'll wait                      // until it is actually required.                      if (_concurrentFlushes.CurrentCount < StorageEnvironment.MaxConcurrentFlushes / 2)                          continue;                        // At the same time' we want to avoid excessive flushes' so we'll limit it to once in a while if we don't                      // have a lot to flush                      if ((DateTime.UtcNow - envToFlush.LastFlushTime).TotalSeconds < StorageEnvironment.TimeToSyncAfterFlashInSec)                          continue;                  }                    envToFlush.LastFlushTime = DateTime.UtcNow;                  Interlocked.Add(ref envToFlush.SizeOfUnflushedTransactionsInJournalFile' -sizeOfUnflushedTransactionsInJournalFile);                    _concurrentFlushes.Wait();                    ThreadPool.QueueUserWorkItem(env =>                  {                      var storageEnvironment = ((StorageEnvironment)env);                      try                      {                          if (storageEnvironment.Disposed)                              return;                            storageEnvironment.BackgroundFlushWritesToDataFile();                        }                      catch (Exception e)                      {                          if (_log.IsOperationsEnabled)                              _log.Operations($"Failed to flush {storageEnvironment.Options.BasePath}"' e);                            storageEnvironment.Options.SetCatastrophicFailure(ExceptionDispatchInfo.Capture(e));                      }                      finally                      {                          _concurrentFlushes.Release();                      }                  }' envToFlush);              }
Magic Number,Voron,PageLocator,C:\repos\ravendb_ravendb\src\Voron\PageLocator.cs,Renew,The following statement contains a magic number: Debug.Assert(cacheSize <= 1024);
Magic Number,Voron,PageLocator,C:\repos\ravendb_ravendb\src\Voron\PageLocator.cs,Renew,The following statement contains a magic number: _andMask = (int) (0xFFFFFFFF >> (sizeof(uint) * 8 - shiftRight));
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,StorageEnvironment,The following statement contains a magic number: try              {                  _log = LoggingSource.Instance.GetLogger<StorageEnvironment>(options.BasePath.FullPath);                  _options = options;                  _dataPager = options.DataPager;                  _freeSpaceHandling = new FreeSpaceHandling();                  _headerAccessor = new HeaderAccessor(this);                  NumOfConcurrentSyncsPerPhysDrive = options.NumOfConcurrentSyncsPerPhysDrive;                  TimeToSyncAfterFlashInSec = options.TimeToSyncAfterFlashInSec;                    Debug.Assert(_dataPager.NumberOfAllocatedPages != 0);                    var remainingBits = _dataPager.NumberOfAllocatedPages % (8 * sizeof(long));                    _validPages = new long[_dataPager.NumberOfAllocatedPages / (8 * sizeof(long)) + (remainingBits == 0 ? 0 : 1)];                  _validPages[_validPages.Length - 1] |= unchecked(((long)ulong.MaxValue << (int)remainingBits));                    _decompressionBuffers = new DecompressionBuffersPool(options);                  var isNew = _headerAccessor.Initialize();                    _scratchBufferPool = new ScratchBufferPool(this);                    options.SetPosixOptions();                    _journal = new WriteAheadJournal(this);                    if (isNew)                      CreateNewDatabase();                  else // existing db' let us load it                      LoadExistingDatabase();                    if (_options.ManualFlushing == false)                      Task.Run(IdleFlushTimer);              }              catch (Exception)              {                  Dispose();                  throw;              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,StorageEnvironment,The following statement contains a magic number: try              {                  _log = LoggingSource.Instance.GetLogger<StorageEnvironment>(options.BasePath.FullPath);                  _options = options;                  _dataPager = options.DataPager;                  _freeSpaceHandling = new FreeSpaceHandling();                  _headerAccessor = new HeaderAccessor(this);                  NumOfConcurrentSyncsPerPhysDrive = options.NumOfConcurrentSyncsPerPhysDrive;                  TimeToSyncAfterFlashInSec = options.TimeToSyncAfterFlashInSec;                    Debug.Assert(_dataPager.NumberOfAllocatedPages != 0);                    var remainingBits = _dataPager.NumberOfAllocatedPages % (8 * sizeof(long));                    _validPages = new long[_dataPager.NumberOfAllocatedPages / (8 * sizeof(long)) + (remainingBits == 0 ? 0 : 1)];                  _validPages[_validPages.Length - 1] |= unchecked(((long)ulong.MaxValue << (int)remainingBits));                    _decompressionBuffers = new DecompressionBuffersPool(options);                  var isNew = _headerAccessor.Initialize();                    _scratchBufferPool = new ScratchBufferPool(this);                    options.SetPosixOptions();                    _journal = new WriteAheadJournal(this);                    if (isNew)                      CreateNewDatabase();                  else // existing db' let us load it                      LoadExistingDatabase();                    if (_options.ManualFlushing == false)                      Task.Run(IdleFlushTimer);              }              catch (Exception)              {                  Dispose();                  throw;              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,IsStorageSupportingO_Direct,The following statement contains a magic number: try              {                  if (fd == -1)                  {                      if (log.IsInfoEnabled)                          log.Info(                              $"Failed to create test file at \'{filename}\'. Cannot determine if O_DIRECT supported by the file system. Assuming it is");                      return true;                  }                    bool usingWrite;                  result = Syscall.AllocateFileSpace(fd' 64L * 1024' filename' out usingWrite);                  if (usingWrite)                  {                      if (log.IsInfoEnabled)                          log.Info(                              $"Failed to allocate test file at \'{filename}\'. (rc = {result}) but had success with pwrite. New file allocations will take longer time with pwrite");                  }                    if (result == (int)Errno.EINVAL)                  {                      if (log.IsInfoEnabled)                          log.Info(                              $"Cannot allocate (rc = EINVAL) to a file \'{filename}\' opened using O_DIRECT. Assuming O_DIRECT is not supported by this file system");                        return false;                  }                    if (result != 0)                  {                      if (log.IsInfoEnabled)                          log.Info(                              $"Failed to allocate test file at \'{filename}\'. (rc = {result}). Cannot determine if O_DIRECT supported by the file system. Assuming it is");                  }                }              finally              {                  result = Syscall.close(fd);                  if (result != 0)                  {                      if (log.IsInfoEnabled)                          log.Info($"Failed to close test file at \'{filename}\'. (rc = {result}).");                  }                    result = Syscall.unlink(filename);                  if (result != 0)                  {                      if (log.IsInfoEnabled)                          log.Info($"Failed to delete test file at \'{filename}\'. (rc = {result}).");                  }              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,IdleFlushTimer,The following statement contains a magic number: while (cancellationToken.IsCancellationRequested == false)              {                  if (Disposed)                      return;                    if (Options.ManualFlushing)                      return;                    try                  {                      if (await _writeTransactionRunning.WaitAsync(TimeSpan.FromMilliseconds(Options.IdleFlushTimeout)) == false)                      {                          if (SizeOfUnflushedTransactionsInJournalFile != 0)                              GlobalFlushingBehavior.GlobalFlusher.Value.MaybeFlushEnvironment(this);                            else if (Journal.Applicator.TotalWrittenButUnsyncedBytes != 0)                              QueueForSyncDataFile();                      }                      else                      {                          await TimeoutManager.WaitFor(TimeSpan.FromMilliseconds(1000)' cancellationToken).ConfigureAwait(false);                      }                  }                  catch (ObjectDisposedException)                  {                      return;                  }                  catch (OperationCanceledException)                  {                      return;                  }              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,LoadExistingDatabase,The following statement contains a magic number: using (var tx = NewLowLevelTransaction(transactionPersistentContext' TransactionFlags.ReadWrite))              using (var root = Tree.Open(tx' null' Constants.RootTreeNameSlice' header->TransactionId == 0 ? &entry.Root : &header->Root))              using (var writeTx = new Transaction(tx))              {                  tx.UpdateRootsIfNeeded(root);                    var metadataTree = writeTx.ReadTree(Constants.MetadataTreeNameSlice);                  if (metadataTree == null)                      VoronUnrecoverableErrorException.Raise(this'                          "Could not find metadata tree in database' possible mismatch / corruption?");                    Debug.Assert(metadataTree != null);                  // ReSharper disable once PossibleNullReferenceException                  var dbId = metadataTree.Read("db-id");                  if (dbId == null)                      VoronUnrecoverableErrorException.Raise(this'                          "Could not find db id in metadata tree' possible mismatch / corruption?");                    var buffer = new byte[16];                  Debug.Assert(dbId != null);                  // ReSharper disable once PossibleNullReferenceException                  var dbIdBytes = dbId.Reader.Read(buffer' 0' 16);                  if (dbIdBytes != 16)                      VoronUnrecoverableErrorException.Raise(this'                          "The db id value in metadata tree wasn't 16 bytes in size' possible mismatch / corruption?");                    var databaseGuidId = _options.GenerateNewDatabaseId == false ? new Guid(buffer) : Guid.NewGuid();                    FillBase64Id(databaseGuidId);                    if (_options.GenerateNewDatabaseId)                  {                      // save the new database id                      metadataTree?.Add("db-id"' DbId.ToByteArray());                  }                    tx.Commit();              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,LoadExistingDatabase,The following statement contains a magic number: using (var tx = NewLowLevelTransaction(transactionPersistentContext' TransactionFlags.ReadWrite))              using (var root = Tree.Open(tx' null' Constants.RootTreeNameSlice' header->TransactionId == 0 ? &entry.Root : &header->Root))              using (var writeTx = new Transaction(tx))              {                  tx.UpdateRootsIfNeeded(root);                    var metadataTree = writeTx.ReadTree(Constants.MetadataTreeNameSlice);                  if (metadataTree == null)                      VoronUnrecoverableErrorException.Raise(this'                          "Could not find metadata tree in database' possible mismatch / corruption?");                    Debug.Assert(metadataTree != null);                  // ReSharper disable once PossibleNullReferenceException                  var dbId = metadataTree.Read("db-id");                  if (dbId == null)                      VoronUnrecoverableErrorException.Raise(this'                          "Could not find db id in metadata tree' possible mismatch / corruption?");                    var buffer = new byte[16];                  Debug.Assert(dbId != null);                  // ReSharper disable once PossibleNullReferenceException                  var dbIdBytes = dbId.Reader.Read(buffer' 0' 16);                  if (dbIdBytes != 16)                      VoronUnrecoverableErrorException.Raise(this'                          "The db id value in metadata tree wasn't 16 bytes in size' possible mismatch / corruption?");                    var databaseGuidId = _options.GenerateNewDatabaseId == false ? new Guid(buffer) : Guid.NewGuid();                    FillBase64Id(databaseGuidId);                    if (_options.GenerateNewDatabaseId)                  {                      // save the new database id                      metadataTree?.Add("db-id"' DbId.ToByteArray());                  }                    tx.Commit();              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,LoadExistingDatabase,The following statement contains a magic number: using (var tx = NewLowLevelTransaction(transactionPersistentContext' TransactionFlags.ReadWrite))              using (var root = Tree.Open(tx' null' Constants.RootTreeNameSlice' header->TransactionId == 0 ? &entry.Root : &header->Root))              using (var writeTx = new Transaction(tx))              {                  tx.UpdateRootsIfNeeded(root);                    var metadataTree = writeTx.ReadTree(Constants.MetadataTreeNameSlice);                  if (metadataTree == null)                      VoronUnrecoverableErrorException.Raise(this'                          "Could not find metadata tree in database' possible mismatch / corruption?");                    Debug.Assert(metadataTree != null);                  // ReSharper disable once PossibleNullReferenceException                  var dbId = metadataTree.Read("db-id");                  if (dbId == null)                      VoronUnrecoverableErrorException.Raise(this'                          "Could not find db id in metadata tree' possible mismatch / corruption?");                    var buffer = new byte[16];                  Debug.Assert(dbId != null);                  // ReSharper disable once PossibleNullReferenceException                  var dbIdBytes = dbId.Reader.Read(buffer' 0' 16);                  if (dbIdBytes != 16)                      VoronUnrecoverableErrorException.Raise(this'                          "The db id value in metadata tree wasn't 16 bytes in size' possible mismatch / corruption?");                    var databaseGuidId = _options.GenerateNewDatabaseId == false ? new Guid(buffer) : Guid.NewGuid();                    FillBase64Id(databaseGuidId);                    if (_options.GenerateNewDatabaseId)                  {                      // save the new database id                      metadataTree?.Add("db-id"' DbId.ToByteArray());                  }                    tx.Commit();              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,FillBase64Id,The following statement contains a magic number: fixed (char* pChars = Base64Id)              {                  var result = Base64.ConvertToBase64ArrayUnpadded(pChars' (byte*)&databseGuidId' 0' 16);                  Debug.Assert(result == 22);              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,FillBase64Id,The following statement contains a magic number: fixed (char* pChars = Base64Id)              {                  var result = Base64.ConvertToBase64ArrayUnpadded(pChars' (byte*)&databseGuidId' 0' 16);                  Debug.Assert(result == 22);              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,NewLowLevelTransaction,The following statement contains a magic number: try              {                  IncrementUsageOnNewTransaction();                    if (flags == TransactionFlags.ReadWrite)                  {                      var wait = timeout ?? (Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30));                        if (FlushInProgressLock.IsWriteLockHeld == false)                      {                          flushInProgressReadLockTaken = FlushInProgressLock.TryEnterReadLock(wait);                          if (flushInProgressReadLockTaken == false)                          {                              GlobalFlushingBehavior.GlobalFlusher.Value.MaybeFlushEnvironment(this);                              ThrowOnTimeoutWaitingForReadFlushingInProgressLock(wait);                          }                      }                        txLockTaken = _transactionWriter.Wait(wait);                        if (txLockTaken == false)                      {                          GlobalFlushingBehavior.GlobalFlusher.Value.MaybeFlushEnvironment(this);                          ThrowOnTimeoutWaitingForWriteTxLock(wait);                      }                        _cancellationTokenSource.Token.ThrowIfCancellationRequested();                        _currentTransactionHolder = NativeMemory.ThreadAllocations.Value;                      WriteTransactionStarted();                        if (_endOfDiskSpace != null)                      {                          _endOfDiskSpace.AssertCanContinueWriting();                            _endOfDiskSpace = null;                          Task.Run(IdleFlushTimer);                          GlobalFlushingBehavior.GlobalFlusher.Value.MaybeFlushEnvironment(this);                      }                  }                    LowLevelTransaction tx;                    _txCommit.EnterReadLock();                  try                  {                      _cancellationTokenSource.Token.ThrowIfCancellationRequested();                        if (_currentTransactionHolder == null)                          _currentTransactionHolder = NativeMemory.ThreadAllocations.Value;                        long txId = flags == TransactionFlags.ReadWrite ? NextWriteTransactionId : CurrentReadTransactionId;                      tx = new LowLevelTransaction(this' txId' transactionPersistentContext' flags' _freeSpaceHandling'                          context)                      {                          FlushInProgressLockTaken = flushInProgressReadLockTaken'                          CurrentTransactionHolder = _currentTransactionHolder                      };                      ActiveTransactions.Add(tx);                  }                  finally                  {                      _txCommit.ExitReadLock();                  }                    var state = _dataPager.PagerState;                  tx.EnsurePagerStateReference(state);                    return tx;              }              catch (Exception)              {                  try                  {                      if (txLockTaken)                      {                          _transactionWriter.Release();                      }                      if (flushInProgressReadLockTaken)                      {                          FlushInProgressLock.ExitReadLock();                      }                  }                  finally                  {                      DecrementUsageOnTransactionCreationFailure();                  }                  throw;              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,NewLowLevelTransaction,The following statement contains a magic number: try              {                  IncrementUsageOnNewTransaction();                    if (flags == TransactionFlags.ReadWrite)                  {                      var wait = timeout ?? (Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30));                        if (FlushInProgressLock.IsWriteLockHeld == false)                      {                          flushInProgressReadLockTaken = FlushInProgressLock.TryEnterReadLock(wait);                          if (flushInProgressReadLockTaken == false)                          {                              GlobalFlushingBehavior.GlobalFlusher.Value.MaybeFlushEnvironment(this);                              ThrowOnTimeoutWaitingForReadFlushingInProgressLock(wait);                          }                      }                        txLockTaken = _transactionWriter.Wait(wait);                        if (txLockTaken == false)                      {                          GlobalFlushingBehavior.GlobalFlusher.Value.MaybeFlushEnvironment(this);                          ThrowOnTimeoutWaitingForWriteTxLock(wait);                      }                        _cancellationTokenSource.Token.ThrowIfCancellationRequested();                        _currentTransactionHolder = NativeMemory.ThreadAllocations.Value;                      WriteTransactionStarted();                        if (_endOfDiskSpace != null)                      {                          _endOfDiskSpace.AssertCanContinueWriting();                            _endOfDiskSpace = null;                          Task.Run(IdleFlushTimer);                          GlobalFlushingBehavior.GlobalFlusher.Value.MaybeFlushEnvironment(this);                      }                  }                    LowLevelTransaction tx;                    _txCommit.EnterReadLock();                  try                  {                      _cancellationTokenSource.Token.ThrowIfCancellationRequested();                        if (_currentTransactionHolder == null)                          _currentTransactionHolder = NativeMemory.ThreadAllocations.Value;                        long txId = flags == TransactionFlags.ReadWrite ? NextWriteTransactionId : CurrentReadTransactionId;                      tx = new LowLevelTransaction(this' txId' transactionPersistentContext' flags' _freeSpaceHandling'                          context)                      {                          FlushInProgressLockTaken = flushInProgressReadLockTaken'                          CurrentTransactionHolder = _currentTransactionHolder                      };                      ActiveTransactions.Add(tx);                  }                  finally                  {                      _txCommit.ExitReadLock();                  }                    var state = _dataPager.PagerState;                  tx.EnsurePagerStateReference(state);                    return tx;              }              catch (Exception)              {                  try                  {                      if (txLockTaken)                      {                          _transactionWriter.Release();                      }                      if (flushInProgressReadLockTaken)                      {                          FlushInProgressLock.ExitReadLock();                      }                  }                  finally                  {                      DecrementUsageOnTransactionCreationFailure();                  }                  throw;              }
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,FlushLogToDataFile,The following statement contains a magic number: _journal.Applicator.ApplyLogsToDataFile(_cancellationTokenSource.Token'                  Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30));
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,FlushLogToDataFile,The following statement contains a magic number: _journal.Applicator.ApplyLogsToDataFile(_cancellationTokenSource.Token'                  Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30));
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,ValidatePageChecksum,The following statement contains a magic number: var index = pageNumber / (8 * sizeof(long));
Magic Number,Voron,StorageEnvironment,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironment.cs,ValidatePageChecksum,The following statement contains a magic number: var bitIndex = (int)(pageNumber % (8 * sizeof(long)));
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: DisposeWaitTime = TimeSpan.FromSeconds(15);
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxLogFileSize = ((sizeof(int) == IntPtr.Size ? 32 : 256) * Constants.Size.Megabyte);
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxLogFileSize = ((sizeof(int) == IntPtr.Size ? 32 : 256) * Constants.Size.Megabyte);
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: InitialLogFileSize = 64 * Constants.Size.Kilobyte;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxScratchBufferSize = ((sizeof(int) == IntPtr.Size ? 32 : 256) * Constants.Size.Megabyte);
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxScratchBufferSize = ((sizeof(int) == IntPtr.Size ? 32 : 256) * Constants.Size.Megabyte);
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxNumberOfPagesInJournalBeforeFlush =                  ((sizeof(int) == IntPtr.Size ? 4 : 32) * Constants.Size.Megabyte) / Constants.Storage.PageSize;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxNumberOfPagesInJournalBeforeFlush =                  ((sizeof(int) == IntPtr.Size ? 4 : 32) * Constants.Size.Megabyte) / Constants.Storage.PageSize;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: IdleFlushTimeout = 5000;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: IoMetrics = new IoMetrics(256' 256' ioChangesNotifications);
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: IoMetrics = new IoMetrics(256' 256' ioChangesNotifications);
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,GetTempPath,The following statement contains a magic number: if (!useSystemTemp)              {                  // Effective permissions are hard to compute' so we try to create a file and write to it as a check.                  try                  {                      var tempFilePath = Path.Combine(tempPath' Guid.NewGuid().ToString());                      File.Create(tempFilePath' 1024).Dispose();                      File.Delete(tempFilePath);                  }                  catch (Exception)                  {                      useSystemTemp = true;                  }                }
Magic Number,Voron,DirectoryStorageEnvironmentOptions,C:\repos\ravendb_ravendb\src\Voron\StorageEnvironmentOptions.cs,AttemptToReuseJournal,The following statement contains a magic number: lock (_journalsForReuse)                  {                      var lastModified = DateTime.MinValue.Ticks;                      while (_journalsForReuse.Count > 0)                      {                          lastModified = _journalsForReuse.Keys[_journalsForReuse.Count - 1];                          var filename = _journalsForReuse.Values[_journalsForReuse.Count - 1];                          _journalsForReuse.RemoveAt(_journalsForReuse.Count - 1);                            try                          {                              if (File.Exists(filename) == false)                                  continue;                                File.Move(filename' desiredPath.FullPath);                              break;                          }                          catch (Exception ex)                          {                              TryDelete(filename);                                if (_log.IsInfoEnabled)                                  _log.Info("Failed to rename " + filename + " to " + desiredPath' ex);                          }                      }                        while (_journalsForReuse.Count > 0)                      {                          try                          {                              var fileInfo = new FileInfo(_journalsForReuse.Values[0]);                              if (fileInfo.Exists == false)                              {                                  _journalsForReuse.RemoveAt(0);                                  continue;                              }                                if (lastModified - fileInfo.LastWriteTimeUtc.Ticks > TickInHour * 72)                              {                                  _journalsForReuse.RemoveAt(0);                                  TryDelete(fileInfo.FullName);                                  continue;                              }                                if (fileInfo.Length < desiredSize)                              {                                  _journalsForReuse.RemoveAt(0);                                  TryDelete(fileInfo.FullName);                                    continue;                              }                            }                          catch (IOException)                          {                              // explicitly ignoring any such file errors                              _journalsForReuse.RemoveAt(0);                              TryDelete(_journalsForReuse.Values[0]);                          }                          break;                      }                    }
Magic Number,Voron,TransactionPersistentContext,C:\repos\ravendb_ravendb\src\Voron\TransactionPersistentContext.cs,FreePageLocator,The following statement contains a magic number: if (_pageLocators.Count < 1024)                  _pageLocators.Push(locator);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: ulong swapped = (0x00000000000000FF) & (uvalue >> 56) |                              (0x000000000000FF00) & (uvalue >> 40) |                              (0x0000000000FF0000) & (uvalue >> 24) |                              (0x00000000FF000000) & (uvalue >> 8) |                              (0x000000FF00000000) & (uvalue << 8) |                              (0x0000FF0000000000) & (uvalue << 24) |                              (0x00FF000000000000) & (uvalue << 40) |                              (0xFF00000000000000) & (uvalue << 56);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: ulong swapped = (0x00000000000000FF) & (uvalue >> 56) |                              (0x000000000000FF00) & (uvalue >> 40) |                              (0x0000000000FF0000) & (uvalue >> 24) |                              (0x00000000FF000000) & (uvalue >> 8) |                              (0x000000FF00000000) & (uvalue << 8) |                              (0x0000FF0000000000) & (uvalue << 24) |                              (0x00FF000000000000) & (uvalue << 40) |                              (0xFF00000000000000) & (uvalue << 56);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: ulong swapped = (0x00000000000000FF) & (uvalue >> 56) |                              (0x000000000000FF00) & (uvalue >> 40) |                              (0x0000000000FF0000) & (uvalue >> 24) |                              (0x00000000FF000000) & (uvalue >> 8) |                              (0x000000FF00000000) & (uvalue << 8) |                              (0x0000FF0000000000) & (uvalue << 24) |                              (0x00FF000000000000) & (uvalue << 40) |                              (0xFF00000000000000) & (uvalue << 56);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: ulong swapped = (0x00000000000000FF) & (uvalue >> 56) |                              (0x000000000000FF00) & (uvalue >> 40) |                              (0x0000000000FF0000) & (uvalue >> 24) |                              (0x00000000FF000000) & (uvalue >> 8) |                              (0x000000FF00000000) & (uvalue << 8) |                              (0x0000FF0000000000) & (uvalue << 24) |                              (0x00FF000000000000) & (uvalue << 40) |                              (0xFF00000000000000) & (uvalue << 56);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: ulong swapped = (0x00000000000000FF) & (uvalue >> 56) |                              (0x000000000000FF00) & (uvalue >> 40) |                              (0x0000000000FF0000) & (uvalue >> 24) |                              (0x00000000FF000000) & (uvalue >> 8) |                              (0x000000FF00000000) & (uvalue << 8) |                              (0x0000FF0000000000) & (uvalue << 24) |                              (0x00FF000000000000) & (uvalue << 40) |                              (0xFF00000000000000) & (uvalue << 56);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: ulong swapped = (0x00000000000000FF) & (uvalue >> 56) |                              (0x000000000000FF00) & (uvalue >> 40) |                              (0x0000000000FF0000) & (uvalue >> 24) |                              (0x00000000FF000000) & (uvalue >> 8) |                              (0x000000FF00000000) & (uvalue << 8) |                              (0x0000FF0000000000) & (uvalue << 24) |                              (0x00FF000000000000) & (uvalue << 40) |                              (0xFF00000000000000) & (uvalue << 56);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: ulong swapped = (0x00000000000000FF) & (uvalue >> 56) |                              (0x000000000000FF00) & (uvalue >> 40) |                              (0x0000000000FF0000) & (uvalue >> 24) |                              (0x00000000FF000000) & (uvalue >> 8) |                              (0x000000FF00000000) & (uvalue << 8) |                              (0x0000FF0000000000) & (uvalue << 24) |                              (0x00FF000000000000) & (uvalue << 40) |                              (0xFF00000000000000) & (uvalue << 56);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: ulong swapped = (0x00000000000000FF) & (uvalue >> 56) |                              (0x000000000000FF00) & (uvalue >> 40) |                              (0x0000000000FF0000) & (uvalue >> 24) |                              (0x00000000FF000000) & (uvalue >> 8) |                              (0x000000FF00000000) & (uvalue << 8) |                              (0x0000FF0000000000) & (uvalue << 24) |                              (0x00FF000000000000) & (uvalue << 40) |                              (0xFF00000000000000) & (uvalue << 56);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: uint swapped = (0x000000FF) & (uvalue << 24) |                             (0x0000FF00) & (uvalue << 8) |                             (0x00FF0000) & (uvalue >> 8) |                             (0xFF000000) & (uvalue >> 24);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: uint swapped = (0x000000FF) & (uvalue << 24) |                             (0x0000FF00) & (uvalue << 8) |                             (0x00FF0000) & (uvalue >> 8) |                             (0xFF000000) & (uvalue >> 24);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: uint swapped = (0x000000FF) & (uvalue << 24) |                             (0x0000FF00) & (uvalue << 8) |                             (0x00FF0000) & (uvalue >> 8) |                             (0xFF000000) & (uvalue >> 24);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: uint swapped = (0x000000FF) & (uvalue << 24) |                             (0x0000FF00) & (uvalue << 8) |                             (0x00FF0000) & (uvalue >> 8) |                             (0xFF000000) & (uvalue >> 24);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: uint swapped = (0x000000FF) & (uvalue << 8) |                             (0x0000FF00) & (uvalue >> 8);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,SwapBitShift,The following statement contains a magic number: uint swapped = (0x000000FF) & (uvalue << 8) |                             (0x0000FF00) & (uvalue >> 8);
Magic Number,Voron,ValueReader,C:\repos\ravendb_ravendb\src\Voron\ValueReader.cs,CopyTo,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,Voron.Impl.Backup,FullBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\FullBackup.cs,ToFile,The following statement contains a magic number: using (var file = new FileStream(backupPath' FileMode.Create))              {                  using (var package = new ZipArchive(file' ZipArchiveMode.Create' leaveOpen: true))                  {                      infoNotify("Voron backup started");                      var dataPager = env.Options.DataPager;                      var copier = new DataCopier(Constants.Storage.PageSize * 16);                      Backup(env' compression' infoNotify' backupStarted' dataPager' package' string.Empty'                          copier);                        file.Flush(true); // make sure that we fully flushed to disk                  }              }
Magic Number,Voron.Impl.Backup,FullBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\FullBackup.cs,ToFile,The following statement contains a magic number: foreach (var e in envs)              {                  infoNotify("Voron backup " + e.Name + "started");                  var basePath = Path.Combine(e.Folder' e.Name);                  var env = e.Env;                  var dataPager = env.Options.DataPager;                  var copier = new DataCopier(Constants.Storage.PageSize * 16);                  Backup(env' compression' infoNotify' backupStarted' dataPager' package' basePath'                      copier);              }
Magic Number,Voron.Impl.Backup,FullBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\FullBackup.cs,Backup,The following statement contains a magic number: try              {                  long allocatedPages;                  var writePesistentContext = new TransactionPersistentContext(true);                  var readPesistentContext = new TransactionPersistentContext(true);                  using (var txw = env.NewLowLevelTransaction(writePesistentContext' TransactionFlags.ReadWrite)) // so we can snapshot the headers safely                  {                      txr = env.NewLowLevelTransaction(readPesistentContext' TransactionFlags.Read);// now have snapshot view                      allocatedPages = dataPager.NumberOfAllocatedPages;                        Debug.Assert(HeaderAccessor.HeaderFileNames.Length == 2);                      infoNotify("Voron copy headers for " + basePath);                      VoronBackupUtil.CopyHeaders(compression' package' copier' env.Options' basePath);                        // journal files snapshot                      var files = env.Journal.Files; // thread safety copy                        JournalInfo journalInfo = env.HeaderAccessor.Get(ptr => ptr->Journal);                      for (var journalNum = journalInfo.CurrentJournal - journalInfo.JournalFilesCount + 1;                          journalNum <= journalInfo.CurrentJournal;                          journalNum++)                      {                          var journalFile = files.FirstOrDefault(x => x.Number == journalNum);                          // first check journal files currently being in use                          if (journalFile == null)                          {                              long journalSize;                              using (var pager = env.Options.OpenJournalPager(journalNum))                              {                                  journalSize = Bits.NextPowerOf2(pager.NumberOfAllocatedPages * Constants.Storage.PageSize);                              }                                journalFile = new JournalFile(env' env.Options.CreateJournalWriter(journalNum' journalSize)' journalNum);                          }                            journalFile.AddRef();                          usedJournals.Add(journalFile);                      }                        if (env.Journal.CurrentFile != null)                      {                          lastWrittenLogFile = env.Journal.CurrentFile.Number;                          lastWrittenLogPage = env.Journal.CurrentFile.WritePosIn4KbPosition - 1;                      }                        // txw.Commit(); intentionally not committing                  }                    backupStarted?.Invoke();                    // data file backup                  var dataPart = package.CreateEntry(Path.Combine(basePath' Constants.DatabaseFilename)' compression);                  Debug.Assert(dataPart != null);                    if (allocatedPages > 0) //only true if dataPager is still empty at backup start                  {                      using (var dataStream = dataPart.Open())                      {                          // now can copy everything else                          copier.ToStream(dataPager' 0' allocatedPages' dataStream);                      }                  }                    try                  {                      long lastBackedupJournal = 0;                      foreach (var journalFile in usedJournals)                      {                          var journalPath = env.Options.GetJournalPath(journalFile.Number).FullPath;                          var journalBasePath = basePath;                          var journalDirectoryName = new DirectoryInfo(journalPath).Parent.Name;                          if (journalDirectoryName.Equals("Journal"' StringComparison.OrdinalIgnoreCase))                          {                              journalBasePath = "Journal";                          }                            var entryName = Path.Combine(journalBasePath' StorageEnvironmentOptions.JournalName(journalFile.Number));                          var journalPart = package.CreateEntry(entryName' compression);                            Debug.Assert(journalPart != null);                            long pagesToCopy = journalFile.JournalWriter.NumberOfAllocated4Kb;                          if (journalFile.Number == lastWrittenLogFile)                              pagesToCopy = lastWrittenLogPage + 1;                            using (var stream = journalPart.Open())                          {                              copier.ToStream(env' journalFile' 0' pagesToCopy' stream);                              infoNotify(string.Format("Voron copy journal file {0}"' entryName));                          }                            lastBackedupJournal = journalFile.Number;                      }                        if (env.Options.IncrementalBackupEnabled)                      {                          env.HeaderAccessor.Modify(header =>                          {                              header->IncrementalBackup.LastBackedUpJournal = lastBackedupJournal;                                //since we backed-up everything' no need to start next incremental backup from the middle                              header->IncrementalBackup.LastBackedUpJournalPage = -1;                          });                      }                      backupSuccess = true;                  }                  catch (Exception)                  {                      backupSuccess = false;                      throw;                  }                  finally                  {                      var lastSyncedJournal = env.HeaderAccessor.Get(header => header->Journal).LastSyncedJournal;                      foreach (var journalFile in usedJournals)                      {                          if (backupSuccess) // if backup succeeded we can remove journals                          {                              if (journalFile.Number < lastWrittenLogFile &&  // prevent deletion of the current journal and journals with a greater number                                  journalFile.Number < lastSyncedJournal) // prevent deletion of journals that aren't synced with the data file                              {                                  journalFile.DeleteOnClose = true;                              }                          }                            journalFile.Release();                      }                  }              }              finally              {                  txr?.Dispose();              }
Magic Number,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,The following statement contains a magic number: var copier = new DataCopier(Constants.Storage.PageSize * 16);
Magic Number,Voron.Impl.Backup,IncrementalBackup,C:\repos\ravendb_ravendb\src\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,The following statement contains a magic number: using (var file = new FileStream(backupPath' FileMode.Create))              {                  using (var package = new ZipArchive(file' ZipArchiveMode.Create' leaveOpen: true))                  {                      foreach (var e in envs)                      {                          if (e.Env.Options.IncrementalBackupEnabled == false)                              throw new InvalidOperationException("Incremental backup is disabled for this storage");                          infoNotify("Voron backup " + e.Name + "started");                          var basePath = Path.Combine(e.Folder' e.Name);                          var env = e.Env;                          var copier = new DataCopier(Constants.Storage.PageSize * 16);                          var numberOfBackedUpPages = Incremental_Backup(env' compression' infoNotify'                                                  backupStarted' package' basePath' copier);                          totalNumberOfBackedUpPages += numberOfBackedUpPages;                      }                  }                  file.Flush(true); // make sure that this is actually persisted fully to disk                    return totalNumberOfBackedUpPages;              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,Execute,The following statement contains a magic number: using (var existingEnv = new StorageEnvironment(srcOptions))              using (var compactedEnv = new StorageEnvironment(compactOptions))              {                  CopyTrees(existingEnv' compactedEnv' progressReport' token);                    compactedEnv.FlushLogToDataFile();                  bool synced;                    const int maxNumberOfRetries = 100;                    var syncRetries = 0;                    while (true)                  {                      token.ThrowIfCancellationRequested();                      using (var op = new WriteAheadJournal.JournalApplicator.SyncOperation(compactedEnv.Journal.Applicator))                      {                          try                          {                                synced = op.SyncDataFile();                                if (synced || ++syncRetries >= maxNumberOfRetries)                                  break;                                Thread.Sleep(100);                          }                          catch (Exception e)                          {                              existingEnv.Options.SetCatastrophicFailure(ExceptionDispatchInfo.Capture(e));                              throw;                          }                      }                  }                    if (synced)                      compactedEnv.Journal.Applicator.DeleteCurrentAlreadyFlushedJournal();                    compactedEnv.Cleanup();                    minimalCompactedDataFileSize = compactedEnv.NextPageNumber * Constants.Storage.PageSize;              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,Execute,The following statement contains a magic number: using (var existingEnv = new StorageEnvironment(srcOptions))              using (var compactedEnv = new StorageEnvironment(compactOptions))              {                  CopyTrees(existingEnv' compactedEnv' progressReport' token);                    compactedEnv.FlushLogToDataFile();                  bool synced;                    const int maxNumberOfRetries = 100;                    var syncRetries = 0;                    while (true)                  {                      token.ThrowIfCancellationRequested();                      using (var op = new WriteAheadJournal.JournalApplicator.SyncOperation(compactedEnv.Journal.Applicator))                      {                          try                          {                                synced = op.SyncDataFile();                                if (synced || ++syncRetries >= maxNumberOfRetries)                                  break;                                Thread.Sleep(100);                          }                          catch (Exception e)                          {                              existingEnv.Options.SetCatastrophicFailure(ExceptionDispatchInfo.Capture(e));                              throw;                          }                      }                  }                    if (synced)                      compactedEnv.Journal.Applicator.DeleteCurrentAlreadyFlushedJournal();                    compactedEnv.Cleanup();                    minimalCompactedDataFileSize = compactedEnv.NextPageNumber * Constants.Storage.PageSize;              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyFixedSizeTrees,The following statement contains a magic number: using (var it = fst.Iterate())              {                  var copiedEntries = 0L;                  if (it.Seek(Int64.MinValue) == false)                      return copiedTrees;                    do                  {                      token.ThrowIfCancellationRequested();                      using (var txw = compactedEnv.WriteTransaction(context))                      {                          var snd = txw.FixedTreeFor(treeNameSlice' header->ValueSize);                          var transactionSize = 0L;                            do                          {                              token.ThrowIfCancellationRequested();                                Slice val;                              using (it.Value(out val))                                  snd.Add(it.CurrentKey' val);                              transactionSize += fst.ValueSize + sizeof(long);                              copiedEntries++;                                var reportRate = fst.NumberOfEntries / 33 + 1;                              if (copiedEntries % reportRate == 0)                                  Report(copiedTrees' totalTreesCount' copiedEntries' fst.NumberOfEntries' progressReport' $"Copying fixed size tree '{treeName}'. Progress: {copiedEntries}/{fst.NumberOfEntries} entries."' treeName);                            } while (transactionSize < compactedEnv.Options.MaxScratchBufferSize / 2 && it.MoveNext());                            txw.Commit();                      }                        if (fst.NumberOfEntries == copiedEntries)                      {                          copiedTrees++;                          Report(copiedTrees' totalTreesCount' copiedEntries' fst.NumberOfEntries' progressReport' $"Finished copying fixed size tree '{treeName}'. Progress: {copiedEntries}/{fst.NumberOfEntries} entries."' treeName);                      }                        compactedEnv.FlushLogToDataFile();                  } while (it.MoveNext());              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyFixedSizeTrees,The following statement contains a magic number: using (var it = fst.Iterate())              {                  var copiedEntries = 0L;                  if (it.Seek(Int64.MinValue) == false)                      return copiedTrees;                    do                  {                      token.ThrowIfCancellationRequested();                      using (var txw = compactedEnv.WriteTransaction(context))                      {                          var snd = txw.FixedTreeFor(treeNameSlice' header->ValueSize);                          var transactionSize = 0L;                            do                          {                              token.ThrowIfCancellationRequested();                                Slice val;                              using (it.Value(out val))                                  snd.Add(it.CurrentKey' val);                              transactionSize += fst.ValueSize + sizeof(long);                              copiedEntries++;                                var reportRate = fst.NumberOfEntries / 33 + 1;                              if (copiedEntries % reportRate == 0)                                  Report(copiedTrees' totalTreesCount' copiedEntries' fst.NumberOfEntries' progressReport' $"Copying fixed size tree '{treeName}'. Progress: {copiedEntries}/{fst.NumberOfEntries} entries."' treeName);                            } while (transactionSize < compactedEnv.Options.MaxScratchBufferSize / 2 && it.MoveNext());                            txw.Commit();                      }                        if (fst.NumberOfEntries == copiedEntries)                      {                          copiedTrees++;                          Report(copiedTrees' totalTreesCount' copiedEntries' fst.NumberOfEntries' progressReport' $"Finished copying fixed size tree '{treeName}'. Progress: {copiedEntries}/{fst.NumberOfEntries} entries."' treeName);                      }                        compactedEnv.FlushLogToDataFile();                  } while (it.MoveNext());              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyVariableSizeTree,The following statement contains a magic number: using (var existingTreeIterator = existingTree.Iterate(true))              {                  if (existingTreeIterator.Seek(Slices.BeforeAllKeys) == false)                      return copiedTrees;                    token.ThrowIfCancellationRequested();                  using (var txw = compactedEnv.WriteTransaction(context))                  {                      if (existingTree.IsLeafCompressionSupported)                          txw.CreateTree(treeName' flags: TreeFlags.LeafsCompressed);                      else                          txw.CreateTree(treeName);                        txw.Commit();                  }                    var copiedEntries = 0L;                    do                  {                      var transactionSize = 0L;                        token.ThrowIfCancellationRequested();                      using (var txw = compactedEnv.WriteTransaction(context))                      {                          var newTree = txw.ReadTree(treeName);                            do                          {                              token.ThrowIfCancellationRequested();                              var key = existingTreeIterator.CurrentKey;                                if (existingTreeIterator.Current->Flags == TreeNodeFlags.MultiValuePageRef)                              {                                  using (var multiTreeIterator = existingTree.MultiRead(key))                                  {                                      if (multiTreeIterator.Seek(Slices.BeforeAllKeys) == false)                                          continue;                                        do                                      {                                          token.ThrowIfCancellationRequested();                                          var multiValue = multiTreeIterator.CurrentKey;                                          newTree.MultiAdd(key' multiValue);                                          transactionSize += multiValue.Size;                                      } while (multiTreeIterator.MoveNext());                                  }                              }                              else if (existingTree.IsLeafCompressionSupported)                              {                                  using (var read = existingTree.ReadDecompressed(key))                                  {                                      var value = read.Reader.AsStream();                                        newTree.Add(key' value);                                      transactionSize += value.Length;                                  }                              }                              else if (existingTree.State.Flags == (TreeFlags.FixedSizeTrees | TreeFlags.Streams))                              {                                  var tag = existingTree.GetStreamTag(key);                                    using (var stream = existingTree.ReadStream(key))                                  {                                      if (tag != null)                                      {                                          Slice tagStr;                                          using (Slice.From(txw.Allocator' tag' out tagStr))                                              newTree.AddStream(key' stream' tagStr);                                      }                                      else                                          newTree.AddStream(key' stream);                                        transactionSize += stream.Length;                                  }                              }                              else                              {                                  using (var value = existingTree.Read(key).Reader.AsStream())                                  {                                      newTree.Add(key' value);                                      transactionSize += value.Length;                                  }                              }                                copiedEntries++;                                var reportRate = existingTree.State.NumberOfEntries / 33 + 1;                              if (copiedEntries % reportRate == 0)                                  Report(copiedTrees' totalTreesCount' copiedEntries' existingTree.State.NumberOfEntries' progressReport' $"Copying variable size tree '{treeName}'. Progress: {copiedEntries}/{existingTree.State.NumberOfEntries} entries."' treeName);                            } while (transactionSize < compactedEnv.Options.MaxScratchBufferSize / 2 && existingTreeIterator.MoveNext());                            txw.Commit();                      }                        if (copiedEntries == existingTree.State.NumberOfEntries)                      {                          copiedTrees++;                          Report(copiedTrees' totalTreesCount' copiedEntries' existingTree.State.NumberOfEntries' progressReport' $"Finished copying variable size tree '{treeName}'. Progress: {copiedEntries}/{existingTree.State.NumberOfEntries} entries."' treeName);                      }                        compactedEnv.FlushLogToDataFile();                  } while (existingTreeIterator.MoveNext());              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyVariableSizeTree,The following statement contains a magic number: using (var existingTreeIterator = existingTree.Iterate(true))              {                  if (existingTreeIterator.Seek(Slices.BeforeAllKeys) == false)                      return copiedTrees;                    token.ThrowIfCancellationRequested();                  using (var txw = compactedEnv.WriteTransaction(context))                  {                      if (existingTree.IsLeafCompressionSupported)                          txw.CreateTree(treeName' flags: TreeFlags.LeafsCompressed);                      else                          txw.CreateTree(treeName);                        txw.Commit();                  }                    var copiedEntries = 0L;                    do                  {                      var transactionSize = 0L;                        token.ThrowIfCancellationRequested();                      using (var txw = compactedEnv.WriteTransaction(context))                      {                          var newTree = txw.ReadTree(treeName);                            do                          {                              token.ThrowIfCancellationRequested();                              var key = existingTreeIterator.CurrentKey;                                if (existingTreeIterator.Current->Flags == TreeNodeFlags.MultiValuePageRef)                              {                                  using (var multiTreeIterator = existingTree.MultiRead(key))                                  {                                      if (multiTreeIterator.Seek(Slices.BeforeAllKeys) == false)                                          continue;                                        do                                      {                                          token.ThrowIfCancellationRequested();                                          var multiValue = multiTreeIterator.CurrentKey;                                          newTree.MultiAdd(key' multiValue);                                          transactionSize += multiValue.Size;                                      } while (multiTreeIterator.MoveNext());                                  }                              }                              else if (existingTree.IsLeafCompressionSupported)                              {                                  using (var read = existingTree.ReadDecompressed(key))                                  {                                      var value = read.Reader.AsStream();                                        newTree.Add(key' value);                                      transactionSize += value.Length;                                  }                              }                              else if (existingTree.State.Flags == (TreeFlags.FixedSizeTrees | TreeFlags.Streams))                              {                                  var tag = existingTree.GetStreamTag(key);                                    using (var stream = existingTree.ReadStream(key))                                  {                                      if (tag != null)                                      {                                          Slice tagStr;                                          using (Slice.From(txw.Allocator' tag' out tagStr))                                              newTree.AddStream(key' stream' tagStr);                                      }                                      else                                          newTree.AddStream(key' stream);                                        transactionSize += stream.Length;                                  }                              }                              else                              {                                  using (var value = existingTree.Read(key).Reader.AsStream())                                  {                                      newTree.Add(key' value);                                      transactionSize += value.Length;                                  }                              }                                copiedEntries++;                                var reportRate = existingTree.State.NumberOfEntries / 33 + 1;                              if (copiedEntries % reportRate == 0)                                  Report(copiedTrees' totalTreesCount' copiedEntries' existingTree.State.NumberOfEntries' progressReport' $"Copying variable size tree '{treeName}'. Progress: {copiedEntries}/{existingTree.State.NumberOfEntries} entries."' treeName);                            } while (transactionSize < compactedEnv.Options.MaxScratchBufferSize / 2 && existingTreeIterator.MoveNext());                            txw.Commit();                      }                        if (copiedEntries == existingTree.State.NumberOfEntries)                      {                          copiedTrees++;                          Report(copiedTrees' totalTreesCount' copiedEntries' existingTree.State.NumberOfEntries' progressReport' $"Finished copying variable size tree '{treeName}'. Progress: {copiedEntries}/{existingTree.State.NumberOfEntries} entries."' treeName);                      }                        compactedEnv.FlushLogToDataFile();                  } while (existingTreeIterator.MoveNext());              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The following statement contains a magic number: while (copiedEntries < inputTable.NumberOfEntries)              {                  token.ThrowIfCancellationRequested();                  using (var txw = compactedEnv.WriteTransaction(context))                  {                      long transactionSize = 0L;                        var outputTable = txw.OpenTable(schema' treeName);                        if (schema.Key == null || schema.Key.IsGlobal)                       {                          // There is no primary key' or there is one that is global to multiple tables                          // we require a table to have at least a single local index that we'll use                            var variableSizeIndex = schema.Indexes.Values.FirstOrDefault(x=>x.IsGlobal == false);                            if (variableSizeIndex!= null)                          {                              // We have a variable size index' use it                                // In case we continue an existing compaction' skip to the next slice                              var skip = 0;                              if (SliceComparer.Compare(lastSlice' Slices.BeforeAllKeys) != 0)                                  skip = 1;                                foreach (var tvr in inputTable.SeekForwardFrom(variableSizeIndex' lastSlice' skip))                              {                                  // The table will take care of reconstructing indexes automatically                                  outputTable.Insert(ref tvr.Result.Reader);                                  copiedEntries++;                                  transactionSize += tvr.Result.Reader.Size;                                    var reportRate = inputTable.NumberOfEntries / 33 + 1;                                  if (copiedEntries % reportRate == 0)                                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                                                                    // The transaction has surpassed the allowed                                  // size before a flush                                  if (lastSlice.Equals(tvr.Key) == false && transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                                  {                                      lastSlice = tvr.Key.Clone(txr.Allocator);                                      break;                                  }                              }                          }                          else                          {                              // Use a fixed size index                              var fixedSizeIndex = schema.FixedSizeIndexes.Values.FirstOrDefault(x => x.IsGlobal == false);                                if (fixedSizeIndex == null)                                  throw new InvalidOperationException("Cannot compact table " + inputTable.Name + " because is has no local indexes' only global ones");                                                              foreach (var entry in inputTable.SeekForwardFrom(fixedSizeIndex' lastFixedIndex' lastFixedIndex > 0 ? 1 : 0))                              {                                    token.ThrowIfCancellationRequested();                                  // The table will take care of reconstructing indexes automatically                                  outputTable.Insert(ref entry.Reader);                                  copiedEntries++;                                  transactionSize += entry.Reader.Size;                                    var reportRate = inputTable.NumberOfEntries / 33 + 1;                                  if (copiedEntries % reportRate == 0)                                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                                    // The transaction has surpassed the allowed                                  // size before a flush                                  if (transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                                  {                                      lastFixedIndex = fixedSizeIndex.GetValue(ref entry.Reader);                                      break;                                  }                              }                          }                      }                      else                      {                          // The table has a primary key' inserts in that order are expected to be faster                          foreach (var entry in inputTable.SeekByPrimaryKey(lastSlice' 0))                          {                              token.ThrowIfCancellationRequested();                              // The table will take care of reconstructing indexes automatically                              outputTable.Insert(ref entry.Reader);                              copiedEntries++;                              transactionSize += entry.Reader.Size;                                // The transaction has surpassed the allowed                              // size before a flush                              if (transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                              {                                  schema.Key.GetSlice(txr.Allocator' ref entry.Reader' out lastSlice);                                  break;                              }                          }                      }                        txw.Commit();                  }                    if (copiedEntries == inputTable.NumberOfEntries)                  {                      copiedTrees++;                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Finished copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                  }                    compactedEnv.FlushLogToDataFile();              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The following statement contains a magic number: while (copiedEntries < inputTable.NumberOfEntries)              {                  token.ThrowIfCancellationRequested();                  using (var txw = compactedEnv.WriteTransaction(context))                  {                      long transactionSize = 0L;                        var outputTable = txw.OpenTable(schema' treeName);                        if (schema.Key == null || schema.Key.IsGlobal)                       {                          // There is no primary key' or there is one that is global to multiple tables                          // we require a table to have at least a single local index that we'll use                            var variableSizeIndex = schema.Indexes.Values.FirstOrDefault(x=>x.IsGlobal == false);                            if (variableSizeIndex!= null)                          {                              // We have a variable size index' use it                                // In case we continue an existing compaction' skip to the next slice                              var skip = 0;                              if (SliceComparer.Compare(lastSlice' Slices.BeforeAllKeys) != 0)                                  skip = 1;                                foreach (var tvr in inputTable.SeekForwardFrom(variableSizeIndex' lastSlice' skip))                              {                                  // The table will take care of reconstructing indexes automatically                                  outputTable.Insert(ref tvr.Result.Reader);                                  copiedEntries++;                                  transactionSize += tvr.Result.Reader.Size;                                    var reportRate = inputTable.NumberOfEntries / 33 + 1;                                  if (copiedEntries % reportRate == 0)                                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                                                                    // The transaction has surpassed the allowed                                  // size before a flush                                  if (lastSlice.Equals(tvr.Key) == false && transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                                  {                                      lastSlice = tvr.Key.Clone(txr.Allocator);                                      break;                                  }                              }                          }                          else                          {                              // Use a fixed size index                              var fixedSizeIndex = schema.FixedSizeIndexes.Values.FirstOrDefault(x => x.IsGlobal == false);                                if (fixedSizeIndex == null)                                  throw new InvalidOperationException("Cannot compact table " + inputTable.Name + " because is has no local indexes' only global ones");                                                              foreach (var entry in inputTable.SeekForwardFrom(fixedSizeIndex' lastFixedIndex' lastFixedIndex > 0 ? 1 : 0))                              {                                    token.ThrowIfCancellationRequested();                                  // The table will take care of reconstructing indexes automatically                                  outputTable.Insert(ref entry.Reader);                                  copiedEntries++;                                  transactionSize += entry.Reader.Size;                                    var reportRate = inputTable.NumberOfEntries / 33 + 1;                                  if (copiedEntries % reportRate == 0)                                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                                    // The transaction has surpassed the allowed                                  // size before a flush                                  if (transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                                  {                                      lastFixedIndex = fixedSizeIndex.GetValue(ref entry.Reader);                                      break;                                  }                              }                          }                      }                      else                      {                          // The table has a primary key' inserts in that order are expected to be faster                          foreach (var entry in inputTable.SeekByPrimaryKey(lastSlice' 0))                          {                              token.ThrowIfCancellationRequested();                              // The table will take care of reconstructing indexes automatically                              outputTable.Insert(ref entry.Reader);                              copiedEntries++;                              transactionSize += entry.Reader.Size;                                // The transaction has surpassed the allowed                              // size before a flush                              if (transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                              {                                  schema.Key.GetSlice(txr.Allocator' ref entry.Reader' out lastSlice);                                  break;                              }                          }                      }                        txw.Commit();                  }                    if (copiedEntries == inputTable.NumberOfEntries)                  {                      copiedTrees++;                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Finished copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                  }                    compactedEnv.FlushLogToDataFile();              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The following statement contains a magic number: while (copiedEntries < inputTable.NumberOfEntries)              {                  token.ThrowIfCancellationRequested();                  using (var txw = compactedEnv.WriteTransaction(context))                  {                      long transactionSize = 0L;                        var outputTable = txw.OpenTable(schema' treeName);                        if (schema.Key == null || schema.Key.IsGlobal)                       {                          // There is no primary key' or there is one that is global to multiple tables                          // we require a table to have at least a single local index that we'll use                            var variableSizeIndex = schema.Indexes.Values.FirstOrDefault(x=>x.IsGlobal == false);                            if (variableSizeIndex!= null)                          {                              // We have a variable size index' use it                                // In case we continue an existing compaction' skip to the next slice                              var skip = 0;                              if (SliceComparer.Compare(lastSlice' Slices.BeforeAllKeys) != 0)                                  skip = 1;                                foreach (var tvr in inputTable.SeekForwardFrom(variableSizeIndex' lastSlice' skip))                              {                                  // The table will take care of reconstructing indexes automatically                                  outputTable.Insert(ref tvr.Result.Reader);                                  copiedEntries++;                                  transactionSize += tvr.Result.Reader.Size;                                    var reportRate = inputTable.NumberOfEntries / 33 + 1;                                  if (copiedEntries % reportRate == 0)                                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                                                                    // The transaction has surpassed the allowed                                  // size before a flush                                  if (lastSlice.Equals(tvr.Key) == false && transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                                  {                                      lastSlice = tvr.Key.Clone(txr.Allocator);                                      break;                                  }                              }                          }                          else                          {                              // Use a fixed size index                              var fixedSizeIndex = schema.FixedSizeIndexes.Values.FirstOrDefault(x => x.IsGlobal == false);                                if (fixedSizeIndex == null)                                  throw new InvalidOperationException("Cannot compact table " + inputTable.Name + " because is has no local indexes' only global ones");                                                              foreach (var entry in inputTable.SeekForwardFrom(fixedSizeIndex' lastFixedIndex' lastFixedIndex > 0 ? 1 : 0))                              {                                    token.ThrowIfCancellationRequested();                                  // The table will take care of reconstructing indexes automatically                                  outputTable.Insert(ref entry.Reader);                                  copiedEntries++;                                  transactionSize += entry.Reader.Size;                                    var reportRate = inputTable.NumberOfEntries / 33 + 1;                                  if (copiedEntries % reportRate == 0)                                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                                    // The transaction has surpassed the allowed                                  // size before a flush                                  if (transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                                  {                                      lastFixedIndex = fixedSizeIndex.GetValue(ref entry.Reader);                                      break;                                  }                              }                          }                      }                      else                      {                          // The table has a primary key' inserts in that order are expected to be faster                          foreach (var entry in inputTable.SeekByPrimaryKey(lastSlice' 0))                          {                              token.ThrowIfCancellationRequested();                              // The table will take care of reconstructing indexes automatically                              outputTable.Insert(ref entry.Reader);                              copiedEntries++;                              transactionSize += entry.Reader.Size;                                // The transaction has surpassed the allowed                              // size before a flush                              if (transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                              {                                  schema.Key.GetSlice(txr.Allocator' ref entry.Reader' out lastSlice);                                  break;                              }                          }                      }                        txw.Commit();                  }                    if (copiedEntries == inputTable.NumberOfEntries)                  {                      copiedTrees++;                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Finished copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                  }                    compactedEnv.FlushLogToDataFile();              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The following statement contains a magic number: while (copiedEntries < inputTable.NumberOfEntries)              {                  token.ThrowIfCancellationRequested();                  using (var txw = compactedEnv.WriteTransaction(context))                  {                      long transactionSize = 0L;                        var outputTable = txw.OpenTable(schema' treeName);                        if (schema.Key == null || schema.Key.IsGlobal)                       {                          // There is no primary key' or there is one that is global to multiple tables                          // we require a table to have at least a single local index that we'll use                            var variableSizeIndex = schema.Indexes.Values.FirstOrDefault(x=>x.IsGlobal == false);                            if (variableSizeIndex!= null)                          {                              // We have a variable size index' use it                                // In case we continue an existing compaction' skip to the next slice                              var skip = 0;                              if (SliceComparer.Compare(lastSlice' Slices.BeforeAllKeys) != 0)                                  skip = 1;                                foreach (var tvr in inputTable.SeekForwardFrom(variableSizeIndex' lastSlice' skip))                              {                                  // The table will take care of reconstructing indexes automatically                                  outputTable.Insert(ref tvr.Result.Reader);                                  copiedEntries++;                                  transactionSize += tvr.Result.Reader.Size;                                    var reportRate = inputTable.NumberOfEntries / 33 + 1;                                  if (copiedEntries % reportRate == 0)                                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                                                                    // The transaction has surpassed the allowed                                  // size before a flush                                  if (lastSlice.Equals(tvr.Key) == false && transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                                  {                                      lastSlice = tvr.Key.Clone(txr.Allocator);                                      break;                                  }                              }                          }                          else                          {                              // Use a fixed size index                              var fixedSizeIndex = schema.FixedSizeIndexes.Values.FirstOrDefault(x => x.IsGlobal == false);                                if (fixedSizeIndex == null)                                  throw new InvalidOperationException("Cannot compact table " + inputTable.Name + " because is has no local indexes' only global ones");                                                              foreach (var entry in inputTable.SeekForwardFrom(fixedSizeIndex' lastFixedIndex' lastFixedIndex > 0 ? 1 : 0))                              {                                    token.ThrowIfCancellationRequested();                                  // The table will take care of reconstructing indexes automatically                                  outputTable.Insert(ref entry.Reader);                                  copiedEntries++;                                  transactionSize += entry.Reader.Size;                                    var reportRate = inputTable.NumberOfEntries / 33 + 1;                                  if (copiedEntries % reportRate == 0)                                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                                    // The transaction has surpassed the allowed                                  // size before a flush                                  if (transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                                  {                                      lastFixedIndex = fixedSizeIndex.GetValue(ref entry.Reader);                                      break;                                  }                              }                          }                      }                      else                      {                          // The table has a primary key' inserts in that order are expected to be faster                          foreach (var entry in inputTable.SeekByPrimaryKey(lastSlice' 0))                          {                              token.ThrowIfCancellationRequested();                              // The table will take care of reconstructing indexes automatically                              outputTable.Insert(ref entry.Reader);                              copiedEntries++;                              transactionSize += entry.Reader.Size;                                // The transaction has surpassed the allowed                              // size before a flush                              if (transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                              {                                  schema.Key.GetSlice(txr.Allocator' ref entry.Reader' out lastSlice);                                  break;                              }                          }                      }                        txw.Commit();                  }                    if (copiedEntries == inputTable.NumberOfEntries)                  {                      copiedTrees++;                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Finished copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                  }                    compactedEnv.FlushLogToDataFile();              }
Magic Number,Voron.Impl.Compaction,StorageCompaction,C:\repos\ravendb_ravendb\src\Voron\Impl\Compaction\StorageCompaction.cs,CopyTableTree,The following statement contains a magic number: while (copiedEntries < inputTable.NumberOfEntries)              {                  token.ThrowIfCancellationRequested();                  using (var txw = compactedEnv.WriteTransaction(context))                  {                      long transactionSize = 0L;                        var outputTable = txw.OpenTable(schema' treeName);                        if (schema.Key == null || schema.Key.IsGlobal)                       {                          // There is no primary key' or there is one that is global to multiple tables                          // we require a table to have at least a single local index that we'll use                            var variableSizeIndex = schema.Indexes.Values.FirstOrDefault(x=>x.IsGlobal == false);                            if (variableSizeIndex!= null)                          {                              // We have a variable size index' use it                                // In case we continue an existing compaction' skip to the next slice                              var skip = 0;                              if (SliceComparer.Compare(lastSlice' Slices.BeforeAllKeys) != 0)                                  skip = 1;                                foreach (var tvr in inputTable.SeekForwardFrom(variableSizeIndex' lastSlice' skip))                              {                                  // The table will take care of reconstructing indexes automatically                                  outputTable.Insert(ref tvr.Result.Reader);                                  copiedEntries++;                                  transactionSize += tvr.Result.Reader.Size;                                    var reportRate = inputTable.NumberOfEntries / 33 + 1;                                  if (copiedEntries % reportRate == 0)                                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                                                                    // The transaction has surpassed the allowed                                  // size before a flush                                  if (lastSlice.Equals(tvr.Key) == false && transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                                  {                                      lastSlice = tvr.Key.Clone(txr.Allocator);                                      break;                                  }                              }                          }                          else                          {                              // Use a fixed size index                              var fixedSizeIndex = schema.FixedSizeIndexes.Values.FirstOrDefault(x => x.IsGlobal == false);                                if (fixedSizeIndex == null)                                  throw new InvalidOperationException("Cannot compact table " + inputTable.Name + " because is has no local indexes' only global ones");                                                              foreach (var entry in inputTable.SeekForwardFrom(fixedSizeIndex' lastFixedIndex' lastFixedIndex > 0 ? 1 : 0))                              {                                    token.ThrowIfCancellationRequested();                                  // The table will take care of reconstructing indexes automatically                                  outputTable.Insert(ref entry.Reader);                                  copiedEntries++;                                  transactionSize += entry.Reader.Size;                                    var reportRate = inputTable.NumberOfEntries / 33 + 1;                                  if (copiedEntries % reportRate == 0)                                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                                    // The transaction has surpassed the allowed                                  // size before a flush                                  if (transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                                  {                                      lastFixedIndex = fixedSizeIndex.GetValue(ref entry.Reader);                                      break;                                  }                              }                          }                      }                      else                      {                          // The table has a primary key' inserts in that order are expected to be faster                          foreach (var entry in inputTable.SeekByPrimaryKey(lastSlice' 0))                          {                              token.ThrowIfCancellationRequested();                              // The table will take care of reconstructing indexes automatically                              outputTable.Insert(ref entry.Reader);                              copiedEntries++;                              transactionSize += entry.Reader.Size;                                // The transaction has surpassed the allowed                              // size before a flush                              if (transactionSize >= compactedEnv.Options.MaxScratchBufferSize / 2)                              {                                  schema.Key.GetSlice(txr.Allocator' ref entry.Reader' out lastSlice);                                  break;                              }                          }                      }                        txw.Commit();                  }                    if (copiedEntries == inputTable.NumberOfEntries)                  {                      copiedTrees++;                      Report(copiedTrees' totalTreesCount' copiedEntries' inputTable.NumberOfEntries' progressReport' $"Finished copying table tree '{treeName}'. Progress: {copiedEntries}/{inputTable.NumberOfEntries} entries."' treeName);                  }                    compactedEnv.FlushLogToDataFile();              }
Magic Number,Voron.Impl.FileHeaders,HeaderAccessor,C:\repos\ravendb_ravendb\src\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,The following statement contains a magic number: try              {                  if (_theHeader == null)                      throw new ObjectDisposedException("Cannot access the header after it was disposed");                    var headers = stackalloc FileHeader[2];                  var f1 = &headers[0];                  var f2 = &headers[1];                  var hasHeader1 = _env.Options.ReadHeader(HeaderFileNames[0]' f1);                  var hasHeader2 = _env.Options.ReadHeader(HeaderFileNames[1]' f2);                  if (hasHeader1 == false && hasHeader2 == false)                  {                      // new                       FillInEmptyHeader(f1);                      FillInEmptyHeader(f2);                      f1->Hash = CalculateFileHeaderHash(f1);                      f2->Hash = CalculateFileHeaderHash(f2);                      _env.Options.WriteHeader(HeaderFileNames[0]' f1);                      _env.Options.WriteHeader(HeaderFileNames[1]' f2);                        Memory.Copy((byte*)_theHeader' (byte*)f1' sizeof(FileHeader));                      return true; // new                  }                    if (f1->MagicMarker != Constants.MagicMarker && f2->MagicMarker != Constants.MagicMarker)                      throw new InvalidDataException("None of the header files start with the magic marker' probably not db files or fatal corruption on " + _env.Options.BasePath);                    if (!ValidHash(f1) && !ValidHash(f2))                      throw new InvalidDataException("None of the header files have a valid hash' possible corruption on " + _env.Options.BasePath);                    // if one of the files is corrupted' but the other isn't' restore to the valid file                  if (f1->MagicMarker != Constants.MagicMarker || !ValidHash(f1))                  {                      *f1 = *f2;                  }                                    if (f2->MagicMarker != Constants.MagicMarker || !ValidHash(f2))                  {                      *f2 = *f1;                  }                    if (f1->Version != Constants.CurrentVersion)                      throw new InvalidDataException(                          $"The db file is for version {f1->Version}' which is not compatible with the current version {Constants.CurrentVersion} on {_env.Options.BasePath}");                    if (f1->TransactionId < 0)                      throw new InvalidDataException("The transaction number cannot be negative on " + _env.Options.BasePath);                      if (f1->HeaderRevision > f2->HeaderRevision)                  {                      Memory.Copy((byte*)_theHeader' (byte*)f1' sizeof(FileHeader));                  }                  else                  {                      Memory.Copy((byte*)_theHeader' (byte*)f2' sizeof(FileHeader));                  }                  _revision = _theHeader->HeaderRevision;                    if (_theHeader->PageSize != Constants.Storage.PageSize)                  {                      var message = string.Format("PageSize mismatch' configured to be {0:#'#} but was {1:#'#}' using the actual value in the file {1:#'#}"'                          Constants.Storage.PageSize' _theHeader->PageSize);                      _env.Options.InvokeRecoveryError(this' message' null);                  }                    return false;              }              finally              {                  _locker.ExitWriteLock();              }
Magic Number,Voron.Impl.FreeSpace,FreeSpaceHandling,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\FreeSpaceHandling.cs,GetFreeSpaceTree,The following statement contains a magic number: return tx._freeSpaceTree = new FixedSizeTree(tx' tx.RootObjects' FreeSpaceKey' 260' clone: false)              {                  FreeSpaceTree = true              };
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,FirstSetBit,The following statement contains a magic number: for (int i = 0; i < _inner.Length; i++)              {                  if (_inner[i] == 0)                      continue;                  return i << 5 | HighestBitSet(_inner[i]);              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 2;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 4;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 8;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 16;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: return MultiplyDeBruijnBitPosition[(uint)(v * 0x07C4ACDDU) >> 27];
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,Get,The following statement contains a magic number: return (_inner[index >> 5] & (1 << (index & 31))) != 0;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,Get,The following statement contains a magic number: return (_inner[index >> 5] & (1 << (index & 31))) != 0;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,Set,The following statement contains a magic number: if (value)              {                  _inner[index >> 5] |= (1 << (index & 31));                  SetCount++;              }              else              {                  _inner[index >> 5] &= ~(1 << (index & 31));                  SetCount--;              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,Set,The following statement contains a magic number: if (value)              {                  _inner[index >> 5] |= (1 << (index & 31));                  SetCount++;              }              else              {                  _inner[index >> 5] &= ~(1 << (index & 31));                  SetCount--;              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,Set,The following statement contains a magic number: if (value)              {                  _inner[index >> 5] |= (1 << (index & 31));                  SetCount++;              }              else              {                  _inner[index >> 5] &= ~(1 << (index & 31));                  SetCount--;              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,Set,The following statement contains a magic number: if (value)              {                  _inner[index >> 5] |= (1 << (index & 31));                  SetCount++;              }              else              {                  _inner[index >> 5] &= ~(1 << (index & 31));                  SetCount--;              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,GetEndRangeCount,The following statement contains a magic number: for (int i = _inner.Length * 32 -1; i >= 0; i--)              {                  if (Get(i) == false)                      break;                  c++;              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,HasStartRangeCount,The following statement contains a magic number: var len = _inner.Length*32;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ravendb_ravendb\src\Voron\Impl\FreeSpace\StreamBitArray.cs,ToStream,The following statement contains a magic number: var ms = new MemoryStream(260);
Magic Number,Voron.Impl.Journal,JournalFile,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalFile.cs,Write,The following statement contains a magic number: if (tx.IsLazyTransaction == false && (lazyTransactionScratch == null || lazyTransactionScratch.HasDataInBuffer() == false))              {                  try                  {                      _journalWriter.Write(cur4KbPos' pages.Base' pages.NumberOf4Kbs);                  }                  catch (Exception e)                  {                      _env.Options.SetCatastrophicFailure(ExceptionDispatchInfo.Capture(e));                      throw;                  }              }              else              {                  if (lazyTransactionScratch == null)                      throw new InvalidOperationException("lazyTransactionScratch cannot be null if the transaction is lazy (or a previous one was)");                  lazyTransactionScratch.EnsureSize(_journalWriter.NumberOfAllocated4Kb);                  lazyTransactionScratch.AddToBuffer(cur4KbPos' pages);                    // non lazy tx will add itself to the buffer and then flush scratch to journal                  if (tx.IsLazyTransaction == false ||                      lazyTransactionScratch.NumberOfPages > tx.Environment.ScratchBufferPool.GetAvailablePagesCount() / 2)                  {                      try                      {                          lazyTransactionScratch.WriteBufferToFile(this' tx);                      }                      catch (Exception e)                      {                          _env.Options.SetCatastrophicFailure(ExceptionDispatchInfo.Capture(e));                          throw;                      }                  }                  else                  {                      lazyTransactionScratch.EnsureHasExistingReadTransaction(tx);                  }              }
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,JournalReader,The following statement contains a magic number: _journalPagerNumberOfAllocated4Kb =                   _journalPager.TotalAllocationSize /(4*Constants.Size.Kilobyte);
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionToDataFile,The following statement contains a magic number: var transactionSizeIn4Kb =                  (size + sizeof(TransactionHeader)) / (4*Constants.Size.Kilobyte) +                  ((size + sizeof(TransactionHeader)) % (4*Constants.Size.Kilobyte) == 0 ? 0 : 1);
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionToDataFile,The following statement contains a magic number: var transactionSizeIn4Kb =                  (size + sizeof(TransactionHeader)) / (4*Constants.Size.Kilobyte) +                  ((size + sizeof(TransactionHeader)) % (4*Constants.Size.Kilobyte) == 0 ? 0 : 1);
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,DecryptTransaction,The following statement contains a magic number: ulong macLen = 16;
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,DecryptTransaction,The following statement contains a magic number: var subKey = stackalloc byte[32];
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,DecryptTransaction,The following statement contains a magic number: fixed (byte* mk = options.MasterKey)              fixed (byte* ctx = Sodium.Context)              {                  if (Sodium.crypto_kdf_derive_from_key(subKey' (UIntPtr)32' (ulong)num' ctx' mk) != 0)                      throw new InvalidOperationException("Unable to generate derived key");              }
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,TryReadAndValidateHeader,The following statement contains a magic number: const int pageTo4KbRatio = Constants.Storage.PageSize / (4 * Constants.Size.Kilobyte);
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,TryReadAndValidateHeader,The following statement contains a magic number: var positionInsidePage = (_readAt4Kb % pageTo4KbRatio) * (4 * Constants.Size.Kilobyte);
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,TryReadAndValidateHeader,The following statement contains a magic number: if (options.EncryptionEnabled)              {                  // We use temp buffers to hold the transaction before decrypting' and release the buffers afterwards.                  var pagesSize = current->CompressedSize != -1 ? current->CompressedSize : current->UncompressedSize;                  var size = (4*Constants.Size.Kilobyte) * GetNumberOf4KbFor(sizeof(TransactionHeader) + pagesSize);                    var ptr = NativeMemory.Allocate4KbAlignedMemory(size' out var thread);                  var buffer = new EncryptionBuffer                  {                      Pointer = ptr'                      Size = size'                      AllocatingThread = thread                  };                    _encryptionBuffers.Add(buffer);                  Memory.Copy(buffer.Pointer' (byte*)current' size);                  current = (TransactionHeader*)buffer.Pointer;                    try                  {                      DecryptTransaction((byte*)current' options);                  }                  catch (InvalidOperationException ex)                  {                      RequireHeaderUpdate = true;                      options.InvokeRecoveryError(this' "Transaction " + current->TransactionId + " was not committed"' ex);                      return false;                  }              }
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,ValidatePagesHash,The following statement contains a magic number: if (size >                  (_journalPagerNumberOfAllocated4Kb - _readAt4Kb) * 4 * Constants.Size.Kilobyte)              {                  // we can't read past the end of the journal                  RequireHeaderUpdate = true;                  var compressLabel = (current->CompressedSize != -1) ? "Compressed" : "Uncompressed";                  options.InvokeRecoveryError(this' $"Size {size} ({compressLabel}) is too big for the journal size {_journalPagerNumberOfAllocated4Kb * 4 * Constants.Size.Kilobyte}"' null);                  return false;              }
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,ValidatePagesHash,The following statement contains a magic number: if (size >                  (_journalPagerNumberOfAllocated4Kb - _readAt4Kb) * 4 * Constants.Size.Kilobyte)              {                  // we can't read past the end of the journal                  RequireHeaderUpdate = true;                  var compressLabel = (current->CompressedSize != -1) ? "Compressed" : "Uncompressed";                  options.InvokeRecoveryError(this' $"Size {size} ({compressLabel}) is too big for the journal size {_journalPagerNumberOfAllocated4Kb * 4 * Constants.Size.Kilobyte}"' null);                  return false;              }
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,GetNumberOf4KbFor,The following statement contains a magic number: return checked((int)(size / (4*Constants.Size.Kilobyte)) + (size % (4 * Constants.Size.Kilobyte) == 0 ? 0 : 1));
Magic Number,Voron.Impl.Journal,JournalReader,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\JournalReader.cs,GetNumberOf4KbFor,The following statement contains a magic number: return checked((int)(size / (4*Constants.Size.Kilobyte)) + (size % (4 * Constants.Size.Kilobyte) == 0 ? 0 : 1));
Magic Number,Voron.Impl.Journal,LazyTransactionBuffer,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\LazyTransactionBuffer.cs,WriteBufferToFile,The following statement contains a magic number: if (_firstPositionInJournalFile != null)              {                  using (var tempTx = new TempPagerTransaction())                  {                      var numberOfPages = _lastUsed4Kbs / (Constants.Storage.PageSize / (4 * Constants.Size.Kilobyte));                      if ((_lastUsed4Kbs % (Constants.Storage.PageSize / (4 * Constants.Size.Kilobyte))) != 0)                          numberOfPages++;                        _lazyTransactionPager.EnsureMapped(tempTx' 0' numberOfPages);                      var src = _lazyTransactionPager.AcquirePagePointer(tempTx' 0);                      var sp = Stopwatch.StartNew();                      journalFile.JournalWriter.Write(_firstPositionInJournalFile.Value' src' _lastUsed4Kbs);                      if (_log.IsInfoEnabled)                      {                          _log.Info($"Writing lazy transaction buffer with {_lastUsed4Kbs / 4:#'#0} kb took {sp.Elapsed}");                      }                      ZeroLazyTransactionBufferIfNeeded(tempTx);                  }              }
Magic Number,Voron.Impl.Journal,LazyTransactionBuffer,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\LazyTransactionBuffer.cs,WriteBufferToFile,The following statement contains a magic number: if (_firstPositionInJournalFile != null)              {                  using (var tempTx = new TempPagerTransaction())                  {                      var numberOfPages = _lastUsed4Kbs / (Constants.Storage.PageSize / (4 * Constants.Size.Kilobyte));                      if ((_lastUsed4Kbs % (Constants.Storage.PageSize / (4 * Constants.Size.Kilobyte))) != 0)                          numberOfPages++;                        _lazyTransactionPager.EnsureMapped(tempTx' 0' numberOfPages);                      var src = _lazyTransactionPager.AcquirePagePointer(tempTx' 0);                      var sp = Stopwatch.StartNew();                      journalFile.JournalWriter.Write(_firstPositionInJournalFile.Value' src' _lastUsed4Kbs);                      if (_log.IsInfoEnabled)                      {                          _log.Info($"Writing lazy transaction buffer with {_lastUsed4Kbs / 4:#'#0} kb took {sp.Elapsed}");                      }                      ZeroLazyTransactionBufferIfNeeded(tempTx);                  }              }
Magic Number,Voron.Impl.Journal,LazyTransactionBuffer,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\LazyTransactionBuffer.cs,WriteBufferToFile,The following statement contains a magic number: if (_firstPositionInJournalFile != null)              {                  using (var tempTx = new TempPagerTransaction())                  {                      var numberOfPages = _lastUsed4Kbs / (Constants.Storage.PageSize / (4 * Constants.Size.Kilobyte));                      if ((_lastUsed4Kbs % (Constants.Storage.PageSize / (4 * Constants.Size.Kilobyte))) != 0)                          numberOfPages++;                        _lazyTransactionPager.EnsureMapped(tempTx' 0' numberOfPages);                      var src = _lazyTransactionPager.AcquirePagePointer(tempTx' 0);                      var sp = Stopwatch.StartNew();                      journalFile.JournalWriter.Write(_firstPositionInJournalFile.Value' src' _lastUsed4Kbs);                      if (_log.IsInfoEnabled)                      {                          _log.Info($"Writing lazy transaction buffer with {_lastUsed4Kbs / 4:#'#0} kb took {sp.Elapsed}");                      }                      ZeroLazyTransactionBufferIfNeeded(tempTx);                  }              }
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,NextFile,The following statement contains a magic number: if ((now - _lastFile).TotalSeconds < 90)              {                  _currentJournalFileSize = Math.Min(_env.Options.MaxLogFileSize' _currentJournalFileSize * 2);              }
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,NextFile,The following statement contains a magic number: if ((now - _lastFile).TotalSeconds < 90)              {                  _currentJournalFileSize = Math.Min(_env.Options.MaxLogFileSize' _currentJournalFileSize * 2);              }
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,NextFile,The following statement contains a magic number: long minRequiredSize = numberOf4Kbs * 4 * Constants.Size.Kilobyte;
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,The following statement contains a magic number: if (_files.Count > 0)              {                  var lastFile = _files.Last();                  if (lastFile.Available4Kbs >= 2)                      // it must have at least one page for the next transaction header and one 4kb for data                      CurrentFile = lastFile;              }
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,WriteToJournal,The following statement contains a magic number: lock (_writeLock)              {                  var sp = Stopwatch.StartNew();                  var journalEntry = PrepareToWriteToJournal(tx);                  if (_logger.IsInfoEnabled)                  {                      _logger.Info($"Preparing to write tx {tx.Id} to journal with {journalEntry.NumberOfUncompressedPages:#'#} pages ({(journalEntry.NumberOfUncompressedPages * Constants.Storage.PageSize) / Constants.Size.Kilobyte:#'#} kb) in {sp.Elapsed} with {Math.Round(journalEntry.NumberOf4Kbs * 4d' 1):#'#.#;;0} kb compressed.");                  }                    if (tx.IsLazyTransaction && _lazyTransactionBuffer == null)                  {                      _lazyTransactionBuffer = new LazyTransactionBuffer(_env.Options);                  }                    if (CurrentFile == null || CurrentFile.Available4Kbs < journalEntry.NumberOf4Kbs)                  {                      _lazyTransactionBuffer?.WriteBufferToFile(CurrentFile' tx);                      CurrentFile = NextFile(journalEntry.NumberOf4Kbs);                      if (_logger.IsInfoEnabled)                          _logger.Info($"New journal file created {CurrentFile.Number:D19}");                  }                    sp.Restart();                  CurrentFile.Write(tx' journalEntry' _lazyTransactionBuffer);                  sp.Stop();                  _lastCompressionAccelerationInfo.WriteDuration = sp.Elapsed;                  _lastCompressionAccelerationInfo.CalculateOptimalAcceleration();                    if (_logger.IsInfoEnabled)                      _logger.Info($"Writing {journalEntry.NumberOf4Kbs * 4:#'#} kb to journal {CurrentFile.Number:D19} took {sp.Elapsed}");                      if (CurrentFile.Available4Kbs == 0)                  {                      _lazyTransactionBuffer?.WriteBufferToFile(CurrentFile' tx);                      CurrentFile = null;                  }                  ZeroCompressionBufferIfNeeded(tx);                  ReduceSizeOfCompressionBufferIfNeeded();                    return journalEntry;              }
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The following statement contains a magic number: var remainder = totalLength % (4 * Constants.Size.Kilobyte);
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The following statement contains a magic number: int entireBuffer4Kbs = checked((int)((totalLength / (4 * Constants.Size.Kilobyte)) + (remainder == 0 ? 0 : 1)));
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The following statement contains a magic number: if (remainder != 0)              {                  // zero the remainder of the page                  UnmanagedMemory.Set(txHeaderPtr + totalLength' 0' 4 * Constants.Size.Kilobyte - remainder);              }
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,PrepareToWriteToJournal,The following statement contains a magic number: Debug.Assert(((long)txHeaderPtr % (4 * Constants.Size.Kilobyte)) == 0' "Memory must be 4kb aligned");
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,EncryptTransaction,The following statement contains a magic number: ulong macLen = 16;
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,EncryptTransaction,The following statement contains a magic number: var subKey = stackalloc byte[32];
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,EncryptTransaction,The following statement contains a magic number: fixed (byte* mk = _env.Options.MasterKey)              fixed (byte* ctx = Sodium.Context)              {                  var num = txHeader->TransactionId;                  if (Sodium.crypto_kdf_derive_from_key(subKey' (UIntPtr)32' (ulong)num' ctx' mk) != 0)                      throw new InvalidOperationException("Unable to generate derived key");              }
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ReduceSizeOfCompressionBufferIfNeeded,The following statement contains a magic number: if (_logger.IsOperationsEnabled)              {                  _logger.Operations(                      $"Compression buffer: {_compressionPager} has reached size {(_compressionPager.NumberOfAllocatedPages * Constants.Storage.PageSize) / Constants.Size.Kilobyte:#'#0} kb which is more than the limit " +                      $"of {_env.Options.MaxScratchBufferSize / 1024:#'#0} kb. Will trim it now to the max size allowed. If this is happen on a regular basis'" +                      " consider raising the limit (MaxScratchBufferSize option control it)' since it can cause performance issues");              }
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ShouldReduceSizeOfCompressionPager,The following statement contains a magic number: if ((DateTime.UtcNow - _lastCompressionBufferReduceCheck).TotalMinutes < 5)                  return false;
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ShouldReduceSizeOfCompressionPager,The following statement contains a magic number: var shouldReduceSizeOfCompressionPager = _maxNumberOfPagesRequiredForCompressionBuffer < _compressionPager.NumberOfAllocatedPages / 2;
Magic Number,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The following statement contains a magic number: try                  {                      Monitor.TryEnter(_flushingLock' timeToWait' ref lockTaken);                        if (lockTaken == false)                      {                          if (timeToWait == TimeSpan.Zero)                              // someone else is flushing' and we were explicitly told that we don't care about this                              // so there is no point in throwing                              return;                            throw new TimeoutException(                              $"Could not acquire the write lock in {timeToWait.TotalSeconds} seconds");                      }                        if (_waj._env.Disposed)                          return;                          var jrnls = GetJournalSnapshots();                        if (jrnls.Count == 0)                          return; // nothing to do                        Debug.Assert(jrnls.First().Number >= _lastFlushedJournalId);                        var pagesToWrite = new Dictionary<long' PagePosition>();                        long lastProcessedJournal = -1;                      long previousJournalMaxTransactionId = -1;                        long lastFlushedTransactionId = -1;                        long oldestActiveTransaction = _waj._env.ActiveTransactions.OldestTransaction;                        foreach (var journalFile in jrnls)                      {                          if (journalFile.Number < _lastFlushedJournalId)                              continue;                          var currentJournalMaxTransactionId = -1L;                            var maxTransactionId = journalFile.LastTransaction;                          if (oldestActiveTransaction != 0)                              maxTransactionId = Math.Min(oldestActiveTransaction - 1' maxTransactionId);                            foreach (var modifedPagesInTx in journalFile.PageTranslationTable.GetModifiedPagesForTransactionRange(                              _lastFlushedTransactionId' maxTransactionId))                          {                              foreach (var pagePosition in modifedPagesInTx)                              {                                  if (pagePosition.Value.IsFreedPageMarker)                                  {                                      // Avoid the case where an older journal file had written a page that was freed in a different journal                                      pagesToWrite.Remove(pagePosition.Key);                                      continue;                                  }                                    if (journalFile.Number == _lastFlushedJournalId &&                                      pagePosition.Value.TransactionId <= _lastFlushedTransactionId)                                      continue;                                    currentJournalMaxTransactionId = Math.Max(currentJournalMaxTransactionId'                                      pagePosition.Value.TransactionId);                                    if (currentJournalMaxTransactionId < previousJournalMaxTransactionId)                                      ThrowReadByeondOldestActiveTransaction(currentJournalMaxTransactionId' previousJournalMaxTransactionId' oldestActiveTransaction);                                      lastProcessedJournal = journalFile.Number;                                  pagesToWrite[pagePosition.Key] = pagePosition.Value;                                    lastFlushedTransactionId = currentJournalMaxTransactionId;                              }                          }                            if (currentJournalMaxTransactionId == -1L)                              continue;                            previousJournalMaxTransactionId = currentJournalMaxTransactionId;                      }                        if (pagesToWrite.Count == 0)                      {                          return;                      }                        try                      {                          ApplyPagesToDataFileFromScratch(pagesToWrite);                      }                      catch (OutOfMemoryException e)                      {                          if (_waj._logger.IsOperationsEnabled)                          {                              _waj._logger.Operations("Could not allocate enough space to apply pages to data file"' e);                          }                          // on 32 bits systems' we likely run out of address space' nothing that we can do' this should                          // be handled by the 32 bits pager.                          return;                      }                      catch (DiskFullException diskFullEx)                      {                          if (_waj._logger.IsOperationsEnabled)                          {                              _waj._logger.Operations("The disk is full!"' diskFullEx);                          }                          _waj._env.HandleDataDiskFullException(diskFullEx);                          return;                      }                        var unusedJournals = GetUnusedJournalFiles(jrnls' lastProcessedJournal' lastFlushedTransactionId);                        var needImmediateFsync =                          _pendingSync.IsCompleted &&                          (_forceDataSync.Lower() ||                           Interlocked.Read(ref _totalWrittenButUnsyncedBytes) > 32 * Constants.Size.Megabyte);                        if (needImmediateFsync)                      {                          // will never wait' we ensure that we have completed the task                          // we call Wait() here to ensure that if there was an error in                           // the previous sync' we'll propagate it out and mark the env                          // as catastrophic failure.                          _pendingSync.Wait(token);                          token.ThrowIfCancellationRequested();                          var operation = new SyncOperation(this);                          if (operation.TryGatherInformationToStartSync(out var syncCounter))                          {                              _pendingSync = operation.Task;                              ThreadPool.QueueUserWorkItem(state => ((SyncOperation)state).CompleteSync(syncCounter)' operation);                          }                      }                        ApplyJournalStateAfterFlush(token' lastProcessedJournal' lastFlushedTransactionId' unusedJournals);                        if (needImmediateFsync == false)                          _waj._env.QueueForSyncDataFile();                  }                  finally                  {                      if (lockTaken)                          Monitor.Exit(_flushingLock);                  }
Magic Number,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,WaitForJournalStateToBeUpdated,The following statement contains a magic number: do                  {                      LowLevelTransaction txw = null;                      try                      {                          try                          {                              txw = _waj._env.NewLowLevelTransaction(transactionPersistentContext'                                  TransactionFlags.ReadWrite' timeout: TimeSpan.Zero);                          }                          catch (OperationCanceledException)                          {                              break;                          }                          catch (TimeoutException)                          {                              // couldn't get the transaction lock' we'll wait for the running transaction to complete                              // for a bit' and then try again                              try                              {                                  if (_waitForJournalStateUpdateUnderTx.Wait(TimeSpan.FromMilliseconds(250)' token))                                      break;                              }                              catch (OperationCanceledException)                              {                                  break;                              }                              continue;                          }                          var action = _updateJournalStateAfterFlush;                          if (action != null)                          {                              action(txw);                              txw.Commit();                          }                          break;                      }                      finally                      {                          txw?.Dispose();                      }                  } while (true);
Magic Number,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,SetLastReadTxHeader,The following statement contains a magic number: while (true)                  {                      if (file.ReadTransaction(txPos' readTxHeader) == false)                          break;                      if (readTxHeader->HeaderMarker != Constants.TransactionHeaderMarker)                          break;                      if (readTxHeader->TransactionId > maxTransactionId)                          break;                      if (lastReadTxHeader.TransactionId > readTxHeader->TransactionId)                          // we got to a trasaction that is smaller than the previous one' this is very                           // likely a reused journal with old transaction' which we can ignore                          break;                        lastReadTxHeader = *readTxHeader;                        var totalSize = readTxHeader->CompressedSize != -1 ? readTxHeader->CompressedSize + sizeof(TransactionHeader) : readTxHeader->UncompressedSize + sizeof(TransactionHeader);                          var roundTo4Kb = (totalSize / (4 * Constants.Size.Kilobyte)) +                                       (totalSize % (4 * Constants.Size.Kilobyte) == 0 ? 0 : 1);                        // We skip to the next transaction header.                      txPos += roundTo4Kb * 4 * Constants.Size.Kilobyte;                  }
Magic Number,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,SetLastReadTxHeader,The following statement contains a magic number: while (true)                  {                      if (file.ReadTransaction(txPos' readTxHeader) == false)                          break;                      if (readTxHeader->HeaderMarker != Constants.TransactionHeaderMarker)                          break;                      if (readTxHeader->TransactionId > maxTransactionId)                          break;                      if (lastReadTxHeader.TransactionId > readTxHeader->TransactionId)                          // we got to a trasaction that is smaller than the previous one' this is very                           // likely a reused journal with old transaction' which we can ignore                          break;                        lastReadTxHeader = *readTxHeader;                        var totalSize = readTxHeader->CompressedSize != -1 ? readTxHeader->CompressedSize + sizeof(TransactionHeader) : readTxHeader->UncompressedSize + sizeof(TransactionHeader);                          var roundTo4Kb = (totalSize / (4 * Constants.Size.Kilobyte)) +                                       (totalSize % (4 * Constants.Size.Kilobyte) == 0 ? 0 : 1);                        // We skip to the next transaction header.                      txPos += roundTo4Kb * 4 * Constants.Size.Kilobyte;                  }
Magic Number,Voron.Impl.Journal,JournalApplicator,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,SetLastReadTxHeader,The following statement contains a magic number: while (true)                  {                      if (file.ReadTransaction(txPos' readTxHeader) == false)                          break;                      if (readTxHeader->HeaderMarker != Constants.TransactionHeaderMarker)                          break;                      if (readTxHeader->TransactionId > maxTransactionId)                          break;                      if (lastReadTxHeader.TransactionId > readTxHeader->TransactionId)                          // we got to a trasaction that is smaller than the previous one' this is very                           // likely a reused journal with old transaction' which we can ignore                          break;                        lastReadTxHeader = *readTxHeader;                        var totalSize = readTxHeader->CompressedSize != -1 ? readTxHeader->CompressedSize + sizeof(TransactionHeader) : readTxHeader->UncompressedSize + sizeof(TransactionHeader);                          var roundTo4Kb = (totalSize / (4 * Constants.Size.Kilobyte)) +                                       (totalSize % (4 * Constants.Size.Kilobyte) == 0 ? 0 : 1);                        // We skip to the next transaction header.                      txPos += roundTo4Kb * 4 * Constants.Size.Kilobyte;                  }
Magic Number,Voron.Impl.Journal,CompressionAccelerationStats,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,CalculateOptimalAcceleration,The following statement contains a magic number: if (CompressionDuration > WriteDuration.Add(WriteDuration))                  {                      if (_lastAcceleration < 99)                      {                          _lastAcceleration = Math.Min(99' _lastAcceleration + 2);                          _flux = -4;                      }                      return;                  }
Magic Number,Voron.Impl.Journal,CompressionAccelerationStats,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,CalculateOptimalAcceleration,The following statement contains a magic number: if (CompressionDuration > WriteDuration.Add(WriteDuration))                  {                      if (_lastAcceleration < 99)                      {                          _lastAcceleration = Math.Min(99' _lastAcceleration + 2);                          _flux = -4;                      }                      return;                  }
Magic Number,Voron.Impl.Journal,CompressionAccelerationStats,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,CalculateOptimalAcceleration,The following statement contains a magic number: if (CompressionDuration > WriteDuration.Add(WriteDuration))                  {                      if (_lastAcceleration < 99)                      {                          _lastAcceleration = Math.Min(99' _lastAcceleration + 2);                          _flux = -4;                      }                      return;                  }
Magic Number,Voron.Impl.Journal,CompressionAccelerationStats,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,CalculateOptimalAcceleration,The following statement contains a magic number: if (CompressionDuration > WriteDuration.Add(WriteDuration))                  {                      if (_lastAcceleration < 99)                      {                          _lastAcceleration = Math.Min(99' _lastAcceleration + 2);                          _flux = -4;                      }                      return;                  }
Magic Number,Voron.Impl.Journal,CompressionAccelerationStats,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,CalculateOptimalAcceleration,The following statement contains a magic number: if (CompressionDuration <= WriteDuration)                  {                      // write time is higher than compression time' so compression is worth it                      if (++_flux > 5)                      {                          _lastAcceleration = Math.Max(1' _lastAcceleration - 1);                          _flux = 3;                      }                        return;                  }
Magic Number,Voron.Impl.Journal,CompressionAccelerationStats,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,CalculateOptimalAcceleration,The following statement contains a magic number: if (CompressionDuration <= WriteDuration)                  {                      // write time is higher than compression time' so compression is worth it                      if (++_flux > 5)                      {                          _lastAcceleration = Math.Max(1' _lastAcceleration - 1);                          _flux = 3;                      }                        return;                  }
Magic Number,Voron.Impl.Journal,CompressionAccelerationStats,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,CalculateOptimalAcceleration,The following statement contains a magic number: if (--_flux < -5)                  {                      _lastAcceleration = Math.Min(99' _lastAcceleration + 1);                      _flux = -2;                  }
Magic Number,Voron.Impl.Journal,CompressionAccelerationStats,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,CalculateOptimalAcceleration,The following statement contains a magic number: if (--_flux < -5)                  {                      _lastAcceleration = Math.Min(99' _lastAcceleration + 1);                      _flux = -2;                  }
Magic Number,Voron.Impl.Journal,CompressionAccelerationStats,C:\repos\ravendb_ravendb\src\Voron\Impl\Journal\WriteAheadJournal.cs,CalculateOptimalAcceleration,The following statement contains a magic number: if (--_flux < -5)                  {                      _lastAcceleration = Math.Min(99' _lastAcceleration + 1);                      _flux = -2;                  }
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,AbstractPager,The following statement contains a magic number: Debug.Assert((Constants.Storage.PageSize - Constants.Tree.PageHeaderSize) / Constants.Tree.MinKeysInPage >= 1024);
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,AbstractPager,The following statement contains a magic number: NodeMaxSize = PageMaxSpace / 2 - 1;
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,AbstractPager,The following statement contains a magic number: PageMinSpace = (int)(PageMaxSpace * 0.33);
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (timeSinceLastIncrease.TotalMinutes < 3)              {                  _increaseSize = Math.Min(_increaseSize * 2' MaxIncreaseSize);              }              else if (timeSinceLastIncrease.TotalMinutes > 15)              {                  _increaseSize = Math.Max(MinIncreaseSize' _increaseSize / 2);              }
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (timeSinceLastIncrease.TotalMinutes < 3)              {                  _increaseSize = Math.Min(_increaseSize * 2' MaxIncreaseSize);              }              else if (timeSinceLastIncrease.TotalMinutes > 15)              {                  _increaseSize = Math.Max(MinIncreaseSize' _increaseSize / 2);              }
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (timeSinceLastIncrease.TotalMinutes < 3)              {                  _increaseSize = Math.Min(_increaseSize * 2' MaxIncreaseSize);              }              else if (timeSinceLastIncrease.TotalMinutes > 15)              {                  _increaseSize = Math.Max(MinIncreaseSize' _increaseSize / 2);              }
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (timeSinceLastIncrease.TotalMinutes < 3)              {                  _increaseSize = Math.Min(_increaseSize * 2' MaxIncreaseSize);              }              else if (timeSinceLastIncrease.TotalMinutes > 15)              {                  _increaseSize = Math.Max(MinIncreaseSize' _increaseSize / 2);              }
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: var actualIncrease = Math.Min(_increaseSize' current / 2);
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (totalSize < 512 * 1024 * 1024L)                  return Bits.NextPowerOf2(totalSize);
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (totalSize < 512 * 1024 * 1024L)                  return Bits.NextPowerOf2(totalSize);
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,CopyPageImpl,The following statement contains a magic number: const int adjustPageSize = (Constants.Storage.PageSize)/(4*Constants.Size.Kilobyte);
Magic Number,Voron.Impl.Paging,Simple4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,Write,The following statement contains a magic number: const int pageSizeTo4KbRatio = (Constants.Storage.PageSize / (4 * Constants.Size.Kilobyte));
Magic Number,Voron.Impl.Paging,Simple4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,Write,The following statement contains a magic number: var toWrite = numberOf4Kbs * 4 * Constants.Size.Kilobyte;
Magic Number,Voron.Impl.Paging,Simple4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\AbstractPager.cs,Write,The following statement contains a magic number: byte* destination = _abstractPager.AcquirePagePointer(null' pageNumber' _pagerState)                                  + (offsetBy4Kb * 4 * Constants.Size.Kilobyte);
Magic Number,Voron.Impl.Paging,CryptoPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\CryptoPager.cs,EncryptPage,The following statement contains a magic number: var subKey = stackalloc byte[32];
Magic Number,Voron.Impl.Paging,CryptoPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\CryptoPager.cs,EncryptPage,The following statement contains a magic number: fixed (byte* ctx = _context)              fixed (byte* mk = _masterKey)              {                  if (Sodium.crypto_kdf_derive_from_key(subKey' (UIntPtr)32' (ulong)num' ctx' mk) != 0)                      throw new InvalidOperationException("Unable to generate derived key");                    var dataSize = (ulong)GetNumberOfPages(page) * Constants.Storage.PageSize;                    var npub = (byte*)page + PageHeader.NonceOffset;                  if (*(long*)npub == 0)                      Sodium.randombytes_buf(npub' (UIntPtr)sizeof(long));                  else                      *(long*)npub = *(long*)npub + 1;                    ulong macLen = MacLen;                  var rc = Sodium.crypto_aead_chacha20poly1305_encrypt_detached(                      destination + PageHeader.SizeOf'                      destination + PageHeader.MacOffset'                      &macLen'                      (byte*)page + PageHeader.SizeOf'                      dataSize - PageHeader.SizeOf'                      (byte*)page'                      (ulong)PageHeader.NonceOffset'                      null'                      npub'                      subKey                  );                  Debug.Assert(macLen == MacLen);                    if (rc != 0)                      throw new InvalidOperationException($"Unable to encrypt page {num}' rc={rc}");              }
Magic Number,Voron.Impl.Paging,CryptoPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\CryptoPager.cs,DecryptPage,The following statement contains a magic number: var subKey = stackalloc byte[32];
Magic Number,Voron.Impl.Paging,CryptoPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\CryptoPager.cs,DecryptPage,The following statement contains a magic number: fixed (byte* ctx = _context)              fixed (byte* mk = _masterKey)              {                  if (Sodium.crypto_kdf_derive_from_key(subKey' (UIntPtr)32' (ulong)num' ctx' mk) != 0)                      throw new InvalidOperationException("Unable to generate derived key");                    var dataSize = (ulong)GetNumberOfPages(page) * Constants.Storage.PageSize;                  var rc = Sodium.crypto_aead_chacha20poly1305_decrypt_detached(                      destination + PageHeader.SizeOf'                      null'                      (byte*)page + PageHeader.SizeOf'                      dataSize - PageHeader.SizeOf'                      (byte*)page + PageHeader.MacOffset'                      (byte*)page'                      (ulong)PageHeader.NonceOffset'                      (byte*)page + PageHeader.NonceOffset'                      subKey                  );                  if (rc != 0)                      throw new InvalidOperationException($"Unable to decrypt page {num}' rc={rc}");              }
Magic Number,Voron.Impl.Paging,Windows32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,CopyPage,The following statement contains a magic number: try              {                    if (result == null)                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      throw new Win32Exception($"Unable to map (default view size) {AllocationGranularity / Constants.Size.Kilobyte:#'#0} kb for page {pageNumber} starting at {allocationStartPosition} on {FileName}"'                          new Win32Exception(lastWin32Error));                  }                    var pageHeader = (PageHeader*)(result + distanceFromStart * Constants.Storage.PageSize);                    int numberOfPages = 1;                  if ((pageHeader->Flags & PageFlags.Overflow) == PageFlags.Overflow)                  {                      numberOfPages = VirtualPagerLegacyExtensions.GetNumberOfOverflowPages(pageHeader->OverflowSize);                  }                    if (numberOfPages + distanceFromStart > NumberOfPagesInAllocationGranularity)                  {                      UnmapViewOfFile(result);                      result = null;                        var newSize = NearestSizeToAllocationGranularity((numberOfPages + distanceFromStart) * Constants.Storage.PageSize);                      result = MapViewOfFileEx(_hFileMappingObject' _mmFileAccessType' offset.High'                          offset.Low'                          (UIntPtr)newSize' null);                        if (result == null)                      {                          var lastWin32Error = Marshal.GetLastWin32Error();                          throw new Win32Exception($"Unable to map {newSize / Constants.Size.Kilobyte:#'#0} kb for page {pageNumber} starting at {allocationStartPosition} on {FileName}"'                              new Win32Exception(lastWin32Error));                      }                        pageHeader = (PageHeader*)(result + (distanceFromStart * Constants.Storage.PageSize));                  }                  const int adjustPageSize = (Constants.Storage.PageSize) / (4 * Constants.Size.Kilobyte);                    destI4KbBatchWrites.Write(pageHeader->PageNumber * adjustPageSize' numberOfPages * adjustPageSize' (byte*)pageHeader);                    return numberOfPages;              }              finally              {                  if (result != null)                      UnmapViewOfFile(result);                }
Magic Number,Voron.Impl.Paging,Windows32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,ThrowInvalidMappingRequested,The following statement contains a magic number: throw new InvalidOperationException(                  $"Was asked to map page {startPage} + {size / 1024:#'#0} kb' but the file size is only {_fileStreamLength}' can't do that.");
Magic Number,Voron.Impl.Paging,Windows32Bit4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,Write,The following statement contains a magic number: const int pageSizeTo4KbRatio = (Constants.Storage.PageSize / (4 * Constants.Size.Kilobyte));
Magic Number,Voron.Impl.Paging,Windows32Bit4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,Write,The following statement contains a magic number: var toWrite = numberOf4Kbs * 4 * Constants.Size.Kilobyte;
Magic Number,Voron.Impl.Paging,Windows32Bit4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Impl\Paging\Windows32BitsMemoryMapPager.cs,Write,The following statement contains a magic number: byte* destination = page.Pointer +                                      (distanceFromStart * Constants.Storage.PageSize) +                                      offsetBy4Kb * (4 * Constants.Size.Kilobyte);
Magic Number,Voron.Impl.Scratch,ScratchBufferPool,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferPool.cs,Allocate,The following statement contains a magic number: var requestedSize = Math.Max(minSize' Math.Min(_current.File.Size * 2' _options.MaxScratchBufferSize));
Magic Number,Voron.Impl.Scratch,ScratchBufferPool,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferPool.cs,Cleanup,The following statement contains a magic number: while (_env.CurrentReadTransactionId <= txIdAllowingToReleaseOldScratches)              {                  // we've just flushed and had no more writes after that' let us bump id of next read transactions to ensure                  // that nobody will attempt to read old scratches so we will be able to release more files                    try                  {                      using (var tx = _env.NewLowLevelTransaction(new TransactionPersistentContext()'                              TransactionFlags.ReadWrite' timeout: TimeSpan.FromMilliseconds(500)))                      {                          tx.ModifyPage(0);                          tx.Commit();                      }                  }                  catch (TimeoutException)                  {                      break;                  }              }
Magic Number,Voron.Impl.Scratch,ScratchBufferPool,C:\repos\ravendb_ravendb\src\Voron\Impl\Scratch\ScratchBufferPool.cs,InfoForDebug,The following statement contains a magic number: foreach (var scratchBufferItem in _scratchBuffers.Values.OrderBy(x => x.Number))              {                  var current = _current;                  var scratchFileUsage = new ScratchFileUsage                  {                      Name = StorageEnvironmentOptions.ScratchBufferName(scratchBufferItem.File.Number)'                      SizeInKB = scratchBufferItem.File.Size / 1024'                      NumberOfAllocations = scratchBufferItem.File.NumberOfAllocations'                      AllocatedPagesCount = scratchBufferItem.File.AllocatedPagesCount'                      CanBeDeleted = scratchBufferItem != current && scratchBufferItem.File.HasActivelyUsedBytes(oldestActiveTransaction) == false'                      TxIdAfterWhichLatestFreePagesBecomeAvailable = scratchBufferItem.File.TxIdAfterWhichLatestFreePagesBecomeAvailable                  };                    foreach (var freePage in scratchBufferItem.File.GetMostAvailableFreePagesBySize())                  {                      scratchFileUsage.MostAvailableFreePages.Add(new MostAvailableFreePagesBySize                      {                          Size = freePage.Key'                          ValidAfterTransactionId = freePage.Value                      });                  }                    scratchBufferPoolInfo.ScratchFilesUsage.Add(scratchFileUsage);              }
Magic Number,Voron.Platform.Posix,Posix32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,CopyPage,The following statement contains a magic number: try              {                  if (result.ToInt64() == -1) //system didn't succeed in mapping the address where we wanted                  {                      var err = Marshal.GetLastWin32Error();                      Syscall.ThrowLastError(err'                          $"Unable to map (default view size) {sizeToMap/Constants.Size.Kilobyte:#'#0} kb for page {pageNumber} starting at {allocationStartPosition} on {FileName}");                  }                    var pageHeader = (PageHeader*) (result.ToInt64() + distanceFromStart*Constants.Storage.PageSize);                    int numberOfPages = 1;                  if ((pageHeader->Flags & PageFlags.Overflow) == PageFlags.Overflow)                  {                      numberOfPages = VirtualPagerLegacyExtensions.GetNumberOfOverflowPages(pageHeader->OverflowSize);                  }                      if (numberOfPages + distanceFromStart > NumberOfPagesInAllocationGranularity)                  {                      Syscall.munmap(result' (UIntPtr) sizeToMap);                      result = new IntPtr(-1);                      sizeToMap =NearestSizeToAllocationGranularity((numberOfPages + distanceFromStart)*                                                             Constants.Storage.PageSize);                      result = Syscall.mmap64(IntPtr.Zero' (UIntPtr) sizeToMap' MmapProts.PROT_READ | MmapProts.PROT_WRITE'                          mmflags' _fd' offset);                        if (result.ToInt64() == -1)                      {                          var err = Marshal.GetLastWin32Error();                          Syscall.ThrowLastError(err'                              $"Unable to map {sizeToMap/Constants.Size.Kilobyte:#'#0} kb for page {pageNumber} starting at {allocationStartPosition} on {FileName}");                      }                        pageHeader = (PageHeader*) (result.ToInt64() + (distanceFromStart*Constants.Storage.PageSize));                  }                  const int adjustPageSize = (Constants.Storage.PageSize)/(4*Constants.Size.Kilobyte);                    destI4KbBatchWrites.Write(pageHeader->PageNumber*adjustPageSize' numberOfPages*adjustPageSize'                      (byte*) pageHeader);                    return numberOfPages;              }              finally              {                  if (result.ToInt64() != -1)                      Syscall.munmap(result' (UIntPtr) sizeToMap);                }
Magic Number,Voron.Platform.Posix,Posix32BitsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,ThrowInvalidMappingRequested,The following statement contains a magic number: throw new InvalidOperationException(                  $"Was asked to map page {startPage} + {size / 1024:#'#0} kb' but the file size is only {_totalAllocationSize}' can't do that.");
Magic Number,Voron.Platform.Posix,Posix32Bit4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,Write,The following statement contains a magic number: const int pageSizeTo4KbRatio = (Constants.Storage.PageSize / (4 * Constants.Size.Kilobyte));
Magic Number,Voron.Platform.Posix,Posix32Bit4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,Write,The following statement contains a magic number: var toWrite = numberOf4Kbs * 4 * Constants.Size.Kilobyte;
Magic Number,Voron.Platform.Posix,Posix32Bit4KbBatchWrites,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\Posix32BitsMemoryMapPager.cs,Write,The following statement contains a magic number: byte* destination = page.Pointer +                                     (distanceFromStart * Constants.Storage.PageSize) +                                     offsetBy4Kb * (4 * Constants.Size.Kilobyte);
Magic Number,Voron.Platform.Posix,PosixAbstractPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixAbstractPager.cs,MaybePrefetchMemory,The following statement contains a magic number: long sizeToPrefetch = 4 * Constants.Storage.PageSize;
Magic Number,Voron.Platform.Posix,PosixJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixJournalWriter.cs,PosixJournalWriter,The following statement contains a magic number: _maxNumberOf4KbPerSingleWrite = int.MaxValue / (4 * Constants.Size.Kilobyte);
Magic Number,Voron.Platform.Posix,PosixJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixJournalWriter.cs,PosixJournalWriter,The following statement contains a magic number: NumberOfAllocated4Kb = (int)(length / (4 * Constants.Size.Kilobyte));
Magic Number,Voron.Platform.Posix,PosixJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixJournalWriter.cs,Write,The following statement contains a magic number: while (numberOf4Kb > _maxNumberOf4KbPerSingleWrite)              {                  WriteFile(posBy4Kb' p' _maxNumberOf4KbPerSingleWrite);                    posBy4Kb += _maxNumberOf4KbPerSingleWrite;                  p += _maxNumberOf4KbPerSingleWrite * (4 * Constants.Size.Kilobyte);                  numberOf4Kb -= _maxNumberOf4KbPerSingleWrite;              }
Magic Number,Voron.Platform.Posix,PosixJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixJournalWriter.cs,WriteFile,The following statement contains a magic number: var nNumberOfBytesToWrite = (ulong)numberOf4Kb * (4 * Constants.Size.Kilobyte);
Magic Number,Voron.Platform.Posix,PosixJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixJournalWriter.cs,WriteFile,The following statement contains a magic number: using (_options.IoMetrics.MeterIoRate(_filename.FullPath' IoMetrics.MeterType.JournalWrite' (long)nNumberOfBytesToWrite))              {                  do                  {                      result = Syscall.pwrite(_fd' p' nNumberOfBytesToWrite - (ulong)actuallyWritten'                          position * 4 * Constants.Size.Kilobyte);                      if (result < 1)                          break;                      actuallyWritten += result;                      p += actuallyWritten;                  } while ((ulong)actuallyWritten < nNumberOfBytesToWrite);              }
Magic Number,Voron.Platform.Posix,PosixMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixMemoryMapPager.cs,NearestSizeToPageSize,The following statement contains a magic number: if (size == 0)                  return SysPageSize * 16;
Magic Number,Voron.Platform.Posix,PosixTempMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Posix\PosixTempMemoryMapPager.cs,NearestSizeToPageSize,The following statement contains a magic number: if (size == 0)                  return SysPageSize * 16;
Magic Number,Voron.Platform.Win32,Win32Helper,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32Helper.cs,WriteFileHeader,The following statement contains a magic number: using (var fs = new FileStream(path.FullPath' FileMode.Create' FileAccess.ReadWrite' FileShare.Read' 4096' FileOptions.None))              {                  var ptr = (byte*)header;                  int remaining = sizeof(FileHeader);                  while (remaining > 0)                  {                      int written;                      if (Win32NativeFileMethods.WriteFile(fs.SafeFileHandle' ptr' remaining' out written' null) == false)                          throw new Win32Exception(Marshal.GetLastWin32Error()' "Failed to write to file " + path);                      ptr += written;                      remaining -= written;                  }                  if(Win32NativeFileMethods.FlushFileBuffers(fs.SafeFileHandle)==false)                      throw new Win32Exception(Marshal.GetLastWin32Error()' "Failed to Flush File Buffers (sync) of file " + path);              }
Magic Number,Voron.Platform.Win32,Win32Helper,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32Helper.cs,TryReadFileHeader,The following statement contains a magic number: using (var fs = new FileStream(path.FullPath' FileMode.Open' FileAccess.ReadWrite' FileShare.Read' 4096' FileOptions.None))              {                  if (fs.Length != sizeof(FileHeader))                      return false; // wrong file size                    var ptr = (byte*)header;                  int remaining = sizeof(FileHeader);                  while (remaining > 0)                  {                      int read;                      if (Win32NativeFileMethods.ReadFile(fs.SafeFileHandle' ptr' remaining' out read' null) == false)                          throw new Win32Exception(Marshal.GetLastWin32Error()' "Failed to read file " + path);                      if (read == 0)                          return false; // we should be reading _something_ here' if we can't' then it is an error and we assume corruption                      ptr += read;                      remaining -= read;                  }                  return true;              }
Magic Number,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,Win32FileJournalWriter,The following statement contains a magic number: NumberOfAllocated4Kb = (int)(length / (4 * Constants.Size.Kilobyte));
Magic Number,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,Write,The following statement contains a magic number: const int maxNumberInSingleWrite = (int.MaxValue / (4 * Constants.Size.Kilobyte));
Magic Number,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,Write,The following statement contains a magic number: while (numberOf4Kb > maxNumberInSingleWrite)              {                  WriteFile(posBy4Kb' p' maxNumberInSingleWrite);                    posBy4Kb += maxNumberInSingleWrite;                  p += maxNumberInSingleWrite * 4 * Constants.Size.Kilobyte;                  numberOf4Kb -= maxNumberInSingleWrite;              }
Magic Number,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,WriteFile,The following statement contains a magic number: position *= 4 * Constants.Size.Kilobyte;
Magic Number,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,WriteFile,The following statement contains a magic number: _nativeOverlapped->OffsetHigh = (int)(position >> 32);
Magic Number,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,WriteFile,The following statement contains a magic number: var nNumberOfBytesToWrite = numberOf4Kb * (4 * Constants.Size.Kilobyte);
Magic Number,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,WriteFile,The following statement contains a magic number: using (var metrics = _options.IoMetrics.MeterIoRate(_filename.FullPath' IoMetrics.MeterType.JournalWrite' nNumberOfBytesToWrite))              {                  int written;                  writeSuccess = Win32NativeFileMethods.WriteFile(_handle' p' nNumberOfBytesToWrite'                      out written'                      _nativeOverlapped);                    metrics.SetFileSize(NumberOfAllocated4Kb * (4 * Constants.Size.Kilobyte));              }
Magic Number,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,Read,The following statement contains a magic number: try              {                  nativeOverlapped->OffsetLow = (int)(offsetInFile & 0xffffffff);                  nativeOverlapped->OffsetHigh = (int)(offsetInFile >> 32);                  nativeOverlapped->EventHandle = IntPtr.Zero;                  while (numOfBytes > 0)                  {                      if (Win32NativeFileMethods.ReadFile(_readHandle' buffer' (int)Math.Min(numOfBytes' int.MaxValue)' out int read' nativeOverlapped) == false)                      {                          int lastWin32Error = Marshal.GetLastWin32Error();                          if (lastWin32Error == Win32NativeFileMethods.ErrorHandleEof)                              return false;                          if (lastWin32Error == Win32NativeFileMethods.ErrorInvalidHandle)                              _readHandle = null;                          throw new Win32Exception(lastWin32Error' "Unable to read from " + _filename);                      }                      numOfBytes -= read;                      buffer += read;                      offsetInFile += read;                      nativeOverlapped->OffsetLow = (int)(offsetInFile & 0xffffffff);                      nativeOverlapped->OffsetHigh = (int)(offsetInFile >> 32);                  }                  return true;              }              finally              {                  NativeMemory.Free((byte*)nativeOverlapped' sizeof(NativeOverlapped));              }
Magic Number,Voron.Platform.Win32,Win32FileJournalWriter,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32JournalWriter.cs,Read,The following statement contains a magic number: try              {                  nativeOverlapped->OffsetLow = (int)(offsetInFile & 0xffffffff);                  nativeOverlapped->OffsetHigh = (int)(offsetInFile >> 32);                  nativeOverlapped->EventHandle = IntPtr.Zero;                  while (numOfBytes > 0)                  {                      if (Win32NativeFileMethods.ReadFile(_readHandle' buffer' (int)Math.Min(numOfBytes' int.MaxValue)' out int read' nativeOverlapped) == false)                      {                          int lastWin32Error = Marshal.GetLastWin32Error();                          if (lastWin32Error == Win32NativeFileMethods.ErrorHandleEof)                              return false;                          if (lastWin32Error == Win32NativeFileMethods.ErrorInvalidHandle)                              _readHandle = null;                          throw new Win32Exception(lastWin32Error' "Unable to read from " + _filename);                      }                      numOfBytes -= read;                      buffer += read;                      offsetInFile += read;                      nativeOverlapped->OffsetLow = (int)(offsetInFile & 0xffffffff);                      nativeOverlapped->OffsetHigh = (int)(offsetInFile >> 32);                  }                  return true;              }              finally              {                  NativeMemory.Free((byte*)nativeOverlapped' sizeof(NativeOverlapped));              }
Magic Number,Voron.Platform.Win32,Win32NativeFileMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: if (SetEndOfFile(fileHandle) == false)              {                  var lastError = Marshal.GetLastWin32Error();                    if (lastError == (int) Win32NativeFileErrors.ERROR_DISK_FULL)                  {                      var filePath = new StringBuilder(256);                        while (GetFinalPathNameByHandle(fileHandle' filePath' filePath.Capacity' 0) > filePath.Capacity &&                             filePath.Capacity < 32767) // max unicode path length                      {                          filePath.EnsureCapacity(filePath.Capacity*2);                      }                        filePath = filePath.Replace(@"\\?\"' String.Empty); // remove extended-length path prefix                        var fullFilePath = filePath.ToString();                      var driveLetter = Path.GetPathRoot(fullFilePath);                        DriveInfo driveInfo;                      try                      {                          driveInfo = new DriveInfo(driveLetter);                      }                      catch (Exception)                      {                          driveInfo = null; // probably network path                      }                        throw new DiskFullException(driveInfo' fullFilePath' length);                  }                    var exception = new Win32Exception(lastError);                    if (lastError == (int) Win32NativeFileErrors.ERROR_NOT_READY ||                      lastError == (int) Win32NativeFileErrors.ERROR_FILE_NOT_FOUND)                      throw new IOException("Could not set the file size because it is inaccessible"' exception);                    throw exception;              }
Magic Number,Voron.Platform.Win32,Win32NativeFileMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: if (SetEndOfFile(fileHandle) == false)              {                  var lastError = Marshal.GetLastWin32Error();                    if (lastError == (int) Win32NativeFileErrors.ERROR_DISK_FULL)                  {                      var filePath = new StringBuilder(256);                        while (GetFinalPathNameByHandle(fileHandle' filePath' filePath.Capacity' 0) > filePath.Capacity &&                             filePath.Capacity < 32767) // max unicode path length                      {                          filePath.EnsureCapacity(filePath.Capacity*2);                      }                        filePath = filePath.Replace(@"\\?\"' String.Empty); // remove extended-length path prefix                        var fullFilePath = filePath.ToString();                      var driveLetter = Path.GetPathRoot(fullFilePath);                        DriveInfo driveInfo;                      try                      {                          driveInfo = new DriveInfo(driveLetter);                      }                      catch (Exception)                      {                          driveInfo = null; // probably network path                      }                        throw new DiskFullException(driveInfo' fullFilePath' length);                  }                    var exception = new Win32Exception(lastError);                    if (lastError == (int) Win32NativeFileErrors.ERROR_NOT_READY ||                      lastError == (int) Win32NativeFileErrors.ERROR_FILE_NOT_FOUND)                      throw new IOException("Could not set the file size because it is inaccessible"' exception);                    throw exception;              }
Magic Number,Voron.Platform.Win32,Win32NativeFileMethods,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\Win32NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: if (SetEndOfFile(fileHandle) == false)              {                  var lastError = Marshal.GetLastWin32Error();                    if (lastError == (int) Win32NativeFileErrors.ERROR_DISK_FULL)                  {                      var filePath = new StringBuilder(256);                        while (GetFinalPathNameByHandle(fileHandle' filePath' filePath.Capacity' 0) > filePath.Capacity &&                             filePath.Capacity < 32767) // max unicode path length                      {                          filePath.EnsureCapacity(filePath.Capacity*2);                      }                        filePath = filePath.Replace(@"\\?\"' String.Empty); // remove extended-length path prefix                        var fullFilePath = filePath.ToString();                      var driveLetter = Path.GetPathRoot(fullFilePath);                        DriveInfo driveInfo;                      try                      {                          driveInfo = new DriveInfo(driveLetter);                      }                      catch (Exception)                      {                          driveInfo = null; // probably network path                      }                        throw new DiskFullException(driveInfo' fullFilePath' length);                  }                    var exception = new Win32Exception(lastError);                    if (lastError == (int) Win32NativeFileErrors.ERROR_NOT_READY ||                      lastError == (int) Win32NativeFileErrors.ERROR_FILE_NOT_FOUND)                      throw new IOException("Could not set the file size because it is inaccessible"' exception);                    throw exception;              }
Magic Number,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,GetPhysicalDriveId,The following statement contains a magic number: return (uint)((int)sdn.DeviceType << 8) + sdn.DeviceNumber;
Magic Number,Voron.Platform.Win32,WindowsMemoryMapPager,C:\repos\ravendb_ravendb\src\Voron\Platform\Win32\WindowsMemoryMapPager.cs,MaybePrefetchMemory,The following statement contains a magic number: for (int i = 0; i < entries.Length; i++)              {                  entries[i].NumberOfBytes = (IntPtr)(4 * Constants.Storage.PageSize);                  entries[i].VirtualAddress = AcquirePagePointer(null' pagesToPrefetch[i]);              }
Magic Number,Voron.Util,DynamicArray,C:\repos\ravendb_ravendb\src\Voron\Util\ActiveTransactions.cs,Add,The following statement contains a magic number: var newItems = new Node[Items.Length*2];
Magic Number,Voron.Util,DataCopier,C:\repos\ravendb_ravendb\src\Voron\Util\DataCopier.cs,ToStream,The following statement contains a magic number: var maxNumOf4KbsToCopyAtOnce = _buffer.Length/(4*Constants.Size.Kilobyte);
Magic Number,Voron.Util,DataCopier,C:\repos\ravendb_ravendb\src\Voron\Util\DataCopier.cs,ToStream,The following statement contains a magic number: fixed (byte* ptr = _buffer)              {                  while (numberOf4KbsToCopy > 0)                  {                      var pageCount = Math.Min(maxNumOf4KbsToCopyAtOnce' numberOf4KbsToCopy);                        if (journal.JournalWriter.Read(ptr'                           pageCount * (4 * Constants.Size.Kilobyte)'                           page * (4 * Constants.Size.Kilobyte)) == false)                           throw new InvalidOperationException("Could not read from journal #" + journal.Number + " " +                                      +pageCount + " pages.");                      var bytesCount = (int)(pageCount * (4 * Constants.Size.Kilobyte));                      output.Write(_buffer' 0' bytesCount);                      page += pageCount;                      numberOf4KbsToCopy -= pageCount;                  }              }
Magic Number,Voron.Util,DataCopier,C:\repos\ravendb_ravendb\src\Voron\Util\DataCopier.cs,ToStream,The following statement contains a magic number: fixed (byte* ptr = _buffer)              {                  while (numberOf4KbsToCopy > 0)                  {                      var pageCount = Math.Min(maxNumOf4KbsToCopyAtOnce' numberOf4KbsToCopy);                        if (journal.JournalWriter.Read(ptr'                           pageCount * (4 * Constants.Size.Kilobyte)'                           page * (4 * Constants.Size.Kilobyte)) == false)                           throw new InvalidOperationException("Could not read from journal #" + journal.Number + " " +                                      +pageCount + " pages.");                      var bytesCount = (int)(pageCount * (4 * Constants.Size.Kilobyte));                      output.Write(_buffer' 0' bytesCount);                      page += pageCount;                      numberOf4KbsToCopy -= pageCount;                  }              }
Magic Number,Voron.Util,DataCopier,C:\repos\ravendb_ravendb\src\Voron\Util\DataCopier.cs,ToStream,The following statement contains a magic number: fixed (byte* ptr = _buffer)              {                  while (numberOf4KbsToCopy > 0)                  {                      var pageCount = Math.Min(maxNumOf4KbsToCopyAtOnce' numberOf4KbsToCopy);                        if (journal.JournalWriter.Read(ptr'                           pageCount * (4 * Constants.Size.Kilobyte)'                           page * (4 * Constants.Size.Kilobyte)) == false)                           throw new InvalidOperationException("Could not read from journal #" + journal.Number + " " +                                      +pageCount + " pages.");                      var bytesCount = (int)(pageCount * (4 * Constants.Size.Kilobyte));                      output.Write(_buffer' 0' bytesCount);                      page += pageCount;                      numberOf4KbsToCopy -= pageCount;                  }              }
Magic Number,Voron.Util,ImmutableAppendOnlyList<T>,C:\repos\ravendb_ravendb\src\Voron\Util\ImmutableAppendOnlyList.cs,Append,The following statement contains a magic number: if (tail == _values.Length)              {                  var newArray = GrowTo(Math.Max(8' Bits.NextPowerOf2(newCount)));                  newArray[_count] = item;                  return new ImmutableAppendOnlyList<T>(newArray' 0' newCount);              }
Magic Number,Voron.Util,ImmutableAppendOnlyList<T>,C:\repos\ravendb_ravendb\src\Voron\Util\ImmutableAppendOnlyList.cs,AppendRange,The following statement contains a magic number: if (tail + nToAdd > _values.Length)              {                  var newArray = GrowTo(_count + nToAdd * 2);                  copier(items' newArray' _count' nToAdd);                  return new ImmutableAppendOnlyList<T>(newArray' 0' newCount);              }
Magic Number,Voron.Util,PageTable,C:\repos\ravendb_ravendb\src\Voron\Util\PageTable.cs,SetItems,The following statement contains a magic number: foreach (var item in items)              {                  PagesBuffer value;                  if (_values.TryGetValue(item.Key' out value) == false)                  {                      value = new PagesBuffer(new PagePosition[2]' null);                      _values.TryAdd(item.Key' value);                  }                  if (value.CanAdd == false)                  {                      var newVal = new PagesBuffer(new PagePosition[value.Capacity*2]' value);                      _values.TryUpdate(item.Key' newVal' value);                      value = newVal;                  }                  value.Add(item.Value);              }
Magic Number,Voron.Util,PageTable,C:\repos\ravendb_ravendb\src\Voron\Util\PageTable.cs,SetItems,The following statement contains a magic number: foreach (var item in items)              {                  PagesBuffer value;                  if (_values.TryGetValue(item.Key' out value) == false)                  {                      value = new PagesBuffer(new PagePosition[2]' null);                      _values.TryAdd(item.Key' value);                  }                  if (value.CanAdd == false)                  {                      var newVal = new PagesBuffer(new PagePosition[value.Capacity*2]' value);                      _values.TryUpdate(item.Key' newVal' value);                      value = newVal;                  }                  value.Add(item.Value);              }
Magic Number,Voron.Util,PtrSize,C:\repos\ravendb_ravendb\src\Voron\Util\PtrSize.cs,PtrSize,The following statement contains a magic number: Debug.Assert(size <= 8);
Magic Number,Voron.Util,ThreadHoppingReaderWriterLock,C:\repos\ravendb_ravendb\src\Voron\Util\ThreadHoppingReaderWriterLock.cs,TryEnterReadLockCore,The following statement contains a magic number: if (waiters > ReaderMask / 2)              {                  ExitReadLock();                  ThrowTooManyReaders(waiters);              }
Magic Number,Voron.Util.Conversion,BigEndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\BigEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: for (int i=0; i < bytes; i++)              {                  buffer[endOffset-i] = unchecked((byte)(value&0xff));                  value = value >> 8;              }
Magic Number,Voron.Util.Conversion,BigEndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\BigEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i=0; i < bytesToConvert; i++)              {                  ret = unchecked((ret << 8) | value[startIndex+i]);              }
Magic Number,Voron.Util.Conversion,BigEndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\BigEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i = 0; i < bytesToConvert; i++)              {                  ret = (ret << 8) | value[i];              }
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToChar,The following statement contains a magic number: return unchecked((char) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToInt16,The following statement contains a magic number: return unchecked((short) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToInt32,The following statement contains a magic number: return unchecked((int) (CheckedFromBytes(value' startIndex' 4)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToInt64,The following statement contains a magic number: return CheckedFromBytes(value' startIndex' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToInt64,The following statement contains a magic number: return FromBytes(value'  8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToUInt16,The following statement contains a magic number: return unchecked((ushort) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return unchecked((uint) (CheckedFromBytes(value' startIndex' 4)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return unchecked((ulong) (CheckedFromBytes(value' startIndex' 8)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: int[] parts = new int[4];
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: for (int i=0; i < 4; i++)              {                  parts[i] = ToInt32(value' startIndex+i*4);              }
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: for (int i=0; i < 4; i++)              {                  parts[i] = ToInt32(value' startIndex+i*4);              }
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: byte[] bytes = new byte[16];
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)              {                  CopyBytesImpl(parts[i]' 4' bytes' i*4);              }
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)              {                  CopyBytesImpl(parts[i]' 4' bytes' i*4);              }
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)              {                  CopyBytesImpl(parts[i]' 4' bytes' i*4);              }
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)              {                  CopyBytesImpl(parts[i]' 4' buffer' i*4+index);              }
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)              {                  CopyBytesImpl(parts[i]' 4' buffer' i*4+index);              }
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)              {                  CopyBytesImpl(parts[i]' 4' buffer' i*4+index);              }
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(DoubleToInt64Bits(value)' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(SingleToInt32Bits(value)' 4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(unchecked((long)value)' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(DoubleToInt64Bits(value)' 8' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 4' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 8' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(SingleToInt32Bits(value)' 4' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 4' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(unchecked((long)value)' 8' buffer' index);
Magic Number,Voron.Util.Conversion,LittleEndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\LittleEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: for (int i=0; i < bytes; i++)              {                  buffer[i+index] = unchecked((byte)(value&0xff));                  value = value >> 8;              }
Magic Number,Voron.Util.Conversion,LittleEndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\LittleEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i=0; i < bytesToConvert; i++)              {                  ret = unchecked((ret << 8) | value[startIndex+bytesToConvert-1-i]);              }
Magic Number,Voron.Util.Conversion,LittleEndianBitConverter,C:\repos\ravendb_ravendb\src\Voron\Util\Conversion\LittleEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i = 0; i < bytesToConvert; i++)              {                  ret = unchecked((ret << 8) | value[bytesToConvert - 1 - i]);              }
Magic Number,Voron.Util.Settings,PathSettingBase<T>,C:\repos\ravendb_ravendb\src\Voron\Util\Settings\PathSettingBase.cs,ToFullPath,The following statement contains a magic number: if (result.Length >= 260 && RuntimeInformation.IsOSPlatform(OSPlatform.Windows))                  result = @"\\?\" + result;
Missing Default,Voron.Data,VoronStream,C:\repos\ravendb_ravendb\src\Voron\Data\VoronStream.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                    case SeekOrigin.Current:                      Position += offset;                      break;                    case SeekOrigin.End:                      Position = Length + offset;                      break;              }
