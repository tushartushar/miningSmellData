Implementation smell,Namespace,Class,File,Method,Description
Long Method,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The method has 152 lines of code.
Long Method,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The method has 374 lines of code.
Complex Method,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,Cyclomatic complexity of the method is 31
Long Parameter List,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteAttachmentMetadata,The method has 5 parameters. Parameters: writer' hash' size' name' contentType
Long Parameter List,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Write,The method has 9 parameters. Parameters: mem' sizeInBytes' documentsWriter' revisionsWriter' conflictsWriter' countersWriter' context' startOffset' tableType
Long Parameter List,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteCounter,The method has 5 parameters. Parameters: mem' sizeInBytes' countersWriter' context' startOffset
Long Parameter List,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteDocument,The method has 5 parameters. Parameters: mem' sizeInBytes' writer' context' startOffest
Long Parameter List,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteRevision,The method has 5 parameters. Parameters: mem' sizeInBytes' writer' context' startOffest
Long Parameter List,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteConflict,The method has 5 parameters. Parameters: mem' sizeInBytes' writer' context' startOffest
Long Identifier,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the parameter initialContextLongLivedSizeInKbArg is 34.
Long Identifier,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the parameter ignoreDataIntegrityErrorsOfAlreadySyncedTransactionsArg is 55.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                var outputFileNameArg = cmd.Option("--OutputFileName"' "Will overwrite the default file name () with your own file name (under output directory)."' CommandOptionType.SingleValue); " is 179.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                var pageSizeInKbArg = cmd.Option("--PageSizeInKB"' "Will set the recovery tool to work with page sizes other than 4kb."' CommandOptionType.SingleValue); " is 152.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                var initialContextSizeInMbArg = cmd.Option("--InitialContextSizeInMB"' "Will set the recovery tool to use a context of the provided size in MB."' CommandOptionType.SingleValue); " is 177.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                var initialContextLongLivedSizeInKbArg = cmd.Option("--InitialContextLongLivedSizeInKB"' "Will set the recovery tool to use a long lived context size of the provided size in KB."' CommandOptionType.SingleValue); " is 211.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                var progressIntervalInSecArg = cmd.Option("--ProgressIntervalInSec"' "Will set the recovery tool refresh to console rate interval in seconds."' CommandOptionType.SingleValue); " is 175.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                var disableCopyOnWriteModeArg = cmd.Option("--DisableCopyOnWriteMode"' "Default is false."' CommandOptionType.SingleValue); " is 123.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                var ignoreInvalidJournalErrorsArg = cmd.Option("--IgnoreInvalidJournalErrors"' "Default is false."' CommandOptionType.SingleValue); " is 131.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                var ignoreDataIntegrityErrorsOfAlreadySyncedTransactionsArg = cmd.Option("--IgnoreInvalidDataErrorsOfAlreadySyncedTransactions"' "Default is false."' CommandOptionType.SingleValue); " is 181.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                var loggingModeArg = cmd.Option("--LoggingMode"' "Logging mode: Operations or Information."' CommandOptionType.SingleValue); " is 124.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                var masterKey = cmd.Option("--MasterKey"' "Encryption key: base64 string of the encryption master key"' CommandOptionType.SingleValue); " is 135.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                    config.OutputFileName = Path.Combine(recoverDirectory' outputFileNameArg.HasValue() ? outputFileNameArg.Value() : RecoveryFileName); " is 132.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                            return ExitWithError($"{nameof(config.InitialContextLongLivedSizeInKB)} argument value ({longLivedContextSize}) is invalid"' cmd); " is 130.
Long Statement,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The length of the statement  "                            return ExitWithError($"{nameof(config.IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions)} argument value ({value}) is invalid"' cmd); " is 136.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,CreateOptions,The length of the statement  "            result.IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions = _config.IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions; " is 123.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                    $"{now:hh:MM:ss}: Recovering page at position {currPos:#'#;;0}/{eofPos:#'#;;0} ({(double)currPos / eofPos:p}) - Last recovered doc is {_lastRecoveredDocumentKey}"); " is 164.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                            writer.WriteLine("Journal recovery failed. To continue' please backup your files and run again with --DisableCopyOnWriteMode flag."); " is 133.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                using (var destinationStreamDocuments = File.OpenWrite(Path.Combine(Path.GetDirectoryName(_output)' Path.GetFileNameWithoutExtension(_output) + "-2-Documents" + Path.GetExtension(_output)))) " is 190.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                using (var destinationStreamRevisions = File.OpenWrite(Path.Combine(Path.GetDirectoryName(_output)' Path.GetFileNameWithoutExtension(_output) + "-3-Revisions" + Path.GetExtension(_output)))) " is 190.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                using (var destinationStreamConflicts = File.OpenWrite(Path.Combine(Path.GetDirectoryName(_output)' Path.GetFileNameWithoutExtension(_output) + "-4-Conflicts" + Path.GetExtension(_output)))) " is 190.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                using (var destinationStreamCounters = File.OpenWrite(Path.Combine(Path.GetDirectoryName(_output)' Path.GetFileNameWithoutExtension(_output) + "-5-Counters" + Path.GetExtension(_output)))) " is 188.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                using (var context = new JsonOperationContext(_initialContextSize' _initialContextLongLivedSize' SharedMultipleUseFlag.None)) " is 125.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                                    $"page #{pageHeader->PageNumber} (offset={GetFilePosition(startOffset' mem)}) has both Overflow and Single flag turned"; " is 120.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                                                _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to initialize Sodium for hash computation will skip this page."); " is 152.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                                                    _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to compute chunk hash' will skip it."); " is 126.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                                                    _logger.Operations($"page #{nextPage->PageNumber} (offset={(long)nextPage}) was suppose to be a stream chunk but isn't marked as Overflow | Stream"); " is 149.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                                                _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to compute attachment hash' will skip it."); " is 131.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                                    $"RawDataSmallPage #{rawHeader->PageNumber} at {GetFilePosition(startOffset' mem)} next allocation is larger than {_pageSize} bytes"; " is 133.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                        WriteDummyDocumentForAttachment(documentsWriter' _lastAttachmentInfo.Value.hash' _lastAttachmentInfo.Value.size' _lastAttachmentInfo.Value.tag); " is 144.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The length of the statement  "                            $"Discovered a total of {_numberOfDocumentsRetrieved:#'#;00} documents within {sw.Elapsed.TotalSeconds::#'#.#;;00} seconds." + Environment.NewLine + " is 148.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,DecryptPageIfNeeded,The length of the statement  "            //We must make sure we can close the transaction since it may hold buffers for memory we still need e.g. attachments chunks. " is 124.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,ReportOrphanAttachmentsAndMissingAttachments,The length of the statement  "                            _logger.Operations($"Document {_documentsAttachments[index].docId} contains attachment with hash {documentHash} but we were not able to recover such attachment."); " is 163.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,ReportOrphanCountersAndMissingCounters,The length of the statement  "                    var documentsCountersKey = _documentsCounters[index].docId + SpecialChars.RecordSeparator + _documentsCounters[index].name; " is 123.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,ReportOrphanCountersAndMissingCounters,The length of the statement  "                            _logger.Operations($"Document {_documentsCounters[index].docId} contains a counter with name {_documentsCounters[index].name} but we were not able to recover such counter."); " is 174.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,ValidateOverflowPage,The length of the statement  "                checksum = StorageEnvironment.CalculatePageChecksum((byte*)pageHeader' pageHeader->PageNumber' pageHeader->Flags' pageHeader->OverflowSize); " is 140.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,ValidateOverflowPage,The length of the statement  "                        $"Invalid checksum for overflow page {pageHeader->PageNumber}' expected hash to be {pageHeader->Checksum} but was {checksum}"; " is 126.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteCounter,The length of the statement  "                        _logger.Operations($"Found invalid counter item at position={GetFilePosition(startOffset' mem)} with document Id={counterGroup?.DocumentId ?? "null"} and counter values={counterGroup?.Values}{Environment.NewLine}{e}"); " is 218.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteCounter,The length of the statement  "                    _logger.Info($"Found counter item with document Id={counterGroup.DocumentId} and counter values={counterGroup.Values}"); " is 120.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteCounter,The length of the statement  "                    _logger.Operations($"Unexpected exception while writing counter item at position {GetFilePosition(startOffset' mem)}: {e}"); " is 124.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteDocument,The length of the statement  "                        _logger.Operations($"Found invalid blittable document at pos={GetFilePosition(startOffest' mem)} with key={document?.Id ?? "null"}{Environment.NewLine}{e}"); " is 157.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteDocument,The length of the statement  "                    _logger.Operations($"Unexpected exception while writing document at position {GetFilePosition(startOffest' mem)}: {e}"); " is 120.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,HandleDocumentAttachments,The length of the statement  "                        _logger.Operations($"Document {document.Id} has attachment flag set but was unable to read its metadata and retrieve the attachments hashes"); " is 142.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,HandleDocumentCounters,The length of the statement  "                        _logger.Operations($"Document {document.Id} has counters flag set but was unable to read its metadata and retrieve the counters names"); " is 136.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteRevision,The length of the statement  "                    revision = RevisionsStorage.ParseRawDataSectionRevisionWithValidation(context' ref tvr' sizeInBytes' out var changeVector); " is 123.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteRevision,The length of the statement  "                            _logger.Operations($"Failed to convert table value to revision document at position {GetFilePosition(startOffest' mem)}"); " is 122.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteRevision,The length of the statement  "                        _logger.Operations($"Found invalid blittable revision document at pos={GetFilePosition(startOffest' mem)} with key={revision?.Id ?? "null"}{Environment.NewLine}{e}"); " is 166.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteRevision,The length of the statement  "                    _logger.Operations($"Unexpected exception while writing revision document at position {GetFilePosition(startOffest' mem)}: {e}"); " is 129.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteConflict,The length of the statement  "                    conflict = ConflictsStorage.ParseRawDataSectionConflictWithValidation(context' ref tvr' sizeInBytes' out var changeVector); " is 123.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteConflict,The length of the statement  "                            _logger.Operations($"Failed to convert table value to conflict document at position {GetFilePosition(startOffest' mem)}"); " is 122.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteConflict,The length of the statement  "                        _logger.Operations($"Found invalid blittable conflict document at pos={GetFilePosition(startOffest' mem)} with key={conflict?.Id ?? "null"}{Environment.NewLine}{e}"); " is 166.
Long Statement,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteConflict,The length of the statement  "                    _logger.Operations($"Unexpected exception while writing conflict document at position {GetFilePosition(startOffest' mem)}: {e}"); " is 129.
Magic Number,Voron.Recovery,CommandLineApp,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\CommandLineApp.cs,ConfigureRecoveryCommand,The following statement contains a magic number: _app.Command("recover"' cmd =>              {                  cmd.ExtendedHelpText = cmd.Description = "Recovering a database into recovery.ravendump.";                  cmd.HelpOption(HelpOptionString);                    var dataFileDirectoryArg = cmd.Argument("DataFileDirectory"' "The database directory which contains the data file");                  var recoverDirectoryArg = cmd.Argument("RecoverDirectory"' "The directory to recover the recovery.ravendump file");                    var outputFileNameArg = cmd.Option("--OutputFileName"' "Will overwrite the default file name () with your own file name (under output directory)."' CommandOptionType.SingleValue);                  var pageSizeInKbArg = cmd.Option("--PageSizeInKB"' "Will set the recovery tool to work with page sizes other than 4kb."' CommandOptionType.SingleValue);                  var initialContextSizeInMbArg = cmd.Option("--InitialContextSizeInMB"' "Will set the recovery tool to use a context of the provided size in MB."' CommandOptionType.SingleValue);                  var initialContextLongLivedSizeInKbArg = cmd.Option("--InitialContextLongLivedSizeInKB"' "Will set the recovery tool to use a long lived context size of the provided size in KB."' CommandOptionType.SingleValue);                  var progressIntervalInSecArg = cmd.Option("--ProgressIntervalInSec"' "Will set the recovery tool refresh to console rate interval in seconds."' CommandOptionType.SingleValue);                  var disableCopyOnWriteModeArg = cmd.Option("--DisableCopyOnWriteMode"' "Default is false."' CommandOptionType.SingleValue);                  var ignoreInvalidJournalErrorsArg = cmd.Option("--IgnoreInvalidJournalErrors"' "Default is false."' CommandOptionType.SingleValue);                  var ignoreDataIntegrityErrorsOfAlreadySyncedTransactionsArg = cmd.Option("--IgnoreInvalidDataErrorsOfAlreadySyncedTransactions"' "Default is false."' CommandOptionType.SingleValue);                      var loggingModeArg = cmd.Option("--LoggingMode"' "Logging mode: Operations or Information."' CommandOptionType.SingleValue);                    var masterKey = cmd.Option("--MasterKey"' "Encryption key: base64 string of the encryption master key"' CommandOptionType.SingleValue);                    cmd.OnExecute(() =>                  {                      VoronRecoveryConfiguration config = new VoronRecoveryConfiguration                      {                          DataFileDirectory = dataFileDirectoryArg.Value'                      };                        if (string.IsNullOrWhiteSpace(config.DataFileDirectory) ||                          Directory.Exists(config.DataFileDirectory) == false ||                          File.Exists(Path.Combine(config.DataFileDirectory' DatafileName)) == false)                      {                          return ExitWithError($"Missing {nameof(config.DataFileDirectory)} argument"' cmd);                      }                      config.PathToDataFile = Path.Combine(config.DataFileDirectory' DatafileName);                        var recoverDirectory = recoverDirectoryArg.Value;                      if (string.IsNullOrWhiteSpace(recoverDirectory))                      {                          return ExitWithError("Missing RecoverDirectory argument"' cmd);                      }                                            config.OutputFileName = Path.Combine(recoverDirectory' outputFileNameArg.HasValue() ? outputFileNameArg.Value() : RecoveryFileName);                      try                      {                          if (!Directory.Exists(recoverDirectory))                              Directory.CreateDirectory(recoverDirectory);                          File.WriteAllText(config.OutputFileName' "I have write permission!");                          File.Delete(config.OutputFileName);                      }                      catch                      {                          return ExitWithError($"Cannot write to the output directory ({recoverDirectory}). " +                                               "Permissions issue?"' cmd);                      }                        if (pageSizeInKbArg.HasValue())                      {                          if (int.TryParse(pageSizeInKbArg.Value()' out var pageSize) == false ||                              pageSize < 1)                              return ExitWithError($"{nameof(config.PageSizeInKB)} argument value ({pageSize}) is invalid"' cmd);                          config.PageSizeInKB = pageSize;                      }                        if (initialContextSizeInMbArg.HasValue())                      {                          if (int.TryParse(initialContextSizeInMbArg.Value()' out var contextSize) == false ||                              contextSize < 1)                              return ExitWithError($"{nameof(config.InitialContextSizeInMB)} argument value ({contextSize}) is invalid"' cmd);                          config.InitialContextSizeInMB = contextSize;                      }                        if (initialContextLongLivedSizeInKbArg.HasValue())                      {                          if (int.TryParse(initialContextLongLivedSizeInKbArg.Value()' out var longLivedContextSize) == false ||                              longLivedContextSize < 1)                              return ExitWithError($"{nameof(config.InitialContextLongLivedSizeInKB)} argument value ({longLivedContextSize}) is invalid"' cmd);                          config.InitialContextLongLivedSizeInKB = longLivedContextSize;                      }                        if (progressIntervalInSecArg.HasValue())                      {                          if (int.TryParse(progressIntervalInSecArg.Value()' out var refreshRate) == false ||                              refreshRate < 1)                              return ExitWithError($"{nameof(config.ProgressIntervalInSec)} argument value ({refreshRate}) is invalid"' cmd);                          config.ProgressIntervalInSec = refreshRate;                      }                        if (disableCopyOnWriteModeArg.HasValue())                      {                          var value = disableCopyOnWriteModeArg.Value();                          if (bool.TryParse(value' out var disableCopyOnWriteMode) == false)                              return ExitWithError($"{nameof(config.DisableCopyOnWriteMode)} argument value ({value}) is invalid"' cmd);                          config.DisableCopyOnWriteMode = disableCopyOnWriteMode;                      }                        if (ignoreInvalidJournalErrorsArg.HasValue())                      {                          var value = ignoreInvalidJournalErrorsArg.Value();                          if (bool.TryParse(value' out var ignoreInvalidJournalErrors) == false)                              return ExitWithError($"{nameof(config.IgnoreInvalidJournalErrors)} argument value ({value}) is invalid"' cmd);                            config.IgnoreInvalidJournalErrors = ignoreInvalidJournalErrors;                      }                        if (ignoreDataIntegrityErrorsOfAlreadySyncedTransactionsArg.HasValue())                      {                          var value = ignoreDataIntegrityErrorsOfAlreadySyncedTransactionsArg.Value();                          if (bool.TryParse(value' out var ignoreDataIntegrityErrorsOfAlreadySyncedTransactions) == false)                              return ExitWithError($"{nameof(config.IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions)} argument value ({value}) is invalid"' cmd);                            config.IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions = ignoreDataIntegrityErrorsOfAlreadySyncedTransactions;                      }                        if (loggingModeArg.HasValue())                      {                          var value = loggingModeArg.Value();                          if (Enum.TryParse(value' out LogMode mode) == false)                              return ExitWithError($"{nameof(config.LoggingMode)} argument value ({value}) is invalid"' cmd);                          config.LoggingMode = mode;                      }                        if (masterKey.HasValue())                      {                          var value = masterKey.Value();                          byte[] key;                          try                          {                              key = Convert.FromBase64String(value);                          }                          catch                          {                              return ExitWithError($"{nameof(config.MasterKey)} argument value ({value}) is not a valid base64 string"' cmd);                          }                                                       config.MasterKey = key;                      }                      using (var recovery = new Recovery(config))                      {                          var cts = new CancellationTokenSource();                          Console.WriteLine("Press 'q' to quit the recovery process");                          var cancellationTask = Task.Factory.StartNew(() =>                          {                              while (Console.Read() != 'q')                              {                              }                                cts.Cancel();                              //The reason i do an exit here is because if we are in the middle of journal recovery                               //we can't cancel it and it may take a long time.                              //That said i'm still going to give it a while to do a proper exit                              Task.Delay(5000).ContinueWith(_ => { Environment.Exit(1); });                          }' cts.Token);                            try                          {                              recovery.Execute(Console.Out' cts.Token);                          }                          catch (Exception e)                          {                              if (e.Data["ReturnCode"] is int returnCode)                                  return returnCode;                                return ExitWithError(e.Message' _app);                          }                            cts.Cancel();                      }                        return 0;                  });              });
Magic Number,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Recovery,The following statement contains a magic number: LoggingSource.Instance.SetupLogMode(config.LoggingMode' Path.Combine(Path.GetDirectoryName(_output)' LogFileName)' TimeSpan.FromDays(3)' long.MaxValue' false);
Magic Number,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The following statement contains a magic number: fixed (byte* hashResultPtr = _streamHashResult)                                      {                                          long totalSize = 0;                                          _attachmentChunks.Clear();                                          rc = Sodium.crypto_generichash_init(hashStatePtr' null' UIntPtr.Zero' (UIntPtr)_streamHashResult.Length);                                          if (rc != 0)                                          {                                              if (_logger.IsOperationsEnabled)                                                  _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to initialize Sodium for hash computation will skip this page.");                                              mem += numberOfPages * _pageSize;                                              continue;                                          }                                          // write document header' including size                                          PageHeader* nextPage = pageHeader;                                            bool valid = true;                                          string tag = null;                                            while (true) // has next                                          {                                              streamPageHeader = (StreamPageHeader*)nextPage;                                              //this is the last page and it contains only stream info + maybe the stream tag                                              if (streamPageHeader->ChunkSize == 0)                                              {                                                  ExtractTagFromLastPage(nextPage' streamPageHeader' ref tag);                                                  break;                                              }                                              totalSize += streamPageHeader->ChunkSize;                                              var dataStart = (byte*)nextPage + PageHeader.SizeOf;                                              _attachmentChunks.Add(((IntPtr)dataStart' (int)streamPageHeader->ChunkSize));                                              rc = Sodium.crypto_generichash_update(hashStatePtr' dataStart' (ulong)streamPageHeader->ChunkSize);                                              if (rc != 0)                                              {                                                  if (_logger.IsOperationsEnabled)                                                      _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to compute chunk hash' will skip it.");                                                  valid = false;                                                  break;                                              }                                              if (streamPageHeader->StreamNextPageNumber == 0)                                              {                                                  ExtractTagFromLastPage(nextPage' streamPageHeader' ref tag);                                                  break;                                              }                                                var nextStreamHeader = (byte*)(streamPageHeader->StreamNextPageNumber * _pageSize) + startOffset;                                              nextPage = (PageHeader*)DecryptPageIfNeeded(nextStreamHeader' startOffset' ref tx' false);                                                //This is the case that the next page isn't a stream page                                              if (nextPage->Flags.HasFlag(PageFlags.Stream) == false || nextPage->Flags.HasFlag(PageFlags.Overflow) == false)                                              {                                                  valid = false;                                                  if (_logger.IsOperationsEnabled)                                                      _logger.Operations($"page #{nextPage->PageNumber} (offset={(long)nextPage}) was suppose to be a stream chunk but isn't marked as Overflow | Stream");                                                  break;                                              }                                                                                            valid = ValidateOverflowPage(nextPage' eof' startOffset' ref mem);                                                                                            //we already advance the pointer inside the validation                                              if (valid == false)                                              {                                                  break;                                              }                                            }                                          if (valid == false)                                          {                                              //The first page was valid so we can skip the entire overflow                                              mem += numberOfPages * _pageSize;                                              continue;                                          }                                            rc = Sodium.crypto_generichash_final(hashStatePtr' hashResultPtr' (UIntPtr)_streamHashResult.Length);                                          if (rc != 0)                                          {                                              if (_logger.IsOperationsEnabled)                                                  _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to compute attachment hash' will skip it.");                                              mem += numberOfPages * _pageSize;                                              continue;                                          }                                          var hash = new string(' '' 44);                                          fixed (char* p = hash)                                          {                                              var len = Base64.ConvertToBase64Array(p' hashResultPtr' 0' 32);                                              Debug.Assert(len == 44);                                          }                                            WriteAttachment(documentsWriter' totalSize' hash' tag);                                      }
Magic Number,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The following statement contains a magic number: fixed (byte* hashResultPtr = _streamHashResult)                                      {                                          long totalSize = 0;                                          _attachmentChunks.Clear();                                          rc = Sodium.crypto_generichash_init(hashStatePtr' null' UIntPtr.Zero' (UIntPtr)_streamHashResult.Length);                                          if (rc != 0)                                          {                                              if (_logger.IsOperationsEnabled)                                                  _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to initialize Sodium for hash computation will skip this page.");                                              mem += numberOfPages * _pageSize;                                              continue;                                          }                                          // write document header' including size                                          PageHeader* nextPage = pageHeader;                                            bool valid = true;                                          string tag = null;                                            while (true) // has next                                          {                                              streamPageHeader = (StreamPageHeader*)nextPage;                                              //this is the last page and it contains only stream info + maybe the stream tag                                              if (streamPageHeader->ChunkSize == 0)                                              {                                                  ExtractTagFromLastPage(nextPage' streamPageHeader' ref tag);                                                  break;                                              }                                              totalSize += streamPageHeader->ChunkSize;                                              var dataStart = (byte*)nextPage + PageHeader.SizeOf;                                              _attachmentChunks.Add(((IntPtr)dataStart' (int)streamPageHeader->ChunkSize));                                              rc = Sodium.crypto_generichash_update(hashStatePtr' dataStart' (ulong)streamPageHeader->ChunkSize);                                              if (rc != 0)                                              {                                                  if (_logger.IsOperationsEnabled)                                                      _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to compute chunk hash' will skip it.");                                                  valid = false;                                                  break;                                              }                                              if (streamPageHeader->StreamNextPageNumber == 0)                                              {                                                  ExtractTagFromLastPage(nextPage' streamPageHeader' ref tag);                                                  break;                                              }                                                var nextStreamHeader = (byte*)(streamPageHeader->StreamNextPageNumber * _pageSize) + startOffset;                                              nextPage = (PageHeader*)DecryptPageIfNeeded(nextStreamHeader' startOffset' ref tx' false);                                                //This is the case that the next page isn't a stream page                                              if (nextPage->Flags.HasFlag(PageFlags.Stream) == false || nextPage->Flags.HasFlag(PageFlags.Overflow) == false)                                              {                                                  valid = false;                                                  if (_logger.IsOperationsEnabled)                                                      _logger.Operations($"page #{nextPage->PageNumber} (offset={(long)nextPage}) was suppose to be a stream chunk but isn't marked as Overflow | Stream");                                                  break;                                              }                                                                                            valid = ValidateOverflowPage(nextPage' eof' startOffset' ref mem);                                                                                            //we already advance the pointer inside the validation                                              if (valid == false)                                              {                                                  break;                                              }                                            }                                          if (valid == false)                                          {                                              //The first page was valid so we can skip the entire overflow                                              mem += numberOfPages * _pageSize;                                              continue;                                          }                                            rc = Sodium.crypto_generichash_final(hashStatePtr' hashResultPtr' (UIntPtr)_streamHashResult.Length);                                          if (rc != 0)                                          {                                              if (_logger.IsOperationsEnabled)                                                  _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to compute attachment hash' will skip it.");                                              mem += numberOfPages * _pageSize;                                              continue;                                          }                                          var hash = new string(' '' 44);                                          fixed (char* p = hash)                                          {                                              var len = Base64.ConvertToBase64Array(p' hashResultPtr' 0' 32);                                              Debug.Assert(len == 44);                                          }                                            WriteAttachment(documentsWriter' totalSize' hash' tag);                                      }
Magic Number,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,Execute,The following statement contains a magic number: fixed (byte* hashResultPtr = _streamHashResult)                                      {                                          long totalSize = 0;                                          _attachmentChunks.Clear();                                          rc = Sodium.crypto_generichash_init(hashStatePtr' null' UIntPtr.Zero' (UIntPtr)_streamHashResult.Length);                                          if (rc != 0)                                          {                                              if (_logger.IsOperationsEnabled)                                                  _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to initialize Sodium for hash computation will skip this page.");                                              mem += numberOfPages * _pageSize;                                              continue;                                          }                                          // write document header' including size                                          PageHeader* nextPage = pageHeader;                                            bool valid = true;                                          string tag = null;                                            while (true) // has next                                          {                                              streamPageHeader = (StreamPageHeader*)nextPage;                                              //this is the last page and it contains only stream info + maybe the stream tag                                              if (streamPageHeader->ChunkSize == 0)                                              {                                                  ExtractTagFromLastPage(nextPage' streamPageHeader' ref tag);                                                  break;                                              }                                              totalSize += streamPageHeader->ChunkSize;                                              var dataStart = (byte*)nextPage + PageHeader.SizeOf;                                              _attachmentChunks.Add(((IntPtr)dataStart' (int)streamPageHeader->ChunkSize));                                              rc = Sodium.crypto_generichash_update(hashStatePtr' dataStart' (ulong)streamPageHeader->ChunkSize);                                              if (rc != 0)                                              {                                                  if (_logger.IsOperationsEnabled)                                                      _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to compute chunk hash' will skip it.");                                                  valid = false;                                                  break;                                              }                                              if (streamPageHeader->StreamNextPageNumber == 0)                                              {                                                  ExtractTagFromLastPage(nextPage' streamPageHeader' ref tag);                                                  break;                                              }                                                var nextStreamHeader = (byte*)(streamPageHeader->StreamNextPageNumber * _pageSize) + startOffset;                                              nextPage = (PageHeader*)DecryptPageIfNeeded(nextStreamHeader' startOffset' ref tx' false);                                                //This is the case that the next page isn't a stream page                                              if (nextPage->Flags.HasFlag(PageFlags.Stream) == false || nextPage->Flags.HasFlag(PageFlags.Overflow) == false)                                              {                                                  valid = false;                                                  if (_logger.IsOperationsEnabled)                                                      _logger.Operations($"page #{nextPage->PageNumber} (offset={(long)nextPage}) was suppose to be a stream chunk but isn't marked as Overflow | Stream");                                                  break;                                              }                                                                                            valid = ValidateOverflowPage(nextPage' eof' startOffset' ref mem);                                                                                            //we already advance the pointer inside the validation                                              if (valid == false)                                              {                                                  break;                                              }                                            }                                          if (valid == false)                                          {                                              //The first page was valid so we can skip the entire overflow                                              mem += numberOfPages * _pageSize;                                              continue;                                          }                                            rc = Sodium.crypto_generichash_final(hashStatePtr' hashResultPtr' (UIntPtr)_streamHashResult.Length);                                          if (rc != 0)                                          {                                              if (_logger.IsOperationsEnabled)                                                  _logger.Operations($"page #{pageHeader->PageNumber} (offset={(long)pageHeader}) failed to compute attachment hash' will skip it.");                                              mem += numberOfPages * _pageSize;                                              continue;                                          }                                          var hash = new string(' '' 44);                                          fixed (char* p = hash)                                          {                                              var len = Base64.ConvertToBase64Array(p' hashResultPtr' 0' 32);                                              Debug.Assert(len == 44);                                          }                                            WriteAttachment(documentsWriter' totalSize' hash' tag);                                      }
Magic Number,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteDummyDocumentForAttachment,The following statement contains a magic number: WriteAttachmentMetadata(writer' hash' size' tokens[2]' tokens[4]);
Magic Number,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteDummyDocumentForAttachment,The following statement contains a magic number: WriteAttachmentMetadata(writer' hash' size' tokens[2]' tokens[4]);
Magic Number,Voron.Recovery,Recovery,C:\research\architectureSmells\repos\ravendb_ravendb\tools\Voron.Recovery\Recovery.cs,WriteDummyDocumentForAttachment,The following statement contains a magic number: tokens.Length == 5
