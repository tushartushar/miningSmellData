Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Voron.Benchmark,Utils,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\Utils.cs,GenerateWornoutTree,The method has 7 parameters. Parameters: env' treeNameSlice' generationTreeSize' generationBatchSize' keyLength' generationDeletionProbability' randomSeed
Long Parameter List,Voron.Benchmark,Utils,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\Utils.cs,GenerateWornoutTable,The method has 8 parameters. Parameters: env' tableNameSlice' schema' generationTableSize' generationBatchSize' keyLength' generationDeletionProbability' randomSeed
Magic Number,Voron.Benchmark,Program,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\Program.cs,Main,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  var a = new BTreeFillRandom();                  {                      a.Setup();                      var sp = Stopwatch.StartNew();                      a.FillRandomMultipleTransactions();                      list.Add(sp.ElapsedMilliseconds);                      Console.WriteLine(". " + sp.ElapsedMilliseconds);                      a.Cleanup();                  }              }
Magic Number,Voron.Benchmark,StorageBenchmark,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\StorageBenchmark.cs,DeleteStorage,The following statement contains a magic number: for (var i = 0; i < 10; ++i)              {                  try                  {                      Directory.Delete(Path' true);                      break;                  }                  catch (DirectoryNotFoundException)                  {                      break;                  }                  catch (Exception)                  {                      Thread.Sleep(20);                  }              }
Magic Number,Voron.Benchmark,StorageBenchmark,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\StorageBenchmark.cs,DeleteStorage,The following statement contains a magic number: for (var i = 0; i < 10; ++i)              {                  try                  {                      Directory.Delete(Path' true);                      break;                  }                  catch (DirectoryNotFoundException)                  {                      break;                  }                  catch (Exception)                  {                      Thread.Sleep(20);                  }              }
Magic Number,Voron.Benchmark,Utils,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\Utils.cs,GenerateUniqueRandomSlicePairs,The following statement contains a magic number: while (pairs.Count < amount)              {                  Slice key;                  Slice value;                    generator.NextBytes(keyBuffer);                    ByteStringContext.Scope keyScope =                      Slice.From(Configuration.Allocator' keyBuffer' ByteStringType.Immutable' out key);                    i++;                    if (added.Contains(key))                  {                      // Release the unused key's memory                      keyScope.Dispose();                      continue;                  }                    // Trees are mostly used by Table to store long values. We                  // attempt to emulate that behavior                  long valueBuffer = generator.Next();                  valueBuffer += (long)generator.Next() << 32;                  valueBuffer += (long)generator.Next() << 64;                  valueBuffer += (long)generator.Next() << 96;                    unsafe                  {                      Slice.From(Configuration.Allocator' (byte*)&valueBuffer' sizeof(long)' ByteStringType.Immutable' out value);                  }                    pairs.Add(new Tuple<Slice' Slice>(key' value));                  added.Add(key);              }
Magic Number,Voron.Benchmark,Utils,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\Utils.cs,GenerateUniqueRandomSlicePairs,The following statement contains a magic number: while (pairs.Count < amount)              {                  Slice key;                  Slice value;                    generator.NextBytes(keyBuffer);                    ByteStringContext.Scope keyScope =                      Slice.From(Configuration.Allocator' keyBuffer' ByteStringType.Immutable' out key);                    i++;                    if (added.Contains(key))                  {                      // Release the unused key's memory                      keyScope.Dispose();                      continue;                  }                    // Trees are mostly used by Table to store long values. We                  // attempt to emulate that behavior                  long valueBuffer = generator.Next();                  valueBuffer += (long)generator.Next() << 32;                  valueBuffer += (long)generator.Next() << 64;                  valueBuffer += (long)generator.Next() << 96;                    unsafe                  {                      Slice.From(Configuration.Allocator' (byte*)&valueBuffer' sizeof(long)' ByteStringType.Immutable' out value);                  }                    pairs.Add(new Tuple<Slice' Slice>(key' value));                  added.Add(key);              }
Magic Number,Voron.Benchmark,Utils,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\Utils.cs,GenerateUniqueRandomSlicePairs,The following statement contains a magic number: while (pairs.Count < amount)              {                  Slice key;                  Slice value;                    generator.NextBytes(keyBuffer);                    ByteStringContext.Scope keyScope =                      Slice.From(Configuration.Allocator' keyBuffer' ByteStringType.Immutable' out key);                    i++;                    if (added.Contains(key))                  {                      // Release the unused key's memory                      keyScope.Dispose();                      continue;                  }                    // Trees are mostly used by Table to store long values. We                  // attempt to emulate that behavior                  long valueBuffer = generator.Next();                  valueBuffer += (long)generator.Next() << 32;                  valueBuffer += (long)generator.Next() << 64;                  valueBuffer += (long)generator.Next() << 96;                    unsafe                  {                      Slice.From(Configuration.Allocator' (byte*)&valueBuffer' sizeof(long)' ByteStringType.Immutable' out value);                  }                    pairs.Add(new Tuple<Slice' Slice>(key' value));                  added.Add(key);              }
Magic Number,Voron.Benchmark,Utils,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\Utils.cs,GenerateWornoutTable,The following statement contains a magic number: if (hasTable)              {                  using (var tx = env.ReadTransaction())                  {                      var table = tx.OpenTable(schema' tableNameSlice);                        foreach (var reader in table.SeekByPrimaryKey(Slices.BeforeAllKeys' 0))                      {                          Slice key;                          schema.Key.GetSlice(Configuration.Allocator' ref reader.Reader' out key);                          tableKeys.Add(key);                      }                        tx.Commit();                  }              }              else              {                  // Create a table with enough wearing                  using (var tx = env.WriteTransaction())                  {                      var values = new List<Tuple<Slice' Slice>>();                      schema.Create(tx' tableNameSlice' 16);                      var table = tx.OpenTable(schema' tableNameSlice);                        while (table.NumberOfEntries < generationTableSize)                      {                          int deletions = 0;                            // Add BatchSize new keys                          for (int i = 0; i < generationBatchSize; i++)                          {                              // We might run out of values while creating the table' generate more.                              if (values.Count == 0)                              {                                  values = GenerateUniqueRandomSlicePairs(                                      generationTableSize'                                      keyLength'                                      randomSeed);                              }                                var pair = values[0];                              values.RemoveAt(0);                                // Add it to the table key set                              tableKeys.Add(pair.Item1);                                // Add it to the table                              table.Insert(new TableValueBuilder                                  {                                      pair.Item1'                                      pair.Item2                                  });                                // Simulate a binomial rv in the mean time                              if (generator.NextDouble() < generationDeletionProbability)                              {                                  deletions++;                              }                          }                            // Delete the number of deletions given by the binomial rv                          // We may have gone a little bit over the limit during                          // insertion' but we rebalance here.                          if (table.NumberOfEntries > generationTableSize)                          {                              while (table.NumberOfEntries > generationTableSize)                              {                                  var keyIndex = generator.Next(tableKeys.Count);                                  // TODO: next two lines will run too slow for big datasets                                  table.DeleteByKey(tableKeys[keyIndex]);                                  tableKeys.RemoveAt(keyIndex);                              }                          }                          else                          {                              while (deletions > 0 && table.NumberOfEntries > 0)                              {                                  var keyIndex = generator.Next(tableKeys.Count);                                  // TODO: next two lines will run too slow for big datasets                                  table.DeleteByKey(tableKeys[keyIndex]);                                  tableKeys.RemoveAt(keyIndex);                                  deletions--;                              }                          }                      }                        tx.Commit();                  }              }
Magic Number,Voron.Benchmark.Table,TableFillRandom,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\Table\TableFillRandom.cs,Setup,The following statement contains a magic number: using (var tx = Env.WriteTransaction())              {                  Schema.Create(tx' TableNameSlice' 16);                  tx.Commit();              }
Magic Number,Voron.Benchmark.Table,TableFillSequential,C:\repos\ravendb_ravendb\bench\Voron.Benchmark\Table\TableFillSequential.cs,Setup,The following statement contains a magic number: using (var tx = Env.WriteTransaction())              {                  Schema.Create(tx' TableNameSlice' 16);                  tx.Commit();              }
