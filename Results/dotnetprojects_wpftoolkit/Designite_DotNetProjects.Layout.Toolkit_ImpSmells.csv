Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,PrepareContainerForItemOverride,The method has 102 lines of code.
Long Method,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnItemsChanged,The method has 114 lines of code.
Long Method,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectedIndicesCollectionChanged,The method has 109 lines of code.
Complex Method,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectionModePropertyChanged,Cyclomatic complexity of the method is 10
Complex Method,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,PrepareContainerForItemOverride,Cyclomatic complexity of the method is 13
Complex Method,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,UnselectItem,Cyclomatic complexity of the method is 9
Complex Method,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,LayoutChildren,Cyclomatic complexity of the method is 11
Complex Method,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,RealizeOverride,Cyclomatic complexity of the method is 10
Complex Method,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,GetNodesIntersecting,Cyclomatic complexity of the method is 10
Complex Method,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,GetNodesInside,Cyclomatic complexity of the method is 10
Long Identifier,System.Windows.Controls,InteractionHelper,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Common\System\Windows\Controls\InteractionHelper.cs,,The length of the parameter SequentialClickThresholdInMilliseconds is 38.
Long Identifier,System.Windows.Controls,InteractionHelper,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Common\System\Windows\Controls\InteractionHelper.cs,,The length of the parameter SequentialClickThresholdInPixelsSquared is 39.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isAllowedToWriteSelectedItems is 30.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isAllowedToWriteSelectedIndices is 32.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isIgnoringSelectedIndicesChanges is 33.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isIgnoringSelectedItemsChanges is 31.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isInSelectedItemsCollectionChanged is 35.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isInSelectedIndicesCollectionChanged is 37.
Long Identifier,System.Windows.Controls,AccordionItem,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,,The length of the parameter _allowedToWriteExpandDirection is 30.
Long Identifier,System.Windows.Controls,AccordionItem,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,,The length of the parameter ExpandableContentControlStyleProperty is 37.
Long Identifier,System.Windows.Controls,AccordionItem,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,,The length of the parameter _allowedToWriteContentTargetSize is 32.
Long Identifier,System.Windows.Controls,TransitioningContentControl,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\TransitioningContentControl\System\Windows\Controls\TransitioningContentControl.cs,,The length of the parameter PreviousContentPresentationSitePartName is 39.
Long Identifier,System.Windows.Controls,TransitioningContentControl,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\TransitioningContentControl\System\Windows\Controls\TransitioningContentControl.cs,,The length of the parameter CurrentContentPresentationSitePartName is 38.
Long Identifier,System.Windows.Controls,TransitioningContentControl,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\TransitioningContentControl\System\Windows\Controls\TransitioningContentControl.cs,,The length of the parameter RestartTransitionOnContentChangeProperty is 40.
Long Statement,System.Windows.Controls,InteractionHelper,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Common\System\Windows\Controls\InteractionHelper.cs,UpdateVisualStateBase,The length of the statement  "                VisualStates.GoToState(Control' useTransitions' VisualStates.StatePressed' VisualStates.StateMouseOver' VisualStates.StateNormal); " is 130.
Long Statement,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectedItemPropertyChanged,The length of the statement  "                        IEnumerable<int> validIndices = source.SelectedIndices.Where(i => i >= 0 && i < source.Items.Count && newValue.Equals(source.Items[i])); " is 136.
Long Statement,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,PrepareContainerForItemOverride,The length of the statement  "                AccordionItem.PreparePrepareHeaderedContentControlContainerForItemOverride(accordionItem' item' this' ItemContainerStyle); " is 122.
Long Statement,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnAccordionItemUnselected,The length of the statement  "            UnselectItem(ItemContainerGenerator.IndexFromContainer(accordionItem)' ItemContainerGenerator.ItemFromContainer(accordionItem)); " is 128.
Long Statement,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,UnselectItem,The length of the statement  "            AccordionItem container = index >= 0 && index < Items.Count ? ItemContainerGenerator.ContainerFromIndex(index) as AccordionItem : null; " is 135.
Long Statement,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,SelectItem,The length of the statement  "            AccordionItem container = index >= 0 && index < Items.Count ? ItemContainerGenerator.ContainerFromIndex(index) as AccordionItem : null; " is 135.
Long Statement,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,ChangeSelectedIndex,The length of the statement  "            AccordionItem oldAccordionItem = oldIndex >= 0 && oldIndex < Items.Count ? ItemContainerGenerator.ContainerFromIndex(oldIndex) as AccordionItem : null; " is 151.
Long Statement,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,ChangeSelectedIndex,The length of the statement  "            AccordionItem newAccordionItem = newIndex >= 0 && newIndex < Items.Count ? ItemContainerGenerator.ContainerFromIndex(newIndex) as AccordionItem : null; " is 151.
Long Statement,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectedIndicesCollectionChanged,The length of the statement  "                            if (SelectedItem != null && e.NewItems.Count != 1 || ((int)e.NewItems[0] < Items.Count && !Items[(int)e.NewItems[0]].Equals(SelectedItem))) " is 139.
Long Statement,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,ProposeSelectedIndexCandidate,The length of the statement  "            IEnumerable<int> validIndices = SelectedIndices.Where(i => i != nonCandidateIndex && (item == null || !item.Equals(Items[i]))); " is 127.
Long Statement,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,SetPanelOrientation,The length of the statement  "                        panel.HorizontalAlignment = ExpandDirection == ExpandDirection.Left ? HorizontalAlignment.Right : HorizontalAlignment.Left; " is 123.
Long Statement,System.Windows.Controls,TransitioningContentControl,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\TransitioningContentControl\System\Windows\Controls\TransitioningContentControl.cs,OnTransitionPropertyChanged,The length of the statement  "                        string.Format(CultureInfo.CurrentCulture' Properties.Resources.TransitioningContentControl_TransitionNotFound' newTransition)); " is 127.
Long Statement,System.Windows.Controls,TransitioningContentControl,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\TransitioningContentControl\System\Windows\Controls\TransitioningContentControl.cs,OnApplyTemplate,The length of the statement  "                    string.Format(CultureInfo.CurrentCulture' Properties.Resources.TransitioningContentControl_TransitionNotFound' invalidTransition)); " is 131.
Long Statement,System.Windows.Controls,VirtualPanel,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\VirtualPanel.cs,OnItemsChanged,The length of the statement  "                        // ItemContainerGenerator is infested with bugs. One of which is that as items are added to the end of a collection' the index from IndexFromGeneratorPosition will usually be wrong. " is 181.
Long Statement,System.Windows.Controls,VirtualPanel,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\VirtualPanel.cs,OnItemsChanged,The length of the statement  "                        // Since we can't actually get the old items directly' and sometimes we can't even get the old index from the generator' we'll get as many as we can from the visuals. " is 166.
Long Statement,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,CoerceOffset,The length of the statement  "                    value = new Point((viewbox.X + viewbox.Width / 2) * scale - renderSize.Width / 2' (viewbox.Y + viewbox.Height / 2) * scale - renderSize.Height / 2); " is 148.
Long Statement,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,RealizeOverride,The length of the statement  "                    query = SpatialIndex.Query(new Rect(Double.NegativeInfinity' Double.NegativeInfinity' Double.PositiveInfinity' Double.PositiveInfinity)); " is 137.
Long Statement,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,ArrangeOverride,The length of the statement  "                    Rect bounds = new Rect(Canvas.GetLeft(child).GetValueOrDefault()' Canvas.GetTop(child).GetValueOrDefault()' child.DesiredSize.Width / scale' child.DesiredSize.Height / scale); " is 175.
Long Statement,System.Collections.Generic,PriorityQuadTree<T>,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,Remove,The length of the statement  "            return Remove(item' new Rect(double.NegativeInfinity' double.NegativeInfinity' double.PositiveInfinity' double.PositiveInfinity)); " is 130.
Long Statement,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,GetNodesIntersecting,The length of the statement  "                        var newPotential = queue.Count > 0 ? !potential.IsNaN() ? Math.Max(potential' queue.Peek().Value) : queue.Peek().Value : potential; " is 131.
Long Statement,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,GetNodesInside,The length of the statement  "                        var newPotential = queue.Count > 0 ? !potential.IsNaN() ? Math.Max(potential' queue.Peek().Value) : queue.Peek().Value : potential; " is 131.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\obj\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnExpandDirectionPropertyChanged,The conditional expression  "expandDirection != ExpandDirection.Down &&                  expandDirection != ExpandDirection.Up &&                  expandDirection != ExpandDirection.Left &&                  expandDirection != ExpandDirection.Right"  is complex.
Complex Conditional,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectionModePropertyChanged,The conditional expression  "newValue != AccordionSelectionMode.One &&                  newValue != AccordionSelectionMode.OneOrMore &&                  newValue != AccordionSelectionMode.ZeroOrMore &&                  newValue != AccordionSelectionMode.ZeroOrOne"  is complex.
Complex Conditional,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectedIndicesCollectionChanged,The conditional expression  "SelectedItem != null && e.NewItems.Count != 1 || ((int)e.NewItems[0] < Items.Count && !Items[(int)e.NewItems[0]].Equals(SelectedItem))"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnExpandDirectionPropertyChanged,The conditional expression  "newValue != ExpandDirection.Down &&                  newValue != ExpandDirection.Left &&                  newValue != ExpandDirection.Right &&                  newValue != ExpandDirection.Up"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnKeyDown,The conditional expression  "(isSelected && e.Key == Key.Up) || (!isSelected && e.Key == Key.Down)"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnKeyDown,The conditional expression  "(isSelected && e.Key == Key.Down) || (!isSelected && e.Key == Key.Up)"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnKeyDown,The conditional expression  "(isSelected && e.Key == Key.Right) || (!isSelected && e.Key == Key.Left)"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnKeyDown,The conditional expression  "(isSelected && e.Key == Key.Left) || (!isSelected && e.Key == Key.Right)"  is complex.
Complex Conditional,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,ArrangeOverride,The conditional expression  "Math.Abs(oldBounds.Top - bounds.Top) > tolerance ||                              Math.Abs(oldBounds.Left - bounds.Left) > tolerance ||                              Math.Abs(oldBounds.Width - bounds.Width) > tolerance ||                              Math.Abs(oldBounds.Height - bounds.Height) > tolerance"  is complex.
Complex Conditional,System.Windows.Controls,PrivateSpatialIndex,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,Optimize,The conditional expression  "treeExtent.Top - realExtent.Top > treeExtent.Height ||                      treeExtent.Left - realExtent.Left > treeExtent.Width ||                      realExtent.Right - treeExtent.Right > treeExtent.Width ||                      realExtent.Bottom - treeExtent.Bottom > treeExtent.Height"  is complex.
Complex Conditional,System.Collections.Generic,PriorityQuadTree<T>,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,Insert,The conditional expression  "bounds.Top.IsNaN() ||                  bounds.Left.IsNaN() ||                  bounds.Width.IsNaN() ||                  bounds.Height.IsNaN()"  is complex.
Complex Conditional,System.Collections.Generic,PriorityQuadTree<T>,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,HasItemsInside,The conditional expression  "bounds.Top.IsNaN() ||                  bounds.Left.IsNaN() ||                  bounds.Width.IsNaN() ||                  bounds.Height.IsNaN()"  is complex.
Complex Conditional,System.Collections.Generic,PriorityQuadTree<T>,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,GetItemsInside,The conditional expression  "bounds.Top.IsNaN() ||                  bounds.Left.IsNaN() ||                  bounds.Width.IsNaN() ||                  bounds.Height.IsNaN()"  is complex.
Complex Conditional,System.Collections.Generic,PriorityQuadTree<T>,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,HasItemsIntersecting,The conditional expression  "bounds.Top.IsNaN() ||                  bounds.Left.IsNaN() ||                  bounds.Width.IsNaN() ||                  bounds.Height.IsNaN()"  is complex.
Complex Conditional,System.Collections.Generic,PriorityQuadTree<T>,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,GetItemsIntersecting,The conditional expression  "bounds.Top.IsNaN() ||                  bounds.Left.IsNaN() ||                  bounds.Width.IsNaN() ||                  bounds.Height.IsNaN()"  is complex.
Complex Conditional,System.Collections.Generic,PriorityQuadTree<T>,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,Remove,The conditional expression  "bounds.Top.IsNaN() ||                  bounds.Left.IsNaN() ||                  bounds.Width.IsNaN() ||                  bounds.Height.IsNaN()"  is complex.
Empty Catch Block,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,ZoomableCanvas,The method has an empty catch block.
Magic Number,System.Windows.Controls.Extensions,RectExtensions,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Extensions\RectExtensions.cs,GetCenter,The following statement contains a magic number: return new Point(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);
Magic Number,System.Windows.Controls.Extensions,RectExtensions,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Extensions\RectExtensions.cs,GetCenter,The following statement contains a magic number: return new Point(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,CoerceOffset,The following statement contains a magic number: if (canvas != null)              {                  var viewbox = canvas.Viewbox;                  if (!viewbox.IsEmpty)                  {                      var scale = canvas.Scale;                      var renderSize = canvas.RenderSize;                      value = new Point((viewbox.X + viewbox.Width / 2) * scale - renderSize.Width / 2' (viewbox.Y + viewbox.Height / 2) * scale - renderSize.Height / 2);                  }              }
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,CoerceOffset,The following statement contains a magic number: if (canvas != null)              {                  var viewbox = canvas.Viewbox;                  if (!viewbox.IsEmpty)                  {                      var scale = canvas.Scale;                      var renderSize = canvas.RenderSize;                      value = new Point((viewbox.X + viewbox.Width / 2) * scale - renderSize.Width / 2' (viewbox.Y + viewbox.Height / 2) * scale - renderSize.Height / 2);                  }              }
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,CoerceOffset,The following statement contains a magic number: if (canvas != null)              {                  var viewbox = canvas.Viewbox;                  if (!viewbox.IsEmpty)                  {                      var scale = canvas.Scale;                      var renderSize = canvas.RenderSize;                      value = new Point((viewbox.X + viewbox.Width / 2) * scale - renderSize.Width / 2' (viewbox.Y + viewbox.Height / 2) * scale - renderSize.Height / 2);                  }              }
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,CoerceOffset,The following statement contains a magic number: if (canvas != null)              {                  var viewbox = canvas.Viewbox;                  if (!viewbox.IsEmpty)                  {                      var scale = canvas.Scale;                      var renderSize = canvas.RenderSize;                      value = new Point((viewbox.X + viewbox.Width / 2) * scale - renderSize.Width / 2' (viewbox.Y + viewbox.Height / 2) * scale - renderSize.Height / 2);                  }              }
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,RealizeOverride,The following statement contains a magic number: if (SpatialIndex != null)              {                  // Optimize our private spatial index for the upcoming query.                  if (PrivateIndex != null)                  {                      PrivateIndex.Optimize();                  }                    IEnumerable<int> query;                    if (IsVirtualizing)                  {                      // Only realize the items within our viewbox.                      var viewbox = ActualViewbox;                      var limit = RealizationLimit;                        // Buffer the viewbox so that panning by small amounts is smooth.                      viewbox.Inflate(viewbox.Width / 10' viewbox.Height / 10);                        // Query the index for all items that intersect our viewbox' up to our realization limit.                      query = SpatialIndex.Query(viewbox).Take(limit);                  }                  else                  {                      // Get all items.                      query = SpatialIndex.Query(new Rect(Double.NegativeInfinity' Double.NegativeInfinity' Double.PositiveInfinity' Double.PositiveInfinity));                  }                    // We insert nodes at the head of the linked list in the order they are returned.                  LinkedListNode<int> lastNode = null;                  LinkedListNode<int> nextNode = RealizedItems.First;                    // Realize them.                  foreach (var index in query)                  {                      // See if the item was already realized.                      var node = RealizedItems.FindNext(lastNode' index);                      if (node == null || node != nextNode)                      {                          if (node != null)                          {                              // If it was already realized further down the list' remove it from the list so we can add it later.                              RealizedItems.Remove(node);                          }                          else                          {                              // If it was not already realized' realize it now and create a new node for it.                              RealizeItem(index);                              node = new LinkedListNode<int>(index);                          }                            // Insert the node after the last node' or at the front if this is the first.                          if (lastNode == null)                          {                              RealizedItems.AddFirst(node);                          }                          else                          {                              RealizedItems.AddAfter(lastNode' node);                          }                      }                        // Keep track of the last node of the query results.                      lastNode = node;                      nextNode = node.Next;                        // Yield control for throttling.                      yield return index;                  }                    // Virtualize any remaining items that are no longer part of our result set' backwards.                  nextNode = RealizedItems.Last;                  while (nextNode != lastNode)                  {                      var node = nextNode;                      nextNode = nextNode.Previous;                        var index = node.Value;                      var container = ContainerFromIndex(index);                      if (container == null || (!container.IsMouseCaptureWithin && !container.IsKeyboardFocusWithin))                      {                          VirtualizeItem(index);                          RealizedItems.Remove(node);                      }                        // Yield control for throttling.                      yield return index;                  }              }
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,RealizeOverride,The following statement contains a magic number: if (SpatialIndex != null)              {                  // Optimize our private spatial index for the upcoming query.                  if (PrivateIndex != null)                  {                      PrivateIndex.Optimize();                  }                    IEnumerable<int> query;                    if (IsVirtualizing)                  {                      // Only realize the items within our viewbox.                      var viewbox = ActualViewbox;                      var limit = RealizationLimit;                        // Buffer the viewbox so that panning by small amounts is smooth.                      viewbox.Inflate(viewbox.Width / 10' viewbox.Height / 10);                        // Query the index for all items that intersect our viewbox' up to our realization limit.                      query = SpatialIndex.Query(viewbox).Take(limit);                  }                  else                  {                      // Get all items.                      query = SpatialIndex.Query(new Rect(Double.NegativeInfinity' Double.NegativeInfinity' Double.PositiveInfinity' Double.PositiveInfinity));                  }                    // We insert nodes at the head of the linked list in the order they are returned.                  LinkedListNode<int> lastNode = null;                  LinkedListNode<int> nextNode = RealizedItems.First;                    // Realize them.                  foreach (var index in query)                  {                      // See if the item was already realized.                      var node = RealizedItems.FindNext(lastNode' index);                      if (node == null || node != nextNode)                      {                          if (node != null)                          {                              // If it was already realized further down the list' remove it from the list so we can add it later.                              RealizedItems.Remove(node);                          }                          else                          {                              // If it was not already realized' realize it now and create a new node for it.                              RealizeItem(index);                              node = new LinkedListNode<int>(index);                          }                            // Insert the node after the last node' or at the front if this is the first.                          if (lastNode == null)                          {                              RealizedItems.AddFirst(node);                          }                          else                          {                              RealizedItems.AddAfter(lastNode' node);                          }                      }                        // Keep track of the last node of the query results.                      lastNode = node;                      nextNode = node.Next;                        // Yield control for throttling.                      yield return index;                  }                    // Virtualize any remaining items that are no longer part of our result set' backwards.                  nextNode = RealizedItems.Last;                  while (nextNode != lastNode)                  {                      var node = nextNode;                      nextNode = nextNode.Previous;                        var index = node.Value;                      var container = ContainerFromIndex(index);                      if (container == null || (!container.IsMouseCaptureWithin && !container.IsKeyboardFocusWithin))                      {                          VirtualizeItem(index);                          RealizedItems.Remove(node);                      }                        // Yield control for throttling.                      yield return index;                  }              }
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,ArrangeOverride,The following statement contains a magic number: foreach (UIElement child in InternalChildren)              {                  if (child != null)                  {                      // Get bounds information from the element.                      Rect bounds = new Rect(Canvas.GetLeft(child).GetValueOrDefault()' Canvas.GetTop(child).GetValueOrDefault()' child.DesiredSize.Width / scale' child.DesiredSize.Height / scale);                        // If we are maintaining our own spatial wrapper then update its bounds.                      if (PrivateIndex != null)                      {                          int index = IndexFromContainer(child);                          Rect oldBounds = PrivateIndex[index];                          const double tolerance = .001; // The exact values during arrange can vary slightly.                          if (Math.Abs(oldBounds.Top - bounds.Top) > tolerance ||                              Math.Abs(oldBounds.Left - bounds.Left) > tolerance ||                              Math.Abs(oldBounds.Width - bounds.Width) > tolerance ||                              Math.Abs(oldBounds.Height - bounds.Height) > tolerance)                          {                              PrivateIndex[index] = bounds;                          }                      }                        // Update the children extent for scrolling.                      ChildrenExtent.Union(bounds);                        // So far everything has been in canvas coordinates.  Here we adjust the result for the final call to Arrange.                      bounds.X *= scale;                      bounds.X -= offset.X;                      bounds.Y *= scale;                      bounds.Y -= offset.Y;                      bounds.Width *= scale;                      bounds.Height *= scale;                        // WPF Arrange will crash if the values are too large.                      bounds.X = bounds.X.AtLeast(Single.MinValue / 2);                      bounds.Y = bounds.Y.AtLeast(Single.MinValue / 2);                      bounds.Width = bounds.Width.AtMost(Single.MaxValue);                      bounds.Height = bounds.Height.AtMost(Single.MaxValue);                        child.Arrange(bounds);                  }              }
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,ArrangeOverride,The following statement contains a magic number: foreach (UIElement child in InternalChildren)              {                  if (child != null)                  {                      // Get bounds information from the element.                      Rect bounds = new Rect(Canvas.GetLeft(child).GetValueOrDefault()' Canvas.GetTop(child).GetValueOrDefault()' child.DesiredSize.Width / scale' child.DesiredSize.Height / scale);                        // If we are maintaining our own spatial wrapper then update its bounds.                      if (PrivateIndex != null)                      {                          int index = IndexFromContainer(child);                          Rect oldBounds = PrivateIndex[index];                          const double tolerance = .001; // The exact values during arrange can vary slightly.                          if (Math.Abs(oldBounds.Top - bounds.Top) > tolerance ||                              Math.Abs(oldBounds.Left - bounds.Left) > tolerance ||                              Math.Abs(oldBounds.Width - bounds.Width) > tolerance ||                              Math.Abs(oldBounds.Height - bounds.Height) > tolerance)                          {                              PrivateIndex[index] = bounds;                          }                      }                        // Update the children extent for scrolling.                      ChildrenExtent.Union(bounds);                        // So far everything has been in canvas coordinates.  Here we adjust the result for the final call to Arrange.                      bounds.X *= scale;                      bounds.X -= offset.X;                      bounds.Y *= scale;                      bounds.Y -= offset.Y;                      bounds.Width *= scale;                      bounds.Height *= scale;                        // WPF Arrange will crash if the values are too large.                      bounds.X = bounds.X.AtLeast(Single.MinValue / 2);                      bounds.Y = bounds.Y.AtLeast(Single.MinValue / 2);                      bounds.Width = bounds.Width.AtMost(Single.MaxValue);                      bounds.Height = bounds.Height.AtMost(Single.MaxValue);                        child.Arrange(bounds);                  }              }
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,ArrangeOverride,The following statement contains a magic number: foreach (UIElement child in InternalChildren)              {                  if (child != null)                  {                      // Get bounds information from the element.                      Rect bounds = new Rect(Canvas.GetLeft(child).GetValueOrDefault()' Canvas.GetTop(child).GetValueOrDefault()' child.DesiredSize.Width / scale' child.DesiredSize.Height / scale);                        // If we are maintaining our own spatial wrapper then update its bounds.                      if (PrivateIndex != null)                      {                          int index = IndexFromContainer(child);                          Rect oldBounds = PrivateIndex[index];                          const double tolerance = .001; // The exact values during arrange can vary slightly.                          if (Math.Abs(oldBounds.Top - bounds.Top) > tolerance ||                              Math.Abs(oldBounds.Left - bounds.Left) > tolerance ||                              Math.Abs(oldBounds.Width - bounds.Width) > tolerance ||                              Math.Abs(oldBounds.Height - bounds.Height) > tolerance)                          {                              PrivateIndex[index] = bounds;                          }                      }                        // Update the children extent for scrolling.                      ChildrenExtent.Union(bounds);                        // So far everything has been in canvas coordinates.  Here we adjust the result for the final call to Arrange.                      bounds.X *= scale;                      bounds.X -= offset.X;                      bounds.Y *= scale;                      bounds.Y -= offset.Y;                      bounds.Width *= scale;                      bounds.Height *= scale;                        // WPF Arrange will crash if the values are too large.                      bounds.X = bounds.X.AtLeast(Single.MinValue / 2);                      bounds.Y = bounds.Y.AtLeast(Single.MinValue / 2);                      bounds.Width = bounds.Width.AtMost(Single.MaxValue);                      bounds.Height = bounds.Height.AtMost(Single.MaxValue);                        child.Arrange(bounds);                  }              }
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,LineDown,The following statement contains a magic number: ((IScrollInfo)this).SetVerticalOffset(((IScrollInfo)this).VerticalOffset + 16);
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,LineLeft,The following statement contains a magic number: ((IScrollInfo)this).SetHorizontalOffset(((IScrollInfo)this).HorizontalOffset - 16);
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,LineRight,The following statement contains a magic number: ((IScrollInfo)this).SetHorizontalOffset(((IScrollInfo)this).HorizontalOffset + 16);
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,LineUp,The following statement contains a magic number: ((IScrollInfo)this).SetVerticalOffset(((IScrollInfo)this).VerticalOffset - 16);
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,MouseWheelDown,The following statement contains a magic number: ((IScrollInfo)this).SetVerticalOffset(((IScrollInfo)this).VerticalOffset + 48);
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,MouseWheelLeft,The following statement contains a magic number: ((IScrollInfo)this).SetHorizontalOffset(((IScrollInfo)this).HorizontalOffset - 48);
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,MouseWheelRight,The following statement contains a magic number: ((IScrollInfo)this).SetHorizontalOffset(((IScrollInfo)this).HorizontalOffset + 48);
Magic Number,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,MouseWheelUp,The following statement contains a magic number: ((IScrollInfo)this).SetVerticalOffset(((IScrollInfo)this).VerticalOffset - 48);
Magic Number,System.Windows.Controls.Primitives,ExpandableContentControl,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\ExpandableContentControl.cs,ArrangeOverride,The following statement contains a magic number: if (child == null || Math.Abs(Percentage) < 0.0001)                  return finalSize;
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,Insert,The following statement contains a magic number: if (depth <= PriorityQuadTree<T>.MaxTreeDepth && (bounds.Width > 0 || bounds.Height > 0))                  {                      double w = _bounds.Width / 2;                      double h = _bounds.Height / 2;                        // assumption that the Rect struct is almost as fast as doing the operations                      // manually since Rect is a value type.                      Rect topLeft = new Rect(_bounds.Left' _bounds.Top' w' h);                      Rect topRight = new Rect(_bounds.Left + w' _bounds.Top' w' h);                      Rect bottomLeft = new Rect(_bounds.Left' _bounds.Top + h' w' h);                      Rect bottomRight = new Rect(_bounds.Left + w' _bounds.Top + h' w' h);                        // See if any child quadrants completely contain this node.                      if (topLeft.Contains(bounds))                      {                          if (_topLeft == null)                          {                              _topLeft = new Quadrant(topLeft);                          }                          child = _topLeft;                      }                      else if (topRight.Contains(bounds))                      {                          if (_topRight == null)                          {                              _topRight = new Quadrant(topRight);                          }                          child = _topRight;                      }                      else if (bottomLeft.Contains(bounds))                      {                          if (_bottomLeft == null)                          {                              _bottomLeft = new Quadrant(bottomLeft);                          }                          child = _bottomLeft;                      }                      else if (bottomRight.Contains(bounds))                      {                          if (_bottomRight == null)                          {                              _bottomRight = new Quadrant(bottomRight);                          }                          child = _bottomRight;                      }                  }
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,Insert,The following statement contains a magic number: if (depth <= PriorityQuadTree<T>.MaxTreeDepth && (bounds.Width > 0 || bounds.Height > 0))                  {                      double w = _bounds.Width / 2;                      double h = _bounds.Height / 2;                        // assumption that the Rect struct is almost as fast as doing the operations                      // manually since Rect is a value type.                      Rect topLeft = new Rect(_bounds.Left' _bounds.Top' w' h);                      Rect topRight = new Rect(_bounds.Left + w' _bounds.Top' w' h);                      Rect bottomLeft = new Rect(_bounds.Left' _bounds.Top + h' w' h);                      Rect bottomRight = new Rect(_bounds.Left + w' _bounds.Top + h' w' h);                        // See if any child quadrants completely contain this node.                      if (topLeft.Contains(bounds))                      {                          if (_topLeft == null)                          {                              _topLeft = new Quadrant(topLeft);                          }                          child = _topLeft;                      }                      else if (topRight.Contains(bounds))                      {                          if (_topRight == null)                          {                              _topRight = new Quadrant(topRight);                          }                          child = _topRight;                      }                      else if (bottomLeft.Contains(bounds))                      {                          if (_bottomLeft == null)                          {                              _bottomLeft = new Quadrant(bottomLeft);                          }                          child = _bottomLeft;                      }                      else if (bottomRight.Contains(bounds))                      {                          if (_bottomRight == null)                          {                              _bottomRight = new Quadrant(bottomRight);                          }                          child = _bottomRight;                      }                  }
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,Remove,The following statement contains a magic number: if (RemoveNode(node))                  {                      nodeRemoved = true;                  }                  else                  {                      double w = _bounds.Width / 2;                      double h = _bounds.Height / 2;                        // assumption that the Rect struct is almost as fast as doing the operations                      // manually since Rect is a value type.                      Rect topLeft = new Rect(_bounds.Left' _bounds.Top' w' h);                      Rect topRight = new Rect(_bounds.Left + w' _bounds.Top' w' h);                      Rect bottomLeft = new Rect(_bounds.Left' _bounds.Top + h' w' h);                      Rect bottomRight = new Rect(_bounds.Left + w' _bounds.Top + h' w' h);                        if (_topLeft != null && topLeft.Intersects(bounds) && _topLeft.Remove(node' bounds))                      {                          if (_topLeft._count == 0)                          {                              _topLeft = null;                          }                            nodeRemoved = true;                      }                      else if (_topRight != null && topRight.Intersects(bounds) && _topRight.Remove(node' bounds))                      {                          if (_topRight._count == 0)                          {                              _topRight = null;                          }                            nodeRemoved = true;                      }                      else if (_bottomLeft != null && bottomLeft.Intersects(bounds) && _bottomLeft.Remove(node' bounds))                      {                          if (_bottomLeft._count == 0)                          {                              _bottomLeft = null;                          }                            nodeRemoved = true;                      }                      else if (_bottomRight != null && bottomRight.Intersects(bounds) && _bottomRight.Remove(node' bounds))                      {                          if (_bottomRight._count == 0)                          {                              _bottomRight = null;                          }                            nodeRemoved = true;                      }                  }
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,Remove,The following statement contains a magic number: if (RemoveNode(node))                  {                      nodeRemoved = true;                  }                  else                  {                      double w = _bounds.Width / 2;                      double h = _bounds.Height / 2;                        // assumption that the Rect struct is almost as fast as doing the operations                      // manually since Rect is a value type.                      Rect topLeft = new Rect(_bounds.Left' _bounds.Top' w' h);                      Rect topRight = new Rect(_bounds.Left + w' _bounds.Top' w' h);                      Rect bottomLeft = new Rect(_bounds.Left' _bounds.Top + h' w' h);                      Rect bottomRight = new Rect(_bounds.Left + w' _bounds.Top + h' w' h);                        if (_topLeft != null && topLeft.Intersects(bounds) && _topLeft.Remove(node' bounds))                      {                          if (_topLeft._count == 0)                          {                              _topLeft = null;                          }                            nodeRemoved = true;                      }                      else if (_topRight != null && topRight.Intersects(bounds) && _topRight.Remove(node' bounds))                      {                          if (_topRight._count == 0)                          {                              _topRight = null;                          }                            nodeRemoved = true;                      }                      else if (_bottomLeft != null && bottomLeft.Intersects(bounds) && _bottomLeft.Remove(node' bounds))                      {                          if (_bottomLeft._count == 0)                          {                              _bottomLeft = null;                          }                            nodeRemoved = true;                      }                      else if (_bottomRight != null && bottomRight.Intersects(bounds) && _bottomRight.Remove(node' bounds))                      {                          if (_bottomRight._count == 0)                          {                              _bottomRight = null;                          }                            nodeRemoved = true;                      }                  }
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,GetNodesIntersecting,The following statement contains a magic number: double w = _bounds.Width / 2;
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,GetNodesIntersecting,The following statement contains a magic number: double h = _bounds.Height / 2;
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,GetNodesInside,The following statement contains a magic number: double w = _bounds.Width / 2;
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,GetNodesInside,The following statement contains a magic number: double h = _bounds.Height / 2;
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,HasNodesInside,The following statement contains a magic number: double w = _bounds.Width / 2;
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,HasNodesInside,The following statement contains a magic number: double h = _bounds.Height / 2;
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,HasNodesIntersecting,The following statement contains a magic number: double w = _bounds.Width / 2;
Magic Number,System.Collections.Generic,Quadrant,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\PriorityQuadTree.cs,HasNodesIntersecting,The following statement contains a magic number: double h = _bounds.Height / 2;
Missing Default,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      try                      {                          _isIgnoringSelectedIndicesChanges = true;                          for (int i = 0; i < SelectedIndices.Count; i++)                          {                              if (SelectedIndices[i] >=                                  e.NewStartingIndex)                              {                                  // add a value of one                                  SelectedIndices[i] = SelectedIndices[i] + 1;                              }                          }                      }                      finally                      {                          _isIgnoringSelectedIndicesChanges = false;                      }                        if (SelectedIndex >= e.NewStartingIndex && SelectedIndex > -1)                      {                          SelectedIndex++;                      }                        // now add the item' will also add indice at correct position.                      if (SelectedItem == null && IsMinimumOneSelected)                      {                          if (!SelectedItems.OfType<object>().Contains(e.NewItems[0]))                          {                              SelectedItems.Add(e.NewItems[0]);                          }                          SelectedItem = e.NewItems[0];                      }                      break;                  case NotifyCollectionChangedAction.Reset:                      {                          _isIgnoringSelectedIndicesChanges = true;                          _isIgnoringSelectedItemsChanges = true;                          try                          {                              // Items has been cleared.                              // so clear selecteditems as well                              SelectedItems.Clear();                              SelectedIndices.Clear();                              SelectedItem = null;                              SelectedIndex = -1;                          }                          finally                          {                              _isIgnoringSelectedIndicesChanges = false;                              _isIgnoringSelectedItemsChanges = false;                          }                            // we receive this action when an itemssource is set                          InitializeNewItemsSource();                      }                  break;                  case NotifyCollectionChangedAction.Remove:                      {                          int index = e.OldStartingIndex;                          object item = e.OldItems[0];                            try                          {                              _isIgnoringSelectedIndicesChanges = true;                                if (SelectedIndices.Contains(index))                              {                                  SelectedIndices.Remove(index);                              }                              for (int i = 0; i < SelectedIndices.Count; i++)                              {                                  if (SelectedIndices[i] > index)                                  {                                      // lower the value by one                                      SelectedIndices[i] = SelectedIndices[i] - 1;                                  }                              }                          }                          finally                          {                              _isIgnoringSelectedIndicesChanges = false;                          }                            try                          {                              _isIgnoringSelectedItemsChanges = true;                                if (SelectedItems.Contains(item))                              {                                  // check that there are no indices pointing to similar                                  // items that are still in the collection                                  if (SelectedIndices.Count(i => i < Items.Count && Items[i].Equals(item)) == 0)                                  {                                      SelectedItems.Remove(item);                                  }                              }                          }                          finally                          {                              _isIgnoringSelectedItemsChanges = false;                          }                            if (SelectedIndex == index)                          {                              // that item is no longer in the Items collection                              // so the index is incorrect as well                              SelectedIndex = -1;                          }                          if (SelectedIndex > e.OldStartingIndex && SelectedIndex > -1)                          {                              SelectedIndex -= 1;                          }                      }                      break;              }
Missing Default,System.Windows.Controls,Accordion,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\Accordion.cs,SetPanelOrientation,The following switch statement is missing a default case: switch (ExpandDirection)                  {                      case ExpandDirection.Down:                      case ExpandDirection.Up:                          panel.HorizontalAlignment = HorizontalAlignment.Stretch;                          panel.VerticalAlignment = ExpandDirection == ExpandDirection.Down ? VerticalAlignment.Top : VerticalAlignment.Bottom;                          panel.Orientation = Orientation.Vertical;                          break;                      case ExpandDirection.Left:                      case ExpandDirection.Right:                          panel.VerticalAlignment = VerticalAlignment.Stretch;                          panel.HorizontalAlignment = ExpandDirection == ExpandDirection.Left ? HorizontalAlignment.Right : HorizontalAlignment.Left;                          panel.Orientation = Orientation.Horizontal;                          break;                  }
Missing Default,System.Windows.Controls,AccordionItem,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnKeyDown,The following switch statement is missing a default case: switch (ExpandDirection)              {                  case ExpandDirection.Down:                      if ((isSelected && e.Key == Key.Up) || (!isSelected && e.Key == Key.Down))                      {                          IsSelected = !isSelected;                      }                      break;                  case ExpandDirection.Up:                      if ((isSelected && e.Key == Key.Down) || (!isSelected && e.Key == Key.Up))                      {                          IsSelected = !isSelected;                      }                      break;                  case ExpandDirection.Left:                      if ((isSelected && e.Key == Key.Right) || (!isSelected && e.Key == Key.Left))                      {                          IsSelected = !isSelected;                      }                      break;                  case ExpandDirection.Right:                      if ((isSelected && e.Key == Key.Left) || (!isSelected && e.Key == Key.Right))                      {                          IsSelected = !isSelected;                      }                      break;              }
Missing Default,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,CoerceScale,The following switch statement is missing a default case: switch (canvas.Stretch)                          {                              case Stretch.Uniform:                                  scale = Math.Min(renderSize.Width / viewbox.Width' renderSize.Height / viewbox.Height);                                  break;                                case Stretch.UniformToFill:                                  scale = Math.Max(renderSize.Width / viewbox.Width' renderSize.Height / viewbox.Height);                                  break;                          }
Missing Default,System.Windows.Controls,ZoomableCanvas,C:\repos\dotnetprojects_wpftoolkit\WpfToolkit\Layout\ZoomableCanvas\ZoomableCanvas.cs,CoerceScale,The following switch statement is missing a default case: switch (canvas.StretchDirection)                          {                              case StretchDirection.DownOnly:                                  scale = scale.AtMost((double)value);                                  break;                                case StretchDirection.UpOnly:                                  scale = scale.AtLeast((double)value);                                  break;                          }
