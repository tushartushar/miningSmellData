Implementation smell,Namespace,Class,File,Method,Description
Long Method,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The method has 110 lines of code.
Long Method,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The method has 103 lines of code.
Complex Method,MetalSoft.Model,SeedSection,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSection.cs,QuickSort,Cyclomatic complexity of the method is 9
Complex Method,MetalSoft.Model,SeedSection,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSection.cs,QuickSortX,Cyclomatic complexity of the method is 9
Complex Method,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,Cyclomatic complexity of the method is 11
Complex Method,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,DiscreteLenght,Cyclomatic complexity of the method is 8
Complex Method,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Slice,Cyclomatic complexity of the method is 10
Complex Method,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateSeed,Cyclomatic complexity of the method is 8
Complex Method,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateCircuit,Cyclomatic complexity of the method is 12
Complex Method,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,Cyclomatic complexity of the method is 8
Complex Method,MetalSoft.Model.Generator,CellularAutomaton,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\CellularAutomaton.cs,Run,Cyclomatic complexity of the method is 19
Complex Method,MetalSoft.Model.Generator,CellularAutomaton,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\CellularAutomaton.cs,Moor,Cyclomatic complexity of the method is 13
Complex Method,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,MatchToSegments,Cyclomatic complexity of the method is 10
Complex Method,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointPath,Cyclomatic complexity of the method is 8
Complex Method,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection3,Cyclomatic complexity of the method is 16
Complex Method,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,Cyclomatic complexity of the method is 21
Complex Method,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,Cyclomatic complexity of the method is 18
Complex Method,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,Fill,Cyclomatic complexity of the method is 16
Complex Method,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,Cyclomatic complexity of the method is 11
Complex Method,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertax2,Cyclomatic complexity of the method is 11
Complex Method,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertaxToTxtWithColor,Cyclomatic complexity of the method is 9
Complex Method,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertaxToTxtWithID,Cyclomatic complexity of the method is 9
Complex Method,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,Cyclomatic complexity of the method is 8
Complex Method,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,Cyclomatic complexity of the method is 8
Complex Method,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,Cyclomatic complexity of the method is 9
Long Parameter List,MetalSoft.Model.Generator,Point3D,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,Point3D,The method has 6 parameters.
Long Parameter List,MetalSoft.Model.Generator,Point3D,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,Point3D,The method has 7 parameters.
Long Parameter List,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillSection,The method has 6 parameters.
Long Parameter List,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The method has 17 parameters.
Long Parameter List,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertax2,The method has 5 parameters.
Long Parameter List,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertaxToTxtWithColor,The method has 5 parameters.
Long Parameter List,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertaxToTxtWithID,The method has 5 parameters.
Long Statement,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The length of the statement  "			double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5))); " is 136.
Long Statement,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateSeed,The length of the statement  "		if (nx >= 0 && nx < w && ny >= 0 && ny < h && _sliceBitmap.GetPixel (my.X + 1' my.Y) == colorKey && _mask [my.X + 1' my.Y] == true) { " is 133.
Long Statement,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateSeed,The length of the statement  "			if (nx >= 0 && nx < w && ny >= 0 && ny < h && _sliceBitmap.GetPixel (my.X - 1' my.Y) == colorKey && _mask [my.X - 1' my.Y] == true) { " is 133.
Long Statement,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateSeed,The length of the statement  "				if (nx >= 0 && nx < w && ny >= 0 && ny < h && _sliceBitmap.GetPixel (my.X' my.Y + 1) == colorKey && _mask [my.X' my.Y + 1] == true) { " is 133.
Long Statement,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateSeed,The length of the statement  "					if (nx >= 0 && nx < w && ny >= 0 && ny < h && _sliceBitmap.GetPixel (my.X' my.Y - 1) == colorKey && _mask [my.X' my.Y - 1] == true) { " is 133.
Long Statement,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The length of the statement  "			List<Point> crossXright = circuit.Where ((p => p.Y == point_y && p.X > point_x)).DistinctBy (p => p.X).Select (p => p).ToList (); " is 129.
Long Statement,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The length of the statement  "			List<Point> crossXleft = circuit.Where ((p => p.Y == point_y && p.X < point_x)).DistinctBy (p => p.X).Select (p => p).ToList (); " is 128.
Long Statement,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The length of the statement  "			List<Point> crossYup = circuit.Where ((p => p.X == point_x && p.Y < point_y)).DistinctBy (p => p.Y).Select (p => p).ToList (); " is 126.
Long Statement,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The length of the statement  "			List<Point> crossYdown = circuit.Where ((p => p.X == point_x && p.Y > point_y)).DistinctBy (p => p.Y).Select (p => p).ToList (); " is 128.
Long Statement,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertax,The length of the statement  "			line = p.X.ToString () + " " + p.Y.ToString () + " " + p.Z.ToString () + " " + p.R.ToString () + " " + p.G.ToString () + " " + p.B.ToString (); " is 143.
Long Statement,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertax2,The length of the statement  "					line = p.X.ToString () + " " + p.Y.ToString () + " " + p.Z.ToString () + " " + p.R.ToString () + " " + p.G.ToString () + " " + p.B.ToString (); " is 143.
Long Statement,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertaxToTxtWithColor,The length of the statement  "					line = p.X.ToString () + " " + p.Y.ToString () + " " + p.Z.ToString () + " " + p.R.ToString () + " " + p.G.ToString () + " " + p.B.ToString (); " is 143.
Complex Conditional,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateSeed,The conditional expression  "nx >= 0 && nx < w && ny >= 0 && ny < h && _sliceBitmap.GetPixel (my.X + 1' my.Y) == colorKey && _mask [my.X + 1' my.Y] == true"  is complex.
Complex Conditional,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateSeed,The conditional expression  "nx >= 0 && nx < w && ny >= 0 && ny < h && _sliceBitmap.GetPixel (my.X - 1' my.Y) == colorKey && _mask [my.X - 1' my.Y] == true"  is complex.
Complex Conditional,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateSeed,The conditional expression  "nx >= 0 && nx < w && ny >= 0 && ny < h && _sliceBitmap.GetPixel (my.X' my.Y + 1) == colorKey && _mask [my.X' my.Y + 1] == true"  is complex.
Complex Conditional,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateSeed,The conditional expression  "nx >= 0 && nx < w && ny >= 0 && ny < h && _sliceBitmap.GetPixel (my.X' my.Y - 1) == colorKey && _mask [my.X' my.Y - 1] == true"  is complex.
Complex Conditional,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The conditional expression  "x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c"  is complex.
Complex Conditional,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The conditional expression  "x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c"  is complex.
Complex Conditional,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The conditional expression  "x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c"  is complex.
Complex Conditional,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The conditional expression  "(x != a.X && y != a.Y) || (x != b.X && y != b.Y)"  is complex.
Complex Conditional,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The conditional expression  "(x != a.X && y != a.Y) || (x != b.X && y != b.Y)"  is complex.
Complex Conditional,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The conditional expression  "(x != a.X && y != a.Y) || (x != b.X && y != b.Y)"  is complex.
Complex Conditional,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The conditional expression  "(crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)"  is complex.
Complex Conditional,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The conditional expression  "(crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)"  is complex.
Magic Number,MetalSoft,MatchingControl,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\MatchingControl.xaml.cs,MatchingControl,The following statement contains a magic number: thicknessRed = new Thickness (3);  
Magic Number,MetalSoft,MatchingControl,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\MatchingControl.xaml.cs,MatchingControl,The following statement contains a magic number: thicknessRed = new Thickness (3);  
Magic Number,MetalSoft.Model,Helper,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Helper.cs,SaveLayerAsBmp,The following statement contains a magic number: for (int z = 0; z < 11; z++) {  	Bitmap bm = new Bitmap (200' 200);  	using (Graphics g = Graphics.FromImage (bm)) {  		g.Clear (Color.White);  	}  	for (int x = 0; x < 200; x++)  		for (int y = 0; y < 200; y++) {  			Point3D p = points [x' y' z];  			bm.SetPixel (x' y' Color.FromArgb (p.R' p.G' p.B));  		}  	bm.Save (z.ToString () + ".bmp");  }  
Magic Number,MetalSoft.Model,Helper,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Helper.cs,SaveLayerAsBmp,The following statement contains a magic number: for (int z = 0; z < 11; z++) {  	Bitmap bm = new Bitmap (200' 200);  	using (Graphics g = Graphics.FromImage (bm)) {  		g.Clear (Color.White);  	}  	for (int x = 0; x < 200; x++)  		for (int y = 0; y < 200; y++) {  			Point3D p = points [x' y' z];  			bm.SetPixel (x' y' Color.FromArgb (p.R' p.G' p.B));  		}  	bm.Save (z.ToString () + ".bmp");  }  
Magic Number,MetalSoft.Model,Helper,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Helper.cs,SaveLayerAsBmp,The following statement contains a magic number: for (int z = 0; z < 11; z++) {  	Bitmap bm = new Bitmap (200' 200);  	using (Graphics g = Graphics.FromImage (bm)) {  		g.Clear (Color.White);  	}  	for (int x = 0; x < 200; x++)  		for (int y = 0; y < 200; y++) {  			Point3D p = points [x' y' z];  			bm.SetPixel (x' y' Color.FromArgb (p.R' p.G' p.B));  		}  	bm.Save (z.ToString () + ".bmp");  }  
Magic Number,MetalSoft.Model,Helper,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Helper.cs,SaveLayerAsBmp,The following statement contains a magic number: for (int z = 0; z < 11; z++) {  	Bitmap bm = new Bitmap (200' 200);  	using (Graphics g = Graphics.FromImage (bm)) {  		g.Clear (Color.White);  	}  	for (int x = 0; x < 200; x++)  		for (int y = 0; y < 200; y++) {  			Point3D p = points [x' y' z];  			bm.SetPixel (x' y' Color.FromArgb (p.R' p.G' p.B));  		}  	bm.Save (z.ToString () + ".bmp");  }  
Magic Number,MetalSoft.Model,Helper,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Helper.cs,SaveLayerAsBmp,The following statement contains a magic number: for (int z = 0; z < 11; z++) {  	Bitmap bm = new Bitmap (200' 200);  	using (Graphics g = Graphics.FromImage (bm)) {  		g.Clear (Color.White);  	}  	for (int x = 0; x < 200; x++)  		for (int y = 0; y < 200; y++) {  			Point3D p = points [x' y' z];  			bm.SetPixel (x' y' Color.FromArgb (p.R' p.G' p.B));  		}  	bm.Save (z.ToString () + ".bmp");  }  
Magic Number,MetalSoft.Model,Helper,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Helper.cs,SaveLayerAsBmp,The following statement contains a magic number: for (int x = 0; x < 200; x++)  	for (int y = 0; y < 200; y++) {  		Point3D p = points [x' y' z];  		bm.SetPixel (x' y' Color.FromArgb (p.R' p.G' p.B));  	}  
Magic Number,MetalSoft.Model,Helper,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Helper.cs,SaveLayerAsBmp,The following statement contains a magic number: for (int x = 0; x < 200; x++)  	for (int y = 0; y < 200; y++) {  		Point3D p = points [x' y' z];  		bm.SetPixel (x' y' Color.FromArgb (p.R' p.G' p.B));  	}  
Magic Number,MetalSoft.Model,Helper,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Helper.cs,SaveLayerAsBmp,The following statement contains a magic number: for (int y = 0; y < 200; y++) {  	Point3D p = points [x' y' z];  	bm.SetPixel (x' y' Color.FromArgb (p.R' p.G' p.B));  }  
Magic Number,MetalSoft.Model,SeedSection,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSection.cs,QuickSort,The following statement contains a magic number: x = items [(left + right) / 2];  
Magic Number,MetalSoft.Model,SeedSection,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSection.cs,QuickSortX,The following statement contains a magic number: x = items [(left + right) / 2];  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int j = 0; j < top.SeedCount; j++) {  	// porównujemy z kazdym który pozostał na dolenej warstwie  	for (int k = 0; k < bottom.SeedCount; k++) {  		//wyliczamy różnice między segmentami  		for (int s = 0; s < top.GetSeed (j).Segments.Count && s < bottom.GetSeed (k).Segments.Count; s++)  			diff.Add (Math.Abs (top.GetSeed (j).Segments [s] - bottom.GetSeed (k).Segments [s]));  		// obliczamy odchylenie standardowe różnic  		double average = diff.Sum () / diff.Count;  		double variation = 0;  		for (int d = 0; d < diff.Count; d++) {  			variation += Math.Pow (diff [d] - average' 2);  		}  		variation /= (diff.Count - 1);  		stdDeviation.Add (Math.Sqrt (variation));  		diff.Clear ();  	}  	SeedSectionContainer container = new SeedSectionContainer ();  	container.Pattern = top.GetSeed (j);  	//Add(top.GetSeed(j));  	seedContainer.Add (container);  	// nie zostało dodane zadne odchylenie' poniewaz wszystkie ziarna z warstwy dolnej zostaly juz dopasowane  	// dlatego nalezy przejsc do nastepnego - co powinno sie powtarzac dla wszystkich pozostalych zianrach na  	// warstwie gornej  	if (stdDeviation.Count == 0)  		continue;  	// wybieramy najmniejsze odchylenie standardowe  	double minStdDev = stdDeviation [0];  	int indexMinStdDec = 0;  	bool swaped = false;  	ShapeFactor f1 = new ShapeFactor (top.GetSeed (j));  	PointF a = f1.Centroid ();  	PointF b = new PointF ();  	int maxSegmentTop = top.GetSeed (j).MaxSegment;  	int maxSegmentBottomLast = 0;  	double discreteLast = 0;  	for (int sd = 0; sd < stdDeviation.Count; sd++) {  		ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  		b = f2.Centroid ();  		int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  		double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  		//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  		//{  		//}  		if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  			minStdDev = stdDeviation [sd];  			indexMinStdDec = sd;  			discreteLast = discreteLenght;  			maxSegmentBottomLast = maxSegmentBottom;  			swaped = true;  		}  	}  	// łączymy ziarno z górnej warstwy z ziarnem z dolnej  	if (swaped) {  		//cont.Add(bottom.GetSeed(indexMinStdDec));  		container.Matched = bottom.GetSeed (indexMinStdDec);  		container.a = a;  		container.b = b;  		container.discreteLenght = discreteLast;  		container.maxTop = maxSegmentTop;  		container.maxBottom = maxSegmentBottomLast;  		// usuwamy ziarno z dolnej warstwy  		bottom.RemoveSeed (indexMinStdDec);  	}  	// czyscimy listy do analizy kolejnej pary  	diff.Clear ();  	stdDeviation.Clear ();  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int j = 0; j < top.SeedCount; j++) {  	// porównujemy z kazdym który pozostał na dolenej warstwie  	for (int k = 0; k < bottom.SeedCount; k++) {  		//wyliczamy różnice między segmentami  		for (int s = 0; s < top.GetSeed (j).Segments.Count && s < bottom.GetSeed (k).Segments.Count; s++)  			diff.Add (Math.Abs (top.GetSeed (j).Segments [s] - bottom.GetSeed (k).Segments [s]));  		// obliczamy odchylenie standardowe różnic  		double average = diff.Sum () / diff.Count;  		double variation = 0;  		for (int d = 0; d < diff.Count; d++) {  			variation += Math.Pow (diff [d] - average' 2);  		}  		variation /= (diff.Count - 1);  		stdDeviation.Add (Math.Sqrt (variation));  		diff.Clear ();  	}  	SeedSectionContainer container = new SeedSectionContainer ();  	container.Pattern = top.GetSeed (j);  	//Add(top.GetSeed(j));  	seedContainer.Add (container);  	// nie zostało dodane zadne odchylenie' poniewaz wszystkie ziarna z warstwy dolnej zostaly juz dopasowane  	// dlatego nalezy przejsc do nastepnego - co powinno sie powtarzac dla wszystkich pozostalych zianrach na  	// warstwie gornej  	if (stdDeviation.Count == 0)  		continue;  	// wybieramy najmniejsze odchylenie standardowe  	double minStdDev = stdDeviation [0];  	int indexMinStdDec = 0;  	bool swaped = false;  	ShapeFactor f1 = new ShapeFactor (top.GetSeed (j));  	PointF a = f1.Centroid ();  	PointF b = new PointF ();  	int maxSegmentTop = top.GetSeed (j).MaxSegment;  	int maxSegmentBottomLast = 0;  	double discreteLast = 0;  	for (int sd = 0; sd < stdDeviation.Count; sd++) {  		ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  		b = f2.Centroid ();  		int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  		double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  		//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  		//{  		//}  		if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  			minStdDev = stdDeviation [sd];  			indexMinStdDec = sd;  			discreteLast = discreteLenght;  			maxSegmentBottomLast = maxSegmentBottom;  			swaped = true;  		}  	}  	// łączymy ziarno z górnej warstwy z ziarnem z dolnej  	if (swaped) {  		//cont.Add(bottom.GetSeed(indexMinStdDec));  		container.Matched = bottom.GetSeed (indexMinStdDec);  		container.a = a;  		container.b = b;  		container.discreteLenght = discreteLast;  		container.maxTop = maxSegmentTop;  		container.maxBottom = maxSegmentBottomLast;  		// usuwamy ziarno z dolnej warstwy  		bottom.RemoveSeed (indexMinStdDec);  	}  	// czyscimy listy do analizy kolejnej pary  	diff.Clear ();  	stdDeviation.Clear ();  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int j = 0; j < top.SeedCount; j++) {  	// porównujemy z kazdym który pozostał na dolenej warstwie  	for (int k = 0; k < bottom.SeedCount; k++) {  		//wyliczamy różnice między segmentami  		for (int s = 0; s < top.GetSeed (j).Segments.Count && s < bottom.GetSeed (k).Segments.Count; s++)  			diff.Add (Math.Abs (top.GetSeed (j).Segments [s] - bottom.GetSeed (k).Segments [s]));  		// obliczamy odchylenie standardowe różnic  		double average = diff.Sum () / diff.Count;  		double variation = 0;  		for (int d = 0; d < diff.Count; d++) {  			variation += Math.Pow (diff [d] - average' 2);  		}  		variation /= (diff.Count - 1);  		stdDeviation.Add (Math.Sqrt (variation));  		diff.Clear ();  	}  	SeedSectionContainer container = new SeedSectionContainer ();  	container.Pattern = top.GetSeed (j);  	//Add(top.GetSeed(j));  	seedContainer.Add (container);  	// nie zostało dodane zadne odchylenie' poniewaz wszystkie ziarna z warstwy dolnej zostaly juz dopasowane  	// dlatego nalezy przejsc do nastepnego - co powinno sie powtarzac dla wszystkich pozostalych zianrach na  	// warstwie gornej  	if (stdDeviation.Count == 0)  		continue;  	// wybieramy najmniejsze odchylenie standardowe  	double minStdDev = stdDeviation [0];  	int indexMinStdDec = 0;  	bool swaped = false;  	ShapeFactor f1 = new ShapeFactor (top.GetSeed (j));  	PointF a = f1.Centroid ();  	PointF b = new PointF ();  	int maxSegmentTop = top.GetSeed (j).MaxSegment;  	int maxSegmentBottomLast = 0;  	double discreteLast = 0;  	for (int sd = 0; sd < stdDeviation.Count; sd++) {  		ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  		b = f2.Centroid ();  		int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  		double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  		//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  		//{  		//}  		if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  			minStdDev = stdDeviation [sd];  			indexMinStdDec = sd;  			discreteLast = discreteLenght;  			maxSegmentBottomLast = maxSegmentBottom;  			swaped = true;  		}  	}  	// łączymy ziarno z górnej warstwy z ziarnem z dolnej  	if (swaped) {  		//cont.Add(bottom.GetSeed(indexMinStdDec));  		container.Matched = bottom.GetSeed (indexMinStdDec);  		container.a = a;  		container.b = b;  		container.discreteLenght = discreteLast;  		container.maxTop = maxSegmentTop;  		container.maxBottom = maxSegmentBottomLast;  		// usuwamy ziarno z dolnej warstwy  		bottom.RemoveSeed (indexMinStdDec);  	}  	// czyscimy listy do analizy kolejnej pary  	diff.Clear ();  	stdDeviation.Clear ();  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int j = 0; j < top.SeedCount; j++) {  	// porównujemy z kazdym który pozostał na dolenej warstwie  	for (int k = 0; k < bottom.SeedCount; k++) {  		//wyliczamy różnice między segmentami  		for (int s = 0; s < top.GetSeed (j).Segments.Count && s < bottom.GetSeed (k).Segments.Count; s++)  			diff.Add (Math.Abs (top.GetSeed (j).Segments [s] - bottom.GetSeed (k).Segments [s]));  		// obliczamy odchylenie standardowe różnic  		double average = diff.Sum () / diff.Count;  		double variation = 0;  		for (int d = 0; d < diff.Count; d++) {  			variation += Math.Pow (diff [d] - average' 2);  		}  		variation /= (diff.Count - 1);  		stdDeviation.Add (Math.Sqrt (variation));  		diff.Clear ();  	}  	SeedSectionContainer container = new SeedSectionContainer ();  	container.Pattern = top.GetSeed (j);  	//Add(top.GetSeed(j));  	seedContainer.Add (container);  	// nie zostało dodane zadne odchylenie' poniewaz wszystkie ziarna z warstwy dolnej zostaly juz dopasowane  	// dlatego nalezy przejsc do nastepnego - co powinno sie powtarzac dla wszystkich pozostalych zianrach na  	// warstwie gornej  	if (stdDeviation.Count == 0)  		continue;  	// wybieramy najmniejsze odchylenie standardowe  	double minStdDev = stdDeviation [0];  	int indexMinStdDec = 0;  	bool swaped = false;  	ShapeFactor f1 = new ShapeFactor (top.GetSeed (j));  	PointF a = f1.Centroid ();  	PointF b = new PointF ();  	int maxSegmentTop = top.GetSeed (j).MaxSegment;  	int maxSegmentBottomLast = 0;  	double discreteLast = 0;  	for (int sd = 0; sd < stdDeviation.Count; sd++) {  		ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  		b = f2.Centroid ();  		int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  		double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  		//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  		//{  		//}  		if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  			minStdDev = stdDeviation [sd];  			indexMinStdDec = sd;  			discreteLast = discreteLenght;  			maxSegmentBottomLast = maxSegmentBottom;  			swaped = true;  		}  	}  	// łączymy ziarno z górnej warstwy z ziarnem z dolnej  	if (swaped) {  		//cont.Add(bottom.GetSeed(indexMinStdDec));  		container.Matched = bottom.GetSeed (indexMinStdDec);  		container.a = a;  		container.b = b;  		container.discreteLenght = discreteLast;  		container.maxTop = maxSegmentTop;  		container.maxBottom = maxSegmentBottomLast;  		// usuwamy ziarno z dolnej warstwy  		bottom.RemoveSeed (indexMinStdDec);  	}  	// czyscimy listy do analizy kolejnej pary  	diff.Clear ();  	stdDeviation.Clear ();  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int j = 0; j < top.SeedCount; j++) {  	// porównujemy z kazdym który pozostał na dolenej warstwie  	for (int k = 0; k < bottom.SeedCount; k++) {  		//wyliczamy różnice między segmentami  		for (int s = 0; s < top.GetSeed (j).Segments.Count && s < bottom.GetSeed (k).Segments.Count; s++)  			diff.Add (Math.Abs (top.GetSeed (j).Segments [s] - bottom.GetSeed (k).Segments [s]));  		// obliczamy odchylenie standardowe różnic  		double average = diff.Sum () / diff.Count;  		double variation = 0;  		for (int d = 0; d < diff.Count; d++) {  			variation += Math.Pow (diff [d] - average' 2);  		}  		variation /= (diff.Count - 1);  		stdDeviation.Add (Math.Sqrt (variation));  		diff.Clear ();  	}  	SeedSectionContainer container = new SeedSectionContainer ();  	container.Pattern = top.GetSeed (j);  	//Add(top.GetSeed(j));  	seedContainer.Add (container);  	// nie zostało dodane zadne odchylenie' poniewaz wszystkie ziarna z warstwy dolnej zostaly juz dopasowane  	// dlatego nalezy przejsc do nastepnego - co powinno sie powtarzac dla wszystkich pozostalych zianrach na  	// warstwie gornej  	if (stdDeviation.Count == 0)  		continue;  	// wybieramy najmniejsze odchylenie standardowe  	double minStdDev = stdDeviation [0];  	int indexMinStdDec = 0;  	bool swaped = false;  	ShapeFactor f1 = new ShapeFactor (top.GetSeed (j));  	PointF a = f1.Centroid ();  	PointF b = new PointF ();  	int maxSegmentTop = top.GetSeed (j).MaxSegment;  	int maxSegmentBottomLast = 0;  	double discreteLast = 0;  	for (int sd = 0; sd < stdDeviation.Count; sd++) {  		ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  		b = f2.Centroid ();  		int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  		double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  		//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  		//{  		//}  		if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  			minStdDev = stdDeviation [sd];  			indexMinStdDec = sd;  			discreteLast = discreteLenght;  			maxSegmentBottomLast = maxSegmentBottom;  			swaped = true;  		}  	}  	// łączymy ziarno z górnej warstwy z ziarnem z dolnej  	if (swaped) {  		//cont.Add(bottom.GetSeed(indexMinStdDec));  		container.Matched = bottom.GetSeed (indexMinStdDec);  		container.a = a;  		container.b = b;  		container.discreteLenght = discreteLast;  		container.maxTop = maxSegmentTop;  		container.maxBottom = maxSegmentBottomLast;  		// usuwamy ziarno z dolnej warstwy  		bottom.RemoveSeed (indexMinStdDec);  	}  	// czyscimy listy do analizy kolejnej pary  	diff.Clear ();  	stdDeviation.Clear ();  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int j = 0; j < top.SeedCount; j++) {  	// porównujemy z kazdym który pozostał na dolenej warstwie  	for (int k = 0; k < bottom.SeedCount; k++) {  		//wyliczamy różnice między segmentami  		for (int s = 0; s < top.GetSeed (j).Segments.Count && s < bottom.GetSeed (k).Segments.Count; s++)  			diff.Add (Math.Abs (top.GetSeed (j).Segments [s] - bottom.GetSeed (k).Segments [s]));  		// obliczamy odchylenie standardowe różnic  		double average = diff.Sum () / diff.Count;  		double variation = 0;  		for (int d = 0; d < diff.Count; d++) {  			variation += Math.Pow (diff [d] - average' 2);  		}  		variation /= (diff.Count - 1);  		stdDeviation.Add (Math.Sqrt (variation));  		diff.Clear ();  	}  	SeedSectionContainer container = new SeedSectionContainer ();  	container.Pattern = top.GetSeed (j);  	//Add(top.GetSeed(j));  	seedContainer.Add (container);  	// nie zostało dodane zadne odchylenie' poniewaz wszystkie ziarna z warstwy dolnej zostaly juz dopasowane  	// dlatego nalezy przejsc do nastepnego - co powinno sie powtarzac dla wszystkich pozostalych zianrach na  	// warstwie gornej  	if (stdDeviation.Count == 0)  		continue;  	// wybieramy najmniejsze odchylenie standardowe  	double minStdDev = stdDeviation [0];  	int indexMinStdDec = 0;  	bool swaped = false;  	ShapeFactor f1 = new ShapeFactor (top.GetSeed (j));  	PointF a = f1.Centroid ();  	PointF b = new PointF ();  	int maxSegmentTop = top.GetSeed (j).MaxSegment;  	int maxSegmentBottomLast = 0;  	double discreteLast = 0;  	for (int sd = 0; sd < stdDeviation.Count; sd++) {  		ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  		b = f2.Centroid ();  		int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  		double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  		//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  		//{  		//}  		if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  			minStdDev = stdDeviation [sd];  			indexMinStdDec = sd;  			discreteLast = discreteLenght;  			maxSegmentBottomLast = maxSegmentBottom;  			swaped = true;  		}  	}  	// łączymy ziarno z górnej warstwy z ziarnem z dolnej  	if (swaped) {  		//cont.Add(bottom.GetSeed(indexMinStdDec));  		container.Matched = bottom.GetSeed (indexMinStdDec);  		container.a = a;  		container.b = b;  		container.discreteLenght = discreteLast;  		container.maxTop = maxSegmentTop;  		container.maxBottom = maxSegmentBottomLast;  		// usuwamy ziarno z dolnej warstwy  		bottom.RemoveSeed (indexMinStdDec);  	}  	// czyscimy listy do analizy kolejnej pary  	diff.Clear ();  	stdDeviation.Clear ();  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int k = 0; k < bottom.SeedCount; k++) {  	//wyliczamy różnice między segmentami  	for (int s = 0; s < top.GetSeed (j).Segments.Count && s < bottom.GetSeed (k).Segments.Count; s++)  		diff.Add (Math.Abs (top.GetSeed (j).Segments [s] - bottom.GetSeed (k).Segments [s]));  	// obliczamy odchylenie standardowe różnic  	double average = diff.Sum () / diff.Count;  	double variation = 0;  	for (int d = 0; d < diff.Count; d++) {  		variation += Math.Pow (diff [d] - average' 2);  	}  	variation /= (diff.Count - 1);  	stdDeviation.Add (Math.Sqrt (variation));  	diff.Clear ();  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int d = 0; d < diff.Count; d++) {  	variation += Math.Pow (diff [d] - average' 2);  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: variation += Math.Pow (diff [d] - average' 2);  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int sd = 0; sd < stdDeviation.Count; sd++) {  	ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  	b = f2.Centroid ();  	int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  	double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  	//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  	//{  	//}  	if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  		minStdDev = stdDeviation [sd];  		indexMinStdDec = sd;  		discreteLast = discreteLenght;  		maxSegmentBottomLast = maxSegmentBottom;  		swaped = true;  	}  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int sd = 0; sd < stdDeviation.Count; sd++) {  	ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  	b = f2.Centroid ();  	int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  	double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  	//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  	//{  	//}  	if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  		minStdDev = stdDeviation [sd];  		indexMinStdDec = sd;  		discreteLast = discreteLenght;  		maxSegmentBottomLast = maxSegmentBottom;  		swaped = true;  	}  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int sd = 0; sd < stdDeviation.Count; sd++) {  	ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  	b = f2.Centroid ();  	int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  	double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  	//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  	//{  	//}  	if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  		minStdDev = stdDeviation [sd];  		indexMinStdDec = sd;  		discreteLast = discreteLenght;  		maxSegmentBottomLast = maxSegmentBottom;  		swaped = true;  	}  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int sd = 0; sd < stdDeviation.Count; sd++) {  	ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  	b = f2.Centroid ();  	int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  	double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  	//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  	//{  	//}  	if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  		minStdDev = stdDeviation [sd];  		indexMinStdDec = sd;  		discreteLast = discreteLenght;  		maxSegmentBottomLast = maxSegmentBottom;  		swaped = true;  	}  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: for (int sd = 0; sd < stdDeviation.Count; sd++) {  	ShapeFactor f2 = new ShapeFactor (bottom.GetSeed (sd));  	b = f2.Centroid ();  	int maxSegmentBottom = bottom.GetSeed (sd).MaxSegment;  	double discreteLenght = DiscreteLenght (new Point ((int)(a.X + 0.5)' (int)(a.Y + 0.5))' new Point ((int)(b.X + 0.5)' (int)(b.Y + 0.5)));  	//if (discreteLenght > ((maxSegmentBottom + maxSegmentTop) / 2) && stdDeviation[sd] < minStdDev)  	//{  	//}  	if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  		minStdDev = stdDeviation [sd];  		indexMinStdDec = sd;  		discreteLast = discreteLenght;  		maxSegmentBottomLast = maxSegmentBottom;  		swaped = true;  	}  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,ConnectSeedSection,The following statement contains a magic number: if (stdDeviation [sd] <= minStdDev && discreteLenght <= ((maxSegmentTop + maxSegmentBottom) / 2)) {  	minStdDev = stdDeviation [sd];  	indexMinStdDec = sd;  	discreteLast = discreteLenght;  	maxSegmentBottomLast = maxSegmentBottom;  	swaped = true;  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,DiscreteLenght,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		cout++;  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		cout++;  	}  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,DiscreteLenght,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		cout++;  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		cout++;  	}  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,DiscreteLenght,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		cout++;  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		cout++;  	}  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,DiscreteLenght,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		cout++;  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		cout++;  	}  }  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,DiscreteLenght,The following statement contains a magic number: ai = (dy - dx) * 2;  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,DiscreteLenght,The following statement contains a magic number: bi = dy * 2;  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,DiscreteLenght,The following statement contains a magic number: ai = (dx - dy) * 2;  
Magic Number,MetalSoft.Model,SeedSectionConnector,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\SeedSectionConnector.cs,DiscreteLenght,The following statement contains a magic number: bi = dx * 2;  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,MalinowskiejFactor,The following statement contains a magic number: return ((double)_seed.EdgeCount / (2 * Math.Sqrt (Math.PI * _seed.PointsCount))) - 1.0;  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,Cyrkularnosci1Factor,The following statement contains a magic number: return 2.0 * Math.Sqrt ((double)_seed.PointsCount / Math.PI);  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,BlairaBlissaFactor,The following statement contains a magic number: for (int i = 0; i < _pointsCount; i++)  	sumLength += Math.Pow (SegmentLenght (_seed.GetPoint (i)' centroid)' 2);  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,BlairaBlissaFactor,The following statement contains a magic number: sumLength += Math.Pow (SegmentLenght (_seed.GetPoint (i)' centroid)' 2);  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,BlairaBlissaFactor,The following statement contains a magic number: return (double)_pointsCount / Math.Sqrt (2.0 * Math.PI * sumLength);  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,HaralickaFactror,The following statement contains a magic number: for (int i = 0; i < _circuitCount; i++) {  	sum += SegmentLenght (_seed.GetCircuitPoint (i)' centroid);  	sum2 += Math.Pow (SegmentLenght (_seed.GetCircuitPoint (i)' centroid)' 2);  }  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,HaralickaFactror,The following statement contains a magic number: sum2 += Math.Pow (SegmentLenght (_seed.GetCircuitPoint (i)' centroid)' 2);  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,MzFactor,The following statement contains a magic number: return (double)2.0 * Math.Sqrt (Math.PI * _pointsCount) / _seed.EdgeCount;  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,SegmentLenght,The following statement contains a magic number: return Math.Sqrt (Math.Pow (b.X - a.X' 2) + Math.Pow (b.Y - b.Y' 2));  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,SegmentLenght,The following statement contains a magic number: return Math.Sqrt (Math.Pow (b.X - a.X' 2) + Math.Pow (b.Y - b.Y' 2));  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,SegmentLenght,The following statement contains a magic number: return Math.Sqrt (Math.Pow (b.X - a.X' 2) + Math.Pow (b.Y - b.Y' 2));  
Magic Number,MetalSoft.Model,ShapeFactor,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\ShapeFactor.cs,SegmentLenght,The following statement contains a magic number: return Math.Sqrt (Math.Pow (b.X - a.X' 2) + Math.Pow (b.Y - b.Y' 2));  
Magic Number,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateInterPoints,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int xi = (int)(x0 + (r * Math.Cos ((2 * Math.PI * i) / n)));  	int yi = (int)(y0 + (r * Math.Sin ((2 * Math.PI * i) / n)));  	_interPoints.Add (new Point (xi' yi));  	double seg = Lenght (new Point (x0' y0)' new Point (xi' yi)' _sliceBitmap' _sliceBitmap.GetPixel (x' y));  	segment.Add (seg);  	if (seg > segmentMax)  		segmentMax = seg;  }  
Magic Number,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateInterPoints,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int xi = (int)(x0 + (r * Math.Cos ((2 * Math.PI * i) / n)));  	int yi = (int)(y0 + (r * Math.Sin ((2 * Math.PI * i) / n)));  	_interPoints.Add (new Point (xi' yi));  	double seg = Lenght (new Point (x0' y0)' new Point (xi' yi)' _sliceBitmap' _sliceBitmap.GetPixel (x' y));  	segment.Add (seg);  	if (seg > segmentMax)  		segmentMax = seg;  }  
Magic Number,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		if (x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c)  			cout++;  		else  			return cout;  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		if (x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c)  			cout++;  		else  			return cout;  	}  }  
Magic Number,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		if (x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c)  			cout++;  		else  			return cout;  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		if (x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c)  			cout++;  		else  			return cout;  	}  }  
Magic Number,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		if (x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c)  			cout++;  		else  			return cout;  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		if (x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c)  			cout++;  		else  			return cout;  	}  }  
Magic Number,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		if (x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c)  			cout++;  		else  			return cout;  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		if (x >= 0 && x < img.Width && y >= 0 && y < img.Height && img.GetPixel (x' y) == c)  			cout++;  		else  			return cout;  	}  }  
Magic Number,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The following statement contains a magic number: ai = (dy - dx) * 2;  
Magic Number,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The following statement contains a magic number: bi = dy * 2;  
Magic Number,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The following statement contains a magic number: ai = (dx - dy) * 2;  
Magic Number,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,Lenght,The following statement contains a magic number: bi = dx * 2;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: if (x >= 0 && y >= 0)  	Quarter = 1;  else if (x <= 0 && y >= 0)  	Quarter = 2;  else if (x <= 0 && y <= 0)  	Quarter = 3;  else if (x >= 0 && y <= 0)  	Quarter = 4;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: if (x >= 0 && y >= 0)  	Quarter = 1;  else if (x <= 0 && y >= 0)  	Quarter = 2;  else if (x <= 0 && y <= 0)  	Quarter = 3;  else if (x >= 0 && y <= 0)  	Quarter = 4;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: if (x >= 0 && y >= 0)  	Quarter = 1;  else if (x <= 0 && y >= 0)  	Quarter = 2;  else if (x <= 0 && y <= 0)  	Quarter = 3;  else if (x >= 0 && y <= 0)  	Quarter = 4;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: if (x <= 0 && y >= 0)  	Quarter = 2;  else if (x <= 0 && y <= 0)  	Quarter = 3;  else if (x >= 0 && y <= 0)  	Quarter = 4;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: if (x <= 0 && y >= 0)  	Quarter = 2;  else if (x <= 0 && y <= 0)  	Quarter = 3;  else if (x >= 0 && y <= 0)  	Quarter = 4;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: if (x <= 0 && y >= 0)  	Quarter = 2;  else if (x <= 0 && y <= 0)  	Quarter = 3;  else if (x >= 0 && y <= 0)  	Quarter = 4;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: Quarter = 2;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: if (x <= 0 && y <= 0)  	Quarter = 3;  else if (x >= 0 && y <= 0)  	Quarter = 4;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: if (x <= 0 && y <= 0)  	Quarter = 3;  else if (x >= 0 && y <= 0)  	Quarter = 4;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: Quarter = 3;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: if (x >= 0 && y <= 0)  	Quarter = 4;  
Magic Number,MetalSoft.Model.Generator,CirclePoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,CirclePoint,The following statement contains a magic number: Quarter = 4;  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointConnectionGenerator,The following statement contains a magic number: for (int i = 0; i < pointCount; i++) {  	double x = r * Math.Cos (2 * Math.PI * i / pointCount) + 0.5;  	double y = r * Math.Sin (2 * Math.PI * i / pointCount) + 0.5;  	topPoints [i] = new CirclePoint (i' (int)x' (int)y);  	bottomPoints [i] = new CirclePoint (i' (int)x' (int)y);  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointConnectionGenerator,The following statement contains a magic number: for (int i = 0; i < pointCount; i++) {  	double x = r * Math.Cos (2 * Math.PI * i / pointCount) + 0.5;  	double y = r * Math.Sin (2 * Math.PI * i / pointCount) + 0.5;  	topPoints [i] = new CirclePoint (i' (int)x' (int)y);  	bottomPoints [i] = new CirclePoint (i' (int)x' (int)y);  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointConnectionGenerator,The following statement contains a magic number: for (int i = 0; i < pointCount; i++) {  	double x = r * Math.Cos (2 * Math.PI * i / pointCount) + 0.5;  	double y = r * Math.Sin (2 * Math.PI * i / pointCount) + 0.5;  	topPoints [i] = new CirclePoint (i' (int)x' (int)y);  	bottomPoints [i] = new CirclePoint (i' (int)x' (int)y);  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointConnectionGenerator,The following statement contains a magic number: for (int i = 0; i < pointCount; i++) {  	double x = r * Math.Cos (2 * Math.PI * i / pointCount) + 0.5;  	double y = r * Math.Sin (2 * Math.PI * i / pointCount) + 0.5;  	topPoints [i] = new CirclePoint (i' (int)x' (int)y);  	bottomPoints [i] = new CirclePoint (i' (int)x' (int)y);  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointPath,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		//cout++;  		points.Add (new Point (x' y));  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		//cout++;  		points.Add (new Point (x' y));  	}  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointPath,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		//cout++;  		points.Add (new Point (x' y));  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		//cout++;  		points.Add (new Point (x' y));  	}  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointPath,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		//cout++;  		points.Add (new Point (x' y));  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		//cout++;  		points.Add (new Point (x' y));  	}  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointPath,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		//cout++;  		points.Add (new Point (x' y));  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		//cout++;  		points.Add (new Point (x' y));  	}  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointPath,The following statement contains a magic number: ai = (dy - dx) * 2;  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointPath,The following statement contains a magic number: bi = dy * 2;  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointPath,The following statement contains a magic number: ai = (dx - dy) * 2;  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,PointPath,The following statement contains a magic number: bi = dx * 2;  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,FindMatched,The following statement contains a magic number: foreach (Point p in path) {  	Point[] tab = new Point[4];  	tab [0] = new Point (p.X - 1' p.Y - 1);  	tab [1] = new Point (p.X + 1' p.Y - 1);  	tab [2] = new Point (p.X - 1' p.Y + 1);  	tab [3] = new Point (p.X + 1' p.Y + 1);  	for (int i = 0; i < 4; i++) {  		if (circuit.Contains (tab [i])) {  			matching = false;  			result = tab [i];  			break;  		}  	}  	if (!matching)  		break;  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,FindMatched,The following statement contains a magic number: foreach (Point p in path) {  	Point[] tab = new Point[4];  	tab [0] = new Point (p.X - 1' p.Y - 1);  	tab [1] = new Point (p.X + 1' p.Y - 1);  	tab [2] = new Point (p.X - 1' p.Y + 1);  	tab [3] = new Point (p.X + 1' p.Y + 1);  	for (int i = 0; i < 4; i++) {  		if (circuit.Contains (tab [i])) {  			matching = false;  			result = tab [i];  			break;  		}  	}  	if (!matching)  		break;  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,FindMatched,The following statement contains a magic number: foreach (Point p in path) {  	Point[] tab = new Point[4];  	tab [0] = new Point (p.X - 1' p.Y - 1);  	tab [1] = new Point (p.X + 1' p.Y - 1);  	tab [2] = new Point (p.X - 1' p.Y + 1);  	tab [3] = new Point (p.X + 1' p.Y + 1);  	for (int i = 0; i < 4; i++) {  		if (circuit.Contains (tab [i])) {  			matching = false;  			result = tab [i];  			break;  		}  	}  	if (!matching)  		break;  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,FindMatched,The following statement contains a magic number: foreach (Point p in path) {  	Point[] tab = new Point[4];  	tab [0] = new Point (p.X - 1' p.Y - 1);  	tab [1] = new Point (p.X + 1' p.Y - 1);  	tab [2] = new Point (p.X - 1' p.Y + 1);  	tab [3] = new Point (p.X + 1' p.Y + 1);  	for (int i = 0; i < 4; i++) {  		if (circuit.Contains (tab [i])) {  			matching = false;  			result = tab [i];  			break;  		}  	}  	if (!matching)  		break;  }  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,FindMatched,The following statement contains a magic number: tab [2] = new Point (p.X - 1' p.Y + 1);  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,FindMatched,The following statement contains a magic number: tab [3] = new Point (p.X + 1' p.Y + 1);  
Magic Number,MetalSoft.Model.Generator,PointConnectionGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PointConnectionGenerator.cs,FindMatched,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (circuit.Contains (tab [i])) {  		matching = false;  		result = tab [i];  		break;  	}  }  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y >= 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI);  else if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y >= 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI);  else if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y >= 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI);  else if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y >= 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI);  else if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y >= 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI);  else if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y >= 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI);  else if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y >= 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI);  else if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y >= 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI);  else if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y >= 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI);  else if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: Fi = Math.Atan (y / x) * (180 / Math.PI);  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x > 0 && y < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  else if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: Fi = Math.Atan (y / x) * (180 / Math.PI) + 360;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x < 0)  	Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  else if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: Fi = Math.Atan (y / x) * (180 / Math.PI) + 180;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x == 0 && y > 0)  	Fi = 90;  else if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: Fi = 90;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: if (x == 0 && y < 0)  	Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,PolarPoint,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateFromCartesian,The following statement contains a magic number: Fi = 3 * 180 / 2;  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection3,The following statement contains a magic number: for (int i = 0; i < top.CircuitCount; i++) {  	Point temp = top.GetCircuitPoint (i);  	topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection3,The following statement contains a magic number: for (int i = 0; i < top.CircuitCount; i++) {  	Point temp = top.GetCircuitPoint (i);  	topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection3,The following statement contains a magic number: topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection3,The following statement contains a magic number: topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection3,The following statement contains a magic number: for (int i = 0; i < bottom.CircuitCount; i++) {  	Point temp = bottom.GetCircuitPoint (i);  	bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection3,The following statement contains a magic number: for (int i = 0; i < bottom.CircuitCount; i++) {  	Point temp = bottom.GetCircuitPoint (i);  	bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection3,The following statement contains a magic number: bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection3,The following statement contains a magic number: bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int s = 0; s < seeds.Count - 1; s++) {  	top = seeds [s];  	bottom = seeds [s + 1];  	PointF topConetroid' bottomCentroid;  	//Point centroid = new Point(0' 0);  	List<Point> topCircuit' bottomCircuit;  	List<Point> topPoints' bottomPoints;  	ShapeFactor sf = new ShapeFactor (top);  	topConetroid = sf.Centroid ();  	sf = new ShapeFactor (bottom);  	bottomCentroid = sf.Centroid ();  	// przesuwamy współrzedne do wspólnego środka (0'0)  	topCircuit = new List<Point> ();  	for (int i = 0; i < top.CircuitCount; i++) {  		Point temp = top.GetCircuitPoint (i);  		topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  	}  	bottomCircuit = new List<Point> ();  	for (int i = 0; i < bottom.CircuitCount; i++) {  		Point temp = bottom.GetCircuitPoint (i);  		bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  	}  	// kolejkujemy punkty na obwodzie  	int startTop = GetStartIndex (topCircuit);  	int startBottom = GetStartIndex (bottomCircuit);  	topPoints = new List<Point> ();  	bottomPoints = new List<Point> ();  	for (int i = startTop; i < topCircuit.Count; i++)  		topPoints.Add (top.GetCircuitPoint (i));  	for (int i = 0; i < startTop; i++)  		topPoints.Add (top.GetCircuitPoint (i));  	for (int i = startBottom; i < bottomCircuit.Count; i++)  		bottomPoints.Add (bottom.GetCircuitPoint (i));  	for (int i = 0; i < startBottom; i++)  		bottomPoints.Add (bottom.GetCircuitPoint (i));  	top.OrderCircuit = topPoints;  	bottom.OrderCircuit = bottomPoints;  	// wyliczamy progi indexów dla top i botton  	double thresholdTop = 0;  	double thresholdBottom = 0;  	//List<Point> less' more;  	if (topPoints.Count > bottomPoints.Count) {  		thresholdTop = (double)topCircuit.Count / bottomPoints.Count;  		thresholdBottom = 1;  	}  	else {  		thresholdBottom = (double)bottomPoints.Count / topPoints.Count;  		thresholdTop = 1;  	}  	List<Connection> conn = new List<Connection> ();  	int topIndex = 0;  	int bottomIndex = 0;  	double topSum = 0;  	double bottomSum = 0;  	while (topIndex < topPoints.Count && bottomIndex < bottomPoints.Count) {  		if (topPoints.Count > bottomPoints.Count) {  			if (topSum <= bottomSum + 1) {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  			}  			else {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				topSum += thresholdTop;  				topSum -= (int)thresholdTop;  				// -= 1  				bottomSum += thresholdBottom;  			}  		}  		else {  			if (bottomSum <= topSum + 1) {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  			}  			else {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  				bottomSum -= (int)thresholdBottom;  				// -=1  			}  		}  	}  	while (topIndex < topPoints.Count) {  		conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomPoints.Count - 1));  		topIndex++;  	}  	while (bottomIndex < bottomPoints.Count) {  		conn.Add (new Connection (lastSectionStart + topPoints.Count - 1' lastSectionStart + topPoints.Count + bottomIndex));  		bottomIndex++;  	}  	if (s == 0)  		AddToVertex (topPoints' s);  	lastSectionStart = vertex.Count;  	AddToVertex (bottomPoints' s + 1);  	connections.AddRange (conn);  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int s = 0; s < seeds.Count - 1; s++) {  	top = seeds [s];  	bottom = seeds [s + 1];  	PointF topConetroid' bottomCentroid;  	//Point centroid = new Point(0' 0);  	List<Point> topCircuit' bottomCircuit;  	List<Point> topPoints' bottomPoints;  	ShapeFactor sf = new ShapeFactor (top);  	topConetroid = sf.Centroid ();  	sf = new ShapeFactor (bottom);  	bottomCentroid = sf.Centroid ();  	// przesuwamy współrzedne do wspólnego środka (0'0)  	topCircuit = new List<Point> ();  	for (int i = 0; i < top.CircuitCount; i++) {  		Point temp = top.GetCircuitPoint (i);  		topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  	}  	bottomCircuit = new List<Point> ();  	for (int i = 0; i < bottom.CircuitCount; i++) {  		Point temp = bottom.GetCircuitPoint (i);  		bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  	}  	// kolejkujemy punkty na obwodzie  	int startTop = GetStartIndex (topCircuit);  	int startBottom = GetStartIndex (bottomCircuit);  	topPoints = new List<Point> ();  	bottomPoints = new List<Point> ();  	for (int i = startTop; i < topCircuit.Count; i++)  		topPoints.Add (top.GetCircuitPoint (i));  	for (int i = 0; i < startTop; i++)  		topPoints.Add (top.GetCircuitPoint (i));  	for (int i = startBottom; i < bottomCircuit.Count; i++)  		bottomPoints.Add (bottom.GetCircuitPoint (i));  	for (int i = 0; i < startBottom; i++)  		bottomPoints.Add (bottom.GetCircuitPoint (i));  	top.OrderCircuit = topPoints;  	bottom.OrderCircuit = bottomPoints;  	// wyliczamy progi indexów dla top i botton  	double thresholdTop = 0;  	double thresholdBottom = 0;  	//List<Point> less' more;  	if (topPoints.Count > bottomPoints.Count) {  		thresholdTop = (double)topCircuit.Count / bottomPoints.Count;  		thresholdBottom = 1;  	}  	else {  		thresholdBottom = (double)bottomPoints.Count / topPoints.Count;  		thresholdTop = 1;  	}  	List<Connection> conn = new List<Connection> ();  	int topIndex = 0;  	int bottomIndex = 0;  	double topSum = 0;  	double bottomSum = 0;  	while (topIndex < topPoints.Count && bottomIndex < bottomPoints.Count) {  		if (topPoints.Count > bottomPoints.Count) {  			if (topSum <= bottomSum + 1) {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  			}  			else {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				topSum += thresholdTop;  				topSum -= (int)thresholdTop;  				// -= 1  				bottomSum += thresholdBottom;  			}  		}  		else {  			if (bottomSum <= topSum + 1) {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  			}  			else {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  				bottomSum -= (int)thresholdBottom;  				// -=1  			}  		}  	}  	while (topIndex < topPoints.Count) {  		conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomPoints.Count - 1));  		topIndex++;  	}  	while (bottomIndex < bottomPoints.Count) {  		conn.Add (new Connection (lastSectionStart + topPoints.Count - 1' lastSectionStart + topPoints.Count + bottomIndex));  		bottomIndex++;  	}  	if (s == 0)  		AddToVertex (topPoints' s);  	lastSectionStart = vertex.Count;  	AddToVertex (bottomPoints' s + 1);  	connections.AddRange (conn);  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int s = 0; s < seeds.Count - 1; s++) {  	top = seeds [s];  	bottom = seeds [s + 1];  	PointF topConetroid' bottomCentroid;  	//Point centroid = new Point(0' 0);  	List<Point> topCircuit' bottomCircuit;  	List<Point> topPoints' bottomPoints;  	ShapeFactor sf = new ShapeFactor (top);  	topConetroid = sf.Centroid ();  	sf = new ShapeFactor (bottom);  	bottomCentroid = sf.Centroid ();  	// przesuwamy współrzedne do wspólnego środka (0'0)  	topCircuit = new List<Point> ();  	for (int i = 0; i < top.CircuitCount; i++) {  		Point temp = top.GetCircuitPoint (i);  		topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  	}  	bottomCircuit = new List<Point> ();  	for (int i = 0; i < bottom.CircuitCount; i++) {  		Point temp = bottom.GetCircuitPoint (i);  		bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  	}  	// kolejkujemy punkty na obwodzie  	int startTop = GetStartIndex (topCircuit);  	int startBottom = GetStartIndex (bottomCircuit);  	topPoints = new List<Point> ();  	bottomPoints = new List<Point> ();  	for (int i = startTop; i < topCircuit.Count; i++)  		topPoints.Add (top.GetCircuitPoint (i));  	for (int i = 0; i < startTop; i++)  		topPoints.Add (top.GetCircuitPoint (i));  	for (int i = startBottom; i < bottomCircuit.Count; i++)  		bottomPoints.Add (bottom.GetCircuitPoint (i));  	for (int i = 0; i < startBottom; i++)  		bottomPoints.Add (bottom.GetCircuitPoint (i));  	top.OrderCircuit = topPoints;  	bottom.OrderCircuit = bottomPoints;  	// wyliczamy progi indexów dla top i botton  	double thresholdTop = 0;  	double thresholdBottom = 0;  	//List<Point> less' more;  	if (topPoints.Count > bottomPoints.Count) {  		thresholdTop = (double)topCircuit.Count / bottomPoints.Count;  		thresholdBottom = 1;  	}  	else {  		thresholdBottom = (double)bottomPoints.Count / topPoints.Count;  		thresholdTop = 1;  	}  	List<Connection> conn = new List<Connection> ();  	int topIndex = 0;  	int bottomIndex = 0;  	double topSum = 0;  	double bottomSum = 0;  	while (topIndex < topPoints.Count && bottomIndex < bottomPoints.Count) {  		if (topPoints.Count > bottomPoints.Count) {  			if (topSum <= bottomSum + 1) {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  			}  			else {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				topSum += thresholdTop;  				topSum -= (int)thresholdTop;  				// -= 1  				bottomSum += thresholdBottom;  			}  		}  		else {  			if (bottomSum <= topSum + 1) {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  			}  			else {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  				bottomSum -= (int)thresholdBottom;  				// -=1  			}  		}  	}  	while (topIndex < topPoints.Count) {  		conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomPoints.Count - 1));  		topIndex++;  	}  	while (bottomIndex < bottomPoints.Count) {  		conn.Add (new Connection (lastSectionStart + topPoints.Count - 1' lastSectionStart + topPoints.Count + bottomIndex));  		bottomIndex++;  	}  	if (s == 0)  		AddToVertex (topPoints' s);  	lastSectionStart = vertex.Count;  	AddToVertex (bottomPoints' s + 1);  	connections.AddRange (conn);  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int s = 0; s < seeds.Count - 1; s++) {  	top = seeds [s];  	bottom = seeds [s + 1];  	PointF topConetroid' bottomCentroid;  	//Point centroid = new Point(0' 0);  	List<Point> topCircuit' bottomCircuit;  	List<Point> topPoints' bottomPoints;  	ShapeFactor sf = new ShapeFactor (top);  	topConetroid = sf.Centroid ();  	sf = new ShapeFactor (bottom);  	bottomCentroid = sf.Centroid ();  	// przesuwamy współrzedne do wspólnego środka (0'0)  	topCircuit = new List<Point> ();  	for (int i = 0; i < top.CircuitCount; i++) {  		Point temp = top.GetCircuitPoint (i);  		topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  	}  	bottomCircuit = new List<Point> ();  	for (int i = 0; i < bottom.CircuitCount; i++) {  		Point temp = bottom.GetCircuitPoint (i);  		bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  	}  	// kolejkujemy punkty na obwodzie  	int startTop = GetStartIndex (topCircuit);  	int startBottom = GetStartIndex (bottomCircuit);  	topPoints = new List<Point> ();  	bottomPoints = new List<Point> ();  	for (int i = startTop; i < topCircuit.Count; i++)  		topPoints.Add (top.GetCircuitPoint (i));  	for (int i = 0; i < startTop; i++)  		topPoints.Add (top.GetCircuitPoint (i));  	for (int i = startBottom; i < bottomCircuit.Count; i++)  		bottomPoints.Add (bottom.GetCircuitPoint (i));  	for (int i = 0; i < startBottom; i++)  		bottomPoints.Add (bottom.GetCircuitPoint (i));  	top.OrderCircuit = topPoints;  	bottom.OrderCircuit = bottomPoints;  	// wyliczamy progi indexów dla top i botton  	double thresholdTop = 0;  	double thresholdBottom = 0;  	//List<Point> less' more;  	if (topPoints.Count > bottomPoints.Count) {  		thresholdTop = (double)topCircuit.Count / bottomPoints.Count;  		thresholdBottom = 1;  	}  	else {  		thresholdBottom = (double)bottomPoints.Count / topPoints.Count;  		thresholdTop = 1;  	}  	List<Connection> conn = new List<Connection> ();  	int topIndex = 0;  	int bottomIndex = 0;  	double topSum = 0;  	double bottomSum = 0;  	while (topIndex < topPoints.Count && bottomIndex < bottomPoints.Count) {  		if (topPoints.Count > bottomPoints.Count) {  			if (topSum <= bottomSum + 1) {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  			}  			else {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				topSum += thresholdTop;  				topSum -= (int)thresholdTop;  				// -= 1  				bottomSum += thresholdBottom;  			}  		}  		else {  			if (bottomSum <= topSum + 1) {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				topIndex++;  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  			}  			else {  				conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomIndex));  				bottomIndex++;  				topSum += thresholdTop;  				bottomSum += thresholdBottom;  				bottomSum -= (int)thresholdBottom;  				// -=1  			}  		}  	}  	while (topIndex < topPoints.Count) {  		conn.Add (new Connection (lastSectionStart + topIndex' lastSectionStart + topPoints.Count + bottomPoints.Count - 1));  		topIndex++;  	}  	while (bottomIndex < bottomPoints.Count) {  		conn.Add (new Connection (lastSectionStart + topPoints.Count - 1' lastSectionStart + topPoints.Count + bottomIndex));  		bottomIndex++;  	}  	if (s == 0)  		AddToVertex (topPoints' s);  	lastSectionStart = vertex.Count;  	AddToVertex (bottomPoints' s + 1);  	connections.AddRange (conn);  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int i = 0; i < top.CircuitCount; i++) {  	Point temp = top.GetCircuitPoint (i);  	topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int i = 0; i < top.CircuitCount; i++) {  	Point temp = top.GetCircuitPoint (i);  	topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int i = 0; i < bottom.CircuitCount; i++) {  	Point temp = bottom.GetCircuitPoint (i);  	bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int i = 0; i < bottom.CircuitCount; i++) {  	Point temp = bottom.GetCircuitPoint (i);  	bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int i = 0; i < top.CircuitCount; i++) {  	Point temp = top.GetCircuitPoint (i);  	topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int i = 0; i < top.CircuitCount; i++) {  	Point temp = top.GetCircuitPoint (i);  	topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: topCircuit.Add (new Point ((int)(temp.X - topConetroid.X + 0.5)' (int)(temp.Y - topConetroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int i = 0; i < bottom.CircuitCount; i++) {  	Point temp = bottom.GetCircuitPoint (i);  	bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: for (int i = 0; i < bottom.CircuitCount; i++) {  	Point temp = bottom.GetCircuitPoint (i);  	bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,CreateLinearConnection4,The following statement contains a magic number: bottomCircuit.Add (new Point ((int)(temp.X - bottomCentroid.X + 0.5)' (int)(temp.Y - bottomCentroid.Y + 0.5)));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,AddToVertex,The following statement contains a magic number: foreach (Point p in v) {  	vertex.Add (new Point3D (p.X' p.Y' sliceIndex * 10));  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,AddToVertex,The following statement contains a magic number: vertex.Add (new Point3D (p.X' p.Y' sliceIndex * 10));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,Length,The following statement contains a magic number: return Math.Sqrt (Math.Pow (b.X - a.X' 2) + Math.Pow (b.Y - a.Y' 2));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,Length,The following statement contains a magic number: return Math.Sqrt (Math.Pow (b.X - a.X' 2) + Math.Pow (b.Y - a.Y' 2));  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		//if (x < bm.Width && x >= 0 && y < bm.Height && y >= 0)  		//    bm.SetPixel(x' y' c);  		if ((x != a.X && y != a.Y) || (x != b.X && y != b.Y))  			newPoint.Add (new Point (x' y));  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		//if (x < bm.Width && x >= 0 && y < bm.Height && y >= 0)  		//    bm.SetPixel(x' y' c);  		if ((x != a.X && y != a.Y) || (x != b.X && y != b.Y))  			newPoint.Add (new Point (x' y));  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		//if (x < bm.Width && x >= 0 && y < bm.Height && y >= 0)  		//    bm.SetPixel(x' y' c);  		if ((x != a.X && y != a.Y) || (x != b.X && y != b.Y))  			newPoint.Add (new Point (x' y));  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		//if (x < bm.Width && x >= 0 && y < bm.Height && y >= 0)  		//    bm.SetPixel(x' y' c);  		if ((x != a.X && y != a.Y) || (x != b.X && y != b.Y))  			newPoint.Add (new Point (x' y));  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		//if (x < bm.Width && x >= 0 && y < bm.Height && y >= 0)  		//    bm.SetPixel(x' y' c);  		if ((x != a.X && y != a.Y) || (x != b.X && y != b.Y))  			newPoint.Add (new Point (x' y));  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		//if (x < bm.Width && x >= 0 && y < bm.Height && y >= 0)  		//    bm.SetPixel(x' y' c);  		if ((x != a.X && y != a.Y) || (x != b.X && y != b.Y))  			newPoint.Add (new Point (x' y));  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The following statement contains a magic number: if (dx > dy) {  	ai = (dy - dx) * 2;  	bi = dy * 2;  	d = bi - dx;  	// pętla po kolejnych x  	while (x != b.X) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			x += xi;  		}  		//if (x < bm.Width && x >= 0 && y < bm.Height && y >= 0)  		//    bm.SetPixel(x' y' c);  		if ((x != a.X && y != a.Y) || (x != b.X && y != b.Y))  			newPoint.Add (new Point (x' y));  	}  }  // oś wiodąca OY  else {  	ai = (dx - dy) * 2;  	bi = dx * 2;  	d = bi - dy;  	// pętla po kolejnych y  	while (y != b.Y) {  		// test współczynnika  		if (d >= 0) {  			x += xi;  			y += yi;  			d += ai;  		}  		else {  			d += bi;  			y += yi;  		}  		//if (x < bm.Width && x >= 0 && y < bm.Height && y >= 0)  		//    bm.SetPixel(x' y' c);  		if ((x != a.X && y != a.Y) || (x != b.X && y != b.Y))  			newPoint.Add (new Point (x' y));  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The following statement contains a magic number: ai = (dy - dx) * 2;  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The following statement contains a magic number: bi = dy * 2;  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The following statement contains a magic number: ai = (dx - dy) * 2;  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,FillCircuitByBresenham,The following statement contains a magic number: bi = dx * 2;  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointFromLine,The following statement contains a magic number: return new Point3D ((int)(x + 0.5)' (int)(y + 0.5)' (int)z);  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointFromLine,The following statement contains a magic number: return new Point3D ((int)(x + 0.5)' (int)(y + 0.5)' (int)z);  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: for (int point_x = x_min; point_x <= x_max; point_x++)  	for (int point_y = y_min; point_y <= y_max; point_y++) {  		List<Point> crossXright = circuit.Where ((p => p.Y == point_y && p.X > point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  		List<Point> crossXleft = circuit.Where ((p => p.Y == point_y && p.X < point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  		List<Point> crossYup = circuit.Where ((p => p.X == point_x && p.Y < point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  		List<Point> crossYdown = circuit.Where ((p => p.X == point_x && p.Y > point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  		// jesli srodek ciezkosci znajduje sie w obiekcie  		if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  			if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  				result = new Point (point_x' point_y);  				return result;  			}  		}  	}  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: for (int point_x = x_min; point_x <= x_max; point_x++)  	for (int point_y = y_min; point_y <= y_max; point_y++) {  		List<Point> crossXright = circuit.Where ((p => p.Y == point_y && p.X > point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  		List<Point> crossXleft = circuit.Where ((p => p.Y == point_y && p.X < point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  		List<Point> crossYup = circuit.Where ((p => p.X == point_x && p.Y < point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  		List<Point> crossYdown = circuit.Where ((p => p.X == point_x && p.Y > point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  		// jesli srodek ciezkosci znajduje sie w obiekcie  		if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  			if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  				result = new Point (point_x' point_y);  				return result;  			}  		}  	}  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: for (int point_x = x_min; point_x <= x_max; point_x++)  	for (int point_y = y_min; point_y <= y_max; point_y++) {  		List<Point> crossXright = circuit.Where ((p => p.Y == point_y && p.X > point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  		List<Point> crossXleft = circuit.Where ((p => p.Y == point_y && p.X < point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  		List<Point> crossYup = circuit.Where ((p => p.X == point_x && p.Y < point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  		List<Point> crossYdown = circuit.Where ((p => p.X == point_x && p.Y > point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  		// jesli srodek ciezkosci znajduje sie w obiekcie  		if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  			if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  				result = new Point (point_x' point_y);  				return result;  			}  		}  	}  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: for (int point_x = x_min; point_x <= x_max; point_x++)  	for (int point_y = y_min; point_y <= y_max; point_y++) {  		List<Point> crossXright = circuit.Where ((p => p.Y == point_y && p.X > point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  		List<Point> crossXleft = circuit.Where ((p => p.Y == point_y && p.X < point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  		List<Point> crossYup = circuit.Where ((p => p.X == point_x && p.Y < point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  		List<Point> crossYdown = circuit.Where ((p => p.X == point_x && p.Y > point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  		// jesli srodek ciezkosci znajduje sie w obiekcie  		if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  			if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  				result = new Point (point_x' point_y);  				return result;  			}  		}  	}  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: for (int point_y = y_min; point_y <= y_max; point_y++) {  	List<Point> crossXright = circuit.Where ((p => p.Y == point_y && p.X > point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  	List<Point> crossXleft = circuit.Where ((p => p.Y == point_y && p.X < point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  	List<Point> crossYup = circuit.Where ((p => p.X == point_x && p.Y < point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  	List<Point> crossYdown = circuit.Where ((p => p.X == point_x && p.Y > point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  	// jesli srodek ciezkosci znajduje sie w obiekcie  	if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  		if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  			result = new Point (point_x' point_y);  			return result;  		}  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: for (int point_y = y_min; point_y <= y_max; point_y++) {  	List<Point> crossXright = circuit.Where ((p => p.Y == point_y && p.X > point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  	List<Point> crossXleft = circuit.Where ((p => p.Y == point_y && p.X < point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  	List<Point> crossYup = circuit.Where ((p => p.X == point_x && p.Y < point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  	List<Point> crossYdown = circuit.Where ((p => p.X == point_x && p.Y > point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  	// jesli srodek ciezkosci znajduje sie w obiekcie  	if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  		if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  			result = new Point (point_x' point_y);  			return result;  		}  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: for (int point_y = y_min; point_y <= y_max; point_y++) {  	List<Point> crossXright = circuit.Where ((p => p.Y == point_y && p.X > point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  	List<Point> crossXleft = circuit.Where ((p => p.Y == point_y && p.X < point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  	List<Point> crossYup = circuit.Where ((p => p.X == point_x && p.Y < point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  	List<Point> crossYdown = circuit.Where ((p => p.X == point_x && p.Y > point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  	// jesli srodek ciezkosci znajduje sie w obiekcie  	if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  		if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  			result = new Point (point_x' point_y);  			return result;  		}  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: for (int point_y = y_min; point_y <= y_max; point_y++) {  	List<Point> crossXright = circuit.Where ((p => p.Y == point_y && p.X > point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  	List<Point> crossXleft = circuit.Where ((p => p.Y == point_y && p.X < point_x)).DistinctBy (p => p.X).Select (p => p).ToList ();  	List<Point> crossYup = circuit.Where ((p => p.X == point_x && p.Y < point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  	List<Point> crossYdown = circuit.Where ((p => p.X == point_x && p.Y > point_y)).DistinctBy (p => p.Y).Select (p => p).ToList ();  	// jesli srodek ciezkosci znajduje sie w obiekcie  	if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  		if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  			result = new Point (point_x' point_y);  			return result;  		}  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  	if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  		result = new Point (point_x' point_y);  		return result;  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  	if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  		result = new Point (point_x' point_y);  		return result;  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  	if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  		result = new Point (point_x' point_y);  		return result;  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: if ((crossXright.Count > 0 && crossXright.Count % 2 == 1) && (crossXleft.Count > 0 && crossXleft.Count % 2 == 1)) {  	if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  		result = new Point (point_x' point_y);  		return result;  	}  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  	result = new Point (point_x' point_y);  	return result;  }  
Magic Number,MetalSoft.Model.Generator,Microstructure3DGenerator,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\Microstructure3DGenerator.cs,GetPointInside,The following statement contains a magic number: if ((crossYup.Count > 0 && crossYup.Count % 2 == 1) && (crossYdown.Count > 0 && crossYdown.Count % 2 == 1)) {  	result = new Point (point_x' point_y);  	return result;  }  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertax,The following statement contains a magic number: header [2] += vertax.Count;  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertax,The following statement contains a magic number: header [9] += 0;  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertax2,The following statement contains a magic number: header [2] += (maxX * maxY * maxZ).ToString ();  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertax2,The following statement contains a magic number: header [9] += 0;  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertax,The following statement contains a magic number: header [2] += vertax.Count;  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteVertax,The following statement contains a magic number: header [9] += 0;  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: header [2] += (vertax1.Count + vertax2.Count);  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: header [9] += (int)(connection.Length / 2);  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: header [9] += (int)(connection.Length / 2);  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: using (System.IO.StreamWriter file = new System.IO.StreamWriter (fileName)) {  	foreach (string s in header)  		file.WriteLine (s);  	string line;  	foreach (Point p in vertax1) {  		line = string.Empty;  		line = p.X.ToString () + " " + p.Y.ToString () + " 0 255 0 0";  		file.WriteLine (line);  	}  	foreach (Point p in vertax2) {  		line = string.Empty;  		line = p.X.ToString () + " " + p.Y.ToString () + " 10 0 255 0";  		file.WriteLine (line);  	}  	int offset = vertax1.Count;  	for (int i = 0; i < connection.Length / 2; i++) {  		line = string.Empty;  		line = connection [0' i] + " " + (connection [1' i] + offset) + " 0 0 255";  		file.WriteLine (line);  	}  }  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: for (int i = 0; i < connection.Length / 2; i++) {  	line = string.Empty;  	line = connection [0' i] + " " + (connection [1' i] + offset) + " 0 0 255";  	file.WriteLine (line);  }  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: header [2] += vertex.Count;  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: header [9] += connection.Count;  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: header [2] += (point1.Length + point2.Length);  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: header [9] += (int)(point1.Length);  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: header [2] += (s1.Circuit.Count + s2.Circuit.Count);  
Magic Number,MetalSoft.Model.Generator,PlyWriter,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Generator\PlyWriter.cs,WriteConnection,The following statement contains a magic number: header [9] += connectionCount;  
Missing Default,MetalSoft.Model,Slice,C:\repos\camillos_Microsructure3DReconstructor\MetalSoft\Model\Slice.cs,CreateCircuit,The following switch statement is missing a default case: switch (direction) {  case dir.straight: {  	tt.move ();  	lp.Add (new Point (tt.x' tt.y));  	edge++;  	break;  }  case dir.left: {  	tt.turnLeft ();  	//lp.Add(new Point(tt.x' tt.y));  	tt.move ();  	break;  }  case dir.right: {  	tt.turnRight ();  	edge++;  	break;  }  }  
