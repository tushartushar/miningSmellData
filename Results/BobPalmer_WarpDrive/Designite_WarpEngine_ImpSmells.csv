Implementation smell,Namespace,Class,File,Method,Description
Complex Method,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,Cyclomatic complexity of the method is 31
Complex Method,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,Cyclomatic complexity of the method is 15
Complex Method,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,Cyclomatic complexity of the method is 10
Long Statement,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The length of the statement  "		if ((FlightGlobals.ActiveVessel.orbit.eccentricity > 1) && (ElipMode == 0))//For Hyperbolic Orbits. Conserve angular momentum by making orbit.h constant. GMp=h^2' so semi-latus rectum must be constant as well.). " is 211.
Long Statement,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The length of the statement  "			Speed = Math.Sqrt (FlightGlobals.ActiveVessel.mainBody.gravParameter * ((2 / FlightGlobals.ActiveVessel.orbit.radius) - ((SemiLatusOriginal * FlightGlobals.ActiveVessel.mainBody.gravParameter) / (FlightGlobals.ActiveVessel.orbit.semiMajorAxis * OriginalMomentumSqr)))); " is 269.
Long Statement,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The length of the statement  "		if ((FlightGlobals.ActiveVessel.orbit.eccentricity <= 1) && (ElipMode == 1))// For Elliptical Orbits. Conserve Angular Momentum directly by altering state vectors " is 162.
Long Statement,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The length of the statement  "			if (((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 0.55) || ((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 1.75))// re-set variables when ratio between current ratio and original gets too far from 1 " is 248.
Long Statement,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The length of the statement  "	if (((FlightGlobals.ActiveVessel.orbit.eccentricity < 1) && (ElipMode == 0)) || ((FlightGlobals.ActiveVessel.orbit.eccentricity > 1) && (ElipMode == 1)) || (PreviousBodyName != FlightGlobals.currentMainBody)) " is 208.
Complex Conditional,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The conditional expression  "((FlightGlobals.ActiveVessel.orbit.eccentricity < 1) && (ElipMode == 0)) || ((FlightGlobals.ActiveVessel.orbit.eccentricity > 1) && (ElipMode == 1)) || (PreviousBodyName != FlightGlobals.currentMainBody)"  is complex.
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: if (v > 0) {  	double m;  	double sv;  	int sextant;  	double fract' vsf' mid1' mid2;  	m = l + l - v;  	sv = (v - m) / v;  	h *= 6.0;  	sextant = (int)h;  	fract = h - sextant;  	vsf = v * sv * fract;  	mid1 = m + vsf;  	mid2 = v - vsf;  	switch (sextant) {  	case 0:  		r = v;  		g = mid1;  		b = m;  		break;  	case 1:  		r = mid2;  		g = v;  		b = m;  		break;  	case 2:  		r = m;  		g = v;  		b = mid1;  		break;  	case 3:  		r = m;  		g = mid2;  		b = v;  		break;  	case 4:  		r = mid1;  		g = m;  		b = v;  		break;  	case 5:  		r = v;  		g = m;  		b = mid2;  		break;  	}  }  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: if (v > 0) {  	double m;  	double sv;  	int sextant;  	double fract' vsf' mid1' mid2;  	m = l + l - v;  	sv = (v - m) / v;  	h *= 6.0;  	sextant = (int)h;  	fract = h - sextant;  	vsf = v * sv * fract;  	mid1 = m + vsf;  	mid2 = v - vsf;  	switch (sextant) {  	case 0:  		r = v;  		g = mid1;  		b = m;  		break;  	case 1:  		r = mid2;  		g = v;  		b = m;  		break;  	case 2:  		r = m;  		g = v;  		b = mid1;  		break;  	case 3:  		r = m;  		g = mid2;  		b = v;  		break;  	case 4:  		r = mid1;  		g = m;  		b = v;  		break;  	case 5:  		r = v;  		g = m;  		b = mid2;  		break;  	}  }  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: if (v > 0) {  	double m;  	double sv;  	int sextant;  	double fract' vsf' mid1' mid2;  	m = l + l - v;  	sv = (v - m) / v;  	h *= 6.0;  	sextant = (int)h;  	fract = h - sextant;  	vsf = v * sv * fract;  	mid1 = m + vsf;  	mid2 = v - vsf;  	switch (sextant) {  	case 0:  		r = v;  		g = mid1;  		b = m;  		break;  	case 1:  		r = mid2;  		g = v;  		b = m;  		break;  	case 2:  		r = m;  		g = v;  		b = mid1;  		break;  	case 3:  		r = m;  		g = mid2;  		b = v;  		break;  	case 4:  		r = mid1;  		g = m;  		b = v;  		break;  	case 5:  		r = v;  		g = m;  		b = mid2;  		break;  	}  }  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: if (v > 0) {  	double m;  	double sv;  	int sextant;  	double fract' vsf' mid1' mid2;  	m = l + l - v;  	sv = (v - m) / v;  	h *= 6.0;  	sextant = (int)h;  	fract = h - sextant;  	vsf = v * sv * fract;  	mid1 = m + vsf;  	mid2 = v - vsf;  	switch (sextant) {  	case 0:  		r = v;  		g = mid1;  		b = m;  		break;  	case 1:  		r = mid2;  		g = v;  		b = m;  		break;  	case 2:  		r = m;  		g = v;  		b = mid1;  		break;  	case 3:  		r = m;  		g = mid2;  		b = v;  		break;  	case 4:  		r = mid1;  		g = m;  		b = v;  		break;  	case 5:  		r = v;  		g = m;  		b = mid2;  		break;  	}  }  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: if (v > 0) {  	double m;  	double sv;  	int sextant;  	double fract' vsf' mid1' mid2;  	m = l + l - v;  	sv = (v - m) / v;  	h *= 6.0;  	sextant = (int)h;  	fract = h - sextant;  	vsf = v * sv * fract;  	mid1 = m + vsf;  	mid2 = v - vsf;  	switch (sextant) {  	case 0:  		r = v;  		g = mid1;  		b = m;  		break;  	case 1:  		r = mid2;  		g = v;  		b = m;  		break;  	case 2:  		r = m;  		g = v;  		b = mid1;  		break;  	case 3:  		r = m;  		g = mid2;  		b = v;  		break;  	case 4:  		r = mid1;  		g = m;  		b = v;  		break;  	case 5:  		r = v;  		g = m;  		b = mid2;  		break;  	}  }  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: h *= 6.0;  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: switch (sextant) {  case 0:  	r = v;  	g = mid1;  	b = m;  	break;  case 1:  	r = mid2;  	g = v;  	b = m;  	break;  case 2:  	r = m;  	g = v;  	b = mid1;  	break;  case 3:  	r = m;  	g = mid2;  	b = v;  	break;  case 4:  	r = mid1;  	g = m;  	b = v;  	break;  case 5:  	r = v;  	g = m;  	b = mid2;  	break;  }  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: switch (sextant) {  case 0:  	r = v;  	g = mid1;  	b = m;  	break;  case 1:  	r = mid2;  	g = v;  	b = m;  	break;  case 2:  	r = m;  	g = v;  	b = mid1;  	break;  case 3:  	r = m;  	g = mid2;  	b = v;  	break;  case 4:  	r = mid1;  	g = m;  	b = v;  	break;  case 5:  	r = v;  	g = m;  	b = mid2;  	break;  }  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: switch (sextant) {  case 0:  	r = v;  	g = mid1;  	b = m;  	break;  case 1:  	r = mid2;  	g = v;  	b = m;  	break;  case 2:  	r = m;  	g = v;  	b = mid1;  	break;  case 3:  	r = m;  	g = mid2;  	b = v;  	break;  case 4:  	r = mid1;  	g = m;  	b = v;  	break;  case 5:  	r = v;  	g = m;  	b = mid2;  	break;  }  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: switch (sextant) {  case 0:  	r = v;  	g = mid1;  	b = m;  	break;  case 1:  	r = mid2;  	g = v;  	b = m;  	break;  case 2:  	r = m;  	g = v;  	b = mid1;  	break;  case 3:  	r = m;  	g = mid2;  	b = v;  	break;  case 4:  	r = mid1;  	g = m;  	b = v;  	break;  case 5:  	r = v;  	g = m;  	b = mid2;  	break;  }  
Magic Number,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: newRGB [2] = (float)b;  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: try {  	DeployAnimation [deployAnimationName].layer = 3;  	if (unfoldAnimationName != "")  		UnfoldAnimation [unfoldAnimationName].layer = 5;  	WarpAnimation [warpAnimationName].layer = 4;  	CheckBubbleDeployment (1000);  	base.OnStart (state);  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnStart - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: try {  	DeployAnimation [deployAnimationName].layer = 3;  	if (unfoldAnimationName != "")  		UnfoldAnimation [unfoldAnimationName].layer = 5;  	WarpAnimation [warpAnimationName].layer = 4;  	CheckBubbleDeployment (1000);  	base.OnStart (state);  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnStart - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: try {  	DeployAnimation [deployAnimationName].layer = 3;  	if (unfoldAnimationName != "")  		UnfoldAnimation [unfoldAnimationName].layer = 5;  	WarpAnimation [warpAnimationName].layer = 4;  	CheckBubbleDeployment (1000);  	base.OnStart (state);  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnStart - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: try {  	DeployAnimation [deployAnimationName].layer = 3;  	if (unfoldAnimationName != "")  		UnfoldAnimation [unfoldAnimationName].layer = 5;  	WarpAnimation [warpAnimationName].layer = 4;  	CheckBubbleDeployment (1000);  	base.OnStart (state);  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnStart - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: DeployAnimation [deployAnimationName].layer = 3;  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: if (unfoldAnimationName != "")  	UnfoldAnimation [unfoldAnimationName].layer = 5;  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: UnfoldAnimation [unfoldAnimationName].layer = 5;  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: WarpAnimation [warpAnimationName].layer = 4;  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: CheckBubbleDeployment (1000);  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnLoad,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	CheckBubbleDeployment (1000);  	if (AMConservationMode == true) {  		ConservationMode = "A.Momentum";  	}  	if (AMConservationMode == false) {  		ConservationMode = "Velocity";  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnLoad - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnLoad,The following statement contains a magic number: CheckBubbleDeployment (1000);  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,CheckAltitude,The following statement contains a magic number: if (FlightGlobals.currentMainBody != null) {  	var altCutoff = FlightGlobals.currentMainBody.Radius * MinAltitude;  	if (vessel.altitude < altCutoff) {  		status = "failsafe: " + Math.Round (altCutoff / 1000' 0) + "km";  		return false;  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,CheckAltitude,The following statement contains a magic number: if (vessel.altitude < altCutoff) {  	status = "failsafe: " + Math.Round (altCutoff / 1000' 0) + "km";  	return false;  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,CheckAltitude,The following statement contains a magic number: status = "failsafe: " + Math.Round (altCutoff / 1000' 0) + "km";  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try {  	if (!HighLogic.LoadedSceneIsFlight)  		return;  	if (eModule == null)  		SetupDrive ();  	if (IsDeployed != eModule.getIgnitionState) {  		IsDeployed = eModule.getIgnitionState;  		CheckBubbleDeployment (3);  		SetPartState (eModule.getIgnitionState);  	}  	if (IsDeployed) {  		//Failsafe  		if (!CheckAltitude ()) {  			eModule.Shutdown ();  			return;  		}  		//Snip parts  		DecoupleBubbleParts ();  		//OH NO FLAMEOUT!  		if (eModule.flameout) {  			print ("Flameout");  			BubbleCollapse (eModule.currentThrottle);  			FlightInputHandler.state.mainThrottle = 0;  			IsDeployed = false;  			return;  		}  		PlayWarpAnimation (eModule.currentThrottle);  		//Start by adding in our subluminal speed which is exponential  		double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  		double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  		//Then if throttle is over our threshold' go linear  		if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  			//How much headroon do we have  			double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  			//How much of this can we use?  			var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  			//How much of this headroom have we used?  			var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  			//Add it to our current throttle calculation  			var additionalDistance = maxSpeed * throttlePercent;  			distance += additionalDistance;  		}  		//Take into acount safe accelleration/decelleration  		if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  		if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  			distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  		CurrentSpeed = distance;  		if (distance > 1000) {  			//Let's see if we can get rid of precision issues with distance.  			Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  			if (precision > MaxAccelleration)  				precision = MaxAccelleration;  			var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  			var jumpDistance = Math.Pow (10' precision) * magnitude;  			distance = jumpDistance;  		}  		double c = (distance * 50) / LIGHTSPEED;  		status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  		if (eModule.currentThrottle > MinThrottle) {  			// Translate through space on the back of a Kraken!  			Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  			//krakensbane.setOffset(ps);  			FloatingOrigin.SetOutOfFrameOffset (ps);  			//AngularMomentum Block  			if (AMConservationMode == true) {  				ApplyAngularMomentum ();  			}  		}  		if (AMConservationMode == true && eModule.currentThrottle == 0) {  			SetAMStartStateVars ();  		}  	}  } catch (Exception ex) {  	print (String.Format ("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed != eModule.getIgnitionState) {  	IsDeployed = eModule.getIgnitionState;  	CheckBubbleDeployment (3);  	SetPartState (eModule.getIgnitionState);  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: CheckBubbleDeployment (3);  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed) {  	//Failsafe  	if (!CheckAltitude ()) {  		eModule.Shutdown ();  		return;  	}  	//Snip parts  	DecoupleBubbleParts ();  	//OH NO FLAMEOUT!  	if (eModule.flameout) {  		print ("Flameout");  		BubbleCollapse (eModule.currentThrottle);  		FlightInputHandler.state.mainThrottle = 0;  		IsDeployed = false;  		return;  	}  	PlayWarpAnimation (eModule.currentThrottle);  	//Start by adding in our subluminal speed which is exponential  	double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  	double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  	//Then if throttle is over our threshold' go linear  	if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  		//How much headroon do we have  		double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  		//How much of this can we use?  		var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  		//How much of this headroom have we used?  		var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  		//Add it to our current throttle calculation  		var additionalDistance = maxSpeed * throttlePercent;  		distance += additionalDistance;  	}  	//Take into acount safe accelleration/decelleration  	if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  	if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  	CurrentSpeed = distance;  	if (distance > 1000) {  		//Let's see if we can get rid of precision issues with distance.  		Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  		if (precision > MaxAccelleration)  			precision = MaxAccelleration;  		var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  		var jumpDistance = Math.Pow (10' precision) * magnitude;  		distance = jumpDistance;  	}  	double c = (distance * 50) / LIGHTSPEED;  	status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  	if (eModule.currentThrottle > MinThrottle) {  		// Translate through space on the back of a Kraken!  		Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  		//krakensbane.setOffset(ps);  		FloatingOrigin.SetOutOfFrameOffset (ps);  		//AngularMomentum Block  		if (AMConservationMode == true) {  			ApplyAngularMomentum ();  		}  	}  	if (AMConservationMode == true && eModule.currentThrottle == 0) {  		SetAMStartStateVars ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed) {  	//Failsafe  	if (!CheckAltitude ()) {  		eModule.Shutdown ();  		return;  	}  	//Snip parts  	DecoupleBubbleParts ();  	//OH NO FLAMEOUT!  	if (eModule.flameout) {  		print ("Flameout");  		BubbleCollapse (eModule.currentThrottle);  		FlightInputHandler.state.mainThrottle = 0;  		IsDeployed = false;  		return;  	}  	PlayWarpAnimation (eModule.currentThrottle);  	//Start by adding in our subluminal speed which is exponential  	double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  	double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  	//Then if throttle is over our threshold' go linear  	if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  		//How much headroon do we have  		double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  		//How much of this can we use?  		var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  		//How much of this headroom have we used?  		var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  		//Add it to our current throttle calculation  		var additionalDistance = maxSpeed * throttlePercent;  		distance += additionalDistance;  	}  	//Take into acount safe accelleration/decelleration  	if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  	if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  	CurrentSpeed = distance;  	if (distance > 1000) {  		//Let's see if we can get rid of precision issues with distance.  		Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  		if (precision > MaxAccelleration)  			precision = MaxAccelleration;  		var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  		var jumpDistance = Math.Pow (10' precision) * magnitude;  		distance = jumpDistance;  	}  	double c = (distance * 50) / LIGHTSPEED;  	status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  	if (eModule.currentThrottle > MinThrottle) {  		// Translate through space on the back of a Kraken!  		Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  		//krakensbane.setOffset(ps);  		FloatingOrigin.SetOutOfFrameOffset (ps);  		//AngularMomentum Block  		if (AMConservationMode == true) {  			ApplyAngularMomentum ();  		}  	}  	if (AMConservationMode == true && eModule.currentThrottle == 0) {  		SetAMStartStateVars ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed) {  	//Failsafe  	if (!CheckAltitude ()) {  		eModule.Shutdown ();  		return;  	}  	//Snip parts  	DecoupleBubbleParts ();  	//OH NO FLAMEOUT!  	if (eModule.flameout) {  		print ("Flameout");  		BubbleCollapse (eModule.currentThrottle);  		FlightInputHandler.state.mainThrottle = 0;  		IsDeployed = false;  		return;  	}  	PlayWarpAnimation (eModule.currentThrottle);  	//Start by adding in our subluminal speed which is exponential  	double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  	double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  	//Then if throttle is over our threshold' go linear  	if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  		//How much headroon do we have  		double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  		//How much of this can we use?  		var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  		//How much of this headroom have we used?  		var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  		//Add it to our current throttle calculation  		var additionalDistance = maxSpeed * throttlePercent;  		distance += additionalDistance;  	}  	//Take into acount safe accelleration/decelleration  	if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  	if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  	CurrentSpeed = distance;  	if (distance > 1000) {  		//Let's see if we can get rid of precision issues with distance.  		Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  		if (precision > MaxAccelleration)  			precision = MaxAccelleration;  		var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  		var jumpDistance = Math.Pow (10' precision) * magnitude;  		distance = jumpDistance;  	}  	double c = (distance * 50) / LIGHTSPEED;  	status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  	if (eModule.currentThrottle > MinThrottle) {  		// Translate through space on the back of a Kraken!  		Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  		//krakensbane.setOffset(ps);  		FloatingOrigin.SetOutOfFrameOffset (ps);  		//AngularMomentum Block  		if (AMConservationMode == true) {  			ApplyAngularMomentum ();  		}  	}  	if (AMConservationMode == true && eModule.currentThrottle == 0) {  		SetAMStartStateVars ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed) {  	//Failsafe  	if (!CheckAltitude ()) {  		eModule.Shutdown ();  		return;  	}  	//Snip parts  	DecoupleBubbleParts ();  	//OH NO FLAMEOUT!  	if (eModule.flameout) {  		print ("Flameout");  		BubbleCollapse (eModule.currentThrottle);  		FlightInputHandler.state.mainThrottle = 0;  		IsDeployed = false;  		return;  	}  	PlayWarpAnimation (eModule.currentThrottle);  	//Start by adding in our subluminal speed which is exponential  	double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  	double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  	//Then if throttle is over our threshold' go linear  	if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  		//How much headroon do we have  		double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  		//How much of this can we use?  		var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  		//How much of this headroom have we used?  		var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  		//Add it to our current throttle calculation  		var additionalDistance = maxSpeed * throttlePercent;  		distance += additionalDistance;  	}  	//Take into acount safe accelleration/decelleration  	if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  	if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  	CurrentSpeed = distance;  	if (distance > 1000) {  		//Let's see if we can get rid of precision issues with distance.  		Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  		if (precision > MaxAccelleration)  			precision = MaxAccelleration;  		var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  		var jumpDistance = Math.Pow (10' precision) * magnitude;  		distance = jumpDistance;  	}  	double c = (distance * 50) / LIGHTSPEED;  	status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  	if (eModule.currentThrottle > MinThrottle) {  		// Translate through space on the back of a Kraken!  		Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  		//krakensbane.setOffset(ps);  		FloatingOrigin.SetOutOfFrameOffset (ps);  		//AngularMomentum Block  		if (AMConservationMode == true) {  			ApplyAngularMomentum ();  		}  	}  	if (AMConservationMode == true && eModule.currentThrottle == 0) {  		SetAMStartStateVars ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed) {  	//Failsafe  	if (!CheckAltitude ()) {  		eModule.Shutdown ();  		return;  	}  	//Snip parts  	DecoupleBubbleParts ();  	//OH NO FLAMEOUT!  	if (eModule.flameout) {  		print ("Flameout");  		BubbleCollapse (eModule.currentThrottle);  		FlightInputHandler.state.mainThrottle = 0;  		IsDeployed = false;  		return;  	}  	PlayWarpAnimation (eModule.currentThrottle);  	//Start by adding in our subluminal speed which is exponential  	double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  	double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  	//Then if throttle is over our threshold' go linear  	if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  		//How much headroon do we have  		double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  		//How much of this can we use?  		var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  		//How much of this headroom have we used?  		var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  		//Add it to our current throttle calculation  		var additionalDistance = maxSpeed * throttlePercent;  		distance += additionalDistance;  	}  	//Take into acount safe accelleration/decelleration  	if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  	if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  	CurrentSpeed = distance;  	if (distance > 1000) {  		//Let's see if we can get rid of precision issues with distance.  		Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  		if (precision > MaxAccelleration)  			precision = MaxAccelleration;  		var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  		var jumpDistance = Math.Pow (10' precision) * magnitude;  		distance = jumpDistance;  	}  	double c = (distance * 50) / LIGHTSPEED;  	status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  	if (eModule.currentThrottle > MinThrottle) {  		// Translate through space on the back of a Kraken!  		Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  		//krakensbane.setOffset(ps);  		FloatingOrigin.SetOutOfFrameOffset (ps);  		//AngularMomentum Block  		if (AMConservationMode == true) {  			ApplyAngularMomentum ();  		}  	}  	if (AMConservationMode == true && eModule.currentThrottle == 0) {  		SetAMStartStateVars ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed) {  	//Failsafe  	if (!CheckAltitude ()) {  		eModule.Shutdown ();  		return;  	}  	//Snip parts  	DecoupleBubbleParts ();  	//OH NO FLAMEOUT!  	if (eModule.flameout) {  		print ("Flameout");  		BubbleCollapse (eModule.currentThrottle);  		FlightInputHandler.state.mainThrottle = 0;  		IsDeployed = false;  		return;  	}  	PlayWarpAnimation (eModule.currentThrottle);  	//Start by adding in our subluminal speed which is exponential  	double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  	double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  	//Then if throttle is over our threshold' go linear  	if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  		//How much headroon do we have  		double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  		//How much of this can we use?  		var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  		//How much of this headroom have we used?  		var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  		//Add it to our current throttle calculation  		var additionalDistance = maxSpeed * throttlePercent;  		distance += additionalDistance;  	}  	//Take into acount safe accelleration/decelleration  	if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  	if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  	CurrentSpeed = distance;  	if (distance > 1000) {  		//Let's see if we can get rid of precision issues with distance.  		Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  		if (precision > MaxAccelleration)  			precision = MaxAccelleration;  		var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  		var jumpDistance = Math.Pow (10' precision) * magnitude;  		distance = jumpDistance;  	}  	double c = (distance * 50) / LIGHTSPEED;  	status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  	if (eModule.currentThrottle > MinThrottle) {  		// Translate through space on the back of a Kraken!  		Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  		//krakensbane.setOffset(ps);  		FloatingOrigin.SetOutOfFrameOffset (ps);  		//AngularMomentum Block  		if (AMConservationMode == true) {  			ApplyAngularMomentum ();  		}  	}  	if (AMConservationMode == true && eModule.currentThrottle == 0) {  		SetAMStartStateVars ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed) {  	//Failsafe  	if (!CheckAltitude ()) {  		eModule.Shutdown ();  		return;  	}  	//Snip parts  	DecoupleBubbleParts ();  	//OH NO FLAMEOUT!  	if (eModule.flameout) {  		print ("Flameout");  		BubbleCollapse (eModule.currentThrottle);  		FlightInputHandler.state.mainThrottle = 0;  		IsDeployed = false;  		return;  	}  	PlayWarpAnimation (eModule.currentThrottle);  	//Start by adding in our subluminal speed which is exponential  	double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  	double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  	//Then if throttle is over our threshold' go linear  	if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  		//How much headroon do we have  		double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  		//How much of this can we use?  		var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  		//How much of this headroom have we used?  		var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  		//Add it to our current throttle calculation  		var additionalDistance = maxSpeed * throttlePercent;  		distance += additionalDistance;  	}  	//Take into acount safe accelleration/decelleration  	if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  	if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  	CurrentSpeed = distance;  	if (distance > 1000) {  		//Let's see if we can get rid of precision issues with distance.  		Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  		if (precision > MaxAccelleration)  			precision = MaxAccelleration;  		var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  		var jumpDistance = Math.Pow (10' precision) * magnitude;  		distance = jumpDistance;  	}  	double c = (distance * 50) / LIGHTSPEED;  	status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  	if (eModule.currentThrottle > MinThrottle) {  		// Translate through space on the back of a Kraken!  		Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  		//krakensbane.setOffset(ps);  		FloatingOrigin.SetOutOfFrameOffset (ps);  		//AngularMomentum Block  		if (AMConservationMode == true) {  			ApplyAngularMomentum ();  		}  	}  	if (AMConservationMode == true && eModule.currentThrottle == 0) {  		SetAMStartStateVars ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed) {  	//Failsafe  	if (!CheckAltitude ()) {  		eModule.Shutdown ();  		return;  	}  	//Snip parts  	DecoupleBubbleParts ();  	//OH NO FLAMEOUT!  	if (eModule.flameout) {  		print ("Flameout");  		BubbleCollapse (eModule.currentThrottle);  		FlightInputHandler.state.mainThrottle = 0;  		IsDeployed = false;  		return;  	}  	PlayWarpAnimation (eModule.currentThrottle);  	//Start by adding in our subluminal speed which is exponential  	double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  	double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  	//Then if throttle is over our threshold' go linear  	if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  		//How much headroon do we have  		double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  		//How much of this can we use?  		var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  		//How much of this headroom have we used?  		var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  		//Add it to our current throttle calculation  		var additionalDistance = maxSpeed * throttlePercent;  		distance += additionalDistance;  	}  	//Take into acount safe accelleration/decelleration  	if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  	if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  	CurrentSpeed = distance;  	if (distance > 1000) {  		//Let's see if we can get rid of precision issues with distance.  		Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  		if (precision > MaxAccelleration)  			precision = MaxAccelleration;  		var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  		var jumpDistance = Math.Pow (10' precision) * magnitude;  		distance = jumpDistance;  	}  	double c = (distance * 50) / LIGHTSPEED;  	status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  	if (eModule.currentThrottle > MinThrottle) {  		// Translate through space on the back of a Kraken!  		Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  		//krakensbane.setOffset(ps);  		FloatingOrigin.SetOutOfFrameOffset (ps);  		//AngularMomentum Block  		if (AMConservationMode == true) {  			ApplyAngularMomentum ();  		}  	}  	if (AMConservationMode == true && eModule.currentThrottle == 0) {  		SetAMStartStateVars ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed) {  	//Failsafe  	if (!CheckAltitude ()) {  		eModule.Shutdown ();  		return;  	}  	//Snip parts  	DecoupleBubbleParts ();  	//OH NO FLAMEOUT!  	if (eModule.flameout) {  		print ("Flameout");  		BubbleCollapse (eModule.currentThrottle);  		FlightInputHandler.state.mainThrottle = 0;  		IsDeployed = false;  		return;  	}  	PlayWarpAnimation (eModule.currentThrottle);  	//Start by adding in our subluminal speed which is exponential  	double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  	double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  	//Then if throttle is over our threshold' go linear  	if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  		//How much headroon do we have  		double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  		//How much of this can we use?  		var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  		//How much of this headroom have we used?  		var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  		//Add it to our current throttle calculation  		var additionalDistance = maxSpeed * throttlePercent;  		distance += additionalDistance;  	}  	//Take into acount safe accelleration/decelleration  	if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  	if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  	CurrentSpeed = distance;  	if (distance > 1000) {  		//Let's see if we can get rid of precision issues with distance.  		Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  		if (precision > MaxAccelleration)  			precision = MaxAccelleration;  		var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  		var jumpDistance = Math.Pow (10' precision) * magnitude;  		distance = jumpDistance;  	}  	double c = (distance * 50) / LIGHTSPEED;  	status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  	if (eModule.currentThrottle > MinThrottle) {  		// Translate through space on the back of a Kraken!  		Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  		//krakensbane.setOffset(ps);  		FloatingOrigin.SetOutOfFrameOffset (ps);  		//AngularMomentum Block  		if (AMConservationMode == true) {  			ApplyAngularMomentum ();  		}  	}  	if (AMConservationMode == true && eModule.currentThrottle == 0) {  		SetAMStartStateVars ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (IsDeployed) {  	//Failsafe  	if (!CheckAltitude ()) {  		eModule.Shutdown ();  		return;  	}  	//Snip parts  	DecoupleBubbleParts ();  	//OH NO FLAMEOUT!  	if (eModule.flameout) {  		print ("Flameout");  		BubbleCollapse (eModule.currentThrottle);  		FlightInputHandler.state.mainThrottle = 0;  		IsDeployed = false;  		return;  	}  	PlayWarpAnimation (eModule.currentThrottle);  	//Start by adding in our subluminal speed which is exponential  	double lowerThrottle = (Math.Min (eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  	double distance = Math.Pow (lowerThrottle' SUBLIGHT_POWER);  	//Then if throttle is over our threshold' go linear  	if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  		//How much headroon do we have  		double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  		//How much of this can we use?  		var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  		//How much of this headroom have we used?  		var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  		//Add it to our current throttle calculation  		var additionalDistance = maxSpeed * throttlePercent;  		distance += additionalDistance;  	}  	//Take into acount safe accelleration/decelleration  	if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  	if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  		distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  	CurrentSpeed = distance;  	if (distance > 1000) {  		//Let's see if we can get rid of precision issues with distance.  		Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  		if (precision > MaxAccelleration)  			precision = MaxAccelleration;  		var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  		var jumpDistance = Math.Pow (10' precision) * magnitude;  		distance = jumpDistance;  	}  	double c = (distance * 50) / LIGHTSPEED;  	status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  	if (eModule.currentThrottle > MinThrottle) {  		// Translate through space on the back of a Kraken!  		Vector3d ps = vessel.transform.position + (transform.up * (float)distance);  		//krakensbane.setOffset(ps);  		FloatingOrigin.SetOutOfFrameOffset (ps);  		//AngularMomentum Block  		if (AMConservationMode == true) {  			ApplyAngularMomentum ();  		}  	}  	if (AMConservationMode == true && eModule.currentThrottle == 0) {  		SetAMStartStateVars ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (eModule.currentThrottle > SUBLIGHT_THROTTLE) {  	//How much headroon do we have  	double maxSpeed = (LIGHTSPEED / 50 * WarpFactor) - distance;  	//How much of this can we use?  	var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  	//How much of this headroom have we used?  	var throttlePercent = upperThrottle / (1 - SUBLIGHT_THROTTLE);  	//Add it to our current throttle calculation  	var additionalDistance = maxSpeed * throttlePercent;  	distance += additionalDistance;  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  	distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (distance > CurrentSpeed + Math.Pow (10' MaxAccelleration))  	distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: distance = CurrentSpeed + Math.Pow (10' MaxAccelleration);  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  	distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (distance < CurrentSpeed - Math.Pow (10' MaxAccelleration))  	distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: distance = CurrentSpeed - Math.Pow (10' MaxAccelleration);  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (distance > 1000) {  	//Let's see if we can get rid of precision issues with distance.  	Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  	if (precision > MaxAccelleration)  		precision = MaxAccelleration;  	var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  	var jumpDistance = Math.Pow (10' precision) * magnitude;  	distance = jumpDistance;  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (distance > 1000) {  	//Let's see if we can get rid of precision issues with distance.  	Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  	if (precision > MaxAccelleration)  		precision = MaxAccelleration;  	var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  	var jumpDistance = Math.Pow (10' precision) * magnitude;  	distance = jumpDistance;  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: if (distance > 1000) {  	//Let's see if we can get rid of precision issues with distance.  	Int32 precision = Math.Round (distance' 0).ToString ().Length - 1;  	if (precision > MaxAccelleration)  		precision = MaxAccelleration;  	var magnitude = Math.Round ((distance / Math.Pow (10' precision))' 0);  	var jumpDistance = Math.Pow (10' precision) * magnitude;  	distance = jumpDistance;  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: status = String.Format ("{1:n0} m/s [{0:0}%c]"' c * 100f' distance * 50);  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if (PreviousBodyName == FlightGlobals.currentMainBody) {  	if ((FlightGlobals.ActiveVessel.orbit.eccentricity > 1) && (ElipMode == 0))//For Hyperbolic Orbits. Conserve angular momentum by making orbit.h constant. GMp=h^2' so semi-latus rectum must be constant as well.).  	 {  		Speed = Math.Sqrt (FlightGlobals.ActiveVessel.mainBody.gravParameter * ((2 / FlightGlobals.ActiveVessel.orbit.radius) - ((SemiLatusOriginal * FlightGlobals.ActiveVessel.mainBody.gravParameter) / (FlightGlobals.ActiveVessel.orbit.semiMajorAxis * OriginalMomentumSqr))));  		if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) > 0) {  			var VelocityOffset = (TravelDirection * Speed) - Krakensbane.GetFrameVelocity ();  			FlightGlobals.ActiveVessel.ChangeWorldVelocity (VelocityOffset);  		} else {  			var VelocityOffset = (TravelDirection * Speed);  			FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  		}  	}  	if ((FlightGlobals.ActiveVessel.orbit.eccentricity <= 1) && (ElipMode == 1))// For Elliptical Orbits. Conserve Angular Momentum directly by altering state vectors  	 {  		Speed = OriginalSpeed * (OriginalFrameTrueRadius / (FlightGlobals.ActiveVessel.orbit.radius));  		if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) > 0) {  			var VelocityOffset = (TravelDirection * Speed) - Krakensbane.GetFrameVelocity ();  			FlightGlobals.ActiveVessel.ChangeWorldVelocity (VelocityOffset);  		}  		if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) == 0) {  			var VelocityOffset = (TravelDirection * Speed);  			FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  		}  		if (((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 0.55) || ((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 1.75))// re-set variables when ratio between current ratio and original gets too far from 1  		 {  			OriginalSpeed = Vector3d.Magnitude (FlightGlobals.ActiveVessel.orbit.GetRelativeVel ());  			OriginalFrameTrueRadius = FlightGlobals.ActiveVessel.orbit.radius;  		}  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if (PreviousBodyName == FlightGlobals.currentMainBody) {  	if ((FlightGlobals.ActiveVessel.orbit.eccentricity > 1) && (ElipMode == 0))//For Hyperbolic Orbits. Conserve angular momentum by making orbit.h constant. GMp=h^2' so semi-latus rectum must be constant as well.).  	 {  		Speed = Math.Sqrt (FlightGlobals.ActiveVessel.mainBody.gravParameter * ((2 / FlightGlobals.ActiveVessel.orbit.radius) - ((SemiLatusOriginal * FlightGlobals.ActiveVessel.mainBody.gravParameter) / (FlightGlobals.ActiveVessel.orbit.semiMajorAxis * OriginalMomentumSqr))));  		if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) > 0) {  			var VelocityOffset = (TravelDirection * Speed) - Krakensbane.GetFrameVelocity ();  			FlightGlobals.ActiveVessel.ChangeWorldVelocity (VelocityOffset);  		} else {  			var VelocityOffset = (TravelDirection * Speed);  			FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  		}  	}  	if ((FlightGlobals.ActiveVessel.orbit.eccentricity <= 1) && (ElipMode == 1))// For Elliptical Orbits. Conserve Angular Momentum directly by altering state vectors  	 {  		Speed = OriginalSpeed * (OriginalFrameTrueRadius / (FlightGlobals.ActiveVessel.orbit.radius));  		if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) > 0) {  			var VelocityOffset = (TravelDirection * Speed) - Krakensbane.GetFrameVelocity ();  			FlightGlobals.ActiveVessel.ChangeWorldVelocity (VelocityOffset);  		}  		if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) == 0) {  			var VelocityOffset = (TravelDirection * Speed);  			FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  		}  		if (((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 0.55) || ((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 1.75))// re-set variables when ratio between current ratio and original gets too far from 1  		 {  			OriginalSpeed = Vector3d.Magnitude (FlightGlobals.ActiveVessel.orbit.GetRelativeVel ());  			OriginalFrameTrueRadius = FlightGlobals.ActiveVessel.orbit.radius;  		}  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if (PreviousBodyName == FlightGlobals.currentMainBody) {  	if ((FlightGlobals.ActiveVessel.orbit.eccentricity > 1) && (ElipMode == 0))//For Hyperbolic Orbits. Conserve angular momentum by making orbit.h constant. GMp=h^2' so semi-latus rectum must be constant as well.).  	 {  		Speed = Math.Sqrt (FlightGlobals.ActiveVessel.mainBody.gravParameter * ((2 / FlightGlobals.ActiveVessel.orbit.radius) - ((SemiLatusOriginal * FlightGlobals.ActiveVessel.mainBody.gravParameter) / (FlightGlobals.ActiveVessel.orbit.semiMajorAxis * OriginalMomentumSqr))));  		if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) > 0) {  			var VelocityOffset = (TravelDirection * Speed) - Krakensbane.GetFrameVelocity ();  			FlightGlobals.ActiveVessel.ChangeWorldVelocity (VelocityOffset);  		} else {  			var VelocityOffset = (TravelDirection * Speed);  			FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  		}  	}  	if ((FlightGlobals.ActiveVessel.orbit.eccentricity <= 1) && (ElipMode == 1))// For Elliptical Orbits. Conserve Angular Momentum directly by altering state vectors  	 {  		Speed = OriginalSpeed * (OriginalFrameTrueRadius / (FlightGlobals.ActiveVessel.orbit.radius));  		if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) > 0) {  			var VelocityOffset = (TravelDirection * Speed) - Krakensbane.GetFrameVelocity ();  			FlightGlobals.ActiveVessel.ChangeWorldVelocity (VelocityOffset);  		}  		if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) == 0) {  			var VelocityOffset = (TravelDirection * Speed);  			FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  		}  		if (((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 0.55) || ((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 1.75))// re-set variables when ratio between current ratio and original gets too far from 1  		 {  			OriginalSpeed = Vector3d.Magnitude (FlightGlobals.ActiveVessel.orbit.GetRelativeVel ());  			OriginalFrameTrueRadius = FlightGlobals.ActiveVessel.orbit.radius;  		}  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if ((FlightGlobals.ActiveVessel.orbit.eccentricity > 1) && (ElipMode == 0))//For Hyperbolic Orbits. Conserve angular momentum by making orbit.h constant. GMp=h^2' so semi-latus rectum must be constant as well.).   {  	Speed = Math.Sqrt (FlightGlobals.ActiveVessel.mainBody.gravParameter * ((2 / FlightGlobals.ActiveVessel.orbit.radius) - ((SemiLatusOriginal * FlightGlobals.ActiveVessel.mainBody.gravParameter) / (FlightGlobals.ActiveVessel.orbit.semiMajorAxis * OriginalMomentumSqr))));  	if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) > 0) {  		var VelocityOffset = (TravelDirection * Speed) - Krakensbane.GetFrameVelocity ();  		FlightGlobals.ActiveVessel.ChangeWorldVelocity (VelocityOffset);  	} else {  		var VelocityOffset = (TravelDirection * Speed);  		FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: Speed = Math.Sqrt (FlightGlobals.ActiveVessel.mainBody.gravParameter * ((2 / FlightGlobals.ActiveVessel.orbit.radius) - ((SemiLatusOriginal * FlightGlobals.ActiveVessel.mainBody.gravParameter) / (FlightGlobals.ActiveVessel.orbit.semiMajorAxis * OriginalMomentumSqr))));  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if ((FlightGlobals.ActiveVessel.orbit.eccentricity <= 1) && (ElipMode == 1))// For Elliptical Orbits. Conserve Angular Momentum directly by altering state vectors   {  	Speed = OriginalSpeed * (OriginalFrameTrueRadius / (FlightGlobals.ActiveVessel.orbit.radius));  	if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) > 0) {  		var VelocityOffset = (TravelDirection * Speed) - Krakensbane.GetFrameVelocity ();  		FlightGlobals.ActiveVessel.ChangeWorldVelocity (VelocityOffset);  	}  	if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) == 0) {  		var VelocityOffset = (TravelDirection * Speed);  		FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  	}  	if (((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 0.55) || ((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 1.75))// re-set variables when ratio between current ratio and original gets too far from 1  	 {  		OriginalSpeed = Vector3d.Magnitude (FlightGlobals.ActiveVessel.orbit.GetRelativeVel ());  		OriginalFrameTrueRadius = FlightGlobals.ActiveVessel.orbit.radius;  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if ((FlightGlobals.ActiveVessel.orbit.eccentricity <= 1) && (ElipMode == 1))// For Elliptical Orbits. Conserve Angular Momentum directly by altering state vectors   {  	Speed = OriginalSpeed * (OriginalFrameTrueRadius / (FlightGlobals.ActiveVessel.orbit.radius));  	if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) > 0) {  		var VelocityOffset = (TravelDirection * Speed) - Krakensbane.GetFrameVelocity ();  		FlightGlobals.ActiveVessel.ChangeWorldVelocity (VelocityOffset);  	}  	if (Vector3d.Magnitude (Krakensbane.GetFrameVelocity ()) == 0) {  		var VelocityOffset = (TravelDirection * Speed);  		FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  	}  	if (((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 0.55) || ((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 1.75))// re-set variables when ratio between current ratio and original gets too far from 1  	 {  		OriginalSpeed = Vector3d.Magnitude (FlightGlobals.ActiveVessel.orbit.GetRelativeVel ());  		OriginalFrameTrueRadius = FlightGlobals.ActiveVessel.orbit.radius;  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if (((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 0.55) || ((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 1.75))// re-set variables when ratio between current ratio and original gets too far from 1   {  	OriginalSpeed = Vector3d.Magnitude (FlightGlobals.ActiveVessel.orbit.GetRelativeVel ());  	OriginalFrameTrueRadius = FlightGlobals.ActiveVessel.orbit.radius;  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if (((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 0.55) || ((OriginalFrameTrueRadius / FlightGlobals.ActiveVessel.orbit.radius) <= 1.75))// re-set variables when ratio between current ratio and original gets too far from 1   {  	OriginalSpeed = Vector3d.Magnitude (FlightGlobals.ActiveVessel.orbit.GetRelativeVel ());  	OriginalFrameTrueRadius = FlightGlobals.ActiveVessel.orbit.radius;  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,BubbleCollapse,The following statement contains a magic number: foreach (var p in vessel.parts) {  	var expl = r.Next (0' 100);  	if (expl <= speed * 100) {  		if (p.mass <= (Demasting * speed) && p.children.Count == 0)  			p.explode ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,BubbleCollapse,The following statement contains a magic number: foreach (var p in vessel.parts) {  	var expl = r.Next (0' 100);  	if (expl <= speed * 100) {  		if (p.mass <= (Demasting * speed) && p.children.Count == 0)  			p.explode ();  	}  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,BubbleCollapse,The following statement contains a magic number: if (expl <= speed * 100) {  	if (p.mass <= (Demasting * speed) && p.children.Count == 0)  		p.explode ();  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,PlayWarpAnimation,The following statement contains a magic number: try {  	WarpAnimation [warpAnimationName].speed = 1 + (speed * WarpFactor);  	if (!WarpAnimation.IsPlaying (warpAnimationName)) {  		WarpAnimation.Play (warpAnimationName);  	}  	//Set our color  	var rgb = ColorUtils.HSL2RGB (Math.Abs (speed - 1)' 0.5' speed / 2);  	var c = new Color (rgb [0]' rgb [1]' rgb [2]);  	warpBubble.GetComponent<Renderer> ().material.SetColor ("_Color"' c);  } catch (Exception) {  	print ("[WARP] ERROR IN PlayWarpAnimation");  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,PlayWarpAnimation,The following statement contains a magic number: try {  	WarpAnimation [warpAnimationName].speed = 1 + (speed * WarpFactor);  	if (!WarpAnimation.IsPlaying (warpAnimationName)) {  		WarpAnimation.Play (warpAnimationName);  	}  	//Set our color  	var rgb = ColorUtils.HSL2RGB (Math.Abs (speed - 1)' 0.5' speed / 2);  	var c = new Color (rgb [0]' rgb [1]' rgb [2]);  	warpBubble.GetComponent<Renderer> ().material.SetColor ("_Color"' c);  } catch (Exception) {  	print ("[WARP] ERROR IN PlayWarpAnimation");  }  
Magic Number,WarpEngine,USI_ModuleWarpEngine,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,PlayWarpAnimation,The following statement contains a magic number: try {  	WarpAnimation [warpAnimationName].speed = 1 + (speed * WarpFactor);  	if (!WarpAnimation.IsPlaying (warpAnimationName)) {  		WarpAnimation.Play (warpAnimationName);  	}  	//Set our color  	var rgb = ColorUtils.HSL2RGB (Math.Abs (speed - 1)' 0.5' speed / 2);  	var c = new Color (rgb [0]' rgb [1]' rgb [2]);  	warpBubble.GetComponent<Renderer> ().material.SetColor ("_Color"' c);  } catch (Exception) {  	print ("[WARP] ERROR IN PlayWarpAnimation");  }  
Missing Default,WarpEngine,ColorUtils,F:\newReposMay17\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following switch statement is missing a default case: switch (sextant) {  case 0:  	r = v;  	g = mid1;  	b = m;  	break;  case 1:  	r = mid2;  	g = v;  	b = m;  	break;  case 2:  	r = m;  	g = v;  	b = mid1;  	break;  case 3:  	r = m;  	g = mid2;  	b = v;  	break;  case 4:  	r = mid1;  	g = m;  	b = v;  	break;  case 5:  	r = v;  	g = m;  	b = mid2;  	break;  }  
