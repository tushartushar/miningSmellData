Implementation smell,Namespace,Class,File,Method,Description
Complex Method,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,Cyclomatic complexity of the method is 12
Long Statement,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,GravityBrake,The length of the statement  "            GravityBrakes = ((FlightGlobals.ActiveVessel.mainBody.gravParameter / Math.Pow(FlightGlobals.ActiveVessel.orbit.radius' BrakeFalloff)) / (FlightGlobals.ActiveVessel.mainBody.gravParameter / Math.Pow(cutoffRadius' BrakeFalloff))); " is 229.
Long Statement,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,GravityBrake,The length of the statement  "                    GravityBrakes = GravityBrakes + (((nextbody.gravParameter / Math.Pow(currentbody.orbit.radius' BrakeFalloff)) / (nextbody.gravParameter / Math.Pow(cutoffRadius' BrakeFalloff)))); " is 178.
Long Statement,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The length of the statement  "                if ((FlightGlobals.ActiveVessel.orbit.eccentricity >= 1) && (ElipMode == 0)) //For Hyperbolic Orbits. Conserve angular momentum by making orbit.h constant. GMp=h^2' so semi-latus rectum must be constant as well.). " is 213.
Long Statement,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The length of the statement  "				Speed = Math.Sqrt(FlightGlobals.ActiveVessel.mainBody.gravParameter*((2/FlightGlobals.ActiveVessel.orbit.radius)-((SemiLatusOriginal*FlightGlobals.ActiveVessel.mainBody.gravParameter)/(FlightGlobals.ActiveVessel.orbit.semiMajorAxis * OriginalMomentumSqr)))); " is 258.
Long Statement,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The length of the statement  "				if ((FlightGlobals.ActiveVessel.orbit.eccentricity < 1) && (ElipMode == 1)) // For Elliptical Orbits. Conserve Angular Momentum directly by altering state vectors " is 162.
Long Statement,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The length of the statement  "					if (((FlightGlobals.ActiveVessel.orbit.radius / OriginalFrameTrueRadius) >= 0.85) || ((FlightGlobals.ActiveVessel.orbit.radius / OriginalFrameTrueRadius) <= 1.15)) // re-set variables when ratio between current ratio and original gets too far from 1 " is 249.
Long Statement,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The length of the statement  "            if (((FlightGlobals.ActiveVessel.orbit.eccentricity < 1) && (ElipMode == 0)) || ((FlightGlobals.ActiveVessel.orbit.eccentricity > 1) && (ElipMode == 1)) || (PreviousBodyName != FlightGlobals.currentMainBody)) " is 208.
Long Statement,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,DecoupleBubbleParts,The length of the statement  "                    if ((p.Modules.Contains("USI_ModuleWarpEngine") == true) && (p.FindModuleImplementing<ModuleEngines>().getIgnitionState == true)) " is 129.
Complex Conditional,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The conditional expression  "((FlightGlobals.ActiveVessel.orbit.eccentricity < 1) && (ElipMode == 0)) || ((FlightGlobals.ActiveVessel.orbit.eccentricity > 1) && (ElipMode == 1)) || (PreviousBodyName != FlightGlobals.currentMainBody)"  is complex.
Magic Number,WarpEngine,ColorUtils,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: v = (l <= 0.5) ? (l*(1.0 + sl)) : (l + sl - l*sl);
Magic Number,WarpEngine,ColorUtils,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: if (v > 0)              {                  double m;                  double sv;                  int sextant;                  double fract' vsf' mid1' mid2;                    m = l + l - v;                  sv = (v - m)/v;                  h *= 6.0;                  sextant = (int) h;                  fract = h - sextant;                  vsf = v*sv*fract;                  mid1 = m + vsf;                  mid2 = v - vsf;                  switch (sextant)                  {                      case 0:                          r = v;                          g = mid1;                          b = m;                          break;                      case 1:                          r = mid2;                          g = v;                          b = m;                          break;                      case 2:                          r = m;                          g = v;                          b = mid1;                          break;                      case 3:                          r = m;                          g = mid2;                          b = v;                          break;                      case 4:                          r = mid1;                          g = m;                          b = v;                          break;                      case 5:                          r = v;                          g = m;                          b = mid2;                          break;                  }              }
Magic Number,WarpEngine,ColorUtils,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: if (v > 0)              {                  double m;                  double sv;                  int sextant;                  double fract' vsf' mid1' mid2;                    m = l + l - v;                  sv = (v - m)/v;                  h *= 6.0;                  sextant = (int) h;                  fract = h - sextant;                  vsf = v*sv*fract;                  mid1 = m + vsf;                  mid2 = v - vsf;                  switch (sextant)                  {                      case 0:                          r = v;                          g = mid1;                          b = m;                          break;                      case 1:                          r = mid2;                          g = v;                          b = m;                          break;                      case 2:                          r = m;                          g = v;                          b = mid1;                          break;                      case 3:                          r = m;                          g = mid2;                          b = v;                          break;                      case 4:                          r = mid1;                          g = m;                          b = v;                          break;                      case 5:                          r = v;                          g = m;                          b = mid2;                          break;                  }              }
Magic Number,WarpEngine,ColorUtils,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: if (v > 0)              {                  double m;                  double sv;                  int sextant;                  double fract' vsf' mid1' mid2;                    m = l + l - v;                  sv = (v - m)/v;                  h *= 6.0;                  sextant = (int) h;                  fract = h - sextant;                  vsf = v*sv*fract;                  mid1 = m + vsf;                  mid2 = v - vsf;                  switch (sextant)                  {                      case 0:                          r = v;                          g = mid1;                          b = m;                          break;                      case 1:                          r = mid2;                          g = v;                          b = m;                          break;                      case 2:                          r = m;                          g = v;                          b = mid1;                          break;                      case 3:                          r = m;                          g = mid2;                          b = v;                          break;                      case 4:                          r = mid1;                          g = m;                          b = v;                          break;                      case 5:                          r = v;                          g = m;                          b = mid2;                          break;                  }              }
Magic Number,WarpEngine,ColorUtils,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: if (v > 0)              {                  double m;                  double sv;                  int sextant;                  double fract' vsf' mid1' mid2;                    m = l + l - v;                  sv = (v - m)/v;                  h *= 6.0;                  sextant = (int) h;                  fract = h - sextant;                  vsf = v*sv*fract;                  mid1 = m + vsf;                  mid2 = v - vsf;                  switch (sextant)                  {                      case 0:                          r = v;                          g = mid1;                          b = m;                          break;                      case 1:                          r = mid2;                          g = v;                          b = m;                          break;                      case 2:                          r = m;                          g = v;                          b = mid1;                          break;                      case 3:                          r = m;                          g = mid2;                          b = v;                          break;                      case 4:                          r = mid1;                          g = m;                          b = v;                          break;                      case 5:                          r = v;                          g = m;                          b = mid2;                          break;                  }              }
Magic Number,WarpEngine,ColorUtils,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: if (v > 0)              {                  double m;                  double sv;                  int sextant;                  double fract' vsf' mid1' mid2;                    m = l + l - v;                  sv = (v - m)/v;                  h *= 6.0;                  sextant = (int) h;                  fract = h - sextant;                  vsf = v*sv*fract;                  mid1 = m + vsf;                  mid2 = v - vsf;                  switch (sextant)                  {                      case 0:                          r = v;                          g = mid1;                          b = m;                          break;                      case 1:                          r = mid2;                          g = v;                          b = m;                          break;                      case 2:                          r = m;                          g = v;                          b = mid1;                          break;                      case 3:                          r = m;                          g = mid2;                          b = v;                          break;                      case 4:                          r = mid1;                          g = m;                          b = v;                          break;                      case 5:                          r = v;                          g = m;                          b = mid2;                          break;                  }              }
Magic Number,WarpEngine,ColorUtils,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: var newRGB = new float[3];
Magic Number,WarpEngine,ColorUtils,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following statement contains a magic number: newRGB[2] = (float)b;
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: try  			{  				DeployAnimation[deployAnimationName].layer = 3;  				if(unfoldAnimationName != "")  					UnfoldAnimation[unfoldAnimationName].layer = 5;  				WarpAnimation[warpAnimationName].layer = 4;  				CheckBubbleDeployment(1000);  				base.OnStart(state);  			}  			catch (Exception ex)  			{  				print(String.Format("[WARP] Error in OnStart - {0}"' ex.Message));  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: try  			{  				DeployAnimation[deployAnimationName].layer = 3;  				if(unfoldAnimationName != "")  					UnfoldAnimation[unfoldAnimationName].layer = 5;  				WarpAnimation[warpAnimationName].layer = 4;  				CheckBubbleDeployment(1000);  				base.OnStart(state);  			}  			catch (Exception ex)  			{  				print(String.Format("[WARP] Error in OnStart - {0}"' ex.Message));  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: try  			{  				DeployAnimation[deployAnimationName].layer = 3;  				if(unfoldAnimationName != "")  					UnfoldAnimation[unfoldAnimationName].layer = 5;  				WarpAnimation[warpAnimationName].layer = 4;  				CheckBubbleDeployment(1000);  				base.OnStart(state);  			}  			catch (Exception ex)  			{  				print(String.Format("[WARP] Error in OnStart - {0}"' ex.Message));  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnStart,The following statement contains a magic number: try  			{  				DeployAnimation[deployAnimationName].layer = 3;  				if(unfoldAnimationName != "")  					UnfoldAnimation[unfoldAnimationName].layer = 5;  				WarpAnimation[warpAnimationName].layer = 4;  				CheckBubbleDeployment(1000);  				base.OnStart(state);  			}  			catch (Exception ex)  			{  				print(String.Format("[WARP] Error in OnStart - {0}"' ex.Message));  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,OnLoad,The following statement contains a magic number: try  			{  				if (!HighLogic.LoadedSceneIsFlight)                      return;                      CheckBubbleDeployment(1000);  				if (AMConservationMode == true)  				{  					ConservationMode = "A.Momentum";  				}  				if (AMConservationMode == false)   				{  					ConservationMode = "Velocity";  				}  			}  			catch (Exception ex)  			{  				print(String.Format("[WARP] Error in OnLoad - {0}"' ex.Message));  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,CheckAltitude,The following statement contains a magic number: if (FlightGlobals.currentMainBody != null)   			{  				var altCutoff = FlightGlobals.ActiveVessel.mainBody.Radius * MinAltitude;  				if (FlightGlobals.ActiveVessel.altitude < altCutoff)                  {  					status = "failsafe: " + Math.Round (altCutoff / 1000' 0) + "km";  					return false;  				}  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,FixedUpdate,The following statement contains a magic number: try  			{  				if (!HighLogic.LoadedSceneIsFlight)                       return;                    if(eModule == null)                      SetupDrive();                    if (IsDeployed != eModule.getIgnitionState)                  {                      IsDeployed = eModule.getIgnitionState;                      CheckBubbleDeployment(3);                      SetPartState(eModule.getIgnitionState);                  }    				if (IsDeployed)  				{  					//Failsafe                      if (!CheckAltitude())                      {                          eModule.Shutdown();                          return;                      }                        //Snip parts                      DecoupleBubbleParts();                        //OH NO FLAMEOUT!                      if (eModule.flameout)                      {                          print("Flameout");                          BubbleCollapse(eModule.currentThrottle);                          FlightInputHandler.state.mainThrottle = 0;                          IsDeployed = false;                          return;                      }                        PlayWarpAnimation(eModule.currentThrottle);                      GravityBrake();                      //Start by adding in our subluminal speed which is exponential                      double lowerThrottle = (Math.Min(eModule.currentThrottle' SUBLIGHT_THROTTLE) * SUBLIGHT_MULT);  					double distance = Math.Pow(lowerThrottle' SUBLIGHT_POWER);    					//Then if throttle is over our threshold' go linear  					if (eModule.currentThrottle > SUBLIGHT_THROTTLE)  					{                          //How much headroom do we have                          double maxSpeed = ((LIGHTSPEED*WarpFactor) - distance);  						//How much of this can we use?  						var upperThrottle = eModule.currentThrottle - SUBLIGHT_THROTTLE;  						//How much of this headroom have we used?  						var throttlePercent = upperThrottle/(1 - SUBLIGHT_THROTTLE);  						//Add it to our current throttle calculation  						var additionalDistance = maxSpeed*throttlePercent;  						distance += additionalDistance;  					}                          //Take into acount safe accelleration/decelleration                      //if (distance > CurrentSpeed + Math.Pow(10'MaxAccelleration))                      //	distance = CurrentSpeed + Math.Pow(10' MaxAccelleration);                      //if (distance < CurrentSpeed - Math.Pow(10' MaxAccelleration))                      //	distance = CurrentSpeed - Math.Pow(10' MaxAccelleration);                      //CurrentSpeed = distance;                        //if (distance > 1000)                      //{                      //Let's see if we can get rid of precision issues with distance.                      //	Int32 precision = Math.Round(distance' 0).ToString().Length - 1;                      //	if (precision > MaxAccelleration) precision = MaxAccelleration;                      //	var magnitude = Math.Round((distance / Math.Pow(10' precision))'0);                      //	var jumpDistance = Math.Pow(10'precision) * magnitude;                      //	distance = jumpDistance;                      //}                        double maxspeeddisp = Math.Pow(LIGHTSPEED * WarpFactor' GravityBrakes) / LIGHTSPEED;                      double ts = WarpFactor * (TurboPoint / 100d);                      if (maxspeeddisp >= ts)                      {                          distance = distance / (Math.Log(1/GravityBrakes) + (1 / (TurboFactor * TurboMult)));                          maxspeeddisp = maxspeeddisp / (Math.Log(1 / GravityBrakes) + (1 / (TurboFactor*TurboMult)));                      }                      if (eModule.currentThrottle > MinThrottle)  					{                          // Translate through space on the back of a Kraken!                                              distance = Math.Pow(distance' GravityBrakes) * TimeWarp.fixedDeltaTime;  						Vector3d ps = FlightGlobals.ActiveVessel.transform.position + (transform.up*(float) distance);                          //krakensbane.setOffset(ps);                          FloatingOrigin.SetOutOfFrameOffset(ps);    						//AngularMomentum Block  						if (AMConservationMode == true)  						{  							ApplyAngularMomentum();  						}  					}  					if (AMConservationMode == true && eModule.currentThrottle == 0)  					{  						SetAMStartStateVars();  					}                      double speedcdisp = (distance) / (LIGHTSPEED * TimeWarp.fixedDeltaTime);                      status = String.Format("{0:g3}c [Max {1:f3}c] T@{2:f3}c"' speedcdisp' maxspeeddisp' ts);                  }  			}  			catch (Exception ex)  			{  				print(String.Format("[WARP] Error in OnFixedUpdate - {0}"' ex.Message));  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: FlightGlobals.ActiveVessel.IgnoreGForces(2);
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if (PreviousBodyName == FlightGlobals.ActiveVessel.mainBody)  			{                  Krakensbane.ResetVelocityFrame(true);                  if ((FlightGlobals.ActiveVessel.orbit.eccentricity >= 1) && (ElipMode == 0)) //For Hyperbolic Orbits. Conserve angular momentum by making orbit.h constant. GMp=h^2' so semi-latus rectum must be constant as well.).  				{  				Speed = Math.Sqrt(FlightGlobals.ActiveVessel.mainBody.gravParameter*((2/FlightGlobals.ActiveVessel.orbit.radius)-((SemiLatusOriginal*FlightGlobals.ActiveVessel.mainBody.gravParameter)/(FlightGlobals.ActiveVessel.orbit.semiMajorAxis * OriginalMomentumSqr))));  						var VelocityOffset = (TravelDirection * Speed);  						FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  				}  				if ((FlightGlobals.ActiveVessel.orbit.eccentricity < 1) && (ElipMode == 1)) // For Elliptical Orbits. Conserve Angular Momentum directly by altering state vectors  				{  					Speed = OriginalSpeed * (OriginalFrameTrueRadius / (FlightGlobals.ActiveVessel.orbit.radius));  						var VelocityOffset = (TravelDirection * Speed);  						FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  					if (((FlightGlobals.ActiveVessel.orbit.radius / OriginalFrameTrueRadius) >= 0.85) || ((FlightGlobals.ActiveVessel.orbit.radius / OriginalFrameTrueRadius) <= 1.15)) // re-set variables when ratio between current ratio and original gets too far from 1  					{  						OriginalSpeed = Vector3d.Magnitude (FlightGlobals.ActiveVessel.orbit.GetRelativeVel ());  						OriginalFrameTrueRadius = FlightGlobals.ActiveVessel.orbit.radius;  					}  				}              }
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if (PreviousBodyName == FlightGlobals.ActiveVessel.mainBody)  			{                  Krakensbane.ResetVelocityFrame(true);                  if ((FlightGlobals.ActiveVessel.orbit.eccentricity >= 1) && (ElipMode == 0)) //For Hyperbolic Orbits. Conserve angular momentum by making orbit.h constant. GMp=h^2' so semi-latus rectum must be constant as well.).  				{  				Speed = Math.Sqrt(FlightGlobals.ActiveVessel.mainBody.gravParameter*((2/FlightGlobals.ActiveVessel.orbit.radius)-((SemiLatusOriginal*FlightGlobals.ActiveVessel.mainBody.gravParameter)/(FlightGlobals.ActiveVessel.orbit.semiMajorAxis * OriginalMomentumSqr))));  						var VelocityOffset = (TravelDirection * Speed);  						FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  				}  				if ((FlightGlobals.ActiveVessel.orbit.eccentricity < 1) && (ElipMode == 1)) // For Elliptical Orbits. Conserve Angular Momentum directly by altering state vectors  				{  					Speed = OriginalSpeed * (OriginalFrameTrueRadius / (FlightGlobals.ActiveVessel.orbit.radius));  						var VelocityOffset = (TravelDirection * Speed);  						FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  					if (((FlightGlobals.ActiveVessel.orbit.radius / OriginalFrameTrueRadius) >= 0.85) || ((FlightGlobals.ActiveVessel.orbit.radius / OriginalFrameTrueRadius) <= 1.15)) // re-set variables when ratio between current ratio and original gets too far from 1  					{  						OriginalSpeed = Vector3d.Magnitude (FlightGlobals.ActiveVessel.orbit.GetRelativeVel ());  						OriginalFrameTrueRadius = FlightGlobals.ActiveVessel.orbit.radius;  					}  				}              }
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,ApplyAngularMomentum,The following statement contains a magic number: if (PreviousBodyName == FlightGlobals.ActiveVessel.mainBody)  			{                  Krakensbane.ResetVelocityFrame(true);                  if ((FlightGlobals.ActiveVessel.orbit.eccentricity >= 1) && (ElipMode == 0)) //For Hyperbolic Orbits. Conserve angular momentum by making orbit.h constant. GMp=h^2' so semi-latus rectum must be constant as well.).  				{  				Speed = Math.Sqrt(FlightGlobals.ActiveVessel.mainBody.gravParameter*((2/FlightGlobals.ActiveVessel.orbit.radius)-((SemiLatusOriginal*FlightGlobals.ActiveVessel.mainBody.gravParameter)/(FlightGlobals.ActiveVessel.orbit.semiMajorAxis * OriginalMomentumSqr))));  						var VelocityOffset = (TravelDirection * Speed);  						FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  				}  				if ((FlightGlobals.ActiveVessel.orbit.eccentricity < 1) && (ElipMode == 1)) // For Elliptical Orbits. Conserve Angular Momentum directly by altering state vectors  				{  					Speed = OriginalSpeed * (OriginalFrameTrueRadius / (FlightGlobals.ActiveVessel.orbit.radius));  						var VelocityOffset = (TravelDirection * Speed);  						FlightGlobals.ActiveVessel.SetWorldVelocity (VelocityOffset);  					if (((FlightGlobals.ActiveVessel.orbit.radius / OriginalFrameTrueRadius) >= 0.85) || ((FlightGlobals.ActiveVessel.orbit.radius / OriginalFrameTrueRadius) <= 1.15)) // re-set variables when ratio between current ratio and original gets too far from 1  					{  						OriginalSpeed = Vector3d.Magnitude (FlightGlobals.ActiveVessel.orbit.GetRelativeVel ());  						OriginalFrameTrueRadius = FlightGlobals.ActiveVessel.orbit.radius;  					}  				}              }
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,BubbleCollapse,The following statement contains a magic number: foreach (var p in vessel.parts)  			{  				var expl = r.Next(0' 100);  				if (expl <= 33)  				{  					p.explode();  				}                  if (expl >= 66)                  {                      p.decouple(10000);                  }  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,BubbleCollapse,The following statement contains a magic number: foreach (var p in vessel.parts)  			{  				var expl = r.Next(0' 100);  				if (expl <= 33)  				{  					p.explode();  				}                  if (expl >= 66)                  {                      p.decouple(10000);                  }  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,BubbleCollapse,The following statement contains a magic number: foreach (var p in vessel.parts)  			{  				var expl = r.Next(0' 100);  				if (expl <= 33)  				{  					p.explode();  				}                  if (expl >= 66)                  {                      p.decouple(10000);                  }  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,BubbleCollapse,The following statement contains a magic number: foreach (var p in vessel.parts)  			{  				var expl = r.Next(0' 100);  				if (expl <= 33)  				{  					p.explode();  				}                  if (expl >= 66)                  {                      p.decouple(10000);                  }  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,PlayWarpAnimation,The following statement contains a magic number: try  			{  				WarpAnimation[warpAnimationName].speed = 1 + (speed * WarpFactor);  				if (!WarpAnimation.IsPlaying(warpAnimationName))  				{  					WarpAnimation.Play(warpAnimationName);  				}  				//Set our color                  var rgb = ColorUtils.HSL2RGB(Math.Abs(speed - 1)' 0.5' speed / 2);                  var c = new Color(rgb[0]' rgb[1]' rgb[2]);                  warpBubble.GetComponent<Renderer>().material.SetColor("_Color"' c);    			}  			catch (Exception)  			{  				print("[WARP] ERROR IN PlayWarpAnimation");  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,PlayWarpAnimation,The following statement contains a magic number: try  			{  				WarpAnimation[warpAnimationName].speed = 1 + (speed * WarpFactor);  				if (!WarpAnimation.IsPlaying(warpAnimationName))  				{  					WarpAnimation.Play(warpAnimationName);  				}  				//Set our color                  var rgb = ColorUtils.HSL2RGB(Math.Abs(speed - 1)' 0.5' speed / 2);                  var c = new Color(rgb[0]' rgb[1]' rgb[2]);                  warpBubble.GetComponent<Renderer>().material.SetColor("_Color"' c);    			}  			catch (Exception)  			{  				print("[WARP] ERROR IN PlayWarpAnimation");  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,PlayWarpAnimation,The following statement contains a magic number: try  			{  				WarpAnimation[warpAnimationName].speed = 1 + (speed * WarpFactor);  				if (!WarpAnimation.IsPlaying(warpAnimationName))  				{  					WarpAnimation.Play(warpAnimationName);  				}  				//Set our color                  var rgb = ColorUtils.HSL2RGB(Math.Abs(speed - 1)' 0.5' speed / 2);                  var c = new Color(rgb[0]' rgb[1]' rgb[2]);                  warpBubble.GetComponent<Renderer>().material.SetColor("_Color"' c);    			}  			catch (Exception)  			{  				print("[WARP] ERROR IN PlayWarpAnimation");  			}
Magic Number,WarpEngine,USI_ModuleWarpEngine,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\USI_ModuleWarpEngine.cs,DecoupleBubbleParts,The following statement contains a magic number: try              {                  int warpenginecount = 0;                  foreach (var p in vessel.parts)                  {                      var posPart = p.partTransform.position;                      var posBubble = part.partTransform.position;                      double distance = Vector3d.Distance(posBubble' posPart);                      if (distance > BubbleSize)                      {                          print("Part outside of warp bubble destroyed " + p.name);                          p.decouple(10000);                      }                      if ((p.Modules.Contains("USI_ModuleWarpEngine") == true) && (p.FindModuleImplementing<ModuleEngines>().getIgnitionState == true))                      {                          warpenginecount++;                      }                  }                  if (warpenginecount > 1)                  {                      ScreenMessages.PostScreenMessage("Invited Kraken - Too Many Active Warp Drives"' 5f' ScreenMessageStyle.UPPER_CENTER);                          foreach (var p in vessel.parts)                          {                                  p.explode();                                  part.explode();                          }                  }              }                catch (Exception)              {                  print("[WARP] ERROR IN DecoupleBubbleParts");              }
Missing Default,WarpEngine,ColorUtils,C:\repos\BobPalmer_WarpDrive\Source\WarpEngine\WarpEngine\ColorUtilities.cs,HSL2RGB,The following switch statement is missing a default case: switch (sextant)                  {                      case 0:                          r = v;                          g = mid1;                          b = m;                          break;                      case 1:                          r = mid2;                          g = v;                          b = m;                          break;                      case 2:                          r = m;                          g = v;                          b = mid1;                          break;                      case 3:                          r = m;                          g = mid2;                          b = v;                          break;                      case 4:                          r = mid1;                          g = m;                          b = v;                          break;                      case 5:                          r = v;                          g = m;                          b = mid2;                          break;                  }
