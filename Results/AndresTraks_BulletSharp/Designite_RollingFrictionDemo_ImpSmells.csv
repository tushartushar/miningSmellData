Implementation smell,Namespace,Class,File,Method,Description
Long Statement,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The length of the statement  "	CollisionObject ground = LocalCreateRigidBody (0' Matrix.RotationAxis (new Vector3 (0' 0' 1)' (float)Math.PI * 0.03f) * Matrix.Translation (0' -50' 0)' groundShape); " is 165.
Long Statement,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The length of the statement  "				body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction); " is 128.
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: World.Gravity = new Vector3 (0' -10' 0);  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: groundShape = new BoxShape (100' 50' 100);  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: groundShape = new BoxShape (100' 50' 100);  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: groundShape = new BoxShape (100' 50' 100);  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: ground = LocalCreateRigidBody (0' Matrix.Translation (0' -54' 0)' groundShape);  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int k = 0; k < ArraySizeY; k++) {  	for (int i = 0; i < ArraySizeX; i++) {  		for (int j = 0; j < ArraySizeZ; j++) {  			Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  			shapeIndex++;  			// using motionstate is recommended' it provides interpolation capabilities  			// and only synchronizes 'active' objects  			rbInfo.MotionState = new DefaultMotionState (startTransform);  			rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  			RigidBody body = new RigidBody (rbInfo);  			body.Friction = 1;  			body.RollingFriction = 0.3f;  			body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  			World.AddRigidBody (body);  		}  	}  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int k = 0; k < ArraySizeY; k++) {  	for (int i = 0; i < ArraySizeX; i++) {  		for (int j = 0; j < ArraySizeZ; j++) {  			Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  			shapeIndex++;  			// using motionstate is recommended' it provides interpolation capabilities  			// and only synchronizes 'active' objects  			rbInfo.MotionState = new DefaultMotionState (startTransform);  			rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  			RigidBody body = new RigidBody (rbInfo);  			body.Friction = 1;  			body.RollingFriction = 0.3f;  			body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  			World.AddRigidBody (body);  		}  	}  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int k = 0; k < ArraySizeY; k++) {  	for (int i = 0; i < ArraySizeX; i++) {  		for (int j = 0; j < ArraySizeZ; j++) {  			Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  			shapeIndex++;  			// using motionstate is recommended' it provides interpolation capabilities  			// and only synchronizes 'active' objects  			rbInfo.MotionState = new DefaultMotionState (startTransform);  			rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  			RigidBody body = new RigidBody (rbInfo);  			body.Friction = 1;  			body.RollingFriction = 0.3f;  			body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  			World.AddRigidBody (body);  		}  	}  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int k = 0; k < ArraySizeY; k++) {  	for (int i = 0; i < ArraySizeX; i++) {  		for (int j = 0; j < ArraySizeZ; j++) {  			Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  			shapeIndex++;  			// using motionstate is recommended' it provides interpolation capabilities  			// and only synchronizes 'active' objects  			rbInfo.MotionState = new DefaultMotionState (startTransform);  			rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  			RigidBody body = new RigidBody (rbInfo);  			body.Friction = 1;  			body.RollingFriction = 0.3f;  			body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  			World.AddRigidBody (body);  		}  	}  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int i = 0; i < ArraySizeX; i++) {  	for (int j = 0; j < ArraySizeZ; j++) {  		Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  		shapeIndex++;  		// using motionstate is recommended' it provides interpolation capabilities  		// and only synchronizes 'active' objects  		rbInfo.MotionState = new DefaultMotionState (startTransform);  		rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  		RigidBody body = new RigidBody (rbInfo);  		body.Friction = 1;  		body.RollingFriction = 0.3f;  		body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  		World.AddRigidBody (body);  	}  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int i = 0; i < ArraySizeX; i++) {  	for (int j = 0; j < ArraySizeZ; j++) {  		Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  		shapeIndex++;  		// using motionstate is recommended' it provides interpolation capabilities  		// and only synchronizes 'active' objects  		rbInfo.MotionState = new DefaultMotionState (startTransform);  		rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  		RigidBody body = new RigidBody (rbInfo);  		body.Friction = 1;  		body.RollingFriction = 0.3f;  		body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  		World.AddRigidBody (body);  	}  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int i = 0; i < ArraySizeX; i++) {  	for (int j = 0; j < ArraySizeZ; j++) {  		Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  		shapeIndex++;  		// using motionstate is recommended' it provides interpolation capabilities  		// and only synchronizes 'active' objects  		rbInfo.MotionState = new DefaultMotionState (startTransform);  		rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  		RigidBody body = new RigidBody (rbInfo);  		body.Friction = 1;  		body.RollingFriction = 0.3f;  		body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  		World.AddRigidBody (body);  	}  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int i = 0; i < ArraySizeX; i++) {  	for (int j = 0; j < ArraySizeZ; j++) {  		Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  		shapeIndex++;  		// using motionstate is recommended' it provides interpolation capabilities  		// and only synchronizes 'active' objects  		rbInfo.MotionState = new DefaultMotionState (startTransform);  		rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  		RigidBody body = new RigidBody (rbInfo);  		body.Friction = 1;  		body.RollingFriction = 0.3f;  		body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  		World.AddRigidBody (body);  	}  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int j = 0; j < ArraySizeZ; j++) {  	Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  	shapeIndex++;  	// using motionstate is recommended' it provides interpolation capabilities  	// and only synchronizes 'active' objects  	rbInfo.MotionState = new DefaultMotionState (startTransform);  	rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  	RigidBody body = new RigidBody (rbInfo);  	body.Friction = 1;  	body.RollingFriction = 0.3f;  	body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  	World.AddRigidBody (body);  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int j = 0; j < ArraySizeZ; j++) {  	Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  	shapeIndex++;  	// using motionstate is recommended' it provides interpolation capabilities  	// and only synchronizes 'active' objects  	rbInfo.MotionState = new DefaultMotionState (startTransform);  	rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  	RigidBody body = new RigidBody (rbInfo);  	body.Friction = 1;  	body.RollingFriction = 0.3f;  	body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  	World.AddRigidBody (body);  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int j = 0; j < ArraySizeZ; j++) {  	Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  	shapeIndex++;  	// using motionstate is recommended' it provides interpolation capabilities  	// and only synchronizes 'active' objects  	rbInfo.MotionState = new DefaultMotionState (startTransform);  	rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  	RigidBody body = new RigidBody (rbInfo);  	body.Friction = 1;  	body.RollingFriction = 0.3f;  	body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  	World.AddRigidBody (body);  }  
Magic Number,RollingFrictionDemo,RollingFrictionDemo,F:\newReposMay17\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int j = 0; j < ArraySizeZ; j++) {  	Matrix startTransform = Matrix.Translation (2 * i + startX' 2 * k + startY + 20' 2 * j + startZ);  	shapeIndex++;  	// using motionstate is recommended' it provides interpolation capabilities  	// and only synchronizes 'active' objects  	rbInfo.MotionState = new DefaultMotionState (startTransform);  	rbInfo.CollisionShape = colShapes [shapeIndex % colShapes.Length];  	RigidBody body = new RigidBody (rbInfo);  	body.Friction = 1;  	body.RollingFriction = 0.3f;  	body.SetAnisotropicFriction (colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);  	World.AddRigidBody (body);  }  
