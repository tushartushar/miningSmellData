Implementation smell,Namespace,Class,File,Method,Description
Long Statement,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The length of the statement  "                        body.SetAnisotropicFriction(colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction); " is 127.
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitialize,The following statement contains a magic number: Freelook.Eye = new Vector3(10' 10' 40);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitialize,The following statement contains a magic number: Freelook.Eye = new Vector3(10' 10' 40);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitialize,The following statement contains a magic number: Freelook.Eye = new Vector3(10' 10' 40);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitialize,The following statement contains a magic number: Freelook.Target = new Vector3(0' 5' -4);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitialize,The following statement contains a magic number: Freelook.Target = new Vector3(0' 5' -4);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: World.Gravity = new Vector3(0' -10' 0);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: CollisionShape groundShape = new BoxShape(20' 50' 10);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: CollisionShape groundShape = new BoxShape(20' 50' 10);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: CollisionShape groundShape = new BoxShape(20' 50' 10);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: CollisionObject ground = LocalCreateRigidBody(0'                  Matrix.RotationAxis(new Vector3(0' 0' 1)' (float)Math.PI * 0.03f) * Matrix.Translation(0' -50' 0)'                  groundShape);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: groundShape = new BoxShape(100' 50' 100);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: groundShape = new BoxShape(100' 50' 100);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: groundShape = new BoxShape(100' 50' 100);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: ground = LocalCreateRigidBody(0' Matrix.Translation(0' -54' 0)' groundShape);
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: const float startX = StartPosX - ArraySizeX / 2;
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: const float startZ = StartPosZ - ArraySizeZ / 2;
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int k = 0; k < ArraySizeY; k++)              {                  for (int i = 0; i < ArraySizeX; i++)                  {                      for (int j = 0; j < ArraySizeZ; j++)                      {                          Matrix startTransform = Matrix.Translation(                              2 * i + startX'                              2 * k + startY + 20'                              2 * j + startZ                          );                          shapeIndex++;                            // using motionstate is recommended' it provides interpolation capabilities                          // and only synchronizes 'active' objects                          rbInfo.MotionState = new DefaultMotionState(startTransform);                          rbInfo.CollisionShape = colShapes[shapeIndex % colShapes.Length];                            RigidBody body = new RigidBody(rbInfo);                          body.Friction = 1;                          body.RollingFriction = 0.3f;                          body.SetAnisotropicFriction(colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);                            World.AddRigidBody(body);                      }                  }              }
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int k = 0; k < ArraySizeY; k++)              {                  for (int i = 0; i < ArraySizeX; i++)                  {                      for (int j = 0; j < ArraySizeZ; j++)                      {                          Matrix startTransform = Matrix.Translation(                              2 * i + startX'                              2 * k + startY + 20'                              2 * j + startZ                          );                          shapeIndex++;                            // using motionstate is recommended' it provides interpolation capabilities                          // and only synchronizes 'active' objects                          rbInfo.MotionState = new DefaultMotionState(startTransform);                          rbInfo.CollisionShape = colShapes[shapeIndex % colShapes.Length];                            RigidBody body = new RigidBody(rbInfo);                          body.Friction = 1;                          body.RollingFriction = 0.3f;                          body.SetAnisotropicFriction(colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);                            World.AddRigidBody(body);                      }                  }              }
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int k = 0; k < ArraySizeY; k++)              {                  for (int i = 0; i < ArraySizeX; i++)                  {                      for (int j = 0; j < ArraySizeZ; j++)                      {                          Matrix startTransform = Matrix.Translation(                              2 * i + startX'                              2 * k + startY + 20'                              2 * j + startZ                          );                          shapeIndex++;                            // using motionstate is recommended' it provides interpolation capabilities                          // and only synchronizes 'active' objects                          rbInfo.MotionState = new DefaultMotionState(startTransform);                          rbInfo.CollisionShape = colShapes[shapeIndex % colShapes.Length];                            RigidBody body = new RigidBody(rbInfo);                          body.Friction = 1;                          body.RollingFriction = 0.3f;                          body.SetAnisotropicFriction(colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);                            World.AddRigidBody(body);                      }                  }              }
Magic Number,RollingFrictionDemo,RollingFrictionDemo,C:\repos\AndresTraks_BulletSharp\demos\Generic\RollingFrictionDemo\RollingFrictionDemo.cs,OnInitializePhysics,The following statement contains a magic number: for (int k = 0; k < ArraySizeY; k++)              {                  for (int i = 0; i < ArraySizeX; i++)                  {                      for (int j = 0; j < ArraySizeZ; j++)                      {                          Matrix startTransform = Matrix.Translation(                              2 * i + startX'                              2 * k + startY + 20'                              2 * j + startZ                          );                          shapeIndex++;                            // using motionstate is recommended' it provides interpolation capabilities                          // and only synchronizes 'active' objects                          rbInfo.MotionState = new DefaultMotionState(startTransform);                          rbInfo.CollisionShape = colShapes[shapeIndex % colShapes.Length];                            RigidBody body = new RigidBody(rbInfo);                          body.Friction = 1;                          body.RollingFriction = 0.3f;                          body.SetAnisotropicFriction(colShape.AnisotropicRollingFrictionDirection' AnisotropicFrictionFlags.AnisotropicRollingFriction);                            World.AddRigidBody(body);                      }                  }              }
