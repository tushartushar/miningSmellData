Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Trader.Domain.Infrastucture,LogEntry,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Infrastucture\LogEntry.cs,LogEntry,The method has 7 parameters. Parameters: counter' message' loggerName' threadName' timeStamp' level' exception
Long Parameter List,Trader.Domain.Model,CurrencyPair,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Model\CurrencyPair.cs,CurrencyPair,The method has 5 parameters. Parameters: code' startingPrice' decimalPlaces' tickFrequency' defaultSpread
Long Parameter List,Trader.Domain.Model,Trade,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Model\Trade.cs,Trade,The method has 9 parameters. Parameters: id' customer' currencyPair' status' buyOrSell' tradePrice' amount' marketPrice' timeStamp
Long Statement,Trader.Domain.Infrastucture,LogEntry,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Infrastucture\LogEntry.cs,ToString,The length of the statement  "            return $"Level: {Level}' ThreadName: {ThreadName}' LoggerName: {LoggerName}' Message: {Message}' TimeStamp: {TimeStamp}"; " is 121.
Long Statement,Trader.Domain.Services,Notification,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\INotificationPublisher.cs,Equals,The length of the statement  "            return _type == other._type && _timeStamp.Equals(other._timeStamp) && string.Equals(_category' other._category) && string.Equals(_message' other._message); " is 155.
Long Statement,Trader.Domain.Services,TradeService,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeService.cs,GenerateTradesAndMaintainCache,The length of the statement  "                    .ExpireAfter(t => t.Status == TradeStatus.Closed ? TimeSpan.FromMinutes(1) : (TimeSpan?)null' TimeSpan.FromMinutes(1)' _schedulerProvider.Background) " is 149.
Magic Number,System,Extensions,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Infrastucture\Extensions.cs,NextBoolean,The following statement contains a magic number: return source.NextDouble() > 0.5;
Magic Number,System.Collections.Generic,Extensions,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Infrastucture\Extensions.cs,NextBoolean,The following statement contains a magic number: return source.NextDouble() > 0.5;
Magic Number,Trader.Domain.Infrastucture,LogEntrySummary,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Infrastucture\LogEntrySummary.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Error;                  hashCode = (hashCode * 397) ^ Warning;                  hashCode = (hashCode * 397) ^ Info;                  hashCode = (hashCode * 397) ^ Debug;                  return hashCode;              }
Magic Number,Trader.Domain.Infrastucture,LogEntrySummary,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Infrastucture\LogEntrySummary.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Error;                  hashCode = (hashCode * 397) ^ Warning;                  hashCode = (hashCode * 397) ^ Info;                  hashCode = (hashCode * 397) ^ Debug;                  return hashCode;              }
Magic Number,Trader.Domain.Infrastucture,LogEntrySummary,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Infrastucture\LogEntrySummary.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Error;                  hashCode = (hashCode * 397) ^ Warning;                  hashCode = (hashCode * 397) ^ Info;                  hashCode = (hashCode * 397) ^ Debug;                  return hashCode;              }
Magic Number,Trader.Domain.Model,CurrencyPair,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Model\CurrencyPair.cs,CurrencyPair,The following statement contains a magic number: PipSize = (decimal)Math.Pow(10' -decimalPlaces);
Magic Number,Trader.Domain.Model,MarketData,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Model\MarketData.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = (Instrument != null ? Instrument.GetHashCode() : 0);                  hashCode = (hashCode * 397) ^ Bid.GetHashCode();                  hashCode = (hashCode * 397) ^ Offer.GetHashCode();                  return hashCode;              }
Magic Number,Trader.Domain.Model,MarketData,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Model\MarketData.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = (Instrument != null ? Instrument.GetHashCode() : 0);                  hashCode = (hashCode * 397) ^ Bid.GetHashCode();                  hashCode = (hashCode * 397) ^ Offer.GetHashCode();                  return hashCode;              }
Magic Number,Trader.Domain.Model,SortParameterData,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Model\SortParameterData.cs,SortParameterData,The following statement contains a magic number: SelectedItem = _sortItems[2];
Magic Number,Trader.Domain.Model,Trade,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Model\Trade.cs,SetMarketPrice,The following statement contains a magic number: PercentFromMarket = Math.Round(((TradePrice - MarketPrice) / MarketPrice) * 100' 4);
Magic Number,Trader.Domain.Model,Trade,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Model\Trade.cs,SetMarketPrice,The following statement contains a magic number: PercentFromMarket = Math.Round(((TradePrice - MarketPrice) / MarketPrice) * 100' 4);
Magic Number,Trader.Domain.Model,TradeProxy,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Model\TradeProxy.cs,TradeProxy,The following statement contains a magic number: var isRecent = DateTime.Now.Subtract(trade.Timestamp).TotalSeconds < 2;
Magic Number,Trader.Domain.Model,TradeProxy,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Model\TradeProxy.cs,TradeProxy,The following statement contains a magic number: if (isRecent)              {                  Recent = true;                  recentIndicator = Observable.Timer(TimeSpan.FromSeconds(2))                      .Subscribe(_ => Recent = false);              }
Magic Number,Trader.Domain.Services,Notification,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\INotificationPublisher.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = (int) _type;                  hashCode = (hashCode*397) ^ _timeStamp.GetHashCode();                  hashCode = (hashCode*397) ^ (_category != null ? _category.GetHashCode() : 0);                  hashCode = (hashCode*397) ^ (_message != null ? _message.GetHashCode() : 0);                  return hashCode;              }
Magic Number,Trader.Domain.Services,Notification,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\INotificationPublisher.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = (int) _type;                  hashCode = (hashCode*397) ^ _timeStamp.GetHashCode();                  hashCode = (hashCode*397) ^ (_category != null ? _category.GetHashCode() : 0);                  hashCode = (hashCode*397) ^ (_message != null ? _message.GetHashCode() : 0);                  return hashCode;              }
Magic Number,Trader.Domain.Services,Notification,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\INotificationPublisher.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = (int) _type;                  hashCode = (hashCode*397) ^ _timeStamp.GetHashCode();                  hashCode = (hashCode*397) ^ (_category != null ? _category.GetHashCode() : 0);                  hashCode = (hashCode*397) ^ (_message != null ? _message.GetHashCode() : 0);                  return hashCode;              }
Magic Number,Trader.Domain.Services,LogEntryService,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\LogEntryService.cs,LogEntryService,The following statement contains a magic number: var loader = ReactiveLogAppender.LogEntryObservable                              .Buffer(TimeSpan.FromMilliseconds(250))                              .Synchronize(_locker)                              .Subscribe(_source.AddRange);
Magic Number,Trader.Domain.Services,LogEntryService,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\LogEntryService.cs,LogEntryService,The following statement contains a magic number: var sizeLimiter = _source.LimitSizeTo(10000).Subscribe();
Magic Number,Trader.Domain.Services,MarketDataService,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\MarketDataService.cs,GenerateStream,The following statement contains a magic number: return Observable.Create<MarketData>(observer =>              {                  var spread = currencyPair.DefaultSpread;                  var midRate = currencyPair.InitialPrice;                  var bid = midRate - (spread * currencyPair.PipSize);                  var offer = midRate + (spread * currencyPair.PipSize);                  var initial = new MarketData(currencyPair.Code' bid' offer);                    var currentPrice = initial;                  observer.OnNext(initial);                    var random = new Random();                      //for a given period' move prices by up to 5 pips                  return Observable.Interval(TimeSpan.FromSeconds(1 / (double)currencyPair.TickFrequency))                      .Select(_ => random.Next(1' 5))                      .Subscribe(pips =>                      {                          //move up or down between 1 and 5 pips                          var adjustment = Math.Round(pips * currencyPair.PipSize' currencyPair.DecimalPlaces);                          currentPrice = random.NextDouble() > 0.5                                          ? currentPrice + adjustment                                          : currentPrice - adjustment;                          observer.OnNext(currentPrice);                        });              });
Magic Number,Trader.Domain.Services,MarketDataService,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\MarketDataService.cs,GenerateStream,The following statement contains a magic number: return Observable.Create<MarketData>(observer =>              {                  var spread = currencyPair.DefaultSpread;                  var midRate = currencyPair.InitialPrice;                  var bid = midRate - (spread * currencyPair.PipSize);                  var offer = midRate + (spread * currencyPair.PipSize);                  var initial = new MarketData(currencyPair.Code' bid' offer);                    var currentPrice = initial;                  observer.OnNext(initial);                    var random = new Random();                      //for a given period' move prices by up to 5 pips                  return Observable.Interval(TimeSpan.FromSeconds(1 / (double)currencyPair.TickFrequency))                      .Select(_ => random.Next(1' 5))                      .Subscribe(pips =>                      {                          //move up or down between 1 and 5 pips                          var adjustment = Math.Round(pips * currencyPair.PipSize' currencyPair.DecimalPlaces);                          currentPrice = random.NextDouble() > 0.5                                          ? currentPrice + adjustment                                          : currentPrice - adjustment;                          observer.OnNext(currentPrice);                        });              });
Magic Number,Trader.Domain.Services,NearToMarketService,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\NearToMarketService.cs,Query,The following statement contains a magic number: return Observable.Create<IChangeSet<Trade' long>>                  (observer =>                   {                       var locker = new object();                         bool Predicate(Trade t) => Math.Abs(t.PercentFromMarket) <= percentFromMarket();                         //re-evaluate filter periodically                       var reevaluator = Observable.Interval(TimeSpan.FromMilliseconds(250))                           .Synchronize(locker)                           .Select(_ => (Func<Trade' bool>) Predicate)                           .StartWith((Func<Trade' bool>) Predicate); ;                         //filter on live trades matching % specified                       return _tradeService.All.Connect(trade => trade.Status == TradeStatus.Live)                           .Synchronize(locker)                           .Filter(reevaluator)                           .Do(_ => { }' ex => _logger.Error(ex' ex.Message))                           .SubscribeSafe(observer);                   });
Magic Number,Trader.Domain.Services,TradeGenerator,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeGenerator.cs,Generate,The following statement contains a magic number: Trade NewTrade()              {                  var id = _counter++;                  var bank = _staticData.Customers[_random.Next(0' _staticData.Customers.Length)];                  var pair = _staticData.CurrencyPairs[_random.Next(0' _staticData.CurrencyPairs.Length)];                  var amount = (_random.Next(1' 2000) / 2) * (10 ^ _random.Next(1' 5));                  var buySell = _random.NextBoolean() ? BuyOrSell.Buy : BuyOrSell.Sell;                    if (initialLoad)                  {                      var status = _random.NextDouble() > 0.5 ? TradeStatus.Live : TradeStatus.Closed;                      var seconds = _random.Next(1' 60 * 60 * 24);                      var time = DateTime.Now.AddSeconds(-seconds);                      return new Trade(id' bank' pair.Code' status' buySell' GererateRandomPrice(pair' buySell)' amount' timeStamp: time);                  }                  return new Trade(id' bank' pair.Code' TradeStatus.Live' buySell' GererateRandomPrice(pair' buySell)' amount);              }
Magic Number,Trader.Domain.Services,TradeGenerator,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeGenerator.cs,Generate,The following statement contains a magic number: Trade NewTrade()              {                  var id = _counter++;                  var bank = _staticData.Customers[_random.Next(0' _staticData.Customers.Length)];                  var pair = _staticData.CurrencyPairs[_random.Next(0' _staticData.CurrencyPairs.Length)];                  var amount = (_random.Next(1' 2000) / 2) * (10 ^ _random.Next(1' 5));                  var buySell = _random.NextBoolean() ? BuyOrSell.Buy : BuyOrSell.Sell;                    if (initialLoad)                  {                      var status = _random.NextDouble() > 0.5 ? TradeStatus.Live : TradeStatus.Closed;                      var seconds = _random.Next(1' 60 * 60 * 24);                      var time = DateTime.Now.AddSeconds(-seconds);                      return new Trade(id' bank' pair.Code' status' buySell' GererateRandomPrice(pair' buySell)' amount' timeStamp: time);                  }                  return new Trade(id' bank' pair.Code' TradeStatus.Live' buySell' GererateRandomPrice(pair' buySell)' amount);              }
Magic Number,Trader.Domain.Services,TradeGenerator,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeGenerator.cs,Generate,The following statement contains a magic number: Trade NewTrade()              {                  var id = _counter++;                  var bank = _staticData.Customers[_random.Next(0' _staticData.Customers.Length)];                  var pair = _staticData.CurrencyPairs[_random.Next(0' _staticData.CurrencyPairs.Length)];                  var amount = (_random.Next(1' 2000) / 2) * (10 ^ _random.Next(1' 5));                  var buySell = _random.NextBoolean() ? BuyOrSell.Buy : BuyOrSell.Sell;                    if (initialLoad)                  {                      var status = _random.NextDouble() > 0.5 ? TradeStatus.Live : TradeStatus.Closed;                      var seconds = _random.Next(1' 60 * 60 * 24);                      var time = DateTime.Now.AddSeconds(-seconds);                      return new Trade(id' bank' pair.Code' status' buySell' GererateRandomPrice(pair' buySell)' amount' timeStamp: time);                  }                  return new Trade(id' bank' pair.Code' TradeStatus.Live' buySell' GererateRandomPrice(pair' buySell)' amount);              }
Magic Number,Trader.Domain.Services,TradeGenerator,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeGenerator.cs,Generate,The following statement contains a magic number: Trade NewTrade()              {                  var id = _counter++;                  var bank = _staticData.Customers[_random.Next(0' _staticData.Customers.Length)];                  var pair = _staticData.CurrencyPairs[_random.Next(0' _staticData.CurrencyPairs.Length)];                  var amount = (_random.Next(1' 2000) / 2) * (10 ^ _random.Next(1' 5));                  var buySell = _random.NextBoolean() ? BuyOrSell.Buy : BuyOrSell.Sell;                    if (initialLoad)                  {                      var status = _random.NextDouble() > 0.5 ? TradeStatus.Live : TradeStatus.Closed;                      var seconds = _random.Next(1' 60 * 60 * 24);                      var time = DateTime.Now.AddSeconds(-seconds);                      return new Trade(id' bank' pair.Code' status' buySell' GererateRandomPrice(pair' buySell)' amount' timeStamp: time);                  }                  return new Trade(id' bank' pair.Code' TradeStatus.Live' buySell' GererateRandomPrice(pair' buySell)' amount);              }
Magic Number,Trader.Domain.Services,TradeGenerator,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeGenerator.cs,Generate,The following statement contains a magic number: Trade NewTrade()              {                  var id = _counter++;                  var bank = _staticData.Customers[_random.Next(0' _staticData.Customers.Length)];                  var pair = _staticData.CurrencyPairs[_random.Next(0' _staticData.CurrencyPairs.Length)];                  var amount = (_random.Next(1' 2000) / 2) * (10 ^ _random.Next(1' 5));                  var buySell = _random.NextBoolean() ? BuyOrSell.Buy : BuyOrSell.Sell;                    if (initialLoad)                  {                      var status = _random.NextDouble() > 0.5 ? TradeStatus.Live : TradeStatus.Closed;                      var seconds = _random.Next(1' 60 * 60 * 24);                      var time = DateTime.Now.AddSeconds(-seconds);                      return new Trade(id' bank' pair.Code' status' buySell' GererateRandomPrice(pair' buySell)' amount' timeStamp: time);                  }                  return new Trade(id' bank' pair.Code' TradeStatus.Live' buySell' GererateRandomPrice(pair' buySell)' amount);              }
Magic Number,Trader.Domain.Services,TradeGenerator,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeGenerator.cs,Generate,The following statement contains a magic number: Trade NewTrade()              {                  var id = _counter++;                  var bank = _staticData.Customers[_random.Next(0' _staticData.Customers.Length)];                  var pair = _staticData.CurrencyPairs[_random.Next(0' _staticData.CurrencyPairs.Length)];                  var amount = (_random.Next(1' 2000) / 2) * (10 ^ _random.Next(1' 5));                  var buySell = _random.NextBoolean() ? BuyOrSell.Buy : BuyOrSell.Sell;                    if (initialLoad)                  {                      var status = _random.NextDouble() > 0.5 ? TradeStatus.Live : TradeStatus.Closed;                      var seconds = _random.Next(1' 60 * 60 * 24);                      var time = DateTime.Now.AddSeconds(-seconds);                      return new Trade(id' bank' pair.Code' status' buySell' GererateRandomPrice(pair' buySell)' amount' timeStamp: time);                  }                  return new Trade(id' bank' pair.Code' TradeStatus.Live' buySell' GererateRandomPrice(pair' buySell)' amount);              }
Magic Number,Trader.Domain.Services,TradeGenerator,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeGenerator.cs,Generate,The following statement contains a magic number: Trade NewTrade()              {                  var id = _counter++;                  var bank = _staticData.Customers[_random.Next(0' _staticData.Customers.Length)];                  var pair = _staticData.CurrencyPairs[_random.Next(0' _staticData.CurrencyPairs.Length)];                  var amount = (_random.Next(1' 2000) / 2) * (10 ^ _random.Next(1' 5));                  var buySell = _random.NextBoolean() ? BuyOrSell.Buy : BuyOrSell.Sell;                    if (initialLoad)                  {                      var status = _random.NextDouble() > 0.5 ? TradeStatus.Live : TradeStatus.Closed;                      var seconds = _random.Next(1' 60 * 60 * 24);                      var time = DateTime.Now.AddSeconds(-seconds);                      return new Trade(id' bank' pair.Code' status' buySell' GererateRandomPrice(pair' buySell)' amount' timeStamp: time);                  }                  return new Trade(id' bank' pair.Code' TradeStatus.Live' buySell' GererateRandomPrice(pair' buySell)' amount);              }
Magic Number,Trader.Domain.Services,TradeGenerator,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeGenerator.cs,Generate,The following statement contains a magic number: Trade NewTrade()              {                  var id = _counter++;                  var bank = _staticData.Customers[_random.Next(0' _staticData.Customers.Length)];                  var pair = _staticData.CurrencyPairs[_random.Next(0' _staticData.CurrencyPairs.Length)];                  var amount = (_random.Next(1' 2000) / 2) * (10 ^ _random.Next(1' 5));                  var buySell = _random.NextBoolean() ? BuyOrSell.Buy : BuyOrSell.Sell;                    if (initialLoad)                  {                      var status = _random.NextDouble() > 0.5 ? TradeStatus.Live : TradeStatus.Closed;                      var seconds = _random.Next(1' 60 * 60 * 24);                      var time = DateTime.Now.AddSeconds(-seconds);                      return new Trade(id' bank' pair.Code' status' buySell' GererateRandomPrice(pair' buySell)' amount' timeStamp: time);                  }                  return new Trade(id' bank' pair.Code' TradeStatus.Live' buySell' GererateRandomPrice(pair' buySell)' amount);              }
Magic Number,Trader.Domain.Services,TradeGenerator,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeGenerator.cs,GererateRandomPrice,The following statement contains a magic number: var pipsFromMarket = _random.Next(1' 100);
Magic Number,Trader.Domain.Services,TradeService,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeService.cs,GenerateTradesAndMaintainCache,The following statement contains a magic number: return ObservableChangeSet.Create<Trade' long>(cache =>              {                  /*                      The following code emulates an external trade provider.                       Alternatively you can use "new SourceCacheTrade' long>(t=>t.Id)" and manually maintain the cache.                        For examples of creating a observable change sets' see https://github.com/RolandPheasant/DynamicData.Snippets                  */                    //bit of code to generate trades                  var random = new Random();                    //initally load some trades                   cache.AddOrUpdate(_tradeGenerator.Generate(5_000' true));                    TimeSpan RandomInterval() => TimeSpan.FromMilliseconds(random.Next(2500' 5000));                      // create a random number of trades at a random interval                  var tradeGenerator = _schedulerProvider.Background                      .ScheduleRecurringAction(RandomInterval' () =>                      {                          var number = random.Next(1' 5);                          var trades = _tradeGenerator.Generate(number);                          cache.AddOrUpdate(trades);                      });                    // close a random number of trades at a random interval                  var tradeCloser = _schedulerProvider.Background                      .ScheduleRecurringAction(RandomInterval' () =>                      {                          var number = random.Next(1' 2);                          cache.Edit(innerCache =>                          {                              var trades = innerCache.Items                                  .Where(trade => trade.Status == TradeStatus.Live)                                  .OrderBy(t => Guid.NewGuid()).Take(number).ToArray();                                var toClose = trades.Select(trade => new Trade(trade' TradeStatus.Closed));                                cache.AddOrUpdate(toClose);                          });                      });                    //expire closed items from the cache to avoid unbounded data                  var expirer = cache                      .ExpireAfter(t => t.Status == TradeStatus.Closed ? TimeSpan.FromMinutes(1) : (TimeSpan?)null' TimeSpan.FromMinutes(1)' _schedulerProvider.Background)                      .Subscribe(x => _logger.Info("{0} filled trades have been removed from memory"' x.Count()));                    return new CompositeDisposable(tradeGenerator' tradeCloser' expirer);              }' trade=>trade.Id);
Magic Number,Trader.Domain.Services,TradeService,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeService.cs,GenerateTradesAndMaintainCache,The following statement contains a magic number: return ObservableChangeSet.Create<Trade' long>(cache =>              {                  /*                      The following code emulates an external trade provider.                       Alternatively you can use "new SourceCacheTrade' long>(t=>t.Id)" and manually maintain the cache.                        For examples of creating a observable change sets' see https://github.com/RolandPheasant/DynamicData.Snippets                  */                    //bit of code to generate trades                  var random = new Random();                    //initally load some trades                   cache.AddOrUpdate(_tradeGenerator.Generate(5_000' true));                    TimeSpan RandomInterval() => TimeSpan.FromMilliseconds(random.Next(2500' 5000));                      // create a random number of trades at a random interval                  var tradeGenerator = _schedulerProvider.Background                      .ScheduleRecurringAction(RandomInterval' () =>                      {                          var number = random.Next(1' 5);                          var trades = _tradeGenerator.Generate(number);                          cache.AddOrUpdate(trades);                      });                    // close a random number of trades at a random interval                  var tradeCloser = _schedulerProvider.Background                      .ScheduleRecurringAction(RandomInterval' () =>                      {                          var number = random.Next(1' 2);                          cache.Edit(innerCache =>                          {                              var trades = innerCache.Items                                  .Where(trade => trade.Status == TradeStatus.Live)                                  .OrderBy(t => Guid.NewGuid()).Take(number).ToArray();                                var toClose = trades.Select(trade => new Trade(trade' TradeStatus.Closed));                                cache.AddOrUpdate(toClose);                          });                      });                    //expire closed items from the cache to avoid unbounded data                  var expirer = cache                      .ExpireAfter(t => t.Status == TradeStatus.Closed ? TimeSpan.FromMinutes(1) : (TimeSpan?)null' TimeSpan.FromMinutes(1)' _schedulerProvider.Background)                      .Subscribe(x => _logger.Info("{0} filled trades have been removed from memory"' x.Count()));                    return new CompositeDisposable(tradeGenerator' tradeCloser' expirer);              }' trade=>trade.Id);
Magic Number,Trader.Domain.Services,TradeService,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeService.cs,GenerateTradesAndMaintainCache,The following statement contains a magic number: return ObservableChangeSet.Create<Trade' long>(cache =>              {                  /*                      The following code emulates an external trade provider.                       Alternatively you can use "new SourceCacheTrade' long>(t=>t.Id)" and manually maintain the cache.                        For examples of creating a observable change sets' see https://github.com/RolandPheasant/DynamicData.Snippets                  */                    //bit of code to generate trades                  var random = new Random();                    //initally load some trades                   cache.AddOrUpdate(_tradeGenerator.Generate(5_000' true));                    TimeSpan RandomInterval() => TimeSpan.FromMilliseconds(random.Next(2500' 5000));                      // create a random number of trades at a random interval                  var tradeGenerator = _schedulerProvider.Background                      .ScheduleRecurringAction(RandomInterval' () =>                      {                          var number = random.Next(1' 5);                          var trades = _tradeGenerator.Generate(number);                          cache.AddOrUpdate(trades);                      });                    // close a random number of trades at a random interval                  var tradeCloser = _schedulerProvider.Background                      .ScheduleRecurringAction(RandomInterval' () =>                      {                          var number = random.Next(1' 2);                          cache.Edit(innerCache =>                          {                              var trades = innerCache.Items                                  .Where(trade => trade.Status == TradeStatus.Live)                                  .OrderBy(t => Guid.NewGuid()).Take(number).ToArray();                                var toClose = trades.Select(trade => new Trade(trade' TradeStatus.Closed));                                cache.AddOrUpdate(toClose);                          });                      });                    //expire closed items from the cache to avoid unbounded data                  var expirer = cache                      .ExpireAfter(t => t.Status == TradeStatus.Closed ? TimeSpan.FromMinutes(1) : (TimeSpan?)null' TimeSpan.FromMinutes(1)' _schedulerProvider.Background)                      .Subscribe(x => _logger.Info("{0} filled trades have been removed from memory"' x.Count()));                    return new CompositeDisposable(tradeGenerator' tradeCloser' expirer);              }' trade=>trade.Id);
Magic Number,Trader.Domain.Services,TradeService,C:\repos\RolandPheasant_TradingDemo\Trader.Domain\Services\TradeService.cs,GenerateTradesAndMaintainCache,The following statement contains a magic number: return ObservableChangeSet.Create<Trade' long>(cache =>              {                  /*                      The following code emulates an external trade provider.                       Alternatively you can use "new SourceCacheTrade' long>(t=>t.Id)" and manually maintain the cache.                        For examples of creating a observable change sets' see https://github.com/RolandPheasant/DynamicData.Snippets                  */                    //bit of code to generate trades                  var random = new Random();                    //initally load some trades                   cache.AddOrUpdate(_tradeGenerator.Generate(5_000' true));                    TimeSpan RandomInterval() => TimeSpan.FromMilliseconds(random.Next(2500' 5000));                      // create a random number of trades at a random interval                  var tradeGenerator = _schedulerProvider.Background                      .ScheduleRecurringAction(RandomInterval' () =>                      {                          var number = random.Next(1' 5);                          var trades = _tradeGenerator.Generate(number);                          cache.AddOrUpdate(trades);                      });                    // close a random number of trades at a random interval                  var tradeCloser = _schedulerProvider.Background                      .ScheduleRecurringAction(RandomInterval' () =>                      {                          var number = random.Next(1' 2);                          cache.Edit(innerCache =>                          {                              var trades = innerCache.Items                                  .Where(trade => trade.Status == TradeStatus.Live)                                  .OrderBy(t => Guid.NewGuid()).Take(number).ToArray();                                var toClose = trades.Select(trade => new Trade(trade' TradeStatus.Closed));                                cache.AddOrUpdate(toClose);                          });                      });                    //expire closed items from the cache to avoid unbounded data                  var expirer = cache                      .ExpireAfter(t => t.Status == TradeStatus.Closed ? TimeSpan.FromMinutes(1) : (TimeSpan?)null' TimeSpan.FromMinutes(1)' _schedulerProvider.Background)                      .Subscribe(x => _logger.Info("{0} filled trades have been removed from memory"' x.Count()));                    return new CompositeDisposable(tradeGenerator' tradeCloser' expirer);              }' trade=>trade.Id);
