Implementation smell,Namespace,Class,File,Method,Description
Complex Method,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,WndProc,Cyclomatic complexity of the method is 8
Complex Method,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ProcessEvent,Cyclomatic complexity of the method is 11
Complex Method,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,Cyclomatic complexity of the method is 17
Complex Method,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,PutAudioData,Cyclomatic complexity of the method is 9
Long Statement,SignalAnalyzer2,ChooseDevice,C:\repos\spark-div_signalanalyzer2\source\ChooseDevice.cs,enumrateDevs,The length of the statement  "		/* Get info about the next device */if (WaveInput.waveInGetDevCapsA ((Int32)i' ref woc' System.Runtime.InteropServices.Marshal.SizeOf (woc)) == WaveConstants.MMSYSERR_NOERROR) { " is 177.
Long Statement,SignalAnalyzer2,SamplesSummator,C:\repos\spark-div_signalanalyzer2\source\SamplesSummator.cs,computeDigest,The length of the statement  "	double digest = currentSpectrumSum [idx_995Hz] + currentSpectrumSum [idx_995Hz + 1] + currentSpectrumSum [idx_995Hz + 1] + currentSpectrumSum [idx_995Hz + 1] + currentSpectrumSum [idx_995Hz + 1]; " is 195.
Long Statement,SignalAnalyzer2,SamplesSummator,C:\repos\spark-div_signalanalyzer2\source\SamplesSummator.cs,computeDelta,The length of the statement  "	double digest = currentSpectrumSum [idx_995Hz] + currentSpectrumSum [idx_995Hz + 1] + currentSpectrumSum [idx_995Hz + 1] + currentSpectrumSum [idx_995Hz + 1] + currentSpectrumSum [idx_995Hz + 1]; " is 195.
Long Statement,NAudio.Gui,VolumeMeter,C:\repos\spark-div_signalanalyzer2\source\VolumeMeter.cs,OnForeColorChanged,The length of the statement  "	brGradient = new LinearGradientBrush (new Rectangle (0' 0' this.Width - 1' this.Height - 1)' Color.Green' Color.Red' 90' false); " is 128.
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,SygnalAnalyzerForm,The following statement contains a magic number: _wfmt.SetPCMFormat (11025' 1' 16);  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,SygnalAnalyzerForm,The following statement contains a magic number: _wfmt.SetPCMFormat (11025' 1' 16);  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,scaleSpectrum,The following statement contains a magic number: for (int i = 0; i < AmplOut.Length; i++) {  	AmplOut [i] = AmplOut [i] / 100;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,scaleSpectrum,The following statement contains a magic number: AmplOut [i] = AmplOut [i] / 100;  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ComputeFFT,The following statement contains a magic number: if (GetAudioData (wbuf.AudioData' wbuf.BytesRecorded' _wfmt)) {  	drawCapturedData (RealIn' _numSamples);  	// adjust FFT Sample to next power 2 but fill data with silence  	uint pow2Samples = FFT.NextPowerOfTwo (_numSamples);  	if (pow2Samples != _numSamples) {  		double dsilence = 0.0;  		if (_wfmt.BitsPerSample == 8) {  			dsilence = 128.0;  		}  		for (uint ii = _numSamples; ii < pow2Samples; ii++) {  			RealIn [ii] = dsilence;  		}  		_numSamples = pow2Samples;  	}  	// You may want to add 'USE_FFTLIB' under the project settings (Build->General tab)  	// to get better performance  	#if USE_FFTLIB  	                // Do the FFT                 FFTLib.ComputeD(_numSamples' RealIn' null' RealOut' ImagOut' false);                 // We can skip N/2 to N samples (mirror frequencies) - Digital samples are real integer                 FFTLib.NormD(_numSamples / 2' RealOut' ImagOut' AmplOut); #else  	FFT.Compute (_numSamples' RealIn' null' RealOut' ImagOut' true);  	FFT.Norm (_numSamples / 2' RealOut' ImagOut' AmplOut);  	#endif  	#if USING_PEAKMETER  	                renderPeakMeter(); #else  	//scaleSpectrum(AmplOut);  	drawSpectrum (AmplOut' NUM_FREQUENCY);  	sumAmplSpectrum (AmplOut' NUM_FREQUENCY);  	refreshDigest ();  	#endif  	_numSamples = 0;  	// ready to do it again  }  else {  	DumpDebugMessage ("GET Audio data failed.");  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ComputeFFT,The following statement contains a magic number: if (GetAudioData (wbuf.AudioData' wbuf.BytesRecorded' _wfmt)) {  	drawCapturedData (RealIn' _numSamples);  	// adjust FFT Sample to next power 2 but fill data with silence  	uint pow2Samples = FFT.NextPowerOfTwo (_numSamples);  	if (pow2Samples != _numSamples) {  		double dsilence = 0.0;  		if (_wfmt.BitsPerSample == 8) {  			dsilence = 128.0;  		}  		for (uint ii = _numSamples; ii < pow2Samples; ii++) {  			RealIn [ii] = dsilence;  		}  		_numSamples = pow2Samples;  	}  	// You may want to add 'USE_FFTLIB' under the project settings (Build->General tab)  	// to get better performance  	#if USE_FFTLIB  	                // Do the FFT                 FFTLib.ComputeD(_numSamples' RealIn' null' RealOut' ImagOut' false);                 // We can skip N/2 to N samples (mirror frequencies) - Digital samples are real integer                 FFTLib.NormD(_numSamples / 2' RealOut' ImagOut' AmplOut); #else  	FFT.Compute (_numSamples' RealIn' null' RealOut' ImagOut' true);  	FFT.Norm (_numSamples / 2' RealOut' ImagOut' AmplOut);  	#endif  	#if USING_PEAKMETER  	                renderPeakMeter(); #else  	//scaleSpectrum(AmplOut);  	drawSpectrum (AmplOut' NUM_FREQUENCY);  	sumAmplSpectrum (AmplOut' NUM_FREQUENCY);  	refreshDigest ();  	#endif  	_numSamples = 0;  	// ready to do it again  }  else {  	DumpDebugMessage ("GET Audio data failed.");  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ComputeFFT,The following statement contains a magic number: if (GetAudioData (wbuf.AudioData' wbuf.BytesRecorded' _wfmt)) {  	drawCapturedData (RealIn' _numSamples);  	// adjust FFT Sample to next power 2 but fill data with silence  	uint pow2Samples = FFT.NextPowerOfTwo (_numSamples);  	if (pow2Samples != _numSamples) {  		double dsilence = 0.0;  		if (_wfmt.BitsPerSample == 8) {  			dsilence = 128.0;  		}  		for (uint ii = _numSamples; ii < pow2Samples; ii++) {  			RealIn [ii] = dsilence;  		}  		_numSamples = pow2Samples;  	}  	// You may want to add 'USE_FFTLIB' under the project settings (Build->General tab)  	// to get better performance  	#if USE_FFTLIB  	                // Do the FFT                 FFTLib.ComputeD(_numSamples' RealIn' null' RealOut' ImagOut' false);                 // We can skip N/2 to N samples (mirror frequencies) - Digital samples are real integer                 FFTLib.NormD(_numSamples / 2' RealOut' ImagOut' AmplOut); #else  	FFT.Compute (_numSamples' RealIn' null' RealOut' ImagOut' true);  	FFT.Norm (_numSamples / 2' RealOut' ImagOut' AmplOut);  	#endif  	#if USING_PEAKMETER  	                renderPeakMeter(); #else  	//scaleSpectrum(AmplOut);  	drawSpectrum (AmplOut' NUM_FREQUENCY);  	sumAmplSpectrum (AmplOut' NUM_FREQUENCY);  	refreshDigest ();  	#endif  	_numSamples = 0;  	// ready to do it again  }  else {  	DumpDebugMessage ("GET Audio data failed.");  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ComputeFFT,The following statement contains a magic number: if (pow2Samples != _numSamples) {  	double dsilence = 0.0;  	if (_wfmt.BitsPerSample == 8) {  		dsilence = 128.0;  	}  	for (uint ii = _numSamples; ii < pow2Samples; ii++) {  		RealIn [ii] = dsilence;  	}  	_numSamples = pow2Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ComputeFFT,The following statement contains a magic number: if (pow2Samples != _numSamples) {  	double dsilence = 0.0;  	if (_wfmt.BitsPerSample == 8) {  		dsilence = 128.0;  	}  	for (uint ii = _numSamples; ii < pow2Samples; ii++) {  		RealIn [ii] = dsilence;  	}  	_numSamples = pow2Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ComputeFFT,The following statement contains a magic number: if (_wfmt.BitsPerSample == 8) {  	dsilence = 128.0;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ComputeFFT,The following statement contains a magic number: if (_wfmt.BitsPerSample == 8) {  	dsilence = 128.0;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ComputeFFT,The following statement contains a magic number: dsilence = 128.0;  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ComputeFFT,The following statement contains a magic number: FFT.Norm (_numSamples / 2' RealOut' ImagOut' AmplOut);  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			for (uint i = 0; i < cbSize; ++i) {  				RealIn [i] = (double)((waveData [i] - 128) << 6);  				// Out = (In-128)*64  			}  			_numSamples = (uint)cbSize;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				RealIn [i] = (double)((waveData [j] - 128) << 6);  				// Out = (In-128)*64  				// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  case 16:  	{  		// NOTE: waveData member is necessary to prevent using 'unsafe' code block  		Marshal.Copy (ptr' waveData' 0' (int)cbSize);  		if (wfmt.Channels == 1)// mono  		 {  			int Samples = cbSize >> 1;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  				short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  				RealIn [i] = (double)val;  			}  			_numSamples = (uint)Samples;  		}  		else if (wfmt.Channels == 2)// stereo  		 {  			// Stereo has Right+Left channels  			int Samples = cbSize >> 2;  			for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  				short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  				// right  				RealIn [i] = (double)val;  				// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  			}  			_numSamples = (uint)Samples;  		}  		samplesReady = (_numSamples != 0);  	}  	break;  default:  	System.Diagnostics.Debug.Assert (false' "Format not supported");  	// not supported  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	for (uint i = 0; i < cbSize; ++i) {  		RealIn [i] = (double)((waveData [i] - 128) << 6);  		// Out = (In-128)*64  	}  	_numSamples = (uint)cbSize;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		RealIn [i] = (double)((waveData [j] - 128) << 6);  		// Out = (In-128)*64  		// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	for (uint i = 0; i < cbSize; ++i) {  		RealIn [i] = (double)((waveData [i] - 128) << 6);  		// Out = (In-128)*64  	}  	_numSamples = (uint)cbSize;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		RealIn [i] = (double)((waveData [j] - 128) << 6);  		// Out = (In-128)*64  		// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	for (uint i = 0; i < cbSize; ++i) {  		RealIn [i] = (double)((waveData [i] - 128) << 6);  		// Out = (In-128)*64  	}  	_numSamples = (uint)cbSize;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		RealIn [i] = (double)((waveData [j] - 128) << 6);  		// Out = (In-128)*64  		// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	for (uint i = 0; i < cbSize; ++i) {  		RealIn [i] = (double)((waveData [i] - 128) << 6);  		// Out = (In-128)*64  	}  	_numSamples = (uint)cbSize;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		RealIn [i] = (double)((waveData [j] - 128) << 6);  		// Out = (In-128)*64  		// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	for (uint i = 0; i < cbSize; ++i) {  		RealIn [i] = (double)((waveData [i] - 128) << 6);  		// Out = (In-128)*64  	}  	_numSamples = (uint)cbSize;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		RealIn [i] = (double)((waveData [j] - 128) << 6);  		// Out = (In-128)*64  		// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	for (uint i = 0; i < cbSize; ++i) {  		RealIn [i] = (double)((waveData [i] - 128) << 6);  		// Out = (In-128)*64  	}  	_numSamples = (uint)cbSize;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		RealIn [i] = (double)((waveData [j] - 128) << 6);  		// Out = (In-128)*64  		// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: for (uint i = 0; i < cbSize; ++i) {  	RealIn [i] = (double)((waveData [i] - 128) << 6);  	// Out = (In-128)*64  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: for (uint i = 0; i < cbSize; ++i) {  	RealIn [i] = (double)((waveData [i] - 128) << 6);  	// Out = (In-128)*64  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: RealIn [i] = (double)((waveData [i] - 128) << 6);  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: RealIn [i] = (double)((waveData [i] - 128) << 6);  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		RealIn [i] = (double)((waveData [j] - 128) << 6);  		// Out = (In-128)*64  		// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		RealIn [i] = (double)((waveData [j] - 128) << 6);  		// Out = (In-128)*64  		// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		RealIn [i] = (double)((waveData [j] - 128) << 6);  		// Out = (In-128)*64  		// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		RealIn [i] = (double)((waveData [j] - 128) << 6);  		// Out = (In-128)*64  		// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  	RealIn [i] = (double)((waveData [j] - 128) << 6);  	// Out = (In-128)*64  	// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  	RealIn [i] = (double)((waveData [j] - 128) << 6);  	// Out = (In-128)*64  	// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  	RealIn [i] = (double)((waveData [j] - 128) << 6);  	// Out = (In-128)*64  	// LeftIn[i] = (double)((waveData[j+1]-128)<<6); // Out = (In-128)*64  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: j += 2
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: RealIn [i] = (double)((waveData [j] - 128) << 6);  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: RealIn [i] = (double)((waveData [j] - 128) << 6);  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  		RealIn [i] = (double)val;  	}  	_numSamples = (uint)Samples;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 2;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  		short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  		// right  		RealIn [i] = (double)val;  		// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  		RealIn [i] = (double)val;  	}  	_numSamples = (uint)Samples;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 2;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  		short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  		// right  		RealIn [i] = (double)val;  		// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  		RealIn [i] = (double)val;  	}  	_numSamples = (uint)Samples;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 2;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  		short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  		// right  		RealIn [i] = (double)val;  		// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  		RealIn [i] = (double)val;  	}  	_numSamples = (uint)Samples;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 2;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  		short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  		// right  		RealIn [i] = (double)val;  		// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  		RealIn [i] = (double)val;  	}  	_numSamples = (uint)Samples;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 2;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  		short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  		// right  		RealIn [i] = (double)val;  		// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 1)// mono   {  	int Samples = cbSize >> 1;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  		short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  		RealIn [i] = (double)val;  	}  	_numSamples = (uint)Samples;  }  else if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 2;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  		short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  		// right  		RealIn [i] = (double)val;  		// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  	short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  	RealIn [i] = (double)val;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: for (uint i = 0' j = 0; i < Samples; ++i' j += 2) {  	short val = (short)unchecked(((waveData [j + 1] << 8) + waveData [j]));  	RealIn [i] = (double)val;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: j += 2
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 2;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  		short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  		// right  		RealIn [i] = (double)val;  		// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 2;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  		short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  		// right  		RealIn [i] = (double)val;  		// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 2;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  		short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  		// right  		RealIn [i] = (double)val;  		// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: if (wfmt.Channels == 2)// stereo   {  	// Stereo has Right+Left channels  	int Samples = cbSize >> 2;  	for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  		short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  		// right  		RealIn [i] = (double)val;  		// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  	}  	_numSamples = (uint)Samples;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  	short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  	// right  	RealIn [i] = (double)val;  	// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: for (uint i = 0' j = 0; i < Samples; ++i' j += 4) {  	short val = unchecked((short)((waveData [j + 1] << 8) + waveData [j]));  	// right  	RealIn [i] = (double)val;  	// val = unchecked((short)((waveData[j+3] << 8) + waveData[j+2])); // left  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,GetAudioData,The following statement contains a magic number: j += 4
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,PutAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// fill with silence - no smoothing  		if (cbSize > recvBytes) {  			MemorySet (pbData' 0x80' (cbSize - recvBytes));  		}  	}  	break;  case 16:  default:  	{  		// fill with silence - no smoothing  		if (cbSize > recvBytes) {  			MemorySet (pbData' 0x00' (cbSize - recvBytes));  		}  	}  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,PutAudioData,The following statement contains a magic number: switch (wfmt.BitsPerSample) {  case 8:  	{  		// fill with silence - no smoothing  		if (cbSize > recvBytes) {  			MemorySet (pbData' 0x80' (cbSize - recvBytes));  		}  	}  	break;  case 16:  default:  	{  		// fill with silence - no smoothing  		if (cbSize > recvBytes) {  			MemorySet (pbData' 0x00' (cbSize - recvBytes));  		}  	}  	break;  }  
Magic Number,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,DumpWaveErrorMessage,The following statement contains a magic number: WaveInput.waveInGetErrorTextW (error' sError' 256);  
Magic Number,NAudio.Gui,VolumeMeter,C:\repos\spark-div_signalanalyzer2\source\VolumeMeter.cs,VolumeMeter,The following statement contains a magic number: MinDb = -60;  
Magic Number,NAudio.Gui,VolumeMeter,C:\repos\spark-div_signalanalyzer2\source\VolumeMeter.cs,VolumeMeter,The following statement contains a magic number: MaxDb = 18;  
Magic Number,NAudio.Gui,VolumeMeter,C:\repos\spark-div_signalanalyzer2\source\VolumeMeter.cs,OnForeColorChanged,The following statement contains a magic number: brGradient = new LinearGradientBrush (new Rectangle (0' 0' this.Width - 1' this.Height - 1)' Color.Green' Color.Red' 90' false);  
Missing Default,SignalAnalyzer2,SygnalAnalyzerForm,C:\repos\spark-div_signalanalyzer2\source\SygnalAnalyzerForm.cs,ProcessEvent,The following switch statement is missing a default case: switch (uMsg) {  case WaveConstants.MM_WIM_OPEN:  	DumpDebugMessage ("Wave Opened");  	break;  case WaveConstants.MM_WIM_DATA:  	{  		GCHandle gch = GCHandle.Alloc (wbuf);  		// Create message  		if (this.IsHandleCreated) {  			Message m = Message.Create (_CopyWindowHandle' WM_AUDIO_DONE' IntPtr.Zero' (IntPtr)gch);  			WndProcCallback wndCallback = new WndProcCallback (WndProc);  			// Ensure all calls will be thread-safe  			this.BeginInvoke (wndCallback' m);  		}  	}  	break;  case WaveConstants.MM_WIM_CLOSE:  	DumpDebugMessage ("Wave Closed");  	break;  }  
