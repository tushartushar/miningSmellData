Implementation smell,Namespace,Class,File,Method,Description
Long Method,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The method has 204 lines of code.
Long Method,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The method has 136 lines of code.
Long Method,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The method has 186 lines of code.
Long Method,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The method has 129 lines of code.
Long Method,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The method has 114 lines of code.
Long Method,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The method has 163 lines of code.
Long Method,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,contextMenuStrip1_Opening,The method has 100 lines of code.
Complex Method,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,CalcSpace,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,Cyclomatic complexity of the method is 9
Complex Method,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,Cyclomatic complexity of the method is 11
Complex Method,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,Cyclomatic complexity of the method is 9
Complex Method,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,Cyclomatic complexity of the method is 11
Complex Method,ZedGraph,CurveItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveItem.cs,GetRange,Cyclomatic complexity of the method is 15
Complex Method,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,Cyclomatic complexity of the method is 29
Complex Method,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetStackRange,Cyclomatic complexity of the method is 12
Complex Method,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,Draw,Cyclomatic complexity of the method is 11
Complex Method,ZedGraph,DataSourcePointList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DataSourcePointList.cs,GetDouble,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,DateAsOrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateAsOrdinalScale.cs,SetDateFormat,Cyclomatic complexity of the method is 17
Complex Method,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcMajorTicValue,Cyclomatic complexity of the method is 22
Complex Method,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcMinorTicValue,Cyclomatic complexity of the method is 19
Complex Method,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcBaseTic,Cyclomatic complexity of the method is 58
Complex Method,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,Cyclomatic complexity of the method is 24
Complex Method,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,PickScale,Cyclomatic complexity of the method is 9
Complex Method,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,Cyclomatic complexity of the method is 61
Complex Method,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcEvenStepDate,Cyclomatic complexity of the method is 9
Complex Method,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,GetUnitMultiple,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,Cyclomatic complexity of the method is 19
Complex Method,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,ScaleBrush,Cyclomatic complexity of the method is 38
Complex Method,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalculateGasGaugeParameters,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalculateGasGuageParameters,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,PickScale,Cyclomatic complexity of the method is 10
Complex Method,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,Draw,Cyclomatic complexity of the method is 12
Complex Method,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestObject,Cyclomatic complexity of the method is 16
Complex Method,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,Cyclomatic complexity of the method is 25
Complex Method,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindLinkableObject,Cyclomatic complexity of the method is 10
Complex Method,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,ToRGB,Cyclomatic complexity of the method is 19
Complex Method,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,Cyclomatic complexity of the method is 13
Complex Method,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Draw,Cyclomatic complexity of the method is 13
Complex Method,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,Cyclomatic complexity of the method is 100
Complex Method,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSticks,Cyclomatic complexity of the method is 11
Complex Method,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,Cyclomatic complexity of the method is 13
Complex Method,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,Cyclomatic complexity of the method is 28
Complex Method,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,Cyclomatic complexity of the method is 25
Complex Method,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,InterpolatePoint,Cyclomatic complexity of the method is 18
Complex Method,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,Cyclomatic complexity of the method is 10
Complex Method,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildLowPointsArray,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,LinearScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearScale.cs,PickScale,Cyclomatic complexity of the method is 12
Complex Method,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,Cyclomatic complexity of the method is 10
Complex Method,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,Cyclomatic complexity of the method is 55
Complex Method,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,NoDupePointList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\NoDupePointList.cs,FilterData,Cyclomatic complexity of the method is 15
Complex Method,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,Cyclomatic complexity of the method is 10
Complex Method,ZedGraph,PaneBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PaneBase.cs,TransformCoord,Cyclomatic complexity of the method is 11
Complex Method,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,Draw,Cyclomatic complexity of the method is 10
Complex Method,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,Cyclomatic complexity of the method is 11
Complex Method,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,BuildLabelString,Cyclomatic complexity of the method is 21
Complex Method,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,Add,Cyclomatic complexity of the method is 11
Complex Method,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,Cyclomatic complexity of the method is 9
Complex Method,ZedGraph,PolyObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PolyObj.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,RollingPointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\RollingPointPairList.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,RollingPointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\RollingPointPairList.cs,Add,Cyclomatic complexity of the method is 11
Complex Method,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,MakeNewScale,Cyclomatic complexity of the method is 10
Complex Method,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,Cyclomatic complexity of the method is 13
Complex Method,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,Cyclomatic complexity of the method is 11
Complex Method,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabel,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,Cyclomatic complexity of the method is 12
Complex Method,ZedGraph,Selection,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Selection.cs,UpdateSelection,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,Cyclomatic complexity of the method is 8
Complex Method,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,MakePath,Cyclomatic complexity of the method is 55
Complex Method,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,Draw,Cyclomatic complexity of the method is 18
Complex Method,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,Cyclomatic complexity of the method is 14
Complex Method,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,Cyclomatic complexity of the method is 26
Complex Method,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,contextMenuStrip1_Opening,Cyclomatic complexity of the method is 17
Complex Method,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,Cyclomatic complexity of the method is 40
Complex Method,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,Cyclomatic complexity of the method is 8
Long Parameter List,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,ArrowObj,The method has 6 parameters.
Long Parameter List,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,FixZeroLine,The method has 5 parameters.
Long Parameter List,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The method has 6 parameters.
Long Parameter List,ZedGraph,AxisLabel,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\AxisLabel.cs,AxisLabel,The method has 7 parameters.
Long Parameter List,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The method has 10 parameters.
Long Parameter List,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The method has 7 parameters.
Long Parameter List,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,DrawBars,The method has 8 parameters.
Long Parameter List,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,DrawSingleBar,The method has 9 parameters.
Long Parameter List,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,DrawSingleBar,The method has 9 parameters.
Long Parameter List,ZedGraph,BarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BarItem.cs,CreateBarLabels,The method has 9 parameters.
Long Parameter List,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,BoxObj,The method has 6 parameters.
Long Parameter List,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,BoxObj,The method has 7 parameters.
Long Parameter List,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,GetCoords,The method has 5 parameters.
Long Parameter List,ZedGraph,HiLowBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HiLowBarItem.cs,HiLowBarItem,The method has 5 parameters.
Long Parameter List,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The method has 10 parameters.
Long Parameter List,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The method has 6 parameters.
Long Parameter List,ZedGraph,CurveItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveItem.cs,GetRange,The method has 7 parameters.
Long Parameter List,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetStackRange,The method has 6 parameters.
Long Parameter List,ZedGraph,EllipseObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\EllipseObj.cs,EllipseObj,The method has 6 parameters.
Long Parameter List,ZedGraph,EllipseObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\EllipseObj.cs,EllipseObj,The method has 7 parameters.
Long Parameter List,ZedGraph,ErrorBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ErrorBar.cs,Draw,The method has 10 parameters.
Long Parameter List,ZedGraph,ErrorBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ErrorBar.cs,Draw,The method has 6 parameters.
Long Parameter List,ZedGraph,ErrorBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ErrorBarItem.cs,ErrorBarItem,The method has 5 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,FontSpec,The method has 6 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,FontSpec,The method has 9 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,Init,The method has 9 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,Draw,The method has 8 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,Draw,The method has 9 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,DrawTenPower,The method has 8 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,PointInBox,The method has 8 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,PointInBox,The method has 9 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,SetupMatrix,The method has 7 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,GetMatrix,The method has 6 parameters.
Long Parameter List,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,GetBox,The method has 8 parameters.
Long Parameter List,ZedGraph,GapLabel,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GapLabel.cs,GapLabel,The method has 7 parameters.
Long Parameter List,ZedGraph,GraphObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphObj.cs,GraphObj,The method has 5 parameters.
Long Parameter List,ZedGraph,GraphObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphObj.cs,GraphObj,The method has 7 parameters.
Long Parameter List,ZedGraph,GraphObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphObj.cs,GetCoords,The method has 5 parameters.
Long Parameter List,ZedGraph,GraphObjList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphObjList.cs,FindPoint,The method has 5 parameters.
Long Parameter List,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,AddCurve,The method has 5 parameters.
Long Parameter List,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,AddErrorBar,The method has 5 parameters.
Long Parameter List,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,AddHiLowBar,The method has 5 parameters.
Long Parameter List,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,AddPieSlice,The method has 6 parameters.
Long Parameter List,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,ReverseTransform,The method has 5 parameters.
Long Parameter List,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,ReverseTransform,The method has 6 parameters.
Long Parameter List,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,ReverseTransform,The method has 5 parameters.
Long Parameter List,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindLinkableObject,The method has 6 parameters.
Long Parameter List,ZedGraph,ImageObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ImageObj.cs,ImageObj,The method has 5 parameters.
Long Parameter List,ZedGraph,ImageObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ImageObj.cs,ImageObj,The method has 5 parameters.
Long Parameter List,ZedGraph,ImageObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ImageObj.cs,GetCoords,The method has 5 parameters.
Long Parameter List,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The method has 14 parameters.
Long Parameter List,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The method has 6 parameters.
Long Parameter List,ZedGraph,Label,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Label.cs,Label,The method has 7 parameters.
Long Parameter List,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSegment,The method has 7 parameters.
Long Parameter List,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,InterpolatePoint,The method has 10 parameters.
Long Parameter List,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,CloseCurve,The method has 6 parameters.
Long Parameter List,ZedGraph,LineItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineItem.cs,LineItem,The method has 6 parameters.
Long Parameter List,ZedGraph,LineItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineItem.cs,LineItem,The method has 5 parameters.
Long Parameter List,ZedGraph,LineItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineItem.cs,LineItem,The method has 5 parameters.
Long Parameter List,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,LineObj,The method has 5 parameters.
Long Parameter List,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The method has 5 parameters.
Long Parameter List,ZedGraph,Location,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Location.cs,Location,The method has 5 parameters.
Long Parameter List,ZedGraph,Location,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Location.cs,Location,The method has 7 parameters.
Long Parameter List,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,FindNearestPaneObject,The method has 5 parameters.
Long Parameter List,ZedGraph,MinorTic,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MinorTic.cs,Draw,The method has 7 parameters.
Long Parameter List,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,PieItem,The method has 6 parameters.
Long Parameter List,ZedGraph,PointPair4,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPair4.cs,PointPair4,The method has 5 parameters.
Long Parameter List,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The method has 7 parameters.
Long Parameter List,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The method has 5 parameters.
Long Parameter List,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabel,The method has 10 parameters.
Long Parameter List,ZedGraph,StickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\StickItem.cs,StickItem,The method has 5 parameters.
Long Parameter List,ZedGraph,StockPointList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\StockPointList.cs,Add,The method has 6 parameters.
Long Parameter List,ZedGraph,StockPt,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\StockPt.cs,StockPt,The method has 6 parameters.
Long Parameter List,ZedGraph,StockPt,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\StockPt.cs,StockPt,The method has 7 parameters.
Long Parameter List,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The method has 6 parameters.
Long Parameter List,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The method has 7 parameters.
Long Parameter List,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,Draw,The method has 5 parameters.
Long Parameter List,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,TextObj,The method has 6 parameters.
Long Parameter List,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,GetCoords,The method has 5 parameters.
Long Parameter List,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The method has 5 parameters.
Long Parameter List,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The method has 6 parameters.
Long Parameter List,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,BarCenterValue,The method has 5 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,XDate,The method has 6 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,XDate,The method has 6 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,XDate,The method has 7 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,GetDate,The method has 6 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,SetDate,The method has 6 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,CalendarDateToXLDate,The method has 7 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,CalendarDateToXLDate,The method has 6 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,CalendarDateToXLDate,The method has 6 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,CalendarDateToJulianDay,The method has 6 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,CalendarDateToJulianDay,The method has 7 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,NormalizeCalendarDate,The method has 7 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,_CalendarDateToXLDate,The method has 7 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,_CalendarDateToJulianDay,The method has 7 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,XLDateToCalendarDate,The method has 7 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,XLDateToCalendarDate,The method has 8 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,XLDateToCalendarDate,The method has 7 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,JulianDayToCalendarDate,The method has 7 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,JulianDayToCalendarDate,The method has 7 parameters.
Long Parameter List,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,JulianDayToCalendarDate,The method has 8 parameters.
Long Statement,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The length of the statement  "	if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) { " is 157.
Long Statement,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,IsCrossShifted,The length of the statement  "		if (((this is XAxis || this is YAxis) && !crossAxis._scale.IsReverse) || ((this is X2Axis || this is Y2Axis) && crossAxis._scale.IsReverse)) { " is 142.
Long Statement,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,CalcCrossFraction,The length of the statement  "	if (((this is XAxis || this is YAxis) && _scale._isLabelsInside == crossAxis._scale.IsReverse) || ((this is X2Axis || this is Y2Axis) && _scale._isLabelsInside != crossAxis._scale.IsReverse)) " is 191.
Long Statement,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,CalcSpace,The length of the statement  "		bool hasTic = this.MajorTic.IsOutside || this.MajorTic._isCrossOutside || this.MinorTic.IsOutside || this.MinorTic._isCrossOutside; " is 131.
Long Statement,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,CalcSpace,The length of the statement  "	if (this.IsPrimary (pane) && (((this is YAxis && ((!pane.XAxis._scale._isSkipFirstLabel && !pane.XAxis._scale._isReverse) || (!pane.XAxis._scale._isSkipLastLabel && pane.XAxis._scale._isReverse))) || (this is Y2Axis && ((!pane.XAxis._scale._isSkipFirstLabel && pane.XAxis._scale._isReverse) || (!pane.XAxis._scale._isSkipLastLabel && !pane.XAxis._scale._isReverse)))) && pane.XAxis.IsVisible && pane.XAxis._scale._isVisible)) { " is 427.
Long Statement,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The length of the statement  "	if ((this.MinorTic.IsOutside || this.MinorTic.IsOpposite || this.MinorTic.IsInside || this.MinorTic._isCrossOutside || this.MinorTic._isCrossInside || _minorGrid._isVisible) && _isVisible) { " is 190.
Long Statement,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The length of the statement  "		double tMajor = _scale._majorStep * _scale.MajorUnitMultiplier' tMinor = _scale._minorStep * _scale.MinorUnitMultiplier; " is 120.
Long Statement,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The length of the statement  "						if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) { " is 183.
Long Statement,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawTitle,The length of the statement  "		bool hasTic = (_scale._isLabelsInside ? (this.MajorTic.IsInside || this.MajorTic._isCrossInside || this.MinorTic.IsInside || this.MinorTic._isCrossInside) : (this.MajorTic.IsOutside || this.MajorTic._isCrossOutside || this.MinorTic.IsOutside || this.MinorTic._isCrossOutside)); " is 277.
Long Statement,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,DrawBars,The length of the statement  "	if (barType == BarType.Overlay || barType == BarType.Stack || barType == BarType.PercentStack || barType == BarType.SortedOverlay) " is 130.
Long Statement,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,DrawSingleBar,The length of the statement  "	if (pane._barSettings.Type == BarType.Overlay || pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack) " is 139.
Long Statement,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,DrawSingleBar,The length of the statement  "			this.Draw (g' pane' pixSide' pixSide + barWidth' pixLowVal' pixHiVal' scaleFactor' true' curve.IsSelected' curve.Points [index]); " is 129.
Long Statement,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,DrawSingleBar,The length of the statement  "			this.Draw (g' pane' pixLowVal' pixHiVal' pixSide' pixSide + barWidth' scaleFactor' true' curve.IsSelected' curve.Points [index]); " is 129.
Long Statement,ZedGraph,BarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BarItem.cs,CreateBarLabels,The length of the statement  "	CreateBarLabels (pane' isBarCenter' valueFormat' TextObj.Default.FontFamily' TextObj.Default.FontSize' TextObj.Default.FontColor' TextObj.Default.FontBold' TextObj.Default.FontItalic' TextObj.Default.FontUnderline); " is 215.
Long Statement,ZedGraph,BarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BarItem.cs,GetCoords,The length of the statement  "		float pixSide = pixBase - clusterWidth / 2.0F + clusterGap / 2.0F + pane.CurveList.GetBarItemPos (pane' this) * (barWidth + barGap); " is 132.
Long Statement,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,Draw,The length of the statement  "	if (Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000) { " is 149.
Long Statement,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The length of the statement  "		using (Pen pen = !curve.IsSelected ? new Pen (_color' _width) : new Pen (Selection.Border.Color' Selection.Border.Width))//				using ( Pen pen = new Pen( _color' _penWidth ) ) " is 175.
Long Statement,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The length of the statement  "				if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) { " is 130.
Long Statement,ZedGraph,CurveItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveItem.cs,GetRange,The length of the statement  "		bool outOfBounds = curX < xLBound || curX > xUBound || curY < yLBound || curY > yUBound || (isZIncluded && isXIndependent && (curZ < yLBound || curZ > yUBound)) || (isZIncluded && !isXIndependent && (curZ < xLBound || curZ > xUBound)) || (curX <= 0 && isXLog) || (curY <= 0 && isYLog); " is 285.
Long Statement,ZedGraph,CurveItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveItem.cs,GetBarWidth,The length of the statement  "		float denom = numBars * (1.0F + pane._barSettings.MinBarGap) - pane._barSettings.MinBarGap + pane._barSettings.MinClusterGap; " is 125.
Long Statement,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The length of the statement  "			if (((curve is BarItem) && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) || ((curve is LineItem) && pane.LineType == LineType.Stack)) { " is 182.
Long Statement,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,Draw,The length of the statement  "				barItem.Bar.DrawSingleBar (g' pane' barItem' ((BarItem)barItem).BaseAxis (pane)' ((BarItem)barItem).ValueAxis (pane)' 0' i' ((BarItem)barItem).GetBarWidth (pane)' scaleFactor); " is 176.
Long Statement,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetBarItemPos,The length of the statement  "	if (pane._barSettings.Type == BarType.Overlay || pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack) " is 139.
Long Statement,ZedGraph,DateAsOrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateAsOrdinalScale.cs,SetDateFormat,The length of the statement  "			if (val1 != PointPair.Missing && val2 != PointPair.Missing && !Double.IsNaN (val1) && !Double.IsNaN (val2) && !Double.IsInfinity (val1) && !Double.IsInfinity (val2) && Math.Abs (val2 - val1) > 1e-10) " is 199.
Long Statement,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The length of the statement  "	XDate.XLDateToCalendarDate (_min' out year1' out month1' out day1' out hour1' out minute1' out second1' out millisecond1); " is 122.
Long Statement,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The length of the statement  "	XDate.XLDateToCalendarDate (_max' out year2' out month2' out day2' out hour2' out minute2' out second2' out millisecond2); " is 122.
Long Statement,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The length of the statement  "			scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps); " is 158.
Long Statement,ZedGraph,EllipseObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\EllipseObj.cs,Draw,The length of the statement  "	if (Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000) { " is 149.
Long Statement,ZedGraph,ErrorBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ErrorBar.cs,Draw,The length of the statement  "		using (Pen pen = !curve.IsSelected ? new Pen (_color' _penWidth) : new Pen (Selection.Border.Color' Selection.Border.Width)) { " is 126.
Long Statement,ZedGraph,ErrorBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ErrorBar.cs,Draw,The length of the statement  "				if (!curve.Points [i].IsInvalid3D && (scaleBase > 0 || !baseAxis._scale.IsLog) && ((scaleValue > 0 && scaleLowValue > 0) || !valueAxis._scale.IsLog)) { " is 151.
Long Statement,ZedGraph,ErrorBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ErrorBar.cs,Draw,The length of the statement  "					this.Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixValue' pixLowValue' scaleFactor' pen' curve.IsSelected' curve.Points [i]); " is 147.
Long Statement,ZedGraph,ErrorBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ErrorBarItem.cs,DrawLegendKey,The length of the statement  "		this.Bar.Draw (g' pane' pane._barSettings.Base == BarBase.X' pixBase' pixValue' pixLowValue' scaleFactor' pen' false' null); " is 124.
Long Statement,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The length of the statement  "		_minorStep = CalcStepSize (_majorStep' (_ownerAxis is XAxis || _ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps); " is 142.
Long Statement,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,ScaleBrush,The length of the statement  "				linBrush.ScaleTransform (rect.Width / linBrush.Rectangle.Width' rect.Height / linBrush.Rectangle.Height' MatrixOrder.Append); " is 125.
Long Statement,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,ScaleBrush,The length of the statement  "				linBrush.TranslateTransform (rect.Left - linBrush.Rectangle.Left' rect.Top - linBrush.Rectangle.Top' MatrixOrder.Append); " is 121.
Long Statement,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,Remake,The length of the statement  "	if (font == null || Math.Abs (newSize - oldSize) > 0.1 || font.Name != this.Family || font.Bold != _isBold || font.Italic != _isItalic || font.Underline != _isUnderline) { " is 171.
Long Statement,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,Remake,The length of the statement  "		style = (_isBold ? FontStyle.Bold : style) | (_isItalic ? FontStyle.Italic : style) | (_isUnderline ? FontStyle.Underline : style); " is 131.
Long Statement,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,DrawTenPower,The length of the statement  "		g.DrawString ("10"' _font' brush' (-totSize.Width + size10.Width) / 2.0F' sizeText.Height * Default.SuperShift' strFormat); " is 123.
Long Statement,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The length of the statement  "			pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f)); " is 188.
Long Statement,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The length of the statement  "			pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f)); " is 168.
Long Statement,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The length of the statement  "			RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f); " is 120.
Long Statement,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestObject,The length of the statement  "			tmpRect = new RectangleF ((_rect.Left + _rect.Right - paneTitleBox.Width) / 2' _rect.Top + _margin.Top * scaleFactor' paneTitleBox.Width' paneTitleBox.Height); " is 159.
Long Statement,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The length of the statement  "						if (curve.IsBar || curve is ErrorBarItem || curve is HiLowBarItem || curve is OHLCBarItem || curve is JapaneseCandleStickItem) { " is 128.
Long Statement,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindContainedObjects,The length of the statement  "			if (ci.Points [i].X > rectF.Left && ci.Points [i].X < rectF.Right && ci.Points [i].Y > rectF.Bottom && ci.Points [i].Y < rectF.Top) { " is 133.
Long Statement,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The length of the statement  "			rect = new RectangleF (pixBase - halfSize' Math.Min (pixOpen' pixClose)' halfSize * 2.0f' Math.Abs (pixOpen - pixClose)); " is 121.
Long Statement,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The length of the statement  "			rect = new RectangleF (Math.Min (pixOpen' pixClose)' pixBase - halfSize' Math.Abs (pixOpen - pixClose)' halfSize * 2.0f); " is 121.
Long Statement,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The length of the statement  "					if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) { " is 130.
Long Statement,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The length of the statement  "								Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (tPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt); " is 230.
Long Statement,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The length of the statement  "							Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (close > open ? risingPen : fallingPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt); " is 263.
Long Statement,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,DrawLegendKey,The length of the statement  "		_stick.Draw (g' pane' pane._barSettings.Base == BarBase.X' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' pen' _stick.RisingFill' _stick.RisingBorder' null); " is 178.
Long Statement,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Draw,The length of the statement  "						tmpFont.Draw (g' pane' curve._label._text' x + 2.5F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor); " is 135.
Long Statement,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Draw,The length of the statement  "						tmpFont.Draw (g' pane' curve._label._text' x + 0.0F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor); " is 135.
Long Statement,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSticks,The length of the statement  "			if (pt.X != PointPair.Missing && pt.Y != PointPair.Missing && !System.Double.IsNaN (pt.X) && !System.Double.IsNaN (pt.Y) && !System.Double.IsInfinity (pt.X) && !System.Double.IsInfinity (pt.Y) && (!xAxis._scale.IsLog || pt.X > 0.0) && (!yAxis._scale.IsLog || pt.Y > 0.0)) { " is 273.
Long Statement,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The length of the statement  "	if (this.IsVisible && !this.Color.IsEmpty && points != null && BuildPointsArray (pane' curve' out arrPoints' out count) && count > 2) { " is 135.
Long Statement,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The length of the statement  "				if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) { " is 245.
Long Statement,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The length of the statement  "					isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY); " is 137.
Long Statement,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The length of the statement  "							if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000) " is 153.
Long Statement,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The length of the statement  "				if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) { " is 245.
Long Statement,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The length of the statement  "					isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY); " is 137.
Long Statement,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The length of the statement  "							if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000) " is 153.
Long Statement,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildLowPointsArray,The length of the statement  "		arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * (pane.LineType == LineType.Stack ? 2 : 1) * points.Count + 1]; " is 136.
Long Statement,ZedGraph,LinearAsOrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearAsOrdinalScale.cs,PickScale,The length of the statement  "		if ((_ownerAxis is Y2Axis && curve.IsY2Axis) || (_ownerAxis is YAxis && !curve.IsY2Axis) || (_ownerAxis is X2Axis && curve.IsX2Axis) || (_ownerAxis is XAxis && !curve.IsX2Axis)) { " is 179.
Long Statement,ZedGraph,LinearScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearScale.cs,PickScale,The length of the statement  "		_minorStep = CalcStepSize (_majorStep' (_ownerAxis is XAxis || _ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps); " is 142.
Long Statement,ZedGraph,LineItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineItem.cs,GetCoords,The length of the statement  "	PointF pixPt = new PointF (xAxis.Scale.Transform (_isOverrideOrdinal' i' x)' yAxis.Scale.Transform (_isOverrideOrdinal' i' y)); " is 127.
Long Statement,ZedGraph,LineItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineItem.cs,GetCoords,The length of the statement  "	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixPt.X - halfSize' pixPt.Y - halfSize' pixPt.X + halfSize' pixPt.Y + halfSize); " is 135.
Long Statement,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The length of the statement  "	if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) { " is 157.
Long Statement,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The length of the statement  "		using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _line._color' pane.ScaledPenWidth( _line._width' scaleFactor ) ) ) " is 127.
Long Statement,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The length of the statement  "	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}'{4:f0}'{5:f0}'{6:f0}'{7:f0}'"' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y' pts [2].X' pts [2].Y' pts [3].X' pts [3].Y); " is 172.
Long Statement,ZedGraph,Link,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Link.cs,MakeCurveItemUrl,The length of the statement  "	if (xAxis.Type == AxisType.Text && index >= 0 && xAxis.Scale.TextLabels != null && index <= xAxis.Scale.TextLabels.Length) " is 122.
Long Statement,ZedGraph,Link,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Link.cs,MakeCurveItemUrl,The length of the statement  "	if (yAxis != null && yAxis.Type == AxisType.Text && index >= 0 && yAxis.Scale.TextLabels != null && index <= yAxis.Scale.TextLabels.Length) " is 139.
Long Statement,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The length of the statement  "			scale._majorStep = Scale.CalcStepSize (scale._max - scale._min' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetXSteps : Default.TargetYSteps); " is 169.
Long Statement,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The length of the statement  "			scale._minorStep = Scale.CalcStepSize (scale._majorStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps); " is 172.
Long Statement,ZedGraph,PaneBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PaneBase.cs,CalcClientRect,The length of the statement  "	RectangleF innerRect = new RectangleF (_rect.Left + _margin.Left * scaleFactor' _rect.Top + _margin.Top * scaleFactor' _rect.Width - scaleFactor * (_margin.Left + _margin.Right)' _rect.Height - scaleFactor * (_margin.Top + _margin.Bottom)); " is 240.
Long Statement,ZedGraph,PaneBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PaneBase.cs,DrawTitle,The length of the statement  "		_title._fontSpec.Draw (g' this' _title._text' (_rect.Left + _rect.Right) / 2' _rect.Top + _margin.Top * (float)scaleFactor + size.Height / 2.0F' AlignH.Center' AlignV.Center' scaleFactor); " is 188.
Long Statement,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The length of the statement  "			nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)); " is 133.
Long Statement,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The length of the statement  "	_intersectionPoint = new PointF ((float)(rectCenter.X + (rect.Width / 2 * Math.Cos ((midAngle) * Math.PI / 180)))' (float)(rectCenter.Y + (rect.Height / 2 * Math.Sin ((midAngle) * Math.PI / 180)))); " is 198.
Long Statement,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The length of the statement  "	_pivotPoint = new PointF ((float)(_intersectionPoint.X + .05 * rect.Width * Math.Cos ((midAngle) * Math.PI / 180))' (float)(_intersectionPoint.Y + .05 * rect.Width * Math.Sin ((midAngle) * Math.PI / 180))); " is 206.
Long Statement,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,BuildLabelString,The length of the statement  "		curve._labelStr = curve._label._text + ": " + curve._pieValue.ToString ("F"' labelFormat) + " (" + (curve._sweepAngle / 360).ToString ("P"' labelFormat) + ")"; " is 159.
Long Statement,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,GetCoords,The length of the statement  "		pts [j] = new PointF (radius * (float)Math.Cos (angle * Math.PI / 180.0)' radius * (float)Math.Sin (angle * Math.PI / 180.0)); " is 126.
Long Statement,ZedGraph,PointPair,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPair.cs,ToString,The length of the statement  "	return "( " + this.X.ToString (format) + "' " + this.Y.ToString (format) + (isShowZ ? ("' " + this.Z.ToString (format)) : "") + " )"; " is 133.
Long Statement,ZedGraph,PointPair4,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPair4.cs,ToString,The length of the statement  "	return "( " + this.X.ToString (format) + "' " + this.Y.ToString (format) + (isShowZT ? ("' " + this.Z.ToString (format) + "' " + this.T.ToString (format)) : "") + " )"; " is 168.
Long Statement,ZedGraph,PointPair4,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPair4.cs,ToString,The length of the statement  "	return "( " + this.X.ToString (formatX) + "' " + this.Y.ToString (formatY) + "' " + this.Z.ToString (formatZ) + "' " + this.T.ToString (formatT) + " )"; " is 152.
Long Statement,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The length of the statement  "			bool isMaxValueAtMaxPix = ((_ownerAxis is XAxis || _ownerAxis is Y2Axis) && !IsReverse) || (_ownerAxis is Y2Axis && IsReverse); " is 127.
Long Statement,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The length of the statement  "			bool isSkipZone = (((_isSkipFirstLabel && isMaxValueAtMaxPix) || (_isSkipLastLabel && !isMaxValueAtMaxPix)) && pixVal < edgeTolerance) || (((_isSkipLastLabel && isMaxValueAtMaxPix) || (_isSkipFirstLabel && !isMaxValueAtMaxPix)) && pixVal > _maxPix - _minPix - edgeTolerance); " is 275.
Long Statement,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The length of the statement  "			bool isSkipCross = _isSkipCrossLabel && !_ownerAxis._crossAuto && Math.Abs (_ownerAxis._cross - dVal) < rangeTol * 10.0; " is 120.
Long Statement,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,GetClusterWidth,The length of the statement  "	return Math.Abs (Transform (basisVal + (IsAnyOrdinal ? 1.0 : pane._barSettings._clusterScaleWidth)) - Transform (basisVal)); " is 124.
Long Statement,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetRange,The length of the statement  "		if (axis != pane.XAxis && axis != pane.X2Axis && pane.YAxis.Scale._rangeMin < double.MaxValue && pane.YAxis.Scale._rangeMax > double.MinValue) { " is 144.
Long Statement,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetRange,The length of the statement  "		else if (axis != pane.XAxis && axis != pane.X2Axis && pane.Y2Axis.Scale._rangeMin < double.MaxValue && pane.Y2Axis.Scale._rangeMax > double.MinValue) { " is 151.
Long Statement,ZedGraph,ScaleState,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ScaleState.cs,IsChanged,The length of the statement  "	return axis._scale._min != _min || axis._scale._majorStep != _majorStep || axis._scale._minorStep != _minorStep || axis._scale._max != _max || axis._scale._minorUnit != _minorUnit || axis._scale._majorUnit != _majorUnit || axis._scale._minAuto != _minAuto || axis._scale._minorStepAuto != _minorStepAuto || axis._scale._majorStepAuto != _majorStepAuto || axis._scale._maxAuto != _maxAuto; " is 388.
Long Statement,ZedGraph,StockPt,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\StockPt.cs,ToString,The length of the statement  "	return "( " + XDate.ToString (this.Date' "g") + "' " + this.Close.ToString (format) + (isShowAll ? ("' " + this.Low.ToString (format) + "' " + this.Open.ToString (format) + "' " + this.Close.ToString (format)) : "") + " )"; " is 223.
Long Statement,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,MakePath,The length of the statement  "	switch (_type == SymbolType.Default || (_type == SymbolType.UserDefined && _userSymbol == null) ? Default.Type : _type) { " is 121.
Long Statement,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,Draw,The length of the statement  "						if (curX != PointPair.Missing && curY != PointPair.Missing && !System.Double.IsNaN (curX) && !System.Double.IsNaN (curY) && !System.Double.IsInfinity (curX) && !System.Double.IsInfinity (curY) && (curX > 0 || !xIsLog) && (!yIsLog || curY > 0.0) && (xIsOrdinal || (curX >= xMin && curX <= xMax))) { " is 297.
Long Statement,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,Init,The length of the statement  "	_fontSpec = new FontSpec (Default.FontFamily' Default.FontSize' Default.FontColor' Default.FontBold' Default.FontItalic' Default.FontUnderline); " is 144.
Long Statement,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,PointInBox,The length of the statement  "	return _fontSpec.PointInBox (pt' g' _text' pix.X' pix.Y' _location.AlignH' _location.AlignV' scaleFactor' this.LayoutArea); " is 123.
Long Statement,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,GetCoords,The length of the statement  "	PointF[] pts = _fontSpec.GetBox (g' _text' pix.X' pix.Y' _location.AlignH' _location.AlignV' scaleFactor' new SizeF ()); " is 120.
Long Statement,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,GetCoords,The length of the statement  "	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}'{4:f0}'{5:f0}'{6:f0}'{7:f0}'"' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y' pts [2].X' pts [2].Y' pts [3].X' pts [3].Y); " is 172.
Long Statement,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The length of the statement  "						hiVal = (curVal == PointPair.Missing || positiveStack == PointPair.Missing) ? PointPair.Missing : positiveStack + curVal; " is 121.
Long Statement,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The length of the statement  "						lowVal = (curVal == PointPair.Missing || negativeStack == PointPair.Missing) ? PointPair.Missing : negativeStack + curVal; " is 122.
Long Statement,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The length of the statement  "					positiveStack = (curVal == PointPair.Missing || positiveStack == PointPair.Missing) ? PointPair.Missing : positiveStack + curVal; " is 129.
Long Statement,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The length of the statement  "					negativeStack = (curVal == PointPair.Missing || negativeStack == PointPair.Missing) ? PointPair.Missing : negativeStack + curVal; " is 129.
Long Statement,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The length of the statement  "	if (baseVal == PointPair.Missing || hiVal == PointPair.Missing || (lowVal == PointPair.Missing && (curve is ErrorBarItem || curve is HiLowBarItem))) " is 148.
Long Statement,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,BarCenterValue,The length of the statement  "		float centerPix = baseAxis.Scale.Transform (curve.IsOverrideOrdinal' iCluster' val) - clusterWidth / 2.0F + clusterGap / 2.0F + iOrdinal * (barWidth + barGap) + 0.5F * barWidth; " is 177.
Long Statement,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,_CalendarDateToJulianDay,The length of the statement  "	return Math.Floor (365.25 * ((double)year + 4716.0)) + Math.Floor (30.6001 * (double)(month + 1)) + (double)day + B - 1524.5 + hour / HoursPerDay + minute / MinutesPerDay + second / SecondsPerDay + millisecond / MillisecondsPerDay; " is 231.
Long Statement,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The length of the statement  "		_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp"; " is 204.
Long Statement,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The length of the statement  "		_saveFileDialog.Filter = "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp"; " is 174.
Long Statement,ZedGraph,ZoomState,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZoomState.cs,IsChanged,The length of the statement  "	return _xAxis.IsChanged (pane.XAxis) || _x2Axis.IsChanged (pane.X2Axis) || _yAxis.IsChanged (pane.YAxisList) || _y2Axis.IsChanged (pane.Y2AxisList); " is 148.
Complex Conditional,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The conditional expression  "pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000"  is complex.
Complex Conditional,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,IsCrossShifted,The conditional expression  "((this is XAxis || this is YAxis) && !crossAxis._scale.IsReverse) || ((this is X2Axis || this is Y2Axis) && crossAxis._scale.IsReverse)"  is complex.
Complex Conditional,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,CalcCrossFraction,The conditional expression  "((this is XAxis || this is YAxis) && _scale._isLabelsInside == crossAxis._scale.IsReverse) || ((this is X2Axis || this is Y2Axis) && _scale._isLabelsInside != crossAxis._scale.IsReverse)"  is complex.
Complex Conditional,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,CalcTotalShift,The conditional expression  "_majorTic.IsOutside || _majorTic._isCrossOutside || _minorTic.IsOutside || _minorTic._isCrossOutside"  is complex.
Complex Conditional,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,CalcTotalShift,The conditional expression  "_majorTic.IsInside || _majorTic._isCrossInside || _minorTic.IsInside || _minorTic._isCrossInside"  is complex.
Complex Conditional,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,CalcSpace,The conditional expression  "this.MajorTic._isInside || this.MajorTic._isCrossInside || this.MinorTic._isInside || this.MinorTic._isCrossInside"  is complex.
Complex Conditional,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,CalcSpace,The conditional expression  "this.IsPrimary (pane) && (((this is YAxis && ((!pane.XAxis._scale._isSkipFirstLabel && !pane.XAxis._scale._isReverse) || (!pane.XAxis._scale._isSkipLastLabel && pane.XAxis._scale._isReverse))) || (this is Y2Axis && ((!pane.XAxis._scale._isSkipFirstLabel && pane.XAxis._scale._isReverse) || (!pane.XAxis._scale._isSkipLastLabel && !pane.XAxis._scale._isReverse)))) && pane.XAxis.IsVisible && pane.XAxis._scale._isVisible)"  is complex.
Complex Conditional,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,FixZeroLine,The conditional expression  "_isVisible && _majorGrid._isZeroLine && _scale._min < 0.0 && _scale._max > 0.0"  is complex.
Complex Conditional,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The conditional expression  "(this.MinorTic.IsOutside || this.MinorTic.IsOpposite || this.MinorTic.IsInside || this.MinorTic._isCrossOutside || this.MinorTic._isCrossInside || _minorGrid._isVisible) && _isVisible"  is complex.
Complex Conditional,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The conditional expression  "((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)"  is complex.
Complex Conditional,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,DrawBars,The conditional expression  "barType == BarType.Overlay || barType == BarType.Stack || barType == BarType.PercentStack || barType == BarType.SortedOverlay"  is complex.
Complex Conditional,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,Draw,The conditional expression  "Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000"  is complex.
Complex Conditional,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The conditional expression  "!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)"  is complex.
Complex Conditional,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,GetCoords,The conditional expression  "!pt.IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)"  is complex.
Complex Conditional,ZedGraph,CurveItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveItem.cs,GetRange,The conditional expression  "!ignoreInitial && !outOfBounds && curX != PointPair.Missing && curY != PointPair.Missing"  is complex.
Complex Conditional,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The conditional expression  "((curve is BarItem) && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) || ((curve is LineItem) && pane.LineType == LineType.Stack)"  is complex.
Complex Conditional,ZedGraph,DateAsOrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateAsOrdinalScale.cs,SetDateFormat,The conditional expression  "val1 != PointPair.Missing && val2 != PointPair.Missing && !Double.IsNaN (val1) && !Double.IsNaN (val2) && !Double.IsInfinity (val1) && !Double.IsInfinity (val2) && Math.Abs (val2 - val1) > 1e-10"  is complex.
Complex Conditional,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcEvenStepDate,The conditional expression  "direction == 1 && month == 1 && day == 1 && hour == 0 && minute == 0 && second == 0"  is complex.
Complex Conditional,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcEvenStepDate,The conditional expression  "direction == 1 && day == 1 && hour == 0 && minute == 0 && second == 0"  is complex.
Complex Conditional,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcEvenStepDate,The conditional expression  "direction == 1 && hour == 0 && minute == 0 && second == 0"  is complex.
Complex Conditional,ZedGraph,EllipseObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\EllipseObj.cs,Draw,The conditional expression  "Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000"  is complex.
Complex Conditional,ZedGraph,ErrorBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ErrorBar.cs,Draw,The conditional expression  "!curve.Points [i].IsInvalid3D && (scaleBase > 0 || !baseAxis._scale.IsLog) && ((scaleValue > 0 && scaleLowValue > 0) || !valueAxis._scale.IsLog)"  is complex.
Complex Conditional,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,Remake,The conditional expression  "font == null || Math.Abs (newSize - oldSize) > 0.1 || font.Name != this.Family || font.Bold != _isBold || font.Italic != _isItalic || font.Underline != _isUnderline"  is complex.
Complex Conditional,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,SetSpace,The conditional expression  "axis._scale._isLabelsInside && (axis.IsPrimary (this) || (crossFrac != 0.0 && crossFrac != 1.0))"  is complex.
Complex Conditional,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The conditional expression  "curve.IsBar || curve is ErrorBarItem || curve is HiLowBarItem || curve is OHLCBarItem || curve is JapaneseCandleStickItem"  is complex.
Complex Conditional,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The conditional expression  "xAct < centerVal - barWidthUserHalf || xAct > centerVal + barWidthUserHalf || yAct < lowVal || yAct > hiVal"  is complex.
Complex Conditional,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The conditional expression  "yAct < centerVal - barWidthUserHalf || yAct > centerVal + barWidthUserHalf || xAct < lowVal || xAct > hiVal"  is complex.
Complex Conditional,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The conditional expression  "xVal >= xAxis._scale._min && xVal <= xAxis._scale._max && yVal >= yMinAct && yVal <= yMaxAct"  is complex.
Complex Conditional,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindContainedObjects,The conditional expression  "ci.Points [i].X > rectF.Left && ci.Points [i].X < rectF.Right && ci.Points [i].Y > rectF.Bottom && ci.Points [i].Y < rectF.Top"  is complex.
Complex Conditional,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The conditional expression  "!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)"  is complex.
Complex Conditional,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,GetCoords,The conditional expression  "!pt.IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)"  is complex.
Complex Conditional,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSticks,The conditional expression  "pt.X != PointPair.Missing && pt.Y != PointPair.Missing && !System.Double.IsNaN (pt.X) && !System.Double.IsNaN (pt.Y) && !System.Double.IsInfinity (pt.X) && !System.Double.IsInfinity (pt.Y) && (!xAxis._scale.IsLog || pt.X > 0.0) && (!yAxis._scale.IsLog || pt.Y > 0.0)"  is complex.
Complex Conditional,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The conditional expression  "this.IsVisible && !this.Color.IsEmpty && points != null && BuildPointsArray (pane' curve' out arrPoints' out count) && count > 2"  is complex.
Complex Conditional,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The conditional expression  "curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)"  is complex.
Complex Conditional,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The conditional expression  "isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY"  is complex.
Complex Conditional,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The conditional expression  "lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000"  is complex.
Complex Conditional,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The conditional expression  "curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)"  is complex.
Complex Conditional,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The conditional expression  "lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000"  is complex.
Complex Conditional,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The conditional expression  "curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000"  is complex.
Complex Conditional,ZedGraph,LinearAsOrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearAsOrdinalScale.cs,PickScale,The conditional expression  "(_ownerAxis is Y2Axis && curve.IsY2Axis) || (_ownerAxis is YAxis && !curve.IsY2Axis) || (_ownerAxis is X2Axis && curve.IsX2Axis) || (_ownerAxis is XAxis && !curve.IsX2Axis)"  is complex.
Complex Conditional,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The conditional expression  "pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000"  is complex.
Complex Conditional,ZedGraph,Link,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Link.cs,MakeCurveItemUrl,The conditional expression  "xAxis.Type == AxisType.Text && index >= 0 && xAxis.Scale.TextLabels != null && index <= xAxis.Scale.TextLabels.Length"  is complex.
Complex Conditional,ZedGraph,Link,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Link.cs,MakeCurveItemUrl,The conditional expression  "yAxis != null && yAxis.Type == AxisType.Text && index >= 0 && yAxis.Scale.TextLabels != null && index <= yAxis.Scale.TextLabels.Length"  is complex.
Complex Conditional,ZedGraph,NoDupePointList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\NoDupePointList.cs,FilterData,The conditional expression  "x >= 0 && x < width && y >= 0 && y < height"  is complex.
Complex Conditional,ZedGraph,RollingPointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\RollingPointPairList.cs,RemoveRange,The conditional expression  "index >= totalCount || index < 0 || count < 0 || count > totalCount"  is complex.
Complex Conditional,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,GetTopRightPix,The conditional expression  "tMajor > 1000 || ((minorTic.IsOutside || minorTic.IsInside || minorTic.IsOpposite) && tMinor > 5000)"  is complex.
Complex Conditional,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetRange,The conditional expression  "axis != pane.XAxis && axis != pane.X2Axis && pane.YAxis.Scale._rangeMin < double.MaxValue && pane.YAxis.Scale._rangeMax > double.MinValue"  is complex.
Complex Conditional,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetRange,The conditional expression  "axis != pane.XAxis && axis != pane.X2Axis && pane.Y2Axis.Scale._rangeMin < double.MaxValue && pane.Y2Axis.Scale._rangeMax > double.MinValue"  is complex.
Complex Conditional,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The conditional expression  "_isVisible && this.Type != SymbolType.None && x < 100000 && x > -100000 && y < 100000 && y > -100000"  is complex.
Complex Conditional,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The conditional expression  "_isVisible && this.Type != SymbolType.None && x < 100000 && x > -100000 && y < 100000 && y > -100000"  is complex.
Complex Conditional,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,Draw,The conditional expression  "curX != PointPair.Missing && curY != PointPair.Missing && !System.Double.IsNaN (curX) && !System.Double.IsNaN (curY) && !System.Double.IsInfinity (curX) && !System.Double.IsInfinity (curY) && (curX > 0 || !xIsLog) && (!yIsLog || curY > 0.0) && (xIsOrdinal || (curX >= xMin && curX <= xMax))"  is complex.
Complex Conditional,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,Draw,The conditional expression  "tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY"  is complex.
Complex Conditional,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,Draw,The conditional expression  "pix.X > -100000 && pix.X < 100000 && pix.Y > -100000 && pix.Y < 100000"  is complex.
Complex Conditional,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The conditional expression  "baseVal == PointPair.Missing || hiVal == PointPair.Missing || (lowVal == PointPair.Missing && (curve is ErrorBarItem || curve is HiLowBarItem))"  is complex.
Complex Conditional,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,BarCenterValue,The conditional expression  "curve is ErrorBarItem || curve is HiLowBarItem || curve is OHLCBarItem || curve is JapaneseCandleStickItem"  is complex.
Empty Catch Block,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,InterpolatePoint,The method has an empty catch block.
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// get a scaled size for the arrowhead  	float scaledSize = (float)(_size * scaleFactor);  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		// Only show the arrowhead if required  		if (_isArrowHead) {  			// Draw the line segment for this arrow  			g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  			// Create a polygon representing the arrowhead based on the scaled  			// size  			PointF[] polyPt = new PointF[4];  			float hsize = scaledSize / 3.0F;  			polyPt [0].X = length;  			polyPt [0].Y = 0;  			polyPt [1].X = length - scaledSize;  			polyPt [1].Y = hsize;  			polyPt [2].X = length - scaledSize;  			polyPt [2].Y = -hsize;  			polyPt [3] = polyPt [0];  			using (SolidBrush brush = new SolidBrush (_line._color))  				// render the arrowhead  				g.FillPolygon (brush' polyPt);  		}  		else  			g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )   {  	//pen.DashStyle = _style;  	// Only show the arrowhead if required  	if (_isArrowHead) {  		// Draw the line segment for this arrow  		g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  		// Create a polygon representing the arrowhead based on the scaled  		// size  		PointF[] polyPt = new PointF[4];  		float hsize = scaledSize / 3.0F;  		polyPt [0].X = length;  		polyPt [0].Y = 0;  		polyPt [1].X = length - scaledSize;  		polyPt [1].Y = hsize;  		polyPt [2].X = length - scaledSize;  		polyPt [2].Y = -hsize;  		polyPt [3] = polyPt [0];  		using (SolidBrush brush = new SolidBrush (_line._color))  			// render the arrowhead  			g.FillPolygon (brush' polyPt);  	}  	else  		g.DrawLine (pen' 0' 0' length' 0);  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )   {  	//pen.DashStyle = _style;  	// Only show the arrowhead if required  	if (_isArrowHead) {  		// Draw the line segment for this arrow  		g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  		// Create a polygon representing the arrowhead based on the scaled  		// size  		PointF[] polyPt = new PointF[4];  		float hsize = scaledSize / 3.0F;  		polyPt [0].X = length;  		polyPt [0].Y = 0;  		polyPt [1].X = length - scaledSize;  		polyPt [1].Y = hsize;  		polyPt [2].X = length - scaledSize;  		polyPt [2].Y = -hsize;  		polyPt [3] = polyPt [0];  		using (SolidBrush brush = new SolidBrush (_line._color))  			// render the arrowhead  			g.FillPolygon (brush' polyPt);  	}  	else  		g.DrawLine (pen' 0' 0' length' 0);  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )   {  	//pen.DashStyle = _style;  	// Only show the arrowhead if required  	if (_isArrowHead) {  		// Draw the line segment for this arrow  		g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  		// Create a polygon representing the arrowhead based on the scaled  		// size  		PointF[] polyPt = new PointF[4];  		float hsize = scaledSize / 3.0F;  		polyPt [0].X = length;  		polyPt [0].Y = 0;  		polyPt [1].X = length - scaledSize;  		polyPt [1].Y = hsize;  		polyPt [2].X = length - scaledSize;  		polyPt [2].Y = -hsize;  		polyPt [3] = polyPt [0];  		using (SolidBrush brush = new SolidBrush (_line._color))  			// render the arrowhead  			g.FillPolygon (brush' polyPt);  	}  	else  		g.DrawLine (pen' 0' 0' length' 0);  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _color' pane.ScaledPenWidth( _penWidth' scaleFactor ) ) )   {  	//pen.DashStyle = _style;  	// Only show the arrowhead if required  	if (_isArrowHead) {  		// Draw the line segment for this arrow  		g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  		// Create a polygon representing the arrowhead based on the scaled  		// size  		PointF[] polyPt = new PointF[4];  		float hsize = scaledSize / 3.0F;  		polyPt [0].X = length;  		polyPt [0].Y = 0;  		polyPt [1].X = length - scaledSize;  		polyPt [1].Y = hsize;  		polyPt [2].X = length - scaledSize;  		polyPt [2].Y = -hsize;  		polyPt [3] = polyPt [0];  		using (SolidBrush brush = new SolidBrush (_line._color))  			// render the arrowhead  			g.FillPolygon (brush' polyPt);  	}  	else  		g.DrawLine (pen' 0' 0' length' 0);  }  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (_isArrowHead) {  	// Draw the line segment for this arrow  	g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  	// Create a polygon representing the arrowhead based on the scaled  	// size  	PointF[] polyPt = new PointF[4];  	float hsize = scaledSize / 3.0F;  	polyPt [0].X = length;  	polyPt [0].Y = 0;  	polyPt [1].X = length - scaledSize;  	polyPt [1].Y = hsize;  	polyPt [2].X = length - scaledSize;  	polyPt [2].Y = -hsize;  	polyPt [3] = polyPt [0];  	using (SolidBrush brush = new SolidBrush (_line._color))  		// render the arrowhead  		g.FillPolygon (brush' polyPt);  }  else  	g.DrawLine (pen' 0' 0' length' 0);  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (_isArrowHead) {  	// Draw the line segment for this arrow  	g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  	// Create a polygon representing the arrowhead based on the scaled  	// size  	PointF[] polyPt = new PointF[4];  	float hsize = scaledSize / 3.0F;  	polyPt [0].X = length;  	polyPt [0].Y = 0;  	polyPt [1].X = length - scaledSize;  	polyPt [1].Y = hsize;  	polyPt [2].X = length - scaledSize;  	polyPt [2].Y = -hsize;  	polyPt [3] = polyPt [0];  	using (SolidBrush brush = new SolidBrush (_line._color))  		// render the arrowhead  		g.FillPolygon (brush' polyPt);  }  else  	g.DrawLine (pen' 0' 0' length' 0);  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (_isArrowHead) {  	// Draw the line segment for this arrow  	g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  	// Create a polygon representing the arrowhead based on the scaled  	// size  	PointF[] polyPt = new PointF[4];  	float hsize = scaledSize / 3.0F;  	polyPt [0].X = length;  	polyPt [0].Y = 0;  	polyPt [1].X = length - scaledSize;  	polyPt [1].Y = hsize;  	polyPt [2].X = length - scaledSize;  	polyPt [2].Y = -hsize;  	polyPt [3] = polyPt [0];  	using (SolidBrush brush = new SolidBrush (_line._color))  		// render the arrowhead  		g.FillPolygon (brush' polyPt);  }  else  	g.DrawLine (pen' 0' 0' length' 0);  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: if (_isArrowHead) {  	// Draw the line segment for this arrow  	g.DrawLine (pen' 0' 0' length - scaledSize + 1' 0);  	// Create a polygon representing the arrowhead based on the scaled  	// size  	PointF[] polyPt = new PointF[4];  	float hsize = scaledSize / 3.0F;  	polyPt [0].X = length;  	polyPt [0].Y = 0;  	polyPt [1].X = length - scaledSize;  	polyPt [1].Y = hsize;  	polyPt [2].X = length - scaledSize;  	polyPt [2].Y = -hsize;  	polyPt [3] = polyPt [0];  	using (SolidBrush brush = new SolidBrush (_line._color))  		// render the arrowhead  		g.FillPolygon (brush' polyPt);  }  else  	g.DrawLine (pen' 0' 0' length' 0);  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: polyPt [2].X = length - scaledSize;  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: polyPt [2].Y = -hsize;  
Magic Number,ZedGraph,ArrowObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ArrowObj.cs,Draw,The following statement contains a magic number: polyPt [3] = polyPt [0];  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if ((this.MinorTic.IsOutside || this.MinorTic.IsOpposite || this.MinorTic.IsInside || this.MinorTic._isCrossOutside || this.MinorTic._isCrossInside || _minorGrid._isVisible) && _isVisible) {  	double tMajor = _scale._majorStep * _scale.MajorUnitMultiplier' tMinor = _scale._minorStep * _scale.MinorUnitMultiplier;  	if (_scale.IsLog || tMinor < tMajor) {  		float minorScaledTic = this.MinorTic.ScaledTic (scaleFactor);  		// Minor tics start at the minimum value and step all the way thru  		// the full scale.  This means that if the minor step size is not  		// an even division of the major step size' the minor tics won't  		// line up with all of the scale labels and major tics.  		double first = _scale._minLinTemp' last = _scale._maxLinTemp;  		double dVal = first;  		float pixVal;  		int iTic = _scale.CalcMinorStart (baseVal);  		int MajorTic = 0;  		double majorVal = _scale.CalcMajorTicValue (baseVal' MajorTic);  		using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  			using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  				// Draw the minor tic marks  				while (dVal < last && iTic < 5000) {  					// Calculate the scale value for the current tic  					dVal = _scale.CalcMinorTicValue (baseVal' iTic);  					// Maintain a value for the current major tic  					if (dVal > majorVal)  						majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  					// Make sure that the current value does not match up with a major tic  					if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  						pixVal = _scale.LocalTransform (dVal);  						_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  						_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  					}  					iTic++;  				}  			}  	}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if ((this.MinorTic.IsOutside || this.MinorTic.IsOpposite || this.MinorTic.IsInside || this.MinorTic._isCrossOutside || this.MinorTic._isCrossInside || _minorGrid._isVisible) && _isVisible) {  	double tMajor = _scale._majorStep * _scale.MajorUnitMultiplier' tMinor = _scale._minorStep * _scale.MinorUnitMultiplier;  	if (_scale.IsLog || tMinor < tMajor) {  		float minorScaledTic = this.MinorTic.ScaledTic (scaleFactor);  		// Minor tics start at the minimum value and step all the way thru  		// the full scale.  This means that if the minor step size is not  		// an even division of the major step size' the minor tics won't  		// line up with all of the scale labels and major tics.  		double first = _scale._minLinTemp' last = _scale._maxLinTemp;  		double dVal = first;  		float pixVal;  		int iTic = _scale.CalcMinorStart (baseVal);  		int MajorTic = 0;  		double majorVal = _scale.CalcMajorTicValue (baseVal' MajorTic);  		using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  			using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  				// Draw the minor tic marks  				while (dVal < last && iTic < 5000) {  					// Calculate the scale value for the current tic  					dVal = _scale.CalcMinorTicValue (baseVal' iTic);  					// Maintain a value for the current major tic  					if (dVal > majorVal)  						majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  					// Make sure that the current value does not match up with a major tic  					if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  						pixVal = _scale.LocalTransform (dVal);  						_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  						_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  					}  					iTic++;  				}  			}  	}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if ((this.MinorTic.IsOutside || this.MinorTic.IsOpposite || this.MinorTic.IsInside || this.MinorTic._isCrossOutside || this.MinorTic._isCrossInside || _minorGrid._isVisible) && _isVisible) {  	double tMajor = _scale._majorStep * _scale.MajorUnitMultiplier' tMinor = _scale._minorStep * _scale.MinorUnitMultiplier;  	if (_scale.IsLog || tMinor < tMajor) {  		float minorScaledTic = this.MinorTic.ScaledTic (scaleFactor);  		// Minor tics start at the minimum value and step all the way thru  		// the full scale.  This means that if the minor step size is not  		// an even division of the major step size' the minor tics won't  		// line up with all of the scale labels and major tics.  		double first = _scale._minLinTemp' last = _scale._maxLinTemp;  		double dVal = first;  		float pixVal;  		int iTic = _scale.CalcMinorStart (baseVal);  		int MajorTic = 0;  		double majorVal = _scale.CalcMajorTicValue (baseVal' MajorTic);  		using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  			using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  				// Draw the minor tic marks  				while (dVal < last && iTic < 5000) {  					// Calculate the scale value for the current tic  					dVal = _scale.CalcMinorTicValue (baseVal' iTic);  					// Maintain a value for the current major tic  					if (dVal > majorVal)  						majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  					// Make sure that the current value does not match up with a major tic  					if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  						pixVal = _scale.LocalTransform (dVal);  						_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  						_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  					}  					iTic++;  				}  			}  	}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if ((this.MinorTic.IsOutside || this.MinorTic.IsOpposite || this.MinorTic.IsInside || this.MinorTic._isCrossOutside || this.MinorTic._isCrossInside || _minorGrid._isVisible) && _isVisible) {  	double tMajor = _scale._majorStep * _scale.MajorUnitMultiplier' tMinor = _scale._minorStep * _scale.MinorUnitMultiplier;  	if (_scale.IsLog || tMinor < tMajor) {  		float minorScaledTic = this.MinorTic.ScaledTic (scaleFactor);  		// Minor tics start at the minimum value and step all the way thru  		// the full scale.  This means that if the minor step size is not  		// an even division of the major step size' the minor tics won't  		// line up with all of the scale labels and major tics.  		double first = _scale._minLinTemp' last = _scale._maxLinTemp;  		double dVal = first;  		float pixVal;  		int iTic = _scale.CalcMinorStart (baseVal);  		int MajorTic = 0;  		double majorVal = _scale.CalcMajorTicValue (baseVal' MajorTic);  		using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  			using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  				// Draw the minor tic marks  				while (dVal < last && iTic < 5000) {  					// Calculate the scale value for the current tic  					dVal = _scale.CalcMinorTicValue (baseVal' iTic);  					// Maintain a value for the current major tic  					if (dVal > majorVal)  						majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  					// Make sure that the current value does not match up with a major tic  					if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  						pixVal = _scale.LocalTransform (dVal);  						_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  						_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  					}  					iTic++;  				}  			}  	}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if ((this.MinorTic.IsOutside || this.MinorTic.IsOpposite || this.MinorTic.IsInside || this.MinorTic._isCrossOutside || this.MinorTic._isCrossInside || _minorGrid._isVisible) && _isVisible) {  	double tMajor = _scale._majorStep * _scale.MajorUnitMultiplier' tMinor = _scale._minorStep * _scale.MinorUnitMultiplier;  	if (_scale.IsLog || tMinor < tMajor) {  		float minorScaledTic = this.MinorTic.ScaledTic (scaleFactor);  		// Minor tics start at the minimum value and step all the way thru  		// the full scale.  This means that if the minor step size is not  		// an even division of the major step size' the minor tics won't  		// line up with all of the scale labels and major tics.  		double first = _scale._minLinTemp' last = _scale._maxLinTemp;  		double dVal = first;  		float pixVal;  		int iTic = _scale.CalcMinorStart (baseVal);  		int MajorTic = 0;  		double majorVal = _scale.CalcMajorTicValue (baseVal' MajorTic);  		using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  			using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  				// Draw the minor tic marks  				while (dVal < last && iTic < 5000) {  					// Calculate the scale value for the current tic  					dVal = _scale.CalcMinorTicValue (baseVal' iTic);  					// Maintain a value for the current major tic  					if (dVal > majorVal)  						majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  					// Make sure that the current value does not match up with a major tic  					if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  						pixVal = _scale.LocalTransform (dVal);  						_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  						_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  					}  					iTic++;  				}  			}  	}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if (_scale.IsLog || tMinor < tMajor) {  	float minorScaledTic = this.MinorTic.ScaledTic (scaleFactor);  	// Minor tics start at the minimum value and step all the way thru  	// the full scale.  This means that if the minor step size is not  	// an even division of the major step size' the minor tics won't  	// line up with all of the scale labels and major tics.  	double first = _scale._minLinTemp' last = _scale._maxLinTemp;  	double dVal = first;  	float pixVal;  	int iTic = _scale.CalcMinorStart (baseVal);  	int MajorTic = 0;  	double majorVal = _scale.CalcMajorTicValue (baseVal' MajorTic);  	using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  		using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  			// Draw the minor tic marks  			while (dVal < last && iTic < 5000) {  				// Calculate the scale value for the current tic  				dVal = _scale.CalcMinorTicValue (baseVal' iTic);  				// Maintain a value for the current major tic  				if (dVal > majorVal)  					majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  				// Make sure that the current value does not match up with a major tic  				if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  					pixVal = _scale.LocalTransform (dVal);  					_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  					_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  				}  				iTic++;  			}  		}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if (_scale.IsLog || tMinor < tMajor) {  	float minorScaledTic = this.MinorTic.ScaledTic (scaleFactor);  	// Minor tics start at the minimum value and step all the way thru  	// the full scale.  This means that if the minor step size is not  	// an even division of the major step size' the minor tics won't  	// line up with all of the scale labels and major tics.  	double first = _scale._minLinTemp' last = _scale._maxLinTemp;  	double dVal = first;  	float pixVal;  	int iTic = _scale.CalcMinorStart (baseVal);  	int MajorTic = 0;  	double majorVal = _scale.CalcMajorTicValue (baseVal' MajorTic);  	using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  		using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  			// Draw the minor tic marks  			while (dVal < last && iTic < 5000) {  				// Calculate the scale value for the current tic  				dVal = _scale.CalcMinorTicValue (baseVal' iTic);  				// Maintain a value for the current major tic  				if (dVal > majorVal)  					majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  				// Make sure that the current value does not match up with a major tic  				if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  					pixVal = _scale.LocalTransform (dVal);  					_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  					_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  				}  				iTic++;  			}  		}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if (_scale.IsLog || tMinor < tMajor) {  	float minorScaledTic = this.MinorTic.ScaledTic (scaleFactor);  	// Minor tics start at the minimum value and step all the way thru  	// the full scale.  This means that if the minor step size is not  	// an even division of the major step size' the minor tics won't  	// line up with all of the scale labels and major tics.  	double first = _scale._minLinTemp' last = _scale._maxLinTemp;  	double dVal = first;  	float pixVal;  	int iTic = _scale.CalcMinorStart (baseVal);  	int MajorTic = 0;  	double majorVal = _scale.CalcMajorTicValue (baseVal' MajorTic);  	using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  		using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  			// Draw the minor tic marks  			while (dVal < last && iTic < 5000) {  				// Calculate the scale value for the current tic  				dVal = _scale.CalcMinorTicValue (baseVal' iTic);  				// Maintain a value for the current major tic  				if (dVal > majorVal)  					majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  				// Make sure that the current value does not match up with a major tic  				if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  					pixVal = _scale.LocalTransform (dVal);  					_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  					_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  				}  				iTic++;  			}  		}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if (_scale.IsLog || tMinor < tMajor) {  	float minorScaledTic = this.MinorTic.ScaledTic (scaleFactor);  	// Minor tics start at the minimum value and step all the way thru  	// the full scale.  This means that if the minor step size is not  	// an even division of the major step size' the minor tics won't  	// line up with all of the scale labels and major tics.  	double first = _scale._minLinTemp' last = _scale._maxLinTemp;  	double dVal = first;  	float pixVal;  	int iTic = _scale.CalcMinorStart (baseVal);  	int MajorTic = 0;  	double majorVal = _scale.CalcMajorTicValue (baseVal' MajorTic);  	using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  		using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  			// Draw the minor tic marks  			while (dVal < last && iTic < 5000) {  				// Calculate the scale value for the current tic  				dVal = _scale.CalcMinorTicValue (baseVal' iTic);  				// Maintain a value for the current major tic  				if (dVal > majorVal)  					majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  				// Make sure that the current value does not match up with a major tic  				if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  					pixVal = _scale.LocalTransform (dVal);  					_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  					_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  				}  				iTic++;  			}  		}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if (_scale.IsLog || tMinor < tMajor) {  	float minorScaledTic = this.MinorTic.ScaledTic (scaleFactor);  	// Minor tics start at the minimum value and step all the way thru  	// the full scale.  This means that if the minor step size is not  	// an even division of the major step size' the minor tics won't  	// line up with all of the scale labels and major tics.  	double first = _scale._minLinTemp' last = _scale._maxLinTemp;  	double dVal = first;  	float pixVal;  	int iTic = _scale.CalcMinorStart (baseVal);  	int MajorTic = 0;  	double majorVal = _scale.CalcMajorTicValue (baseVal' MajorTic);  	using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  		using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  			// Draw the minor tic marks  			while (dVal < last && iTic < 5000) {  				// Calculate the scale value for the current tic  				dVal = _scale.CalcMinorTicValue (baseVal' iTic);  				// Maintain a value for the current major tic  				if (dVal > majorVal)  					majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  				// Make sure that the current value does not match up with a major tic  				if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  					pixVal = _scale.LocalTransform (dVal);  					_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  					_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  				}  				iTic++;  			}  		}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  	using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  		// Draw the minor tic marks  		while (dVal < last && iTic < 5000) {  			// Calculate the scale value for the current tic  			dVal = _scale.CalcMinorTicValue (baseVal' iTic);  			// Maintain a value for the current major tic  			if (dVal > majorVal)  				majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  			// Make sure that the current value does not match up with a major tic  			if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  				pixVal = _scale.LocalTransform (dVal);  				_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  				_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  			}  			iTic++;  		}  	}  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  	using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  		// Draw the minor tic marks  		while (dVal < last && iTic < 5000) {  			// Calculate the scale value for the current tic  			dVal = _scale.CalcMinorTicValue (baseVal' iTic);  			// Maintain a value for the current major tic  			if (dVal > majorVal)  				majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  			// Make sure that the current value does not match up with a major tic  			if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  				pixVal = _scale.LocalTransform (dVal);  				_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  				_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  			}  			iTic++;  		}  	}  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  	using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  		// Draw the minor tic marks  		while (dVal < last && iTic < 5000) {  			// Calculate the scale value for the current tic  			dVal = _scale.CalcMinorTicValue (baseVal' iTic);  			// Maintain a value for the current major tic  			if (dVal > majorVal)  				majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  			// Make sure that the current value does not match up with a major tic  			if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  				pixVal = _scale.LocalTransform (dVal);  				_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  				_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  			}  			iTic++;  		}  	}  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  	using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  		// Draw the minor tic marks  		while (dVal < last && iTic < 5000) {  			// Calculate the scale value for the current tic  			dVal = _scale.CalcMinorTicValue (baseVal' iTic);  			// Maintain a value for the current major tic  			if (dVal > majorVal)  				majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  			// Make sure that the current value does not match up with a major tic  			if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  				pixVal = _scale.LocalTransform (dVal);  				_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  				_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  			}  			iTic++;  		}  	}  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: using (Pen pen = new Pen (_minorTic._color' pane.ScaledPenWidth (MinorTic._penWidth' scaleFactor)))  	using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  		// Draw the minor tic marks  		while (dVal < last && iTic < 5000) {  			// Calculate the scale value for the current tic  			dVal = _scale.CalcMinorTicValue (baseVal' iTic);  			// Maintain a value for the current major tic  			if (dVal > majorVal)  				majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  			// Make sure that the current value does not match up with a major tic  			if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  				pixVal = _scale.LocalTransform (dVal);  				_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  				_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  			}  			iTic++;  		}  	}  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  	// Draw the minor tic marks  	while (dVal < last && iTic < 5000) {  		// Calculate the scale value for the current tic  		dVal = _scale.CalcMinorTicValue (baseVal' iTic);  		// Maintain a value for the current major tic  		if (dVal > majorVal)  			majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  		// Make sure that the current value does not match up with a major tic  		if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  			pixVal = _scale.LocalTransform (dVal);  			_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  			_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  		}  		iTic++;  	}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  	// Draw the minor tic marks  	while (dVal < last && iTic < 5000) {  		// Calculate the scale value for the current tic  		dVal = _scale.CalcMinorTicValue (baseVal' iTic);  		// Maintain a value for the current major tic  		if (dVal > majorVal)  			majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  		// Make sure that the current value does not match up with a major tic  		if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  			pixVal = _scale.LocalTransform (dVal);  			_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  			_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  		}  		iTic++;  	}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  	// Draw the minor tic marks  	while (dVal < last && iTic < 5000) {  		// Calculate the scale value for the current tic  		dVal = _scale.CalcMinorTicValue (baseVal' iTic);  		// Maintain a value for the current major tic  		if (dVal > majorVal)  			majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  		// Make sure that the current value does not match up with a major tic  		if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  			pixVal = _scale.LocalTransform (dVal);  			_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  			_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  		}  		iTic++;  	}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  	// Draw the minor tic marks  	while (dVal < last && iTic < 5000) {  		// Calculate the scale value for the current tic  		dVal = _scale.CalcMinorTicValue (baseVal' iTic);  		// Maintain a value for the current major tic  		if (dVal > majorVal)  			majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  		// Make sure that the current value does not match up with a major tic  		if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  			pixVal = _scale.LocalTransform (dVal);  			_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  			_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  		}  		iTic++;  	}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: using (Pen minorGridPen = _minorGrid.GetPen (pane' scaleFactor)) {  	// Draw the minor tic marks  	while (dVal < last && iTic < 5000) {  		// Calculate the scale value for the current tic  		dVal = _scale.CalcMinorTicValue (baseVal' iTic);  		// Maintain a value for the current major tic  		if (dVal > majorVal)  			majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  		// Make sure that the current value does not match up with a major tic  		if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  			pixVal = _scale.LocalTransform (dVal);  			_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  			_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  		}  		iTic++;  	}  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: while (dVal < last && iTic < 5000) {  	// Calculate the scale value for the current tic  	dVal = _scale.CalcMinorTicValue (baseVal' iTic);  	// Maintain a value for the current major tic  	if (dVal > majorVal)  		majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  	// Make sure that the current value does not match up with a major tic  	if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  		pixVal = _scale.LocalTransform (dVal);  		_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  		_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  	}  	iTic++;  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: while (dVal < last && iTic < 5000) {  	// Calculate the scale value for the current tic  	dVal = _scale.CalcMinorTicValue (baseVal' iTic);  	// Maintain a value for the current major tic  	if (dVal > majorVal)  		majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  	// Make sure that the current value does not match up with a major tic  	if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  		pixVal = _scale.LocalTransform (dVal);  		_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  		_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  	}  	iTic++;  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: while (dVal < last && iTic < 5000) {  	// Calculate the scale value for the current tic  	dVal = _scale.CalcMinorTicValue (baseVal' iTic);  	// Maintain a value for the current major tic  	if (dVal > majorVal)  		majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  	// Make sure that the current value does not match up with a major tic  	if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  		pixVal = _scale.LocalTransform (dVal);  		_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  		_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  	}  	iTic++;  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: while (dVal < last && iTic < 5000) {  	// Calculate the scale value for the current tic  	dVal = _scale.CalcMinorTicValue (baseVal' iTic);  	// Maintain a value for the current major tic  	if (dVal > majorVal)  		majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  	// Make sure that the current value does not match up with a major tic  	if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  		pixVal = _scale.LocalTransform (dVal);  		_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  		_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  	}  	iTic++;  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: while (dVal < last && iTic < 5000) {  	// Calculate the scale value for the current tic  	dVal = _scale.CalcMinorTicValue (baseVal' iTic);  	// Maintain a value for the current major tic  	if (dVal > majorVal)  		majorVal = _scale.CalcMajorTicValue (baseVal' ++MajorTic);  	// Make sure that the current value does not match up with a major tic  	if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  		pixVal = _scale.LocalTransform (dVal);  		_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  		_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  	}  	iTic++;  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  	pixVal = _scale.LocalTransform (dVal);  	_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  	_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  	pixVal = _scale.LocalTransform (dVal);  	_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  	_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  	pixVal = _scale.LocalTransform (dVal);  	_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  	_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawMinorTics,The following statement contains a magic number: if (((Math.Abs (dVal) < 1e-20 && Math.Abs (dVal - majorVal) > 1e-20) || (Math.Abs (dVal) > 1e-20 && Math.Abs ((dVal - majorVal) / dVal) > 1e-10)) && (dVal >= first && dVal <= last)) {  	pixVal = _scale.LocalTransform (dVal);  	_minorGrid.Draw (g' minorGridPen' pixVal' topPix);  	_minorTic.Draw (g' pane' pen' pixVal' topPix' shift' minorScaledTic);  }  
Magic Number,ZedGraph,Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Axis.cs,DrawTitle,The following statement contains a magic number: if (_isVisible && _title._isVisible && !string.IsNullOrEmpty (str)) {  	bool hasTic = (_scale._isLabelsInside ? (this.MajorTic.IsInside || this.MajorTic._isCrossInside || this.MinorTic.IsInside || this.MinorTic._isCrossInside) : (this.MajorTic.IsOutside || this.MajorTic._isCrossOutside || this.MinorTic.IsOutside || this.MinorTic._isCrossOutside));  	// Calculate the title position in screen coordinates  	float x = (_scale._maxPix - _scale._minPix) / 2;  	float scaledTic = MajorTic.ScaledTic (scaleFactor);  	float scaledLabelGap = _scale._fontSpec.GetHeight (scaleFactor) * _scale._labelGap;  	float scaledTitleGap = _title.GetScaledGap (scaleFactor);  	// The space for the scale labels is only reserved if the axis is not shifted due to the  	// cross value.  Note that this could be a problem if the axis is only shifted slightly'  	// since the scale value labels may overlap the axis title.  However' it's not possible to  	// calculate that actual shift amount at this point' because the ChartRect rect has not yet been  	// calculated' and the cross value is determined using a transform of scale values (which  	// rely on ChartRect).  	float gap = scaledTic * (hasTic ? 1.0f : 0.0f) + this.Title.FontSpec.BoundingBox (g' str' scaleFactor).Height / 2.0F;  	float y = (_scale._isVisible ? _scale.GetScaleMaxSpace (g' pane' scaleFactor' true).Height + scaledLabelGap : 0);  	if (_scale._isLabelsInside)  		y = shiftPos - y - gap;  	else  		y = shiftPos + y + gap;  	if (!_crossAuto && !_title._isTitleAtCross)  		y = Math.Max (y' gap);  	AlignV alignV = AlignV.Center;  	// Add in the TitleGap space  	y += scaledTitleGap;  	// Draw the title  	this.Title.FontSpec.Draw (g' pane' str' x' y' AlignH.Center' alignV' scaleFactor);  }  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (top < -10000)  	top = -10000;  else if (top > 10000)  	top = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (top < -10000)  	top = -10000;  else if (top > 10000)  	top = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (top < -10000)  	top = -10000;  else if (top > 10000)  	top = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (top < -10000)  	top = -10000;  else if (top > 10000)  	top = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: top = -10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (top > 10000)  	top = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (top > 10000)  	top = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: top = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (left < -10000)  	left = -10000;  else if (left > 10000)  	left = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (left < -10000)  	left = -10000;  else if (left > 10000)  	left = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (left < -10000)  	left = -10000;  else if (left > 10000)  	left = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (left < -10000)  	left = -10000;  else if (left > 10000)  	left = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: left = -10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (left > 10000)  	left = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (left > 10000)  	left = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: left = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (right < -10000)  	right = -10000;  else if (right > 10000)  	right = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (right < -10000)  	right = -10000;  else if (right > 10000)  	right = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (right < -10000)  	right = -10000;  else if (right > 10000)  	right = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (right < -10000)  	right = -10000;  else if (right > 10000)  	right = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: right = -10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (right > 10000)  	right = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (right > 10000)  	right = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: right = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (bottom < -10000)  	bottom = -10000;  else if (bottom > 10000)  	bottom = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (bottom < -10000)  	bottom = -10000;  else if (bottom > 10000)  	bottom = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (bottom < -10000)  	bottom = -10000;  else if (bottom > 10000)  	bottom = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (bottom < -10000)  	bottom = -10000;  else if (bottom > 10000)  	bottom = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: bottom = -10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (bottom > 10000)  	bottom = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: if (bottom > 10000)  	bottom = 10000;  
Magic Number,ZedGraph,Bar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Bar.cs,Draw,The following statement contains a magic number: bottom = 10000;  
Magic Number,ZedGraph,BarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BarItem.cs,CreateBarLabels,The following statement contains a magic number: foreach (CurveItem curve in pane.CurveList) {  	// work with BarItems only  	BarItem bar = curve as BarItem;  	if (bar != null) {  		IPointList points = curve.Points;  		// ADD JKB 9/21/07  		// The labelOffset should depend on whether the curve is YAxis or Y2Axis.  		// JHC - Generalize to any value axis  		// Make the gap between the bars and the labels = 1.5% of the axis range  		float labelOffset;  		Scale scale = curve.ValueAxis (pane).Scale;  		labelOffset = (float)(scale._max - scale._min) * 0.015f;  		// Loop through each point in the BarItem  		for (int i = 0; i < points.Count; i++) {  			// Get the high' low and base values for the current bar  			// note that this method will automatically calculate the "effective"  			// values if the bar is stacked  			double baseVal' lowVal' hiVal;  			valueHandler.GetValues (curve' i' out baseVal' out lowVal' out hiVal);  			// Get the value that corresponds to the center of the bar base  			// This method figures out how the bars are positioned within a cluster  			float centerVal = (float)valueHandler.BarCenterValue (bar' bar.GetBarWidth (pane)' i' baseVal' curveIndex);  			// Create a text label -- note that we have to go back to the original point  			// data for this' since hiVal and lowVal could be "effective" values from a bar stack  			string barLabelText = (isVertical ? points [i].Y : points [i].X).ToString (valueFormat);  			// Calculate the position of the label -- this is either the X or the Y coordinate  			// depending on whether they are horizontal or vertical bars' respectively  			float position;  			if (isBarCenter)  				position = (float)(hiVal + lowVal) / 2.0f;  			else if (hiVal >= 0)  				position = (float)hiVal + labelOffset;  			else  				position = (float)hiVal - labelOffset;  			// Create the new TextObj  			TextObj label;  			if (isVertical)  				label = new TextObj (barLabelText' centerVal' position);  			else  				label = new TextObj (barLabelText' position' centerVal);  			label.FontSpec.Family = fontFamily;  			// Configure the TextObj  			// CHANGE JKB 9/21/07  			// CoordinateFrame should depend on whether curve is YAxis or Y2Axis.  			label.Location.CoordinateFrame = (isVertical && curve.IsY2Axis) ? CoordType.AxisXY2Scale : CoordType.AxisXYScale;  			label.FontSpec.Size = fontSize;  			label.FontSpec.FontColor = fontColor;  			label.FontSpec.IsItalic = isItalic;  			label.FontSpec.IsBold = isBold;  			label.FontSpec.IsUnderline = isUnderline;  			label.FontSpec.Angle = isVertical ? 90 : 0;  			label.Location.AlignH = isBarCenter ? AlignH.Center : (hiVal >= 0 ? AlignH.Left : AlignH.Right);  			label.Location.AlignV = AlignV.Center;  			label.FontSpec.Border.IsVisible = false;  			label.FontSpec.Fill.IsVisible = false;  			// Add the TextObj to the GraphPane  			pane.GraphObjList.Add (label);  		}  		curveIndex++;  	}  }  
Magic Number,ZedGraph,BarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BarItem.cs,CreateBarLabels,The following statement contains a magic number: if (bar != null) {  	IPointList points = curve.Points;  	// ADD JKB 9/21/07  	// The labelOffset should depend on whether the curve is YAxis or Y2Axis.  	// JHC - Generalize to any value axis  	// Make the gap between the bars and the labels = 1.5% of the axis range  	float labelOffset;  	Scale scale = curve.ValueAxis (pane).Scale;  	labelOffset = (float)(scale._max - scale._min) * 0.015f;  	// Loop through each point in the BarItem  	for (int i = 0; i < points.Count; i++) {  		// Get the high' low and base values for the current bar  		// note that this method will automatically calculate the "effective"  		// values if the bar is stacked  		double baseVal' lowVal' hiVal;  		valueHandler.GetValues (curve' i' out baseVal' out lowVal' out hiVal);  		// Get the value that corresponds to the center of the bar base  		// This method figures out how the bars are positioned within a cluster  		float centerVal = (float)valueHandler.BarCenterValue (bar' bar.GetBarWidth (pane)' i' baseVal' curveIndex);  		// Create a text label -- note that we have to go back to the original point  		// data for this' since hiVal and lowVal could be "effective" values from a bar stack  		string barLabelText = (isVertical ? points [i].Y : points [i].X).ToString (valueFormat);  		// Calculate the position of the label -- this is either the X or the Y coordinate  		// depending on whether they are horizontal or vertical bars' respectively  		float position;  		if (isBarCenter)  			position = (float)(hiVal + lowVal) / 2.0f;  		else if (hiVal >= 0)  			position = (float)hiVal + labelOffset;  		else  			position = (float)hiVal - labelOffset;  		// Create the new TextObj  		TextObj label;  		if (isVertical)  			label = new TextObj (barLabelText' centerVal' position);  		else  			label = new TextObj (barLabelText' position' centerVal);  		label.FontSpec.Family = fontFamily;  		// Configure the TextObj  		// CHANGE JKB 9/21/07  		// CoordinateFrame should depend on whether curve is YAxis or Y2Axis.  		label.Location.CoordinateFrame = (isVertical && curve.IsY2Axis) ? CoordType.AxisXY2Scale : CoordType.AxisXYScale;  		label.FontSpec.Size = fontSize;  		label.FontSpec.FontColor = fontColor;  		label.FontSpec.IsItalic = isItalic;  		label.FontSpec.IsBold = isBold;  		label.FontSpec.IsUnderline = isUnderline;  		label.FontSpec.Angle = isVertical ? 90 : 0;  		label.Location.AlignH = isBarCenter ? AlignH.Center : (hiVal >= 0 ? AlignH.Left : AlignH.Right);  		label.Location.AlignV = AlignV.Center;  		label.FontSpec.Border.IsVisible = false;  		label.FontSpec.Fill.IsVisible = false;  		// Add the TextObj to the GraphPane  		pane.GraphObjList.Add (label);  	}  	curveIndex++;  }  
Magic Number,ZedGraph,BarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BarItem.cs,CreateBarLabels,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	// Get the high' low and base values for the current bar  	// note that this method will automatically calculate the "effective"  	// values if the bar is stacked  	double baseVal' lowVal' hiVal;  	valueHandler.GetValues (curve' i' out baseVal' out lowVal' out hiVal);  	// Get the value that corresponds to the center of the bar base  	// This method figures out how the bars are positioned within a cluster  	float centerVal = (float)valueHandler.BarCenterValue (bar' bar.GetBarWidth (pane)' i' baseVal' curveIndex);  	// Create a text label -- note that we have to go back to the original point  	// data for this' since hiVal and lowVal could be "effective" values from a bar stack  	string barLabelText = (isVertical ? points [i].Y : points [i].X).ToString (valueFormat);  	// Calculate the position of the label -- this is either the X or the Y coordinate  	// depending on whether they are horizontal or vertical bars' respectively  	float position;  	if (isBarCenter)  		position = (float)(hiVal + lowVal) / 2.0f;  	else if (hiVal >= 0)  		position = (float)hiVal + labelOffset;  	else  		position = (float)hiVal - labelOffset;  	// Create the new TextObj  	TextObj label;  	if (isVertical)  		label = new TextObj (barLabelText' centerVal' position);  	else  		label = new TextObj (barLabelText' position' centerVal);  	label.FontSpec.Family = fontFamily;  	// Configure the TextObj  	// CHANGE JKB 9/21/07  	// CoordinateFrame should depend on whether curve is YAxis or Y2Axis.  	label.Location.CoordinateFrame = (isVertical && curve.IsY2Axis) ? CoordType.AxisXY2Scale : CoordType.AxisXYScale;  	label.FontSpec.Size = fontSize;  	label.FontSpec.FontColor = fontColor;  	label.FontSpec.IsItalic = isItalic;  	label.FontSpec.IsBold = isBold;  	label.FontSpec.IsUnderline = isUnderline;  	label.FontSpec.Angle = isVertical ? 90 : 0;  	label.Location.AlignH = isBarCenter ? AlignH.Center : (hiVal >= 0 ? AlignH.Left : AlignH.Right);  	label.Location.AlignV = AlignV.Center;  	label.FontSpec.Border.IsVisible = false;  	label.FontSpec.Fill.IsVisible = false;  	// Add the TextObj to the GraphPane  	pane.GraphObjList.Add (label);  }  
Magic Number,ZedGraph,BarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BarItem.cs,CreateBarLabels,The following statement contains a magic number: label.FontSpec.Angle = isVertical ? 90 : 0;  
Magic Number,ZedGraph,BarSettings,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BarSettings.cs,GetMinStepSize,The following statement contains a magic number: if (range <= 0)  	minStep = 1.0;  //			else if ( minStep <= 0 || minStep < 0.001 * range || minStep > range )  else if (minStep <= 0 || minStep > range)  	minStep = 0.1 * range;  
Magic Number,ZedGraph,BarSettings,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BarSettings.cs,GetMinStepSize,The following statement contains a magic number: if (minStep <= 0 || minStep > range)  	minStep = 0.1 * range;  
Magic Number,ZedGraph,BarSettings,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BarSettings.cs,GetMinStepSize,The following statement contains a magic number: minStep = 0.1 * range;  
Magic Number,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,Draw,The following statement contains a magic number: tmpRect.Inflate (20' 20);  
Magic Number,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,Draw,The following statement contains a magic number: tmpRect.Inflate (20' 20);  
Magic Number,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000) {  	// If the box is to be filled' fill it  	_fill.Draw (g' pixRect);  	// Draw the border around the box if required  	_border.Draw (g' pane' scaleFactor' pixRect);  }  
Magic Number,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000) {  	// If the box is to be filled' fill it  	_fill.Draw (g' pixRect);  	// Draw the border around the box if required  	_border.Draw (g' pane' scaleFactor' pixRect);  }  
Magic Number,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000) {  	// If the box is to be filled' fill it  	_fill.Draw (g' pixRect);  	// Draw the border around the box if required  	_border.Draw (g' pane' scaleFactor' pixRect);  }  
Magic Number,ZedGraph,BoxObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\BoxObj.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000) {  	// If the box is to be filled' fill it  	_fill.Draw (g' pixRect);  	// Draw the border around the box if required  	_border.Draw (g' pane' scaleFactor' pixRect);  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing) {  	if (isXBase) {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  	}  	else {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing) {  	if (isXBase) {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  	}  	else {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing) {  	if (isXBase) {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  	}  	else {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing) {  	if (isXBase) {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  	}  	else {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing) {  	if (isXBase) {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  	}  	else {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing) {  	if (isXBase) {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  	}  	else {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing) {  	if (isXBase) {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  	}  	else {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing) {  	if (isXBase) {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  	}  	else {  		if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  			g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  			g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  		if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  			g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (isXBase) {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  }  else {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (isXBase) {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  }  else {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (isXBase) {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  }  else {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (isXBase) {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  }  else {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (isXBase) {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  }  else {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (isXBase) {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  }  else {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (isXBase) {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  }  else {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (isXBase) {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  }  else {  	if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  		g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  	if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  		g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  	g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  	g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  	g.DrawLine (pen' pixBase - halfSize' pixOpen' pixBase' pixOpen);  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  	g.DrawLine (pen' pixBase' pixClose' pixBase + halfSize' pixClose);  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  	g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000)  	g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000)  	g.DrawLine (pen' pixOpen' pixBase - halfSize' pixOpen' pixBase);  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (_isOpenCloseVisible && Math.Abs (pixClose) < 1000000)  	g.DrawLine (pen' pixClose' pixBase' pixClose' pixBase + halfSize);  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (curve.Points != null) {  	//float halfSize = _size * scaleFactor;  	float halfSize = GetBarWidth (pane' baseAxis' scaleFactor);  	using (Pen pen = !curve.IsSelected ? new Pen (_color' _width) : new Pen (Selection.Border.Color' Selection.Border.Width))//				using ( Pen pen = new Pen( _color' _penWidth ) )  	 {  		// Loop over each defined point							  		for (int i = 0; i < curve.Points.Count; i++) {  			PointPair pt = curve.Points [i];  			double date = pt.X;  			double high = pt.Y;  			double low = pt.Z;  			double open = PointPair.Missing;  			double close = PointPair.Missing;  			if (pt is StockPt) {  				open = (pt as StockPt).Open;  				close = (pt as StockPt).Close;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  				pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  				//pixBase = baseAxis.Scale.Transform( curve.IsOverrideOrdinal' i' date );  				pixHigh = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' high);  				pixLow = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' low);  				if (PointPair.IsValueInvalid (open))  					pixOpen = Single.MaxValue;  				else  					pixOpen = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' open);  				if (PointPair.IsValueInvalid (close))  					pixClose = Single.MaxValue;  				else  					pixClose = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' close);  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' pt))  						Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' tPen);  				}  				else  					Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' pen);  			}  		}  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: using (Pen pen = !curve.IsSelected ? new Pen (_color' _width) : new Pen (Selection.Border.Color' Selection.Border.Width))//				using ( Pen pen = new Pen( _color' _penWidth ) )   {  	// Loop over each defined point							  	for (int i = 0; i < curve.Points.Count; i++) {  		PointPair pt = curve.Points [i];  		double date = pt.X;  		double high = pt.Y;  		double low = pt.Z;  		double open = PointPair.Missing;  		double close = PointPair.Missing;  		if (pt is StockPt) {  			open = (pt as StockPt).Open;  			close = (pt as StockPt).Close;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  			pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  			//pixBase = baseAxis.Scale.Transform( curve.IsOverrideOrdinal' i' date );  			pixHigh = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' high);  			pixLow = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' low);  			if (PointPair.IsValueInvalid (open))  				pixOpen = Single.MaxValue;  			else  				pixOpen = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' open);  			if (PointPair.IsValueInvalid (close))  				pixClose = Single.MaxValue;  			else  				pixClose = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' close);  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' pt))  					Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' tPen);  			}  			else  				Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' pen);  		}  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: for (int i = 0; i < curve.Points.Count; i++) {  	PointPair pt = curve.Points [i];  	double date = pt.X;  	double high = pt.Y;  	double low = pt.Z;  	double open = PointPair.Missing;  	double close = PointPair.Missing;  	if (pt is StockPt) {  		open = (pt as StockPt).Open;  		close = (pt as StockPt).Close;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  		pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  		//pixBase = baseAxis.Scale.Transform( curve.IsOverrideOrdinal' i' date );  		pixHigh = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' high);  		pixLow = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' low);  		if (PointPair.IsValueInvalid (open))  			pixOpen = Single.MaxValue;  		else  			pixOpen = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' open);  		if (PointPair.IsValueInvalid (close))  			pixClose = Single.MaxValue;  		else  			pixClose = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' close);  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' pt))  				Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' tPen);  		}  		else  			Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' pen);  	}  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  	pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  	//pixBase = baseAxis.Scale.Transform( curve.IsOverrideOrdinal' i' date );  	pixHigh = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' high);  	pixLow = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' low);  	if (PointPair.IsValueInvalid (open))  		pixOpen = Single.MaxValue;  	else  		pixOpen = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' open);  	if (PointPair.IsValueInvalid (close))  		pixClose = Single.MaxValue;  	else  		pixClose = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' close);  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' pt))  			Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' tPen);  	}  	else  		Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' pen);  }  
Magic Number,ZedGraph,OHLCBar,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBar.cs,Draw,The following statement contains a magic number: pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,DrawLegendKey,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X) {  	pixBase = rect.Left + rect.Width / 2.0F;  	pixHigh = rect.Top;  	pixLow = rect.Bottom;  	pixOpen = pixHigh + rect.Height / 4;  	pixClose = pixLow - rect.Height / 4;  }  else {  	pixBase = rect.Top + rect.Height / 2.0F;  	pixHigh = rect.Right;  	pixLow = rect.Left;  	pixOpen = pixHigh - rect.Width / 4;  	pixClose = pixLow + rect.Width / 4;  }  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,DrawLegendKey,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X) {  	pixBase = rect.Left + rect.Width / 2.0F;  	pixHigh = rect.Top;  	pixLow = rect.Bottom;  	pixOpen = pixHigh + rect.Height / 4;  	pixClose = pixLow - rect.Height / 4;  }  else {  	pixBase = rect.Top + rect.Height / 2.0F;  	pixHigh = rect.Right;  	pixLow = rect.Left;  	pixOpen = pixHigh - rect.Width / 4;  	pixClose = pixLow + rect.Width / 4;  }  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,DrawLegendKey,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X) {  	pixBase = rect.Left + rect.Width / 2.0F;  	pixHigh = rect.Top;  	pixLow = rect.Bottom;  	pixOpen = pixHigh + rect.Height / 4;  	pixClose = pixLow - rect.Height / 4;  }  else {  	pixBase = rect.Top + rect.Height / 2.0F;  	pixHigh = rect.Right;  	pixLow = rect.Left;  	pixOpen = pixHigh - rect.Width / 4;  	pixClose = pixLow + rect.Width / 4;  }  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,DrawLegendKey,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X) {  	pixBase = rect.Left + rect.Width / 2.0F;  	pixHigh = rect.Top;  	pixLow = rect.Bottom;  	pixOpen = pixHigh + rect.Height / 4;  	pixClose = pixLow - rect.Height / 4;  }  else {  	pixBase = rect.Top + rect.Height / 2.0F;  	pixHigh = rect.Right;  	pixLow = rect.Left;  	pixOpen = pixHigh - rect.Width / 4;  	pixClose = pixLow + rect.Width / 4;  }  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,DrawLegendKey,The following statement contains a magic number: pixOpen = pixHigh + rect.Height / 4;  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,DrawLegendKey,The following statement contains a magic number: pixClose = pixLow - rect.Height / 4;  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,DrawLegendKey,The following statement contains a magic number: pixOpen = pixHigh - rect.Width / 4;  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,DrawLegendKey,The following statement contains a magic number: pixClose = pixLow + rect.Width / 4;  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,GetCoords,The following statement contains a magic number: if (!pt.IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  	float pixBase' pixHigh' pixLow;  	pixBase = baseAxis.Scale.Transform (_isOverrideOrdinal' i' date);  	pixHigh = valueAxis.Scale.Transform (_isOverrideOrdinal' i' high);  	pixLow = valueAxis.Scale.Transform (_isOverrideOrdinal' i' low);  	// Calculate the pixel location for the side of the bar (on the base axis)  	float pixSide = pixBase - halfSize;  	// Draw the bar  	if (baseAxis is XAxis || baseAxis is X2Axis)  		coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixSide' pixLow' pixSide + halfSize * 2' pixHigh);  	else  		coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixLow' pixSide' pixHigh' pixSide + halfSize * 2);  	return true;  }  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,GetCoords,The following statement contains a magic number: if (!pt.IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  	float pixBase' pixHigh' pixLow;  	pixBase = baseAxis.Scale.Transform (_isOverrideOrdinal' i' date);  	pixHigh = valueAxis.Scale.Transform (_isOverrideOrdinal' i' high);  	pixLow = valueAxis.Scale.Transform (_isOverrideOrdinal' i' low);  	// Calculate the pixel location for the side of the bar (on the base axis)  	float pixSide = pixBase - halfSize;  	// Draw the bar  	if (baseAxis is XAxis || baseAxis is X2Axis)  		coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixSide' pixLow' pixSide + halfSize * 2' pixHigh);  	else  		coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixLow' pixSide' pixHigh' pixSide + halfSize * 2);  	return true;  }  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,GetCoords,The following statement contains a magic number: if (baseAxis is XAxis || baseAxis is X2Axis)  	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixSide' pixLow' pixSide + halfSize * 2' pixHigh);  else  	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixLow' pixSide' pixHigh' pixSide + halfSize * 2);  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,GetCoords,The following statement contains a magic number: if (baseAxis is XAxis || baseAxis is X2Axis)  	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixSide' pixLow' pixSide + halfSize * 2' pixHigh);  else  	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixLow' pixSide' pixHigh' pixSide + halfSize * 2);  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixSide' pixLow' pixSide + halfSize * 2' pixHigh);  
Magic Number,ZedGraph,OHLCBarItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OHLCBarItem.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixLow' pixSide' pixHigh' pixSide + halfSize * 2);  
Magic Number,ZedGraph,CurveItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveItem.cs,CurveItem,The following statement contains a magic number: if (sch >= 11)  	_isX2Axis = info.GetBoolean ("isX2Axis");  else  	_isX2Axis = false;  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: foreach (CurveItem curve in this) {  	if (curve.IsVisible) {  		// For stacked types' use the GetStackRange() method which accounts for accumulated values  		// rather than simple curve values.  		if (((curve is BarItem) && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) || ((curve is LineItem) && pane.LineType == LineType.Stack)) {  			GetStackRange (pane' curve' out tXMinVal' out tYMinVal' out tXMaxVal' out tYMaxVal);  		}  		else {  			// Call the GetRange() member function for the current  			// curve to get the min and max values  			curve.GetRange (out tXMinVal' out tXMaxVal' out tYMinVal' out tYMaxVal' bIgnoreInitial' true' pane);  		}  		// isYOrd is true if the Y axis is an ordinal type  		Scale yScale = curve.GetYAxis (pane).Scale;  		Scale xScale = curve.GetXAxis (pane).Scale;  		bool isYOrd = yScale.IsAnyOrdinal;  		// isXOrd is true if the X axis is an ordinal type  		bool isXOrd = xScale.IsAnyOrdinal;  		// For ordinal Axes' the data range is just 1 to Npts  		if (isYOrd && !curve.IsOverrideOrdinal) {  			tYMinVal = 1.0;  			tYMaxVal = curve.NPts;  		}  		if (isXOrd && !curve.IsOverrideOrdinal) {  			tXMinVal = 1.0;  			tXMaxVal = curve.NPts;  		}  		// Bar types always include the Y=0 value  		if (curve.IsBar) {  			if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  				// Only force z=0 for BarItems' not HiLowBarItems  				if (!(curve is HiLowBarItem)) {  					if (tYMinVal > 0)  						tYMinVal = 0;  					else if (tYMaxVal < 0)  						tYMaxVal = 0;  				}  				// for non-ordinal axes' expand the data range slightly for bar charts to  				// account for the fact that the bar clusters have a width  				if (!isXOrd) {  					tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  					tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  				}  			}  			else {  				// Only force z=0 for BarItems' not HiLowBarItems  				if (!(curve is HiLowBarItem)) {  					if (tXMinVal > 0)  						tXMinVal = 0;  					else if (tXMaxVal < 0)  						tXMaxVal = 0;  				}  				// for non-ordinal axes' expand the data range slightly for bar charts to  				// account for the fact that the bar clusters have a width  				if (!isYOrd) {  					tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  					tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  				}  			}  		}  		// determine which curve has the maximum number of points  		if (curve.NPts > maxPts)  			maxPts = curve.NPts;  		// If the min and/or max values from the current curve  		// are the absolute min and/or max' then save the values  		// Also' differentiate between Y and Y2 values  		if (tYMinVal < yScale._rangeMin)  			yScale._rangeMin = tYMinVal;  		if (tYMaxVal > yScale._rangeMax)  			yScale._rangeMax = tYMaxVal;  		if (tXMinVal < xScale._rangeMin)  			xScale._rangeMin = tXMinVal;  		if (tXMaxVal > xScale._rangeMax)  			xScale._rangeMax = tXMaxVal;  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: foreach (CurveItem curve in this) {  	if (curve.IsVisible) {  		// For stacked types' use the GetStackRange() method which accounts for accumulated values  		// rather than simple curve values.  		if (((curve is BarItem) && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) || ((curve is LineItem) && pane.LineType == LineType.Stack)) {  			GetStackRange (pane' curve' out tXMinVal' out tYMinVal' out tXMaxVal' out tYMaxVal);  		}  		else {  			// Call the GetRange() member function for the current  			// curve to get the min and max values  			curve.GetRange (out tXMinVal' out tXMaxVal' out tYMinVal' out tYMaxVal' bIgnoreInitial' true' pane);  		}  		// isYOrd is true if the Y axis is an ordinal type  		Scale yScale = curve.GetYAxis (pane).Scale;  		Scale xScale = curve.GetXAxis (pane).Scale;  		bool isYOrd = yScale.IsAnyOrdinal;  		// isXOrd is true if the X axis is an ordinal type  		bool isXOrd = xScale.IsAnyOrdinal;  		// For ordinal Axes' the data range is just 1 to Npts  		if (isYOrd && !curve.IsOverrideOrdinal) {  			tYMinVal = 1.0;  			tYMaxVal = curve.NPts;  		}  		if (isXOrd && !curve.IsOverrideOrdinal) {  			tXMinVal = 1.0;  			tXMaxVal = curve.NPts;  		}  		// Bar types always include the Y=0 value  		if (curve.IsBar) {  			if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  				// Only force z=0 for BarItems' not HiLowBarItems  				if (!(curve is HiLowBarItem)) {  					if (tYMinVal > 0)  						tYMinVal = 0;  					else if (tYMaxVal < 0)  						tYMaxVal = 0;  				}  				// for non-ordinal axes' expand the data range slightly for bar charts to  				// account for the fact that the bar clusters have a width  				if (!isXOrd) {  					tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  					tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  				}  			}  			else {  				// Only force z=0 for BarItems' not HiLowBarItems  				if (!(curve is HiLowBarItem)) {  					if (tXMinVal > 0)  						tXMinVal = 0;  					else if (tXMaxVal < 0)  						tXMaxVal = 0;  				}  				// for non-ordinal axes' expand the data range slightly for bar charts to  				// account for the fact that the bar clusters have a width  				if (!isYOrd) {  					tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  					tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  				}  			}  		}  		// determine which curve has the maximum number of points  		if (curve.NPts > maxPts)  			maxPts = curve.NPts;  		// If the min and/or max values from the current curve  		// are the absolute min and/or max' then save the values  		// Also' differentiate between Y and Y2 values  		if (tYMinVal < yScale._rangeMin)  			yScale._rangeMin = tYMinVal;  		if (tYMaxVal > yScale._rangeMax)  			yScale._rangeMax = tYMaxVal;  		if (tXMinVal < xScale._rangeMin)  			xScale._rangeMin = tXMinVal;  		if (tXMaxVal > xScale._rangeMax)  			xScale._rangeMax = tXMaxVal;  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: foreach (CurveItem curve in this) {  	if (curve.IsVisible) {  		// For stacked types' use the GetStackRange() method which accounts for accumulated values  		// rather than simple curve values.  		if (((curve is BarItem) && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) || ((curve is LineItem) && pane.LineType == LineType.Stack)) {  			GetStackRange (pane' curve' out tXMinVal' out tYMinVal' out tXMaxVal' out tYMaxVal);  		}  		else {  			// Call the GetRange() member function for the current  			// curve to get the min and max values  			curve.GetRange (out tXMinVal' out tXMaxVal' out tYMinVal' out tYMaxVal' bIgnoreInitial' true' pane);  		}  		// isYOrd is true if the Y axis is an ordinal type  		Scale yScale = curve.GetYAxis (pane).Scale;  		Scale xScale = curve.GetXAxis (pane).Scale;  		bool isYOrd = yScale.IsAnyOrdinal;  		// isXOrd is true if the X axis is an ordinal type  		bool isXOrd = xScale.IsAnyOrdinal;  		// For ordinal Axes' the data range is just 1 to Npts  		if (isYOrd && !curve.IsOverrideOrdinal) {  			tYMinVal = 1.0;  			tYMaxVal = curve.NPts;  		}  		if (isXOrd && !curve.IsOverrideOrdinal) {  			tXMinVal = 1.0;  			tXMaxVal = curve.NPts;  		}  		// Bar types always include the Y=0 value  		if (curve.IsBar) {  			if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  				// Only force z=0 for BarItems' not HiLowBarItems  				if (!(curve is HiLowBarItem)) {  					if (tYMinVal > 0)  						tYMinVal = 0;  					else if (tYMaxVal < 0)  						tYMaxVal = 0;  				}  				// for non-ordinal axes' expand the data range slightly for bar charts to  				// account for the fact that the bar clusters have a width  				if (!isXOrd) {  					tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  					tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  				}  			}  			else {  				// Only force z=0 for BarItems' not HiLowBarItems  				if (!(curve is HiLowBarItem)) {  					if (tXMinVal > 0)  						tXMinVal = 0;  					else if (tXMaxVal < 0)  						tXMaxVal = 0;  				}  				// for non-ordinal axes' expand the data range slightly for bar charts to  				// account for the fact that the bar clusters have a width  				if (!isYOrd) {  					tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  					tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  				}  			}  		}  		// determine which curve has the maximum number of points  		if (curve.NPts > maxPts)  			maxPts = curve.NPts;  		// If the min and/or max values from the current curve  		// are the absolute min and/or max' then save the values  		// Also' differentiate between Y and Y2 values  		if (tYMinVal < yScale._rangeMin)  			yScale._rangeMin = tYMinVal;  		if (tYMaxVal > yScale._rangeMax)  			yScale._rangeMax = tYMaxVal;  		if (tXMinVal < xScale._rangeMin)  			xScale._rangeMin = tXMinVal;  		if (tXMaxVal > xScale._rangeMax)  			xScale._rangeMax = tXMaxVal;  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: foreach (CurveItem curve in this) {  	if (curve.IsVisible) {  		// For stacked types' use the GetStackRange() method which accounts for accumulated values  		// rather than simple curve values.  		if (((curve is BarItem) && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) || ((curve is LineItem) && pane.LineType == LineType.Stack)) {  			GetStackRange (pane' curve' out tXMinVal' out tYMinVal' out tXMaxVal' out tYMaxVal);  		}  		else {  			// Call the GetRange() member function for the current  			// curve to get the min and max values  			curve.GetRange (out tXMinVal' out tXMaxVal' out tYMinVal' out tYMaxVal' bIgnoreInitial' true' pane);  		}  		// isYOrd is true if the Y axis is an ordinal type  		Scale yScale = curve.GetYAxis (pane).Scale;  		Scale xScale = curve.GetXAxis (pane).Scale;  		bool isYOrd = yScale.IsAnyOrdinal;  		// isXOrd is true if the X axis is an ordinal type  		bool isXOrd = xScale.IsAnyOrdinal;  		// For ordinal Axes' the data range is just 1 to Npts  		if (isYOrd && !curve.IsOverrideOrdinal) {  			tYMinVal = 1.0;  			tYMaxVal = curve.NPts;  		}  		if (isXOrd && !curve.IsOverrideOrdinal) {  			tXMinVal = 1.0;  			tXMaxVal = curve.NPts;  		}  		// Bar types always include the Y=0 value  		if (curve.IsBar) {  			if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  				// Only force z=0 for BarItems' not HiLowBarItems  				if (!(curve is HiLowBarItem)) {  					if (tYMinVal > 0)  						tYMinVal = 0;  					else if (tYMaxVal < 0)  						tYMaxVal = 0;  				}  				// for non-ordinal axes' expand the data range slightly for bar charts to  				// account for the fact that the bar clusters have a width  				if (!isXOrd) {  					tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  					tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  				}  			}  			else {  				// Only force z=0 for BarItems' not HiLowBarItems  				if (!(curve is HiLowBarItem)) {  					if (tXMinVal > 0)  						tXMinVal = 0;  					else if (tXMaxVal < 0)  						tXMaxVal = 0;  				}  				// for non-ordinal axes' expand the data range slightly for bar charts to  				// account for the fact that the bar clusters have a width  				if (!isYOrd) {  					tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  					tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  				}  			}  		}  		// determine which curve has the maximum number of points  		if (curve.NPts > maxPts)  			maxPts = curve.NPts;  		// If the min and/or max values from the current curve  		// are the absolute min and/or max' then save the values  		// Also' differentiate between Y and Y2 values  		if (tYMinVal < yScale._rangeMin)  			yScale._rangeMin = tYMinVal;  		if (tYMaxVal > yScale._rangeMax)  			yScale._rangeMax = tYMaxVal;  		if (tXMinVal < xScale._rangeMin)  			xScale._rangeMin = tXMinVal;  		if (tXMaxVal > xScale._rangeMax)  			xScale._rangeMax = tXMaxVal;  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (curve.IsVisible) {  	// For stacked types' use the GetStackRange() method which accounts for accumulated values  	// rather than simple curve values.  	if (((curve is BarItem) && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) || ((curve is LineItem) && pane.LineType == LineType.Stack)) {  		GetStackRange (pane' curve' out tXMinVal' out tYMinVal' out tXMaxVal' out tYMaxVal);  	}  	else {  		// Call the GetRange() member function for the current  		// curve to get the min and max values  		curve.GetRange (out tXMinVal' out tXMaxVal' out tYMinVal' out tYMaxVal' bIgnoreInitial' true' pane);  	}  	// isYOrd is true if the Y axis is an ordinal type  	Scale yScale = curve.GetYAxis (pane).Scale;  	Scale xScale = curve.GetXAxis (pane).Scale;  	bool isYOrd = yScale.IsAnyOrdinal;  	// isXOrd is true if the X axis is an ordinal type  	bool isXOrd = xScale.IsAnyOrdinal;  	// For ordinal Axes' the data range is just 1 to Npts  	if (isYOrd && !curve.IsOverrideOrdinal) {  		tYMinVal = 1.0;  		tYMaxVal = curve.NPts;  	}  	if (isXOrd && !curve.IsOverrideOrdinal) {  		tXMinVal = 1.0;  		tXMaxVal = curve.NPts;  	}  	// Bar types always include the Y=0 value  	if (curve.IsBar) {  		if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  			// Only force z=0 for BarItems' not HiLowBarItems  			if (!(curve is HiLowBarItem)) {  				if (tYMinVal > 0)  					tYMinVal = 0;  				else if (tYMaxVal < 0)  					tYMaxVal = 0;  			}  			// for non-ordinal axes' expand the data range slightly for bar charts to  			// account for the fact that the bar clusters have a width  			if (!isXOrd) {  				tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  				tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  			}  		}  		else {  			// Only force z=0 for BarItems' not HiLowBarItems  			if (!(curve is HiLowBarItem)) {  				if (tXMinVal > 0)  					tXMinVal = 0;  				else if (tXMaxVal < 0)  					tXMaxVal = 0;  			}  			// for non-ordinal axes' expand the data range slightly for bar charts to  			// account for the fact that the bar clusters have a width  			if (!isYOrd) {  				tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  				tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  			}  		}  	}  	// determine which curve has the maximum number of points  	if (curve.NPts > maxPts)  		maxPts = curve.NPts;  	// If the min and/or max values from the current curve  	// are the absolute min and/or max' then save the values  	// Also' differentiate between Y and Y2 values  	if (tYMinVal < yScale._rangeMin)  		yScale._rangeMin = tYMinVal;  	if (tYMaxVal > yScale._rangeMax)  		yScale._rangeMax = tYMaxVal;  	if (tXMinVal < xScale._rangeMin)  		xScale._rangeMin = tXMinVal;  	if (tXMaxVal > xScale._rangeMax)  		xScale._rangeMax = tXMaxVal;  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (curve.IsVisible) {  	// For stacked types' use the GetStackRange() method which accounts for accumulated values  	// rather than simple curve values.  	if (((curve is BarItem) && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) || ((curve is LineItem) && pane.LineType == LineType.Stack)) {  		GetStackRange (pane' curve' out tXMinVal' out tYMinVal' out tXMaxVal' out tYMaxVal);  	}  	else {  		// Call the GetRange() member function for the current  		// curve to get the min and max values  		curve.GetRange (out tXMinVal' out tXMaxVal' out tYMinVal' out tYMaxVal' bIgnoreInitial' true' pane);  	}  	// isYOrd is true if the Y axis is an ordinal type  	Scale yScale = curve.GetYAxis (pane).Scale;  	Scale xScale = curve.GetXAxis (pane).Scale;  	bool isYOrd = yScale.IsAnyOrdinal;  	// isXOrd is true if the X axis is an ordinal type  	bool isXOrd = xScale.IsAnyOrdinal;  	// For ordinal Axes' the data range is just 1 to Npts  	if (isYOrd && !curve.IsOverrideOrdinal) {  		tYMinVal = 1.0;  		tYMaxVal = curve.NPts;  	}  	if (isXOrd && !curve.IsOverrideOrdinal) {  		tXMinVal = 1.0;  		tXMaxVal = curve.NPts;  	}  	// Bar types always include the Y=0 value  	if (curve.IsBar) {  		if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  			// Only force z=0 for BarItems' not HiLowBarItems  			if (!(curve is HiLowBarItem)) {  				if (tYMinVal > 0)  					tYMinVal = 0;  				else if (tYMaxVal < 0)  					tYMaxVal = 0;  			}  			// for non-ordinal axes' expand the data range slightly for bar charts to  			// account for the fact that the bar clusters have a width  			if (!isXOrd) {  				tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  				tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  			}  		}  		else {  			// Only force z=0 for BarItems' not HiLowBarItems  			if (!(curve is HiLowBarItem)) {  				if (tXMinVal > 0)  					tXMinVal = 0;  				else if (tXMaxVal < 0)  					tXMaxVal = 0;  			}  			// for non-ordinal axes' expand the data range slightly for bar charts to  			// account for the fact that the bar clusters have a width  			if (!isYOrd) {  				tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  				tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  			}  		}  	}  	// determine which curve has the maximum number of points  	if (curve.NPts > maxPts)  		maxPts = curve.NPts;  	// If the min and/or max values from the current curve  	// are the absolute min and/or max' then save the values  	// Also' differentiate between Y and Y2 values  	if (tYMinVal < yScale._rangeMin)  		yScale._rangeMin = tYMinVal;  	if (tYMaxVal > yScale._rangeMax)  		yScale._rangeMax = tYMaxVal;  	if (tXMinVal < xScale._rangeMin)  		xScale._rangeMin = tXMinVal;  	if (tXMaxVal > xScale._rangeMax)  		xScale._rangeMax = tXMaxVal;  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (curve.IsVisible) {  	// For stacked types' use the GetStackRange() method which accounts for accumulated values  	// rather than simple curve values.  	if (((curve is BarItem) && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) || ((curve is LineItem) && pane.LineType == LineType.Stack)) {  		GetStackRange (pane' curve' out tXMinVal' out tYMinVal' out tXMaxVal' out tYMaxVal);  	}  	else {  		// Call the GetRange() member function for the current  		// curve to get the min and max values  		curve.GetRange (out tXMinVal' out tXMaxVal' out tYMinVal' out tYMaxVal' bIgnoreInitial' true' pane);  	}  	// isYOrd is true if the Y axis is an ordinal type  	Scale yScale = curve.GetYAxis (pane).Scale;  	Scale xScale = curve.GetXAxis (pane).Scale;  	bool isYOrd = yScale.IsAnyOrdinal;  	// isXOrd is true if the X axis is an ordinal type  	bool isXOrd = xScale.IsAnyOrdinal;  	// For ordinal Axes' the data range is just 1 to Npts  	if (isYOrd && !curve.IsOverrideOrdinal) {  		tYMinVal = 1.0;  		tYMaxVal = curve.NPts;  	}  	if (isXOrd && !curve.IsOverrideOrdinal) {  		tXMinVal = 1.0;  		tXMaxVal = curve.NPts;  	}  	// Bar types always include the Y=0 value  	if (curve.IsBar) {  		if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  			// Only force z=0 for BarItems' not HiLowBarItems  			if (!(curve is HiLowBarItem)) {  				if (tYMinVal > 0)  					tYMinVal = 0;  				else if (tYMaxVal < 0)  					tYMaxVal = 0;  			}  			// for non-ordinal axes' expand the data range slightly for bar charts to  			// account for the fact that the bar clusters have a width  			if (!isXOrd) {  				tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  				tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  			}  		}  		else {  			// Only force z=0 for BarItems' not HiLowBarItems  			if (!(curve is HiLowBarItem)) {  				if (tXMinVal > 0)  					tXMinVal = 0;  				else if (tXMaxVal < 0)  					tXMaxVal = 0;  			}  			// for non-ordinal axes' expand the data range slightly for bar charts to  			// account for the fact that the bar clusters have a width  			if (!isYOrd) {  				tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  				tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  			}  		}  	}  	// determine which curve has the maximum number of points  	if (curve.NPts > maxPts)  		maxPts = curve.NPts;  	// If the min and/or max values from the current curve  	// are the absolute min and/or max' then save the values  	// Also' differentiate between Y and Y2 values  	if (tYMinVal < yScale._rangeMin)  		yScale._rangeMin = tYMinVal;  	if (tYMaxVal > yScale._rangeMax)  		yScale._rangeMax = tYMaxVal;  	if (tXMinVal < xScale._rangeMin)  		xScale._rangeMin = tXMinVal;  	if (tXMaxVal > xScale._rangeMax)  		xScale._rangeMax = tXMaxVal;  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (curve.IsVisible) {  	// For stacked types' use the GetStackRange() method which accounts for accumulated values  	// rather than simple curve values.  	if (((curve is BarItem) && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) || ((curve is LineItem) && pane.LineType == LineType.Stack)) {  		GetStackRange (pane' curve' out tXMinVal' out tYMinVal' out tXMaxVal' out tYMaxVal);  	}  	else {  		// Call the GetRange() member function for the current  		// curve to get the min and max values  		curve.GetRange (out tXMinVal' out tXMaxVal' out tYMinVal' out tYMaxVal' bIgnoreInitial' true' pane);  	}  	// isYOrd is true if the Y axis is an ordinal type  	Scale yScale = curve.GetYAxis (pane).Scale;  	Scale xScale = curve.GetXAxis (pane).Scale;  	bool isYOrd = yScale.IsAnyOrdinal;  	// isXOrd is true if the X axis is an ordinal type  	bool isXOrd = xScale.IsAnyOrdinal;  	// For ordinal Axes' the data range is just 1 to Npts  	if (isYOrd && !curve.IsOverrideOrdinal) {  		tYMinVal = 1.0;  		tYMaxVal = curve.NPts;  	}  	if (isXOrd && !curve.IsOverrideOrdinal) {  		tXMinVal = 1.0;  		tXMaxVal = curve.NPts;  	}  	// Bar types always include the Y=0 value  	if (curve.IsBar) {  		if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  			// Only force z=0 for BarItems' not HiLowBarItems  			if (!(curve is HiLowBarItem)) {  				if (tYMinVal > 0)  					tYMinVal = 0;  				else if (tYMaxVal < 0)  					tYMaxVal = 0;  			}  			// for non-ordinal axes' expand the data range slightly for bar charts to  			// account for the fact that the bar clusters have a width  			if (!isXOrd) {  				tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  				tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  			}  		}  		else {  			// Only force z=0 for BarItems' not HiLowBarItems  			if (!(curve is HiLowBarItem)) {  				if (tXMinVal > 0)  					tXMinVal = 0;  				else if (tXMaxVal < 0)  					tXMaxVal = 0;  			}  			// for non-ordinal axes' expand the data range slightly for bar charts to  			// account for the fact that the bar clusters have a width  			if (!isYOrd) {  				tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  				tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  			}  		}  	}  	// determine which curve has the maximum number of points  	if (curve.NPts > maxPts)  		maxPts = curve.NPts;  	// If the min and/or max values from the current curve  	// are the absolute min and/or max' then save the values  	// Also' differentiate between Y and Y2 values  	if (tYMinVal < yScale._rangeMin)  		yScale._rangeMin = tYMinVal;  	if (tYMaxVal > yScale._rangeMax)  		yScale._rangeMax = tYMaxVal;  	if (tXMinVal < xScale._rangeMin)  		xScale._rangeMin = tXMinVal;  	if (tXMaxVal > xScale._rangeMax)  		xScale._rangeMax = tXMaxVal;  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (curve.IsBar) {  	if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  		// Only force z=0 for BarItems' not HiLowBarItems  		if (!(curve is HiLowBarItem)) {  			if (tYMinVal > 0)  				tYMinVal = 0;  			else if (tYMaxVal < 0)  				tYMaxVal = 0;  		}  		// for non-ordinal axes' expand the data range slightly for bar charts to  		// account for the fact that the bar clusters have a width  		if (!isXOrd) {  			tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  			tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  		}  	}  	else {  		// Only force z=0 for BarItems' not HiLowBarItems  		if (!(curve is HiLowBarItem)) {  			if (tXMinVal > 0)  				tXMinVal = 0;  			else if (tXMaxVal < 0)  				tXMaxVal = 0;  		}  		// for non-ordinal axes' expand the data range slightly for bar charts to  		// account for the fact that the bar clusters have a width  		if (!isYOrd) {  			tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  			tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  		}  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (curve.IsBar) {  	if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  		// Only force z=0 for BarItems' not HiLowBarItems  		if (!(curve is HiLowBarItem)) {  			if (tYMinVal > 0)  				tYMinVal = 0;  			else if (tYMaxVal < 0)  				tYMaxVal = 0;  		}  		// for non-ordinal axes' expand the data range slightly for bar charts to  		// account for the fact that the bar clusters have a width  		if (!isXOrd) {  			tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  			tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  		}  	}  	else {  		// Only force z=0 for BarItems' not HiLowBarItems  		if (!(curve is HiLowBarItem)) {  			if (tXMinVal > 0)  				tXMinVal = 0;  			else if (tXMaxVal < 0)  				tXMaxVal = 0;  		}  		// for non-ordinal axes' expand the data range slightly for bar charts to  		// account for the fact that the bar clusters have a width  		if (!isYOrd) {  			tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  			tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  		}  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (curve.IsBar) {  	if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  		// Only force z=0 for BarItems' not HiLowBarItems  		if (!(curve is HiLowBarItem)) {  			if (tYMinVal > 0)  				tYMinVal = 0;  			else if (tYMaxVal < 0)  				tYMaxVal = 0;  		}  		// for non-ordinal axes' expand the data range slightly for bar charts to  		// account for the fact that the bar clusters have a width  		if (!isXOrd) {  			tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  			tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  		}  	}  	else {  		// Only force z=0 for BarItems' not HiLowBarItems  		if (!(curve is HiLowBarItem)) {  			if (tXMinVal > 0)  				tXMinVal = 0;  			else if (tXMaxVal < 0)  				tXMaxVal = 0;  		}  		// for non-ordinal axes' expand the data range slightly for bar charts to  		// account for the fact that the bar clusters have a width  		if (!isYOrd) {  			tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  			tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  		}  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (curve.IsBar) {  	if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  		// Only force z=0 for BarItems' not HiLowBarItems  		if (!(curve is HiLowBarItem)) {  			if (tYMinVal > 0)  				tYMinVal = 0;  			else if (tYMaxVal < 0)  				tYMaxVal = 0;  		}  		// for non-ordinal axes' expand the data range slightly for bar charts to  		// account for the fact that the bar clusters have a width  		if (!isXOrd) {  			tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  			tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  		}  	}  	else {  		// Only force z=0 for BarItems' not HiLowBarItems  		if (!(curve is HiLowBarItem)) {  			if (tXMinVal > 0)  				tXMinVal = 0;  			else if (tXMaxVal < 0)  				tXMaxVal = 0;  		}  		// for non-ordinal axes' expand the data range slightly for bar charts to  		// account for the fact that the bar clusters have a width  		if (!isYOrd) {  			tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  			tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  		}  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  	// Only force z=0 for BarItems' not HiLowBarItems  	if (!(curve is HiLowBarItem)) {  		if (tYMinVal > 0)  			tYMinVal = 0;  		else if (tYMaxVal < 0)  			tYMaxVal = 0;  	}  	// for non-ordinal axes' expand the data range slightly for bar charts to  	// account for the fact that the bar clusters have a width  	if (!isXOrd) {  		tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  		tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  	}  }  else {  	// Only force z=0 for BarItems' not HiLowBarItems  	if (!(curve is HiLowBarItem)) {  		if (tXMinVal > 0)  			tXMinVal = 0;  		else if (tXMaxVal < 0)  			tXMaxVal = 0;  	}  	// for non-ordinal axes' expand the data range slightly for bar charts to  	// account for the fact that the bar clusters have a width  	if (!isYOrd) {  		tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  		tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  	// Only force z=0 for BarItems' not HiLowBarItems  	if (!(curve is HiLowBarItem)) {  		if (tYMinVal > 0)  			tYMinVal = 0;  		else if (tYMaxVal < 0)  			tYMaxVal = 0;  	}  	// for non-ordinal axes' expand the data range slightly for bar charts to  	// account for the fact that the bar clusters have a width  	if (!isXOrd) {  		tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  		tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  	}  }  else {  	// Only force z=0 for BarItems' not HiLowBarItems  	if (!(curve is HiLowBarItem)) {  		if (tXMinVal > 0)  			tXMinVal = 0;  		else if (tXMaxVal < 0)  			tXMaxVal = 0;  	}  	// for non-ordinal axes' expand the data range slightly for bar charts to  	// account for the fact that the bar clusters have a width  	if (!isYOrd) {  		tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  		tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  	// Only force z=0 for BarItems' not HiLowBarItems  	if (!(curve is HiLowBarItem)) {  		if (tYMinVal > 0)  			tYMinVal = 0;  		else if (tYMaxVal < 0)  			tYMaxVal = 0;  	}  	// for non-ordinal axes' expand the data range slightly for bar charts to  	// account for the fact that the bar clusters have a width  	if (!isXOrd) {  		tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  		tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  	}  }  else {  	// Only force z=0 for BarItems' not HiLowBarItems  	if (!(curve is HiLowBarItem)) {  		if (tXMinVal > 0)  			tXMinVal = 0;  		else if (tXMaxVal < 0)  			tXMaxVal = 0;  	}  	// for non-ordinal axes' expand the data range slightly for bar charts to  	// account for the fact that the bar clusters have a width  	if (!isYOrd) {  		tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  		tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2) {  	// Only force z=0 for BarItems' not HiLowBarItems  	if (!(curve is HiLowBarItem)) {  		if (tYMinVal > 0)  			tYMinVal = 0;  		else if (tYMaxVal < 0)  			tYMaxVal = 0;  	}  	// for non-ordinal axes' expand the data range slightly for bar charts to  	// account for the fact that the bar clusters have a width  	if (!isXOrd) {  		tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  		tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  	}  }  else {  	// Only force z=0 for BarItems' not HiLowBarItems  	if (!(curve is HiLowBarItem)) {  		if (tXMinVal > 0)  			tXMinVal = 0;  		else if (tXMaxVal < 0)  			tXMaxVal = 0;  	}  	// for non-ordinal axes' expand the data range slightly for bar charts to  	// account for the fact that the bar clusters have a width  	if (!isYOrd) {  		tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  		tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  	}  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (!isXOrd) {  	tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  	tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (!isXOrd) {  	tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  	tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: tXMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: tXMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (!isYOrd) {  	tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  	tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: if (!isYOrd) {  	tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  	tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  }  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: tYMinVal -= pane._barSettings._clusterScaleWidth / 2.0;  
Magic Number,ZedGraph,CurveList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\CurveList.cs,GetRange,The following statement contains a magic number: tYMaxVal += pane._barSettings._clusterScaleWidth / 2.0;  
Magic Number,ZedGraph,DateAsOrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateAsOrdinalScale.cs,SetDateFormat,The following statement contains a magic number: if (_formatAuto) {  	double range = 10;  	if (pane.CurveList.Count > 0 && pane.CurveList [0].Points.Count > 1) {  		double val1' val2;  		PointPair pt1 = pane.CurveList [0].Points [0];  		PointPair pt2 = pane.CurveList [0].Points [pane.CurveList [0].Points.Count - 1];  		int p1 = 1;  		int p2 = pane.CurveList [0].Points.Count;  		if (pane.IsBoundedRanges) {  			p1 = (int)Math.Floor (_ownerAxis.Scale.Min);  			p2 = (int)Math.Ceiling (_ownerAxis.Scale.Max);  			p1 = Math.Min (Math.Max (p1' 1)' pane.CurveList [0].Points.Count);  			p2 = Math.Min (Math.Max (p2' 1)' pane.CurveList [0].Points.Count);  			if (p2 > p1) {  				pt1 = pane.CurveList [0].Points [p1 - 1];  				pt2 = pane.CurveList [0].Points [p2 - 1];  			}  		}  		if (_ownerAxis is XAxis || _ownerAxis is X2Axis) {  			val1 = pt1.X;  			val2 = pt2.X;  		}  		else {  			val1 = pt1.Y;  			val2 = pt2.Y;  		}  		if (val1 != PointPair.Missing && val2 != PointPair.Missing && !Double.IsNaN (val1) && !Double.IsNaN (val2) && !Double.IsInfinity (val1) && !Double.IsInfinity (val2) && Math.Abs (val2 - val1) > 1e-10)  			range = Math.Abs (val2 - val1);  	}  	if (range > Default.RangeYearYear)  		_format = Default.FormatYearYear;  	else if (range > Default.RangeYearMonth)  		_format = Default.FormatYearMonth;  	else if (range > Default.RangeMonthMonth)  		_format = Default.FormatMonthMonth;  	else if (range > Default.RangeDayDay)  		_format = Default.FormatDayDay;  	else if (range > Default.RangeDayHour)  		_format = Default.FormatDayHour;  	else if (range > Default.RangeHourHour)  		_format = Default.FormatHourHour;  	else if (range > Default.RangeHourMinute)  		_format = Default.FormatHourMinute;  	else if (range > Default.RangeMinuteMinute)  		_format = Default.FormatMinuteMinute;  	else if (range > Default.RangeMinuteSecond)  		_format = Default.FormatMinuteSecond;  	else if (range > Default.RangeSecondSecond)  		_format = Default.FormatSecondSecond;  	else  		// MilliSecond  		_format = Default.FormatMillisecond;  }  
Magic Number,ZedGraph,DateAsOrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateAsOrdinalScale.cs,SetDateFormat,The following statement contains a magic number: if (_formatAuto) {  	double range = 10;  	if (pane.CurveList.Count > 0 && pane.CurveList [0].Points.Count > 1) {  		double val1' val2;  		PointPair pt1 = pane.CurveList [0].Points [0];  		PointPair pt2 = pane.CurveList [0].Points [pane.CurveList [0].Points.Count - 1];  		int p1 = 1;  		int p2 = pane.CurveList [0].Points.Count;  		if (pane.IsBoundedRanges) {  			p1 = (int)Math.Floor (_ownerAxis.Scale.Min);  			p2 = (int)Math.Ceiling (_ownerAxis.Scale.Max);  			p1 = Math.Min (Math.Max (p1' 1)' pane.CurveList [0].Points.Count);  			p2 = Math.Min (Math.Max (p2' 1)' pane.CurveList [0].Points.Count);  			if (p2 > p1) {  				pt1 = pane.CurveList [0].Points [p1 - 1];  				pt2 = pane.CurveList [0].Points [p2 - 1];  			}  		}  		if (_ownerAxis is XAxis || _ownerAxis is X2Axis) {  			val1 = pt1.X;  			val2 = pt2.X;  		}  		else {  			val1 = pt1.Y;  			val2 = pt2.Y;  		}  		if (val1 != PointPair.Missing && val2 != PointPair.Missing && !Double.IsNaN (val1) && !Double.IsNaN (val2) && !Double.IsInfinity (val1) && !Double.IsInfinity (val2) && Math.Abs (val2 - val1) > 1e-10)  			range = Math.Abs (val2 - val1);  	}  	if (range > Default.RangeYearYear)  		_format = Default.FormatYearYear;  	else if (range > Default.RangeYearMonth)  		_format = Default.FormatYearMonth;  	else if (range > Default.RangeMonthMonth)  		_format = Default.FormatMonthMonth;  	else if (range > Default.RangeDayDay)  		_format = Default.FormatDayDay;  	else if (range > Default.RangeDayHour)  		_format = Default.FormatDayHour;  	else if (range > Default.RangeHourHour)  		_format = Default.FormatHourHour;  	else if (range > Default.RangeHourMinute)  		_format = Default.FormatHourMinute;  	else if (range > Default.RangeMinuteMinute)  		_format = Default.FormatMinuteMinute;  	else if (range > Default.RangeMinuteSecond)  		_format = Default.FormatMinuteSecond;  	else if (range > Default.RangeSecondSecond)  		_format = Default.FormatSecondSecond;  	else  		// MilliSecond  		_format = Default.FormatMillisecond;  }  
Magic Number,ZedGraph,DateAsOrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateAsOrdinalScale.cs,SetDateFormat,The following statement contains a magic number: if (pane.CurveList.Count > 0 && pane.CurveList [0].Points.Count > 1) {  	double val1' val2;  	PointPair pt1 = pane.CurveList [0].Points [0];  	PointPair pt2 = pane.CurveList [0].Points [pane.CurveList [0].Points.Count - 1];  	int p1 = 1;  	int p2 = pane.CurveList [0].Points.Count;  	if (pane.IsBoundedRanges) {  		p1 = (int)Math.Floor (_ownerAxis.Scale.Min);  		p2 = (int)Math.Ceiling (_ownerAxis.Scale.Max);  		p1 = Math.Min (Math.Max (p1' 1)' pane.CurveList [0].Points.Count);  		p2 = Math.Min (Math.Max (p2' 1)' pane.CurveList [0].Points.Count);  		if (p2 > p1) {  			pt1 = pane.CurveList [0].Points [p1 - 1];  			pt2 = pane.CurveList [0].Points [p2 - 1];  		}  	}  	if (_ownerAxis is XAxis || _ownerAxis is X2Axis) {  		val1 = pt1.X;  		val2 = pt2.X;  	}  	else {  		val1 = pt1.Y;  		val2 = pt2.Y;  	}  	if (val1 != PointPair.Missing && val2 != PointPair.Missing && !Double.IsNaN (val1) && !Double.IsNaN (val2) && !Double.IsInfinity (val1) && !Double.IsInfinity (val2) && Math.Abs (val2 - val1) > 1e-10)  		range = Math.Abs (val2 - val1);  }  
Magic Number,ZedGraph,DateAsOrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateAsOrdinalScale.cs,SetDateFormat,The following statement contains a magic number: if (val1 != PointPair.Missing && val2 != PointPair.Missing && !Double.IsNaN (val1) && !Double.IsNaN (val2) && !Double.IsInfinity (val1) && !Double.IsInfinity (val2) && Math.Abs (val2 - val1) > 1e-10)  	range = Math.Abs (val2 - val1);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcMinorStart,The following statement contains a magic number: switch (_minorUnit) {  case DateUnit.Year:  default:  	return (int)((_min - baseVal) / (365.0 * _minorStep));  case DateUnit.Month:  	return (int)((_min - baseVal) / (28.0 * _minorStep));  case DateUnit.Day:  	return (int)((_min - baseVal) / _minorStep);  case DateUnit.Hour:  	return (int)((_min - baseVal) * XDate.HoursPerDay / _minorStep);  case DateUnit.Minute:  	return (int)((_min - baseVal) * XDate.MinutesPerDay / _minorStep);  case DateUnit.Second:  	return (int)((_min - baseVal) * XDate.SecondsPerDay / _minorStep);  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcMinorStart,The following statement contains a magic number: switch (_minorUnit) {  case DateUnit.Year:  default:  	return (int)((_min - baseVal) / (365.0 * _minorStep));  case DateUnit.Month:  	return (int)((_min - baseVal) / (28.0 * _minorStep));  case DateUnit.Day:  	return (int)((_min - baseVal) / _minorStep);  case DateUnit.Hour:  	return (int)((_min - baseVal) * XDate.HoursPerDay / _minorStep);  case DateUnit.Minute:  	return (int)((_min - baseVal) * XDate.MinutesPerDay / _minorStep);  case DateUnit.Second:  	return (int)((_min - baseVal) * XDate.SecondsPerDay / _minorStep);  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcMinorStart,The following statement contains a magic number: return (int)((_min - baseVal) / (365.0 * _minorStep));  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcMinorStart,The following statement contains a magic number: return (int)((_min - baseVal) / (28.0 * _minorStep));  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: switch (_majorUnit) {  case DateUnit.Year:  default:  	nTics = (int)((year2 - year1) / _majorStep + 1.001);  	break;  case DateUnit.Month:  	nTics = (int)((month2 - month1 + 12.0 * (year2 - year1)) / _majorStep + 1.001);  	break;  case DateUnit.Day:  	nTics = (int)((_max - _min) / _majorStep + 1.001);  	break;  case DateUnit.Hour:  	nTics = (int)((_max - _min) / (_majorStep / XDate.HoursPerDay) + 1.001);  	break;  case DateUnit.Minute:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MinutesPerDay) + 1.001);  	break;  case DateUnit.Second:  	nTics = (int)((_max - _min) / (_majorStep / XDate.SecondsPerDay) + 1.001);  	break;  case DateUnit.Millisecond:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MillisecondsPerDay) + 1.001);  	break;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: switch (_majorUnit) {  case DateUnit.Year:  default:  	nTics = (int)((year2 - year1) / _majorStep + 1.001);  	break;  case DateUnit.Month:  	nTics = (int)((month2 - month1 + 12.0 * (year2 - year1)) / _majorStep + 1.001);  	break;  case DateUnit.Day:  	nTics = (int)((_max - _min) / _majorStep + 1.001);  	break;  case DateUnit.Hour:  	nTics = (int)((_max - _min) / (_majorStep / XDate.HoursPerDay) + 1.001);  	break;  case DateUnit.Minute:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MinutesPerDay) + 1.001);  	break;  case DateUnit.Second:  	nTics = (int)((_max - _min) / (_majorStep / XDate.SecondsPerDay) + 1.001);  	break;  case DateUnit.Millisecond:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MillisecondsPerDay) + 1.001);  	break;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: switch (_majorUnit) {  case DateUnit.Year:  default:  	nTics = (int)((year2 - year1) / _majorStep + 1.001);  	break;  case DateUnit.Month:  	nTics = (int)((month2 - month1 + 12.0 * (year2 - year1)) / _majorStep + 1.001);  	break;  case DateUnit.Day:  	nTics = (int)((_max - _min) / _majorStep + 1.001);  	break;  case DateUnit.Hour:  	nTics = (int)((_max - _min) / (_majorStep / XDate.HoursPerDay) + 1.001);  	break;  case DateUnit.Minute:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MinutesPerDay) + 1.001);  	break;  case DateUnit.Second:  	nTics = (int)((_max - _min) / (_majorStep / XDate.SecondsPerDay) + 1.001);  	break;  case DateUnit.Millisecond:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MillisecondsPerDay) + 1.001);  	break;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: switch (_majorUnit) {  case DateUnit.Year:  default:  	nTics = (int)((year2 - year1) / _majorStep + 1.001);  	break;  case DateUnit.Month:  	nTics = (int)((month2 - month1 + 12.0 * (year2 - year1)) / _majorStep + 1.001);  	break;  case DateUnit.Day:  	nTics = (int)((_max - _min) / _majorStep + 1.001);  	break;  case DateUnit.Hour:  	nTics = (int)((_max - _min) / (_majorStep / XDate.HoursPerDay) + 1.001);  	break;  case DateUnit.Minute:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MinutesPerDay) + 1.001);  	break;  case DateUnit.Second:  	nTics = (int)((_max - _min) / (_majorStep / XDate.SecondsPerDay) + 1.001);  	break;  case DateUnit.Millisecond:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MillisecondsPerDay) + 1.001);  	break;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: switch (_majorUnit) {  case DateUnit.Year:  default:  	nTics = (int)((year2 - year1) / _majorStep + 1.001);  	break;  case DateUnit.Month:  	nTics = (int)((month2 - month1 + 12.0 * (year2 - year1)) / _majorStep + 1.001);  	break;  case DateUnit.Day:  	nTics = (int)((_max - _min) / _majorStep + 1.001);  	break;  case DateUnit.Hour:  	nTics = (int)((_max - _min) / (_majorStep / XDate.HoursPerDay) + 1.001);  	break;  case DateUnit.Minute:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MinutesPerDay) + 1.001);  	break;  case DateUnit.Second:  	nTics = (int)((_max - _min) / (_majorStep / XDate.SecondsPerDay) + 1.001);  	break;  case DateUnit.Millisecond:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MillisecondsPerDay) + 1.001);  	break;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: switch (_majorUnit) {  case DateUnit.Year:  default:  	nTics = (int)((year2 - year1) / _majorStep + 1.001);  	break;  case DateUnit.Month:  	nTics = (int)((month2 - month1 + 12.0 * (year2 - year1)) / _majorStep + 1.001);  	break;  case DateUnit.Day:  	nTics = (int)((_max - _min) / _majorStep + 1.001);  	break;  case DateUnit.Hour:  	nTics = (int)((_max - _min) / (_majorStep / XDate.HoursPerDay) + 1.001);  	break;  case DateUnit.Minute:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MinutesPerDay) + 1.001);  	break;  case DateUnit.Second:  	nTics = (int)((_max - _min) / (_majorStep / XDate.SecondsPerDay) + 1.001);  	break;  case DateUnit.Millisecond:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MillisecondsPerDay) + 1.001);  	break;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: switch (_majorUnit) {  case DateUnit.Year:  default:  	nTics = (int)((year2 - year1) / _majorStep + 1.001);  	break;  case DateUnit.Month:  	nTics = (int)((month2 - month1 + 12.0 * (year2 - year1)) / _majorStep + 1.001);  	break;  case DateUnit.Day:  	nTics = (int)((_max - _min) / _majorStep + 1.001);  	break;  case DateUnit.Hour:  	nTics = (int)((_max - _min) / (_majorStep / XDate.HoursPerDay) + 1.001);  	break;  case DateUnit.Minute:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MinutesPerDay) + 1.001);  	break;  case DateUnit.Second:  	nTics = (int)((_max - _min) / (_majorStep / XDate.SecondsPerDay) + 1.001);  	break;  case DateUnit.Millisecond:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MillisecondsPerDay) + 1.001);  	break;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: switch (_majorUnit) {  case DateUnit.Year:  default:  	nTics = (int)((year2 - year1) / _majorStep + 1.001);  	break;  case DateUnit.Month:  	nTics = (int)((month2 - month1 + 12.0 * (year2 - year1)) / _majorStep + 1.001);  	break;  case DateUnit.Day:  	nTics = (int)((_max - _min) / _majorStep + 1.001);  	break;  case DateUnit.Hour:  	nTics = (int)((_max - _min) / (_majorStep / XDate.HoursPerDay) + 1.001);  	break;  case DateUnit.Minute:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MinutesPerDay) + 1.001);  	break;  case DateUnit.Second:  	nTics = (int)((_max - _min) / (_majorStep / XDate.SecondsPerDay) + 1.001);  	break;  case DateUnit.Millisecond:  	nTics = (int)((_max - _min) / (_majorStep / XDate.MillisecondsPerDay) + 1.001);  	break;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: nTics = (int)((year2 - year1) / _majorStep + 1.001);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: nTics = (int)((month2 - month1 + 12.0 * (year2 - year1)) / _majorStep + 1.001);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: nTics = (int)((month2 - month1 + 12.0 * (year2 - year1)) / _majorStep + 1.001);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: nTics = (int)((_max - _min) / _majorStep + 1.001);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: nTics = (int)((_max - _min) / (_majorStep / XDate.HoursPerDay) + 1.001);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: nTics = (int)((_max - _min) / (_majorStep / XDate.MinutesPerDay) + 1.001);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: nTics = (int)((_max - _min) / (_majorStep / XDate.SecondsPerDay) + 1.001);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: nTics = (int)((_max - _min) / (_majorStep / XDate.MillisecondsPerDay) + 1.001);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics < 1)  	nTics = 1;  else if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics < 1)  	nTics = 1;  else if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcNumTics,The following statement contains a magic number: nTics = 1000;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-20) {  	if (_maxAuto)  		_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  	if (_minAuto)  		_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-20) {  	if (_maxAuto)  		_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  	if (_minAuto)  		_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-20) {  	if (_maxAuto)  		_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  	if (_minAuto)  		_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,PickScale,The following statement contains a magic number: if (_maxAuto)  	_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,PickScale,The following statement contains a magic number: _max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,PickScale,The following statement contains a magic number: if (_minAuto)  	_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,PickScale,The following statement contains a magic number: _min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearYear) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearYear;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Year;  		if (tempStep == 1.0)  			scale._minorStep = 0.25;  		else  			scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  	}  }  else if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = Math.Ceiling (tempStep / 365.0);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Year;  	if (tempStep == 1.0)  		scale._minorStep = 0.25;  	else  		scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep == 1.0)  	scale._minorStep = 0.25;  else  	scale._minorStep = Scale.CalcStepSize (tempStep' targetSteps);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 0.25;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeYearMonth) {  	scale._majorUnit = DateUnit.Year;  	if (scale._formatAuto)  		scale._format = Default.FormatYearMonth;  	tempStep = Math.Ceiling (tempStep / 365.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  		// make sure the minorStep is 1' 2' 3' 6' or 12 months  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  	}  }  else if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = Math.Ceiling (tempStep / 365.0);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Month;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  	// make sure the minorStep is 1' 2' 3' 6' or 12 months  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Month;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  	// make sure the minorStep is 1' 2' 3' 6' or 12 months  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Month;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  	// make sure the minorStep is 1' 2' 3' 6' or 12 months  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Month;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  	// make sure the minorStep is 1' 2' 3' 6' or 12 months  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Month;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  	// make sure the minorStep is 1' 2' 3' 6' or 12 months  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Month;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  	// make sure the minorStep is 1' 2' 3' 6' or 12 months  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = Math.Ceiling (range / (targetSteps * 3) / 30.0);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 6)  	scale._minorStep = 12;  else if (scale._minorStep > 3)  	scale._minorStep = 6;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 6)  	scale._minorStep = 12;  else if (scale._minorStep > 3)  	scale._minorStep = 6;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 6)  	scale._minorStep = 12;  else if (scale._minorStep > 3)  	scale._minorStep = 6;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 6)  	scale._minorStep = 12;  else if (scale._minorStep > 3)  	scale._minorStep = 6;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 12;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 3)  	scale._minorStep = 6;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 3)  	scale._minorStep = 6;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 6;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMonthMonth) {  	scale._majorUnit = DateUnit.Month;  	if (scale._formatAuto)  		scale._format = Default.FormatMonthMonth;  	tempStep = Math.Ceiling (tempStep / 30.0);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Month;  		scale._minorStep = tempStep * 0.25;  	}  }  else if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = Math.Ceiling (tempStep / 30.0);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Month;  	scale._minorStep = tempStep * 0.25;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = tempStep * 0.25;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayDay) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayDay;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Day;  		scale._minorStep = tempStep * 0.25;  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	}  }  else if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Day;  	scale._minorStep = tempStep * 0.25;  	// make sure the minorStep is 1' 2' 3' 6' or 12 hours  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = tempStep * 0.25;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeDayHour) {  	scale._majorUnit = DateUnit.Day;  	if (scale._formatAuto)  		scale._format = Default.FormatDayHour;  	tempStep = Math.Ceiling (tempStep);  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  		// make sure the minorStep is 1' 2' 3' 6' or 12 hours  		if (scale._minorStep > 6)  			scale._minorStep = 12;  		else if (scale._minorStep > 3)  			scale._minorStep = 6;  		else  			scale._minorStep = 1;  	}  }  else if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Hour;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  	// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  	else  		scale._minorStep = 1;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Hour;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  	// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  	else  		scale._minorStep = 1;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Hour;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  	// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  	else  		scale._minorStep = 1;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Hour;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  	// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  	else  		scale._minorStep = 1;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Hour;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  	// make sure the minorStep is 1' 2' 3' 6' or 12 hours  	if (scale._minorStep > 6)  		scale._minorStep = 12;  	else if (scale._minorStep > 3)  		scale._minorStep = 6;  	else  		scale._minorStep = 1;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.HoursPerDay);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 6)  	scale._minorStep = 12;  else if (scale._minorStep > 3)  	scale._minorStep = 6;  else  	scale._minorStep = 1;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 6)  	scale._minorStep = 12;  else if (scale._minorStep > 3)  	scale._minorStep = 6;  else  	scale._minorStep = 1;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 6)  	scale._minorStep = 12;  else if (scale._minorStep > 3)  	scale._minorStep = 6;  else  	scale._minorStep = 1;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 6)  	scale._minorStep = 12;  else if (scale._minorStep > 3)  	scale._minorStep = 6;  else  	scale._minorStep = 1;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 12;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 3)  	scale._minorStep = 6;  else  	scale._minorStep = 1;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 3)  	scale._minorStep = 6;  else  	scale._minorStep = 1;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 6;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourHour) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourHour;  	if (tempStep > 12.0)  		tempStep = 24.0;  	else if (tempStep > 6.0)  		tempStep = 12.0;  	else if (tempStep > 2.0)  		tempStep = 6.0;  	else if (tempStep > 1.0)  		tempStep = 2.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Hour;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 6.0)  			scale._minorStep = 1.0;  		else if (tempStep <= 12.0)  			scale._minorStep = 2.0;  		else  			scale._minorStep = 4.0;  	}  }  else if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 12.0)  	tempStep = 24.0;  else if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 12.0)  	tempStep = 24.0;  else if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 12.0)  	tempStep = 24.0;  else if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 12.0)  	tempStep = 24.0;  else if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 12.0)  	tempStep = 24.0;  else if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 12.0)  	tempStep = 24.0;  else if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 12.0)  	tempStep = 24.0;  else if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = 24.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 6.0)  	tempStep = 12.0;  else if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = 12.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 2.0)  	tempStep = 6.0;  else if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = 6.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 1.0)  	tempStep = 2.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = 2.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Hour;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 6.0)  		scale._minorStep = 1.0;  	else if (tempStep <= 12.0)  		scale._minorStep = 2.0;  	else  		scale._minorStep = 4.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Hour;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 6.0)  		scale._minorStep = 1.0;  	else if (tempStep <= 12.0)  		scale._minorStep = 2.0;  	else  		scale._minorStep = 4.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Hour;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 6.0)  		scale._minorStep = 1.0;  	else if (tempStep <= 12.0)  		scale._minorStep = 2.0;  	else  		scale._minorStep = 4.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Hour;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 6.0)  		scale._minorStep = 1.0;  	else if (tempStep <= 12.0)  		scale._minorStep = 2.0;  	else  		scale._minorStep = 4.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Hour;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 6.0)  		scale._minorStep = 1.0;  	else if (tempStep <= 12.0)  		scale._minorStep = 2.0;  	else  		scale._minorStep = 4.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 6.0)  	scale._minorStep = 1.0;  else if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 6.0)  	scale._minorStep = 1.0;  else if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 6.0)  	scale._minorStep = 1.0;  else if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 6.0)  	scale._minorStep = 1.0;  else if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 6.0)  	scale._minorStep = 1.0;  else if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 0.25;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 6.0)  	scale._minorStep = 1.0;  else if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 6.0)  	scale._minorStep = 1.0;  else if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 6.0)  	scale._minorStep = 1.0;  else if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 6.0)  	scale._minorStep = 1.0;  else if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 12.0)  	scale._minorStep = 2.0;  else  	scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 2.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 4.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeHourMinute) {  	scale._majorUnit = DateUnit.Hour;  	tempStep = Math.Ceiling (tempStep * XDate.HoursPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatHourMinute;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 minutes  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Minute;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 minutes  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Minute;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 minutes  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Minute;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 minutes  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Minute;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 minutes  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Minute;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 minutes  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Minute;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 minutes  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.MinutesPerDay);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 15.0)  	scale._minorStep = 30.0;  else if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 15.0)  	scale._minorStep = 30.0;  else if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 15.0)  	scale._minorStep = 30.0;  else if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 15.0)  	scale._minorStep = 30.0;  else if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 15.0)  	scale._minorStep = 30.0;  else if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 30.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 15.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteMinute) {  	scale._majorUnit = DateUnit.Minute;  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteMinute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	// make sure the minute step size is 1' 5' 15' or 30 minutes  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Minute;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 15.0)  	tempStep = 30.0;  else if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 15.0)  	tempStep = 30.0;  else if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 15.0)  	tempStep = 30.0;  else if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 15.0)  	tempStep = 30.0;  else if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 15.0)  	tempStep = 30.0;  else if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = 30.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = 15.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Minute;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 5.0)  		scale._minorStep = 1.0;  	else  		scale._minorStep = 5.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Minute;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 5.0)  		scale._minorStep = 1.0;  	else  		scale._minorStep = 5.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Minute;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 5.0)  		scale._minorStep = 1.0;  	else  		scale._minorStep = 5.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 5.0)  	scale._minorStep = 1.0;  else  	scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 5.0)  	scale._minorStep = 1.0;  else  	scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 5.0)  	scale._minorStep = 1.0;  else  	scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 0.25;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 5.0)  	scale._minorStep = 1.0;  else  	scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 5.0)  	scale._minorStep = 1.0;  else  	scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeMinuteSecond) {  	scale._majorUnit = DateUnit.Minute;  	tempStep = Math.Ceiling (tempStep * XDate.MinutesPerDay);  	if (scale._formatAuto)  		scale._format = Default.FormatMinuteSecond;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		// Calculate the minor steps to give an estimated 4 steps  		// per major step.  		scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  		// make sure the minorStep is 1' 5' 15' or 30 seconds  		if (scale._minorStep > 15.0)  			scale._minorStep = 30.0;  		else if (scale._minorStep > 5.0)  			scale._minorStep = 15.0;  		else if (scale._minorStep > 1.0)  			scale._minorStep = 5.0;  		else  			scale._minorStep = 1.0;  	}  }  else if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Second;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 seconds  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Second;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 seconds  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Second;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 seconds  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Second;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 seconds  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Second;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 seconds  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Second;  	// Calculate the minor steps to give an estimated 4 steps  	// per major step.  	scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  	// make sure the minorStep is 1' 5' 15' or 30 seconds  	if (scale._minorStep > 15.0)  		scale._minorStep = 30.0;  	else if (scale._minorStep > 5.0)  		scale._minorStep = 15.0;  	else if (scale._minorStep > 1.0)  		scale._minorStep = 5.0;  	else  		scale._minorStep = 1.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = Math.Ceiling (range / (targetSteps * 3) * XDate.SecondsPerDay);  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 15.0)  	scale._minorStep = 30.0;  else if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 15.0)  	scale._minorStep = 30.0;  else if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 15.0)  	scale._minorStep = 30.0;  else if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 15.0)  	scale._minorStep = 30.0;  else if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 15.0)  	scale._minorStep = 30.0;  else if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 30.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 5.0)  	scale._minorStep = 15.0;  else if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 15.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStep > 1.0)  	scale._minorStep = 5.0;  else  	scale._minorStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (range > Default.RangeSecondSecond)// SecondSecond   {  	scale._majorUnit = DateUnit.Second;  	if (scale._formatAuto)  		scale._format = Default.FormatSecondSecond;  	tempStep = Math.Ceiling (tempStep * XDate.SecondsPerDay);  	// make sure the second step size is 1' 5' 15' or 30 seconds  	if (tempStep > 15.0)  		tempStep = 30.0;  	else if (tempStep > 5.0)  		tempStep = 15.0;  	else if (tempStep > 1.0)  		tempStep = 5.0;  	else  		tempStep = 1.0;  	if (scale._minorStepAuto) {  		scale._minorUnit = DateUnit.Second;  		if (tempStep <= 1.0)  			scale._minorStep = 0.25;  		else if (tempStep <= 5.0)  			scale._minorStep = 1.0;  		else  			scale._minorStep = 5.0;  	}  }  else// MilliSecond   {  	scale._majorUnit = DateUnit.Millisecond;  	if (scale._formatAuto)  		scale._format = Default.FormatMillisecond;  	tempStep = CalcStepSize (range * XDate.MillisecondsPerDay' Default.TargetXSteps);  	if (scale._minorStepAuto) {  		scale._minorStep = CalcStepSize (tempStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  		scale._minorUnit = DateUnit.Millisecond;  	}  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 15.0)  	tempStep = 30.0;  else if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 15.0)  	tempStep = 30.0;  else if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 15.0)  	tempStep = 30.0;  else if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 15.0)  	tempStep = 30.0;  else if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 15.0)  	tempStep = 30.0;  else if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = 30.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 5.0)  	tempStep = 15.0;  else if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = 15.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep > 1.0)  	tempStep = 5.0;  else  	tempStep = 1.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: tempStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Second;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 5.0)  		scale._minorStep = 1.0;  	else  		scale._minorStep = 5.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Second;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 5.0)  		scale._minorStep = 1.0;  	else  		scale._minorStep = 5.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (scale._minorStepAuto) {  	scale._minorUnit = DateUnit.Second;  	if (tempStep <= 1.0)  		scale._minorStep = 0.25;  	else if (tempStep <= 5.0)  		scale._minorStep = 1.0;  	else  		scale._minorStep = 5.0;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 5.0)  	scale._minorStep = 1.0;  else  	scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 5.0)  	scale._minorStep = 1.0;  else  	scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 1.0)  	scale._minorStep = 0.25;  else if (tempStep <= 5.0)  	scale._minorStep = 1.0;  else  	scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 0.25;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 5.0)  	scale._minorStep = 1.0;  else  	scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: if (tempStep <= 5.0)  	scale._minorStep = 1.0;  else  	scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,CalcDateStepSize,The following statement contains a magic number: scale._minorStep = 5.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,GetUnitMultiple,The following statement contains a magic number: switch (unit) {  case DateUnit.Year:  default:  	return 365.0;  case DateUnit.Month:  	return 30.0;  case DateUnit.Day:  	return 1.0;  case DateUnit.Hour:  	return 1.0 / XDate.HoursPerDay;  case DateUnit.Minute:  	return 1.0 / XDate.MinutesPerDay;  case DateUnit.Second:  	return 1.0 / XDate.SecondsPerDay;  case DateUnit.Millisecond:  	return 1.0 / XDate.MillisecondsPerDay;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,GetUnitMultiple,The following statement contains a magic number: switch (unit) {  case DateUnit.Year:  default:  	return 365.0;  case DateUnit.Month:  	return 30.0;  case DateUnit.Day:  	return 1.0;  case DateUnit.Hour:  	return 1.0 / XDate.HoursPerDay;  case DateUnit.Minute:  	return 1.0 / XDate.MinutesPerDay;  case DateUnit.Second:  	return 1.0 / XDate.SecondsPerDay;  case DateUnit.Millisecond:  	return 1.0 / XDate.MillisecondsPerDay;  }  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,GetUnitMultiple,The following statement contains a magic number: return 365.0;  
Magic Number,ZedGraph,DateScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\DateScale.cs,GetUnitMultiple,The following statement contains a magic number: return 30.0;  
Magic Number,ZedGraph,EllipseObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\EllipseObj.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000) {  	if (_fill.IsVisible)  		using (Brush brush = _fill.MakeBrush (pixRect))  			g.FillEllipse (brush' pixRect);  	if (_border.IsVisible)  		using (Pen pen = _border.GetPen (pane' scaleFactor))  			g.DrawEllipse (pen' pixRect);  }  
Magic Number,ZedGraph,EllipseObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\EllipseObj.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000) {  	if (_fill.IsVisible)  		using (Brush brush = _fill.MakeBrush (pixRect))  			g.FillEllipse (brush' pixRect);  	if (_border.IsVisible)  		using (Pen pen = _border.GetPen (pane' scaleFactor))  			g.DrawEllipse (pen' pixRect);  }  
Magic Number,ZedGraph,EllipseObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\EllipseObj.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000) {  	if (_fill.IsVisible)  		using (Brush brush = _fill.MakeBrush (pixRect))  			g.FillEllipse (brush' pixRect);  	if (_border.IsVisible)  		using (Pen pen = _border.GetPen (pane' scaleFactor))  			g.DrawEllipse (pen' pixRect);  }  
Magic Number,ZedGraph,EllipseObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\EllipseObj.cs,Draw,The following statement contains a magic number: if (Math.Abs (pixRect.Left) < 100000 && Math.Abs (pixRect.Top) < 100000 && Math.Abs (pixRect.Right) < 100000 && Math.Abs (pixRect.Bottom) < 100000) {  	if (_fill.IsVisible)  		using (Brush brush = _fill.MakeBrush (pixRect))  			g.FillEllipse (brush' pixRect);  	if (_border.IsVisible)  		using (Pen pen = _border.GetPen (pane' scaleFactor))  			g.DrawEllipse (pen' pixRect);  }  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-20) {  	if (_maxAuto)  		_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  	if (_minAuto)  		_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  }  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-20) {  	if (_maxAuto)  		_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  	if (_minAuto)  		_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  }  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-20) {  	if (_maxAuto)  		_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  	if (_minAuto)  		_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  }  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (_maxAuto)  	_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: _max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (_minAuto)  	_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: _min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = 0;  	double mag2 = 0;  	if (Math.Abs (_min) > 1.0e-10)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-10)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	if (Math.Abs (mag2) > Math.Abs (mag))  		mag = mag2;  	// Do not use scale multiples for magnitudes below 4  	if (Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = 0;  	double mag2 = 0;  	if (Math.Abs (_min) > 1.0e-10)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-10)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	if (Math.Abs (mag2) > Math.Abs (mag))  		mag = mag2;  	// Do not use scale multiples for magnitudes below 4  	if (Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = 0;  	double mag2 = 0;  	if (Math.Abs (_min) > 1.0e-10)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-10)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	if (Math.Abs (mag2) > Math.Abs (mag))  		mag = mag2;  	// Do not use scale multiples for magnitudes below 4  	if (Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = 0;  	double mag2 = 0;  	if (Math.Abs (_min) > 1.0e-10)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-10)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	if (Math.Abs (mag2) > Math.Abs (mag))  		mag = mag2;  	// Do not use scale multiples for magnitudes below 4  	if (Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = 0;  	double mag2 = 0;  	if (Math.Abs (_min) > 1.0e-10)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-10)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	if (Math.Abs (mag2) > Math.Abs (mag))  		mag = mag2;  	// Do not use scale multiples for magnitudes below 4  	if (Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (Math.Abs (_min) > 1.0e-10)  	mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (Math.Abs (_max) > 1.0e-10)  	mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: if (Math.Abs (mag) <= 3)  	mag = 0;  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: _mag = (int)(Math.Floor (mag / 3.0) * 3.0);  
Magic Number,ZedGraph,ExponentScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ExponentScale.cs,PickScale,The following statement contains a magic number: _mag = (int)(Math.Floor (mag / 3.0) * 3.0);  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,Fill,The following statement contains a magic number: blend.Colors [2] = color3;  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,Fill,The following statement contains a magic number: blend.Positions [2] = 1.0f;  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,CreateBrushFromBlend,The following statement contains a magic number: _brush = new LinearGradientBrush (new Rectangle (0' 0' 100' 100)' Color.Red' Color.White' angle);  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,CreateBrushFromBlend,The following statement contains a magic number: _brush = new LinearGradientBrush (new Rectangle (0' 0' 100' 100)' Color.Red' Color.White' angle);  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,GetGradientColor,The following statement contains a magic number: if (_rangeMax - _rangeMin < 1e-20 || val == double.MaxValue)  	valueFraction = 0.5;  else  	valueFraction = (val - _rangeMin) / (_rangeMax - _rangeMin);  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,GetGradientColor,The following statement contains a magic number: if (_rangeMax - _rangeMin < 1e-20 || val == double.MaxValue)  	valueFraction = 0.5;  else  	valueFraction = (val - _rangeMin) / (_rangeMax - _rangeMin);  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,GetGradientColor,The following statement contains a magic number: valueFraction = 0.5;  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,GetGradientColor,The following statement contains a magic number: if (_gradientBM == null) {  	RectangleF rect = new RectangleF (0' 0' 100' 1);  	_gradientBM = new Bitmap (100' 1);  	Graphics gBM = Graphics.FromImage (_gradientBM);  	Brush tmpBrush = ScaleBrush (rect' _brush' true);  	gBM.FillRectangle (tmpBrush' rect);  }  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,GetGradientColor,The following statement contains a magic number: if (_gradientBM == null) {  	RectangleF rect = new RectangleF (0' 0' 100' 1);  	_gradientBM = new Bitmap (100' 1);  	Graphics gBM = Graphics.FromImage (_gradientBM);  	Brush tmpBrush = ScaleBrush (rect' _brush' true);  	gBM.FillRectangle (tmpBrush' rect);  }  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,GetGradientColor,The following statement contains a magic number: _gradientBM = new Bitmap (100' 1);  
Magic Number,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,GetGradientColor,The following statement contains a magic number: return _gradientBM.GetPixel ((int)(99.9 * valueFraction)' 0);  
Magic Number,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,Remake,The following statement contains a magic number: if (font == null || Math.Abs (newSize - oldSize) > 0.1 || font.Name != this.Family || font.Bold != _isBold || font.Italic != _isItalic || font.Underline != _isUnderline) {  	FontStyle style = FontStyle.Regular;  	style = (_isBold ? FontStyle.Bold : style) | (_isItalic ? FontStyle.Italic : style) | (_isUnderline ? FontStyle.Underline : style);  	scaledSize = size * (float)scaleFactor;  	font = new Font (_family' scaledSize' style' GraphicsUnit.World);  }  
Magic Number,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,GetBox,The following statement contains a magic number: pts [2] = new PointF (rect.Right' rect.Bottom);  
Magic Number,ZedGraph,FontSpec,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\FontSpec.cs,GetBox,The following statement contains a magic number: pts [3] = new PointF (rect.Left' rect.Bottom);  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: if (pane.Chart._rect.Width <= 0 && pane.Chart._rect.Height <= 0) {  	_slicePath = null;  }  else {  	CalcRectangle (g' pane' scaleFactor' pane.Chart._rect);  	_slicePath = new GraphicsPath ();  	if (!_isVisible)  		return;  	RectangleF tRect = _boundingRectangle;  	if (tRect.Width >= 1 && tRect.Height >= 1) {  		SmoothingMode sMode = g.SmoothingMode;  		g.SmoothingMode = SmoothingMode.AntiAlias;  		Matrix matrix = new Matrix ();  		matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  		PointF[] pts = new PointF[2];  		pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  		pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  		matrix.TransformPoints (pts);  		Pen p = new Pen (NeedleColor' ((tRect.Height * .10f) / 2.0f));  		p.EndCap = LineCap.ArrowAnchor;  		g.DrawLine (p' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y);  		//Fill center 10% with Black dot;  		Fill f = new Fill (Color.Black);  		RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f);  		r.Inflate ((tRect.Height * .10f)' (tRect.Height * .10f));  		Brush b = f.MakeBrush (r);  		g.FillPie (b' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  		Pen borderPen = new Pen (Color.White' 2.0f);  		g.DrawPie (borderPen' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  		g.SmoothingMode = sMode;  	}  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: if (pane.Chart._rect.Width <= 0 && pane.Chart._rect.Height <= 0) {  	_slicePath = null;  }  else {  	CalcRectangle (g' pane' scaleFactor' pane.Chart._rect);  	_slicePath = new GraphicsPath ();  	if (!_isVisible)  		return;  	RectangleF tRect = _boundingRectangle;  	if (tRect.Width >= 1 && tRect.Height >= 1) {  		SmoothingMode sMode = g.SmoothingMode;  		g.SmoothingMode = SmoothingMode.AntiAlias;  		Matrix matrix = new Matrix ();  		matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  		PointF[] pts = new PointF[2];  		pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  		pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  		matrix.TransformPoints (pts);  		Pen p = new Pen (NeedleColor' ((tRect.Height * .10f) / 2.0f));  		p.EndCap = LineCap.ArrowAnchor;  		g.DrawLine (p' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y);  		//Fill center 10% with Black dot;  		Fill f = new Fill (Color.Black);  		RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f);  		r.Inflate ((tRect.Height * .10f)' (tRect.Height * .10f));  		Brush b = f.MakeBrush (r);  		g.FillPie (b' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  		Pen borderPen = new Pen (Color.White' 2.0f);  		g.DrawPie (borderPen' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  		g.SmoothingMode = sMode;  	}  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: if (pane.Chart._rect.Width <= 0 && pane.Chart._rect.Height <= 0) {  	_slicePath = null;  }  else {  	CalcRectangle (g' pane' scaleFactor' pane.Chart._rect);  	_slicePath = new GraphicsPath ();  	if (!_isVisible)  		return;  	RectangleF tRect = _boundingRectangle;  	if (tRect.Width >= 1 && tRect.Height >= 1) {  		SmoothingMode sMode = g.SmoothingMode;  		g.SmoothingMode = SmoothingMode.AntiAlias;  		Matrix matrix = new Matrix ();  		matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  		PointF[] pts = new PointF[2];  		pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  		pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  		matrix.TransformPoints (pts);  		Pen p = new Pen (NeedleColor' ((tRect.Height * .10f) / 2.0f));  		p.EndCap = LineCap.ArrowAnchor;  		g.DrawLine (p' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y);  		//Fill center 10% with Black dot;  		Fill f = new Fill (Color.Black);  		RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f);  		r.Inflate ((tRect.Height * .10f)' (tRect.Height * .10f));  		Brush b = f.MakeBrush (r);  		g.FillPie (b' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  		Pen borderPen = new Pen (Color.White' 2.0f);  		g.DrawPie (borderPen' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  		g.SmoothingMode = sMode;  	}  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: if (pane.Chart._rect.Width <= 0 && pane.Chart._rect.Height <= 0) {  	_slicePath = null;  }  else {  	CalcRectangle (g' pane' scaleFactor' pane.Chart._rect);  	_slicePath = new GraphicsPath ();  	if (!_isVisible)  		return;  	RectangleF tRect = _boundingRectangle;  	if (tRect.Width >= 1 && tRect.Height >= 1) {  		SmoothingMode sMode = g.SmoothingMode;  		g.SmoothingMode = SmoothingMode.AntiAlias;  		Matrix matrix = new Matrix ();  		matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  		PointF[] pts = new PointF[2];  		pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  		pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  		matrix.TransformPoints (pts);  		Pen p = new Pen (NeedleColor' ((tRect.Height * .10f) / 2.0f));  		p.EndCap = LineCap.ArrowAnchor;  		g.DrawLine (p' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y);  		//Fill center 10% with Black dot;  		Fill f = new Fill (Color.Black);  		RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f);  		r.Inflate ((tRect.Height * .10f)' (tRect.Height * .10f));  		Brush b = f.MakeBrush (r);  		g.FillPie (b' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  		Pen borderPen = new Pen (Color.White' 2.0f);  		g.DrawPie (borderPen' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  		g.SmoothingMode = sMode;  	}  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: if (pane.Chart._rect.Width <= 0 && pane.Chart._rect.Height <= 0) {  	_slicePath = null;  }  else {  	CalcRectangle (g' pane' scaleFactor' pane.Chart._rect);  	_slicePath = new GraphicsPath ();  	if (!_isVisible)  		return;  	RectangleF tRect = _boundingRectangle;  	if (tRect.Width >= 1 && tRect.Height >= 1) {  		SmoothingMode sMode = g.SmoothingMode;  		g.SmoothingMode = SmoothingMode.AntiAlias;  		Matrix matrix = new Matrix ();  		matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  		PointF[] pts = new PointF[2];  		pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  		pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  		matrix.TransformPoints (pts);  		Pen p = new Pen (NeedleColor' ((tRect.Height * .10f) / 2.0f));  		p.EndCap = LineCap.ArrowAnchor;  		g.DrawLine (p' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y);  		//Fill center 10% with Black dot;  		Fill f = new Fill (Color.Black);  		RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f);  		r.Inflate ((tRect.Height * .10f)' (tRect.Height * .10f));  		Brush b = f.MakeBrush (r);  		g.FillPie (b' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  		Pen borderPen = new Pen (Color.White' 2.0f);  		g.DrawPie (borderPen' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  		g.SmoothingMode = sMode;  	}  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: if (tRect.Width >= 1 && tRect.Height >= 1) {  	SmoothingMode sMode = g.SmoothingMode;  	g.SmoothingMode = SmoothingMode.AntiAlias;  	Matrix matrix = new Matrix ();  	matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  	PointF[] pts = new PointF[2];  	pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  	pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  	matrix.TransformPoints (pts);  	Pen p = new Pen (NeedleColor' ((tRect.Height * .10f) / 2.0f));  	p.EndCap = LineCap.ArrowAnchor;  	g.DrawLine (p' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y);  	//Fill center 10% with Black dot;  	Fill f = new Fill (Color.Black);  	RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f);  	r.Inflate ((tRect.Height * .10f)' (tRect.Height * .10f));  	Brush b = f.MakeBrush (r);  	g.FillPie (b' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  	Pen borderPen = new Pen (Color.White' 2.0f);  	g.DrawPie (borderPen' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  	g.SmoothingMode = sMode;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: if (tRect.Width >= 1 && tRect.Height >= 1) {  	SmoothingMode sMode = g.SmoothingMode;  	g.SmoothingMode = SmoothingMode.AntiAlias;  	Matrix matrix = new Matrix ();  	matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  	PointF[] pts = new PointF[2];  	pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  	pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  	matrix.TransformPoints (pts);  	Pen p = new Pen (NeedleColor' ((tRect.Height * .10f) / 2.0f));  	p.EndCap = LineCap.ArrowAnchor;  	g.DrawLine (p' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y);  	//Fill center 10% with Black dot;  	Fill f = new Fill (Color.Black);  	RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f);  	r.Inflate ((tRect.Height * .10f)' (tRect.Height * .10f));  	Brush b = f.MakeBrush (r);  	g.FillPie (b' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  	Pen borderPen = new Pen (Color.White' 2.0f);  	g.DrawPie (borderPen' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  	g.SmoothingMode = sMode;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: if (tRect.Width >= 1 && tRect.Height >= 1) {  	SmoothingMode sMode = g.SmoothingMode;  	g.SmoothingMode = SmoothingMode.AntiAlias;  	Matrix matrix = new Matrix ();  	matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  	PointF[] pts = new PointF[2];  	pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  	pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  	matrix.TransformPoints (pts);  	Pen p = new Pen (NeedleColor' ((tRect.Height * .10f) / 2.0f));  	p.EndCap = LineCap.ArrowAnchor;  	g.DrawLine (p' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y);  	//Fill center 10% with Black dot;  	Fill f = new Fill (Color.Black);  	RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f);  	r.Inflate ((tRect.Height * .10f)' (tRect.Height * .10f));  	Brush b = f.MakeBrush (r);  	g.FillPie (b' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  	Pen borderPen = new Pen (Color.White' 2.0f);  	g.DrawPie (borderPen' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  	g.SmoothingMode = sMode;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: if (tRect.Width >= 1 && tRect.Height >= 1) {  	SmoothingMode sMode = g.SmoothingMode;  	g.SmoothingMode = SmoothingMode.AntiAlias;  	Matrix matrix = new Matrix ();  	matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  	PointF[] pts = new PointF[2];  	pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  	pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  	matrix.TransformPoints (pts);  	Pen p = new Pen (NeedleColor' ((tRect.Height * .10f) / 2.0f));  	p.EndCap = LineCap.ArrowAnchor;  	g.DrawLine (p' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y);  	//Fill center 10% with Black dot;  	Fill f = new Fill (Color.Black);  	RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f);  	r.Inflate ((tRect.Height * .10f)' (tRect.Height * .10f));  	Brush b = f.MakeBrush (r);  	g.FillPie (b' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  	Pen borderPen = new Pen (Color.White' 2.0f);  	g.DrawPie (borderPen' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  	g.SmoothingMode = sMode;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: if (tRect.Width >= 1 && tRect.Height >= 1) {  	SmoothingMode sMode = g.SmoothingMode;  	g.SmoothingMode = SmoothingMode.AntiAlias;  	Matrix matrix = new Matrix ();  	matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  	PointF[] pts = new PointF[2];  	pts [0] = new PointF (((tRect.Height * .10f) / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' ((tRect.Height * .10f) / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  	pts [1] = new PointF ((tRect.Width / 2.0f) * (float)Math.Cos (-SweepAngle * Math.PI / 180.0f)' (tRect.Width / 2.0f) * (float)Math.Sin (-SweepAngle * Math.PI / 180.0f));  	matrix.TransformPoints (pts);  	Pen p = new Pen (NeedleColor' ((tRect.Height * .10f) / 2.0f));  	p.EndCap = LineCap.ArrowAnchor;  	g.DrawLine (p' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y);  	//Fill center 10% with Black dot;  	Fill f = new Fill (Color.Black);  	RectangleF r = new RectangleF ((tRect.X + (tRect.Width / 2)) - 1.0f' (tRect.Y + (tRect.Height / 2)) - 1.0f' 1.0f' 1.0f);  	r.Inflate ((tRect.Height * .10f)' (tRect.Height * .10f));  	Brush b = f.MakeBrush (r);  	g.FillPie (b' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  	Pen borderPen = new Pen (Color.White' 2.0f);  	g.DrawPie (borderPen' r.X' r.Y' r.Width' r.Height' 0.0f' -180.0f);  	g.SmoothingMode = sMode;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,Draw,The following statement contains a magic number: matrix.Translate (tRect.X + (tRect.Width / 2)' tRect.Y + (tRect.Height / 2)' MatrixOrder.Prepend);  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalcRectangle,The following statement contains a magic number: nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalcRectangle,The following statement contains a magic number: nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalcRectangle,The following statement contains a magic number: nonExpRect.Height = nonExpRect.Height * 2;  
Magic Number,ZedGraph,GasGaugeNeedle,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeNeedle.cs,CalcRectangle,The following statement contains a magic number: nonExpRect.Inflate (-(float)0.05F * nonExpRect.Height' -(float)0.05 * nonExpRect.Width);  
Magic Number,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalcRectangle,The following statement contains a magic number: if ((2 * nonExpRect.Height) > nonExpRect.Width) {  	//Scale based on width  	float percentS = ((nonExpRect.Height * 2) - nonExpRect.Width) / (nonExpRect.Height * 2);  	nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  }  else {  	nonExpRect.Height = nonExpRect.Height * 2;  }  
Magic Number,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalcRectangle,The following statement contains a magic number: nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  
Magic Number,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalcRectangle,The following statement contains a magic number: nonExpRect.Height = ((nonExpRect.Height * 2) - ((nonExpRect.Height * 2) * percentS));  
Magic Number,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalcRectangle,The following statement contains a magic number: nonExpRect.Height = nonExpRect.Height * 2;  
Magic Number,ZedGraph,GasGaugeRegion,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GasGaugeRegion.cs,CalcRectangle,The following statement contains a magic number: nonExpRect.Inflate (-(float)0.05F * nonExpRect.Height' -(float)0.05 * nonExpRect.Width);  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,GraphPane,The following statement contains a magic number: if (sch >= 11)  	_x2Axis = (X2Axis)info.GetValue ("x2Axis"' typeof(X2Axis));  else  	_x2Axis = new X2Axis ("");  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestObject,The following statement contains a magic number: if (AxisRangesValid ()) {  	float scaleFactor = CalcScaleFactor ();  	//int			hStack;  	//float		legendWidth' legendHeight;  	RectangleF tmpRect;  	GraphObj saveGraphItem = null;  	int saveIndex = -1;  	ZOrder saveZOrder = ZOrder.H_BehindAll;  	// Calculate the chart rect' deducting the area for the scales' titles' legend' etc.  	RectangleF tmpChartRect = CalcChartRect (g' scaleFactor);  	// See if the point is in a GraphObj  	// If so' just save the object and index so we can see if other overlying objects were  	// intersected as well.  	if (this.GraphObjList.FindPoint (mousePt' this' g' scaleFactor' out index)) {  		saveGraphItem = this.GraphObjList [index];  		saveIndex = index;  		saveZOrder = saveGraphItem.ZOrder;  	}  	// See if the point is in the legend  	if (saveZOrder <= ZOrder.B_BehindLegend && this.Legend.FindPoint (mousePt' this' scaleFactor' out index)) {  		nearestObj = this.Legend;  		return true;  	}  	// See if the point is in the Pane Title  	SizeF paneTitleBox = _title._fontSpec.BoundingBox (g' _title._text' scaleFactor);  	if (saveZOrder <= ZOrder.H_BehindAll && _title._isVisible) {  		tmpRect = new RectangleF ((_rect.Left + _rect.Right - paneTitleBox.Width) / 2' _rect.Top + _margin.Top * scaleFactor' paneTitleBox.Width' paneTitleBox.Height);  		if (tmpRect.Contains (mousePt)) {  			nearestObj = this;  			return true;  		}  	}  	float left = tmpChartRect.Left;  	// See if the point is in one of the Y Axes  	for (int yIndex = 0; yIndex < _yAxisList.Count; yIndex++) {  		Axis yAxis = _yAxisList [yIndex];  		float width = yAxis._tmpSpace;  		if (width > 0) {  			tmpRect = new RectangleF (left - width' tmpChartRect.Top' width' tmpChartRect.Height);  			if (saveZOrder <= ZOrder.D_BehindAxis && tmpRect.Contains (mousePt)) {  				nearestObj = yAxis;  				index = yIndex;  				return true;  			}  			left -= width;  		}  	}  	left = tmpChartRect.Right;  	// See if the point is in one of the Y2 Axes  	for (int yIndex = 0; yIndex < _y2AxisList.Count; yIndex++) {  		Axis y2Axis = _y2AxisList [yIndex];  		float width = y2Axis._tmpSpace;  		if (width > 0) {  			tmpRect = new RectangleF (left' tmpChartRect.Top' width' tmpChartRect.Height);  			if (saveZOrder <= ZOrder.D_BehindAxis && tmpRect.Contains (mousePt)) {  				nearestObj = y2Axis;  				index = yIndex;  				return true;  			}  			left += width;  		}  	}  	// See if the point is in the X Axis  	float height = _xAxis._tmpSpace;  	tmpRect = new RectangleF (tmpChartRect.Left' tmpChartRect.Bottom' tmpChartRect.Width' height);  	//_rect.Bottom - tmpChartRect.Bottom );  	if (saveZOrder <= ZOrder.D_BehindAxis && tmpRect.Contains (mousePt)) {  		nearestObj = this.XAxis;  		return true;  	}  	// See if the point is in the X2 Axis  	height = _x2Axis._tmpSpace;  	tmpRect = new RectangleF (tmpChartRect.Left' tmpChartRect.Top - height' tmpChartRect.Width' height);  	if (saveZOrder <= ZOrder.D_BehindAxis && tmpRect.Contains (mousePt)) {  		nearestObj = this.X2Axis;  		return true;  	}  	CurveItem curve;  	// See if it's a data point  	if (saveZOrder <= ZOrder.E_BehindCurves && FindNearestPoint (mousePt' out curve' out index)) {  		nearestObj = curve;  		return true;  	}  	if (saveGraphItem != null) {  		index = saveIndex;  		nearestObj = saveGraphItem;  		return true;  	}  }  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestObject,The following statement contains a magic number: if (saveZOrder <= ZOrder.H_BehindAll && _title._isVisible) {  	tmpRect = new RectangleF ((_rect.Left + _rect.Right - paneTitleBox.Width) / 2' _rect.Top + _margin.Top * scaleFactor' paneTitleBox.Width' paneTitleBox.Height);  	if (tmpRect.Contains (mousePt)) {  		nearestObj = this;  		return true;  	}  }  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestObject,The following statement contains a magic number: tmpRect = new RectangleF ((_rect.Left + _rect.Right - paneTitleBox.Width) / 2' _rect.Top + _margin.Top * scaleFactor' paneTitleBox.Width' paneTitleBox.Height);  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: foreach (CurveItem curve in targetCurveList) {  	//test for pie first...if it's a pie rest of method superfluous  	if (curve is PieItem && curve.IsVisible) {  		if (((PieItem)curve).SlicePath != null && ((PieItem)curve).SlicePath.IsVisible (mousePt)) {  			nearestBar = curve;  			iNearestBar = 0;  		}  		continue;  	}  	else if (curve.IsVisible) {  		int yIndex = curve.GetYAxisIndex (this);  		Axis yAxis = curve.GetYAxis (this);  		Axis xAxis = curve.GetXAxis (this);  		if (curve.IsY2Axis) {  			yAct = y2 [yIndex];  			yMinAct = _y2AxisList [yIndex]._scale._min;  			yMaxAct = _y2AxisList [yIndex]._scale._max;  		}  		else {  			yAct = y [yIndex];  			yMinAct = _yAxisList [yIndex]._scale._min;  			yMaxAct = _yAxisList [yIndex]._scale._max;  		}  		yPixPerUnitAct = _chart._rect.Height / (yMaxAct - yMinAct);  		double xPixPerUnit = _chart._rect.Width / (xAxis._scale._max - xAxis._scale._min);  		xAct = xAxis is XAxis ? x : x2;  		IPointList points = curve.Points;  		float barWidth = curve.GetBarWidth (this);  		double barWidthUserHalf;  		Axis baseAxis = curve.BaseAxis (this);  		bool isXBaseAxis = (baseAxis is XAxis || baseAxis is X2Axis);  		if (isXBaseAxis)  			barWidthUserHalf = barWidth / xPixPerUnit / 2.0;  		else  			barWidthUserHalf = barWidth / yPixPerUnitAct / 2.0;  		if (points != null) {  			for (int iPt = 0; iPt < curve.NPts; iPt++) {  				// xVal is the user scale X value of the current point  				if (xAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  					xVal = (double)iPt + 1.0;  				else  					xVal = points [iPt].X;  				// yVal is the user scale Y value of the current point  				if (yAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  					yVal = (double)iPt + 1.0;  				else  					yVal = points [iPt].Y;  				if (xVal != PointPair.Missing && yVal != PointPair.Missing) {  					if (curve.IsBar || curve is ErrorBarItem || curve is HiLowBarItem || curve is OHLCBarItem || curve is JapaneseCandleStickItem) {  						double baseVal' lowVal' hiVal;  						valueHandler.GetValues (curve' iPt' out baseVal' out lowVal' out hiVal);  						if (lowVal > hiVal) {  							double tmpVal = lowVal;  							lowVal = hiVal;  							hiVal = tmpVal;  						}  						if (isXBaseAxis) {  							double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' xVal' iBar);  							if (xAct < centerVal - barWidthUserHalf || xAct > centerVal + barWidthUserHalf || yAct < lowVal || yAct > hiVal)  								continue;  						}  						else {  							double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' yVal' iBar);  							if (yAct < centerVal - barWidthUserHalf || yAct > centerVal + barWidthUserHalf || xAct < lowVal || xAct > hiVal)  								continue;  						}  						if (nearestBar == null) {  							iNearestBar = iPt;  							nearestBar = curve;  						}  					}  					else if (xVal >= xAxis._scale._min && xVal <= xAxis._scale._max && yVal >= yMinAct && yVal <= yMaxAct) {  						if (curve is LineItem && _lineType == LineType.Stack) {  							double zVal;  							valueHandler.GetValues (curve' iPt' out xVal' out zVal' out yVal);  						}  						distX = (xVal - xAct) * xPixPerUnit;  						distY = (yVal - yAct) * yPixPerUnitAct;  						dist = distX * distX + distY * distY;  						if (dist >= minDist)  							continue;  						minDist = dist;  						iNearest = iPt;  						nearestCurve = curve;  					}  				}  			}  			if (curve.IsBar)  				iBar++;  		}  	}  }  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: foreach (CurveItem curve in targetCurveList) {  	//test for pie first...if it's a pie rest of method superfluous  	if (curve is PieItem && curve.IsVisible) {  		if (((PieItem)curve).SlicePath != null && ((PieItem)curve).SlicePath.IsVisible (mousePt)) {  			nearestBar = curve;  			iNearestBar = 0;  		}  		continue;  	}  	else if (curve.IsVisible) {  		int yIndex = curve.GetYAxisIndex (this);  		Axis yAxis = curve.GetYAxis (this);  		Axis xAxis = curve.GetXAxis (this);  		if (curve.IsY2Axis) {  			yAct = y2 [yIndex];  			yMinAct = _y2AxisList [yIndex]._scale._min;  			yMaxAct = _y2AxisList [yIndex]._scale._max;  		}  		else {  			yAct = y [yIndex];  			yMinAct = _yAxisList [yIndex]._scale._min;  			yMaxAct = _yAxisList [yIndex]._scale._max;  		}  		yPixPerUnitAct = _chart._rect.Height / (yMaxAct - yMinAct);  		double xPixPerUnit = _chart._rect.Width / (xAxis._scale._max - xAxis._scale._min);  		xAct = xAxis is XAxis ? x : x2;  		IPointList points = curve.Points;  		float barWidth = curve.GetBarWidth (this);  		double barWidthUserHalf;  		Axis baseAxis = curve.BaseAxis (this);  		bool isXBaseAxis = (baseAxis is XAxis || baseAxis is X2Axis);  		if (isXBaseAxis)  			barWidthUserHalf = barWidth / xPixPerUnit / 2.0;  		else  			barWidthUserHalf = barWidth / yPixPerUnitAct / 2.0;  		if (points != null) {  			for (int iPt = 0; iPt < curve.NPts; iPt++) {  				// xVal is the user scale X value of the current point  				if (xAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  					xVal = (double)iPt + 1.0;  				else  					xVal = points [iPt].X;  				// yVal is the user scale Y value of the current point  				if (yAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  					yVal = (double)iPt + 1.0;  				else  					yVal = points [iPt].Y;  				if (xVal != PointPair.Missing && yVal != PointPair.Missing) {  					if (curve.IsBar || curve is ErrorBarItem || curve is HiLowBarItem || curve is OHLCBarItem || curve is JapaneseCandleStickItem) {  						double baseVal' lowVal' hiVal;  						valueHandler.GetValues (curve' iPt' out baseVal' out lowVal' out hiVal);  						if (lowVal > hiVal) {  							double tmpVal = lowVal;  							lowVal = hiVal;  							hiVal = tmpVal;  						}  						if (isXBaseAxis) {  							double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' xVal' iBar);  							if (xAct < centerVal - barWidthUserHalf || xAct > centerVal + barWidthUserHalf || yAct < lowVal || yAct > hiVal)  								continue;  						}  						else {  							double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' yVal' iBar);  							if (yAct < centerVal - barWidthUserHalf || yAct > centerVal + barWidthUserHalf || xAct < lowVal || xAct > hiVal)  								continue;  						}  						if (nearestBar == null) {  							iNearestBar = iPt;  							nearestBar = curve;  						}  					}  					else if (xVal >= xAxis._scale._min && xVal <= xAxis._scale._max && yVal >= yMinAct && yVal <= yMaxAct) {  						if (curve is LineItem && _lineType == LineType.Stack) {  							double zVal;  							valueHandler.GetValues (curve' iPt' out xVal' out zVal' out yVal);  						}  						distX = (xVal - xAct) * xPixPerUnit;  						distY = (yVal - yAct) * yPixPerUnitAct;  						dist = distX * distX + distY * distY;  						if (dist >= minDist)  							continue;  						minDist = dist;  						iNearest = iPt;  						nearestCurve = curve;  					}  				}  			}  			if (curve.IsBar)  				iBar++;  		}  	}  }  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: if (curve is PieItem && curve.IsVisible) {  	if (((PieItem)curve).SlicePath != null && ((PieItem)curve).SlicePath.IsVisible (mousePt)) {  		nearestBar = curve;  		iNearestBar = 0;  	}  	continue;  }  else if (curve.IsVisible) {  	int yIndex = curve.GetYAxisIndex (this);  	Axis yAxis = curve.GetYAxis (this);  	Axis xAxis = curve.GetXAxis (this);  	if (curve.IsY2Axis) {  		yAct = y2 [yIndex];  		yMinAct = _y2AxisList [yIndex]._scale._min;  		yMaxAct = _y2AxisList [yIndex]._scale._max;  	}  	else {  		yAct = y [yIndex];  		yMinAct = _yAxisList [yIndex]._scale._min;  		yMaxAct = _yAxisList [yIndex]._scale._max;  	}  	yPixPerUnitAct = _chart._rect.Height / (yMaxAct - yMinAct);  	double xPixPerUnit = _chart._rect.Width / (xAxis._scale._max - xAxis._scale._min);  	xAct = xAxis is XAxis ? x : x2;  	IPointList points = curve.Points;  	float barWidth = curve.GetBarWidth (this);  	double barWidthUserHalf;  	Axis baseAxis = curve.BaseAxis (this);  	bool isXBaseAxis = (baseAxis is XAxis || baseAxis is X2Axis);  	if (isXBaseAxis)  		barWidthUserHalf = barWidth / xPixPerUnit / 2.0;  	else  		barWidthUserHalf = barWidth / yPixPerUnitAct / 2.0;  	if (points != null) {  		for (int iPt = 0; iPt < curve.NPts; iPt++) {  			// xVal is the user scale X value of the current point  			if (xAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  				xVal = (double)iPt + 1.0;  			else  				xVal = points [iPt].X;  			// yVal is the user scale Y value of the current point  			if (yAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  				yVal = (double)iPt + 1.0;  			else  				yVal = points [iPt].Y;  			if (xVal != PointPair.Missing && yVal != PointPair.Missing) {  				if (curve.IsBar || curve is ErrorBarItem || curve is HiLowBarItem || curve is OHLCBarItem || curve is JapaneseCandleStickItem) {  					double baseVal' lowVal' hiVal;  					valueHandler.GetValues (curve' iPt' out baseVal' out lowVal' out hiVal);  					if (lowVal > hiVal) {  						double tmpVal = lowVal;  						lowVal = hiVal;  						hiVal = tmpVal;  					}  					if (isXBaseAxis) {  						double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' xVal' iBar);  						if (xAct < centerVal - barWidthUserHalf || xAct > centerVal + barWidthUserHalf || yAct < lowVal || yAct > hiVal)  							continue;  					}  					else {  						double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' yVal' iBar);  						if (yAct < centerVal - barWidthUserHalf || yAct > centerVal + barWidthUserHalf || xAct < lowVal || xAct > hiVal)  							continue;  					}  					if (nearestBar == null) {  						iNearestBar = iPt;  						nearestBar = curve;  					}  				}  				else if (xVal >= xAxis._scale._min && xVal <= xAxis._scale._max && yVal >= yMinAct && yVal <= yMaxAct) {  					if (curve is LineItem && _lineType == LineType.Stack) {  						double zVal;  						valueHandler.GetValues (curve' iPt' out xVal' out zVal' out yVal);  					}  					distX = (xVal - xAct) * xPixPerUnit;  					distY = (yVal - yAct) * yPixPerUnitAct;  					dist = distX * distX + distY * distY;  					if (dist >= minDist)  						continue;  					minDist = dist;  					iNearest = iPt;  					nearestCurve = curve;  				}  			}  		}  		if (curve.IsBar)  			iBar++;  	}  }  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: if (curve is PieItem && curve.IsVisible) {  	if (((PieItem)curve).SlicePath != null && ((PieItem)curve).SlicePath.IsVisible (mousePt)) {  		nearestBar = curve;  		iNearestBar = 0;  	}  	continue;  }  else if (curve.IsVisible) {  	int yIndex = curve.GetYAxisIndex (this);  	Axis yAxis = curve.GetYAxis (this);  	Axis xAxis = curve.GetXAxis (this);  	if (curve.IsY2Axis) {  		yAct = y2 [yIndex];  		yMinAct = _y2AxisList [yIndex]._scale._min;  		yMaxAct = _y2AxisList [yIndex]._scale._max;  	}  	else {  		yAct = y [yIndex];  		yMinAct = _yAxisList [yIndex]._scale._min;  		yMaxAct = _yAxisList [yIndex]._scale._max;  	}  	yPixPerUnitAct = _chart._rect.Height / (yMaxAct - yMinAct);  	double xPixPerUnit = _chart._rect.Width / (xAxis._scale._max - xAxis._scale._min);  	xAct = xAxis is XAxis ? x : x2;  	IPointList points = curve.Points;  	float barWidth = curve.GetBarWidth (this);  	double barWidthUserHalf;  	Axis baseAxis = curve.BaseAxis (this);  	bool isXBaseAxis = (baseAxis is XAxis || baseAxis is X2Axis);  	if (isXBaseAxis)  		barWidthUserHalf = barWidth / xPixPerUnit / 2.0;  	else  		barWidthUserHalf = barWidth / yPixPerUnitAct / 2.0;  	if (points != null) {  		for (int iPt = 0; iPt < curve.NPts; iPt++) {  			// xVal is the user scale X value of the current point  			if (xAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  				xVal = (double)iPt + 1.0;  			else  				xVal = points [iPt].X;  			// yVal is the user scale Y value of the current point  			if (yAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  				yVal = (double)iPt + 1.0;  			else  				yVal = points [iPt].Y;  			if (xVal != PointPair.Missing && yVal != PointPair.Missing) {  				if (curve.IsBar || curve is ErrorBarItem || curve is HiLowBarItem || curve is OHLCBarItem || curve is JapaneseCandleStickItem) {  					double baseVal' lowVal' hiVal;  					valueHandler.GetValues (curve' iPt' out baseVal' out lowVal' out hiVal);  					if (lowVal > hiVal) {  						double tmpVal = lowVal;  						lowVal = hiVal;  						hiVal = tmpVal;  					}  					if (isXBaseAxis) {  						double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' xVal' iBar);  						if (xAct < centerVal - barWidthUserHalf || xAct > centerVal + barWidthUserHalf || yAct < lowVal || yAct > hiVal)  							continue;  					}  					else {  						double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' yVal' iBar);  						if (yAct < centerVal - barWidthUserHalf || yAct > centerVal + barWidthUserHalf || xAct < lowVal || xAct > hiVal)  							continue;  					}  					if (nearestBar == null) {  						iNearestBar = iPt;  						nearestBar = curve;  					}  				}  				else if (xVal >= xAxis._scale._min && xVal <= xAxis._scale._max && yVal >= yMinAct && yVal <= yMaxAct) {  					if (curve is LineItem && _lineType == LineType.Stack) {  						double zVal;  						valueHandler.GetValues (curve' iPt' out xVal' out zVal' out yVal);  					}  					distX = (xVal - xAct) * xPixPerUnit;  					distY = (yVal - yAct) * yPixPerUnitAct;  					dist = distX * distX + distY * distY;  					if (dist >= minDist)  						continue;  					minDist = dist;  					iNearest = iPt;  					nearestCurve = curve;  				}  			}  		}  		if (curve.IsBar)  			iBar++;  	}  }  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: if (curve.IsVisible) {  	int yIndex = curve.GetYAxisIndex (this);  	Axis yAxis = curve.GetYAxis (this);  	Axis xAxis = curve.GetXAxis (this);  	if (curve.IsY2Axis) {  		yAct = y2 [yIndex];  		yMinAct = _y2AxisList [yIndex]._scale._min;  		yMaxAct = _y2AxisList [yIndex]._scale._max;  	}  	else {  		yAct = y [yIndex];  		yMinAct = _yAxisList [yIndex]._scale._min;  		yMaxAct = _yAxisList [yIndex]._scale._max;  	}  	yPixPerUnitAct = _chart._rect.Height / (yMaxAct - yMinAct);  	double xPixPerUnit = _chart._rect.Width / (xAxis._scale._max - xAxis._scale._min);  	xAct = xAxis is XAxis ? x : x2;  	IPointList points = curve.Points;  	float barWidth = curve.GetBarWidth (this);  	double barWidthUserHalf;  	Axis baseAxis = curve.BaseAxis (this);  	bool isXBaseAxis = (baseAxis is XAxis || baseAxis is X2Axis);  	if (isXBaseAxis)  		barWidthUserHalf = barWidth / xPixPerUnit / 2.0;  	else  		barWidthUserHalf = barWidth / yPixPerUnitAct / 2.0;  	if (points != null) {  		for (int iPt = 0; iPt < curve.NPts; iPt++) {  			// xVal is the user scale X value of the current point  			if (xAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  				xVal = (double)iPt + 1.0;  			else  				xVal = points [iPt].X;  			// yVal is the user scale Y value of the current point  			if (yAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  				yVal = (double)iPt + 1.0;  			else  				yVal = points [iPt].Y;  			if (xVal != PointPair.Missing && yVal != PointPair.Missing) {  				if (curve.IsBar || curve is ErrorBarItem || curve is HiLowBarItem || curve is OHLCBarItem || curve is JapaneseCandleStickItem) {  					double baseVal' lowVal' hiVal;  					valueHandler.GetValues (curve' iPt' out baseVal' out lowVal' out hiVal);  					if (lowVal > hiVal) {  						double tmpVal = lowVal;  						lowVal = hiVal;  						hiVal = tmpVal;  					}  					if (isXBaseAxis) {  						double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' xVal' iBar);  						if (xAct < centerVal - barWidthUserHalf || xAct > centerVal + barWidthUserHalf || yAct < lowVal || yAct > hiVal)  							continue;  					}  					else {  						double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' yVal' iBar);  						if (yAct < centerVal - barWidthUserHalf || yAct > centerVal + barWidthUserHalf || xAct < lowVal || xAct > hiVal)  							continue;  					}  					if (nearestBar == null) {  						iNearestBar = iPt;  						nearestBar = curve;  					}  				}  				else if (xVal >= xAxis._scale._min && xVal <= xAxis._scale._max && yVal >= yMinAct && yVal <= yMaxAct) {  					if (curve is LineItem && _lineType == LineType.Stack) {  						double zVal;  						valueHandler.GetValues (curve' iPt' out xVal' out zVal' out yVal);  					}  					distX = (xVal - xAct) * xPixPerUnit;  					distY = (yVal - yAct) * yPixPerUnitAct;  					dist = distX * distX + distY * distY;  					if (dist >= minDist)  						continue;  					minDist = dist;  					iNearest = iPt;  					nearestCurve = curve;  				}  			}  		}  		if (curve.IsBar)  			iBar++;  	}  }  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: if (curve.IsVisible) {  	int yIndex = curve.GetYAxisIndex (this);  	Axis yAxis = curve.GetYAxis (this);  	Axis xAxis = curve.GetXAxis (this);  	if (curve.IsY2Axis) {  		yAct = y2 [yIndex];  		yMinAct = _y2AxisList [yIndex]._scale._min;  		yMaxAct = _y2AxisList [yIndex]._scale._max;  	}  	else {  		yAct = y [yIndex];  		yMinAct = _yAxisList [yIndex]._scale._min;  		yMaxAct = _yAxisList [yIndex]._scale._max;  	}  	yPixPerUnitAct = _chart._rect.Height / (yMaxAct - yMinAct);  	double xPixPerUnit = _chart._rect.Width / (xAxis._scale._max - xAxis._scale._min);  	xAct = xAxis is XAxis ? x : x2;  	IPointList points = curve.Points;  	float barWidth = curve.GetBarWidth (this);  	double barWidthUserHalf;  	Axis baseAxis = curve.BaseAxis (this);  	bool isXBaseAxis = (baseAxis is XAxis || baseAxis is X2Axis);  	if (isXBaseAxis)  		barWidthUserHalf = barWidth / xPixPerUnit / 2.0;  	else  		barWidthUserHalf = barWidth / yPixPerUnitAct / 2.0;  	if (points != null) {  		for (int iPt = 0; iPt < curve.NPts; iPt++) {  			// xVal is the user scale X value of the current point  			if (xAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  				xVal = (double)iPt + 1.0;  			else  				xVal = points [iPt].X;  			// yVal is the user scale Y value of the current point  			if (yAxis._scale.IsAnyOrdinal && !curve.IsOverrideOrdinal)  				yVal = (double)iPt + 1.0;  			else  				yVal = points [iPt].Y;  			if (xVal != PointPair.Missing && yVal != PointPair.Missing) {  				if (curve.IsBar || curve is ErrorBarItem || curve is HiLowBarItem || curve is OHLCBarItem || curve is JapaneseCandleStickItem) {  					double baseVal' lowVal' hiVal;  					valueHandler.GetValues (curve' iPt' out baseVal' out lowVal' out hiVal);  					if (lowVal > hiVal) {  						double tmpVal = lowVal;  						lowVal = hiVal;  						hiVal = tmpVal;  					}  					if (isXBaseAxis) {  						double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' xVal' iBar);  						if (xAct < centerVal - barWidthUserHalf || xAct > centerVal + barWidthUserHalf || yAct < lowVal || yAct > hiVal)  							continue;  					}  					else {  						double centerVal = valueHandler.BarCenterValue (curve' barWidth' iPt' yVal' iBar);  						if (yAct < centerVal - barWidthUserHalf || yAct > centerVal + barWidthUserHalf || xAct < lowVal || xAct > hiVal)  							continue;  					}  					if (nearestBar == null) {  						iNearestBar = iPt;  						nearestBar = curve;  					}  				}  				else if (xVal >= xAxis._scale._min && xVal <= xAxis._scale._max && yVal >= yMinAct && yVal <= yMaxAct) {  					if (curve is LineItem && _lineType == LineType.Stack) {  						double zVal;  						valueHandler.GetValues (curve' iPt' out xVal' out zVal' out yVal);  					}  					distX = (xVal - xAct) * xPixPerUnit;  					distY = (yVal - yAct) * yPixPerUnitAct;  					dist = distX * distX + distY * distY;  					if (dist >= minDist)  						continue;  					minDist = dist;  					iNearest = iPt;  					nearestCurve = curve;  				}  			}  		}  		if (curve.IsBar)  			iBar++;  	}  }  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: if (isXBaseAxis)  	barWidthUserHalf = barWidth / xPixPerUnit / 2.0;  else  	barWidthUserHalf = barWidth / yPixPerUnitAct / 2.0;  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: if (isXBaseAxis)  	barWidthUserHalf = barWidth / xPixPerUnit / 2.0;  else  	barWidthUserHalf = barWidth / yPixPerUnitAct / 2.0;  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: barWidthUserHalf = barWidth / xPixPerUnit / 2.0;  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: barWidthUserHalf = barWidth / yPixPerUnitAct / 2.0;  
Magic Number,ZedGraph,GraphPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\GraphPane.cs,FindNearestPoint,The following statement contains a magic number: if (nearestCurve is LineItem) {  	float halfSymbol = (float)(((LineItem)nearestCurve).Symbol.Size * CalcScaleFactor () / 2);  	minDist -= halfSymbol * halfSymbol;  	if (minDist < 0)  		minDist = 0;  }  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,HSBColor,The following statement contains a magic number: this.A = 255;  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,ToRGB,The following statement contains a magic number: switch (sector) {  case 0:  	// red - yellow  	rgbColor = Color.FromArgb (hsbColor.A' hsbColor.B' t' p);  	break;  case 1:  	// yellow - green  	rgbColor = Color.FromArgb (hsbColor.A' q' hsbColor.B' p);  	break;  case 2:  	// green - cyan  	rgbColor = Color.FromArgb (hsbColor.A' p' hsbColor.B' t);  	break;  case 3:  	// cyan - blue  	rgbColor = Color.FromArgb (hsbColor.A' p' q' hsbColor.B);  	break;  case 4:  	// blue - magenta  	rgbColor = Color.FromArgb (hsbColor.A' t' p' hsbColor.B);  	break;  case 5:  default:  	// magenta - red  	rgbColor = Color.FromArgb (hsbColor.A' hsbColor.B' p' q);  	break;  }  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,ToRGB,The following statement contains a magic number: switch (sector) {  case 0:  	// red - yellow  	rgbColor = Color.FromArgb (hsbColor.A' hsbColor.B' t' p);  	break;  case 1:  	// yellow - green  	rgbColor = Color.FromArgb (hsbColor.A' q' hsbColor.B' p);  	break;  case 2:  	// green - cyan  	rgbColor = Color.FromArgb (hsbColor.A' p' hsbColor.B' t);  	break;  case 3:  	// cyan - blue  	rgbColor = Color.FromArgb (hsbColor.A' p' q' hsbColor.B);  	break;  case 4:  	// blue - magenta  	rgbColor = Color.FromArgb (hsbColor.A' t' p' hsbColor.B);  	break;  case 5:  default:  	// magenta - red  	rgbColor = Color.FromArgb (hsbColor.A' hsbColor.B' p' q);  	break;  }  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,ToRGB,The following statement contains a magic number: switch (sector) {  case 0:  	// red - yellow  	rgbColor = Color.FromArgb (hsbColor.A' hsbColor.B' t' p);  	break;  case 1:  	// yellow - green  	rgbColor = Color.FromArgb (hsbColor.A' q' hsbColor.B' p);  	break;  case 2:  	// green - cyan  	rgbColor = Color.FromArgb (hsbColor.A' p' hsbColor.B' t);  	break;  case 3:  	// cyan - blue  	rgbColor = Color.FromArgb (hsbColor.A' p' q' hsbColor.B);  	break;  case 4:  	// blue - magenta  	rgbColor = Color.FromArgb (hsbColor.A' t' p' hsbColor.B);  	break;  case 5:  default:  	// magenta - red  	rgbColor = Color.FromArgb (hsbColor.A' hsbColor.B' p' q);  	break;  }  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,ToRGB,The following statement contains a magic number: switch (sector) {  case 0:  	// red - yellow  	rgbColor = Color.FromArgb (hsbColor.A' hsbColor.B' t' p);  	break;  case 1:  	// yellow - green  	rgbColor = Color.FromArgb (hsbColor.A' q' hsbColor.B' p);  	break;  case 2:  	// green - cyan  	rgbColor = Color.FromArgb (hsbColor.A' p' hsbColor.B' t);  	break;  case 3:  	// cyan - blue  	rgbColor = Color.FromArgb (hsbColor.A' p' q' hsbColor.B);  	break;  case 4:  	// blue - magenta  	rgbColor = Color.FromArgb (hsbColor.A' t' p' hsbColor.B);  	break;  case 5:  default:  	// magenta - red  	rgbColor = Color.FromArgb (hsbColor.A' hsbColor.B' p' q);  	break;  }  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: hsbColor.B = (byte)(max * 255.0 + 0.5);  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: hsbColor.B = (byte)(max * 255.0 + 0.5);  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: if (max != 0.0) {  	hsbColor.S = (byte)(delta / max * 255.0 + 0.5);  }  else {  	hsbColor.S = 0;  	hsbColor.H = 0;  	return hsbColor;  }  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: if (max != 0.0) {  	hsbColor.S = (byte)(delta / max * 255.0 + 0.5);  }  else {  	hsbColor.S = 0;  	hsbColor.H = 0;  	return hsbColor;  }  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: hsbColor.S = (byte)(delta / max * 255.0 + 0.5);  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: hsbColor.S = (byte)(delta / max * 255.0 + 0.5);  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: if (r == max)  	h = (g - b) / delta;  // between yellow & magenta  else if (g == max)  	h = 2 + (b - r) / delta;  // between cyan & yellow  else  	h = 4 + (r - g) / delta;  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: if (r == max)  	h = (g - b) / delta;  // between yellow & magenta  else if (g == max)  	h = 2 + (b - r) / delta;  // between cyan & yellow  else  	h = 4 + (r - g) / delta;  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: if (g == max)  	h = 2 + (b - r) / delta;  // between cyan & yellow  else  	h = 4 + (r - g) / delta;  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: if (g == max)  	h = 2 + (b - r) / delta;  // between cyan & yellow  else  	h = 4 + (r - g) / delta;  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: h = 2 + (b - r) / delta;  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: h = 4 + (r - g) / delta;  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: hsbColor.H = (byte)(h * 42.5);  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: if (hsbColor.H < 0)  	hsbColor.H += 255;  
Magic Number,ZedGraph,HSBColor,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\HSBColor.cs,FromRGB,The following statement contains a magic number: hsbColor.H += 255;  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,JapaneseCandleStick,The following statement contains a magic number: if (schema2 >= 11)  	_fallingColor = (Color)info.GetValue ("fallingColor"' typeof(Color));  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing && Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000) {  	RectangleF rect;  	if (isXBase) {  		rect = new RectangleF (pixBase - halfSize' Math.Min (pixOpen' pixClose)' halfSize * 2.0f' Math.Abs (pixOpen - pixClose));  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	}  	else {  		rect = new RectangleF (Math.Min (pixOpen' pixClose)' pixBase - halfSize' Math.Abs (pixOpen - pixClose)' halfSize * 2.0f);  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	}  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000 && Math.Abs (pixClose) < 1000000) {  		if (rect.Width == 0)  			rect.Width = 1;  		if (rect.Height == 0)  			rect.Height = 1;  		fill.Draw (g' rect' pt);  		border.Draw (g' pane' scaleFactor' rect);  	}  }  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing && Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000) {  	RectangleF rect;  	if (isXBase) {  		rect = new RectangleF (pixBase - halfSize' Math.Min (pixOpen' pixClose)' halfSize * 2.0f' Math.Abs (pixOpen - pixClose));  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	}  	else {  		rect = new RectangleF (Math.Min (pixOpen' pixClose)' pixBase - halfSize' Math.Abs (pixOpen - pixClose)' halfSize * 2.0f);  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	}  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000 && Math.Abs (pixClose) < 1000000) {  		if (rect.Width == 0)  			rect.Width = 1;  		if (rect.Height == 0)  			rect.Height = 1;  		fill.Draw (g' rect' pt);  		border.Draw (g' pane' scaleFactor' rect);  	}  }  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing && Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000) {  	RectangleF rect;  	if (isXBase) {  		rect = new RectangleF (pixBase - halfSize' Math.Min (pixOpen' pixClose)' halfSize * 2.0f' Math.Abs (pixOpen - pixClose));  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	}  	else {  		rect = new RectangleF (Math.Min (pixOpen' pixClose)' pixBase - halfSize' Math.Abs (pixOpen - pixClose)' halfSize * 2.0f);  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	}  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000 && Math.Abs (pixClose) < 1000000) {  		if (rect.Width == 0)  			rect.Width = 1;  		if (rect.Height == 0)  			rect.Height = 1;  		fill.Draw (g' rect' pt);  		border.Draw (g' pane' scaleFactor' rect);  	}  }  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: if (pixBase != PointPair.Missing && Math.Abs (pixLow) < 1000000 && Math.Abs (pixHigh) < 1000000) {  	RectangleF rect;  	if (isXBase) {  		rect = new RectangleF (pixBase - halfSize' Math.Min (pixOpen' pixClose)' halfSize * 2.0f' Math.Abs (pixOpen - pixClose));  		g.DrawLine (pen' pixBase' pixHigh' pixBase' pixLow);  	}  	else {  		rect = new RectangleF (Math.Min (pixOpen' pixClose)' pixBase - halfSize' Math.Abs (pixOpen - pixClose)' halfSize * 2.0f);  		g.DrawLine (pen' pixHigh' pixBase' pixLow' pixBase);  	}  	if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000 && Math.Abs (pixClose) < 1000000) {  		if (rect.Width == 0)  			rect.Width = 1;  		if (rect.Height == 0)  			rect.Height = 1;  		fill.Draw (g' rect' pt);  		border.Draw (g' pane' scaleFactor' rect);  	}  }  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000 && Math.Abs (pixClose) < 1000000) {  	if (rect.Width == 0)  		rect.Width = 1;  	if (rect.Height == 0)  		rect.Height = 1;  	fill.Draw (g' rect' pt);  	border.Draw (g' pane' scaleFactor' rect);  }  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: if (_isOpenCloseVisible && Math.Abs (pixOpen) < 1000000 && Math.Abs (pixClose) < 1000000) {  	if (rect.Width == 0)  		rect.Width = 1;  	if (rect.Height == 0)  		rect.Height = 1;  	fill.Draw (g' rect' pt);  	border.Draw (g' pane' scaleFactor' rect);  }  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: if (curve.Points != null) {  	//float halfSize = _size * scaleFactor;  	float halfSize = GetBarWidth (pane' baseAxis' scaleFactor);  	Color tColor = _color;  	Color tFallingColor = _fallingColor;  	float tPenWidth = _width;  	Fill tRisingFill = _risingFill;  	Fill tFallingFill = _fallingFill;  	Border tRisingBorder = _risingBorder;  	Border tFallingBorder = _fallingBorder;  	if (curve.IsSelected) {  		tColor = Selection.Border.Color;  		tFallingColor = Selection.Border.Color;  		tPenWidth = Selection.Border.Width;  		tRisingFill = Selection.Fill;  		tFallingFill = Selection.Fill;  		tRisingBorder = Selection.Border;  		tFallingBorder = Selection.Border;  	}  	using (Pen risingPen = new Pen (tColor' tPenWidth))  		using (Pen fallingPen = new Pen (tFallingColor' tPenWidth)) {  			// Loop over each defined point							  			for (int i = 0; i < curve.Points.Count; i++) {  				PointPair pt = curve.Points [i];  				double date = pt.X;  				double high = pt.Y;  				double low = pt.Z;  				double open = PointPair.Missing;  				double close = PointPair.Missing;  				if (pt is StockPt) {  					open = (pt as StockPt).Open;  					close = (pt as StockPt).Close;  				}  				// Any value set to double max is invalid and should be skipped  				// This is used for calculated values that are out of range' divide  				//   by zero' etc.  				// Also' any value <= zero on a log scale is invalid  				if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  					pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  					//pixBase = baseAxis.Scale.Transform( curve.IsOverrideOrdinal' i' date );  					pixHigh = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' high);  					pixLow = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' low);  					if (PointPair.IsValueInvalid (open))  						pixOpen = Single.MaxValue;  					else  						pixOpen = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' open);  					if (PointPair.IsValueInvalid (close))  						pixClose = Single.MaxValue;  					else  						pixClose = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' close);  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' pt))  							Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (tPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt);  					}  					else  						Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (close > open ? risingPen : fallingPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt);  				}  			}  		}  }  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: using (Pen risingPen = new Pen (tColor' tPenWidth))  	using (Pen fallingPen = new Pen (tFallingColor' tPenWidth)) {  		// Loop over each defined point							  		for (int i = 0; i < curve.Points.Count; i++) {  			PointPair pt = curve.Points [i];  			double date = pt.X;  			double high = pt.Y;  			double low = pt.Z;  			double open = PointPair.Missing;  			double close = PointPair.Missing;  			if (pt is StockPt) {  				open = (pt as StockPt).Open;  				close = (pt as StockPt).Close;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  				pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  				//pixBase = baseAxis.Scale.Transform( curve.IsOverrideOrdinal' i' date );  				pixHigh = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' high);  				pixLow = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' low);  				if (PointPair.IsValueInvalid (open))  					pixOpen = Single.MaxValue;  				else  					pixOpen = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' open);  				if (PointPair.IsValueInvalid (close))  					pixClose = Single.MaxValue;  				else  					pixClose = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' close);  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' pt))  						Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (tPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt);  				}  				else  					Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (close > open ? risingPen : fallingPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt);  			}  		}  	}  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: using (Pen fallingPen = new Pen (tFallingColor' tPenWidth)) {  	// Loop over each defined point							  	for (int i = 0; i < curve.Points.Count; i++) {  		PointPair pt = curve.Points [i];  		double date = pt.X;  		double high = pt.Y;  		double low = pt.Z;  		double open = PointPair.Missing;  		double close = PointPair.Missing;  		if (pt is StockPt) {  			open = (pt as StockPt).Open;  			close = (pt as StockPt).Close;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  			pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  			//pixBase = baseAxis.Scale.Transform( curve.IsOverrideOrdinal' i' date );  			pixHigh = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' high);  			pixLow = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' low);  			if (PointPair.IsValueInvalid (open))  				pixOpen = Single.MaxValue;  			else  				pixOpen = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' open);  			if (PointPair.IsValueInvalid (close))  				pixClose = Single.MaxValue;  			else  				pixClose = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' close);  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' pt))  					Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (tPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt);  			}  			else  				Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (close > open ? risingPen : fallingPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt);  		}  	}  }  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: for (int i = 0; i < curve.Points.Count; i++) {  	PointPair pt = curve.Points [i];  	double date = pt.X;  	double high = pt.Y;  	double low = pt.Z;  	double open = PointPair.Missing;  	double close = PointPair.Missing;  	if (pt is StockPt) {  		open = (pt as StockPt).Open;  		close = (pt as StockPt).Close;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  		pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  		//pixBase = baseAxis.Scale.Transform( curve.IsOverrideOrdinal' i' date );  		pixHigh = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' high);  		pixLow = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' low);  		if (PointPair.IsValueInvalid (open))  			pixOpen = Single.MaxValue;  		else  			pixOpen = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' open);  		if (PointPair.IsValueInvalid (close))  			pixClose = Single.MaxValue;  		else  			pixClose = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' close);  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' pt))  				Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (tPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt);  		}  		else  			Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (close > open ? risingPen : fallingPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt);  	}  }  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: if (!curve.Points [i].IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  	pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  	//pixBase = baseAxis.Scale.Transform( curve.IsOverrideOrdinal' i' date );  	pixHigh = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' high);  	pixLow = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' low);  	if (PointPair.IsValueInvalid (open))  		pixOpen = Single.MaxValue;  	else  		pixOpen = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' open);  	if (PointPair.IsValueInvalid (close))  		pixClose = Single.MaxValue;  	else  		pixClose = valueAxis.Scale.Transform (curve.IsOverrideOrdinal' i' close);  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' pt))  			Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (tPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt);  	}  	else  		Draw (g' pane' baseAxis is XAxis || baseAxis is X2Axis' pixBase' pixHigh' pixLow' pixOpen' pixClose' halfSize' scaleFactor' (close > open ? risingPen : fallingPen)' (close > open ? tRisingFill : tFallingFill)' (close > open ? tRisingBorder : tFallingBorder)' pt);  }  
Magic Number,ZedGraph,JapaneseCandleStick,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStick.cs,Draw,The following statement contains a magic number: pixBase = (int)(baseAxis.Scale.Transform (curve.IsOverrideOrdinal' i' date) + 0.5);  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,DrawLegendKey,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X) {  	pixBase = rect.Left + rect.Width / 2.0F;  	pixHigh = rect.Top;  	pixLow = rect.Bottom;  	pixOpen = pixHigh + rect.Height / 3;  	pixClose = pixLow - rect.Height / 3;  }  else {  	pixBase = rect.Top + rect.Height / 2.0F;  	pixHigh = rect.Right;  	pixLow = rect.Left;  	pixOpen = pixHigh - rect.Width / 3;  	pixClose = pixLow + rect.Width / 3;  }  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,DrawLegendKey,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X) {  	pixBase = rect.Left + rect.Width / 2.0F;  	pixHigh = rect.Top;  	pixLow = rect.Bottom;  	pixOpen = pixHigh + rect.Height / 3;  	pixClose = pixLow - rect.Height / 3;  }  else {  	pixBase = rect.Top + rect.Height / 2.0F;  	pixHigh = rect.Right;  	pixLow = rect.Left;  	pixOpen = pixHigh - rect.Width / 3;  	pixClose = pixLow + rect.Width / 3;  }  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,DrawLegendKey,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X) {  	pixBase = rect.Left + rect.Width / 2.0F;  	pixHigh = rect.Top;  	pixLow = rect.Bottom;  	pixOpen = pixHigh + rect.Height / 3;  	pixClose = pixLow - rect.Height / 3;  }  else {  	pixBase = rect.Top + rect.Height / 2.0F;  	pixHigh = rect.Right;  	pixLow = rect.Left;  	pixOpen = pixHigh - rect.Width / 3;  	pixClose = pixLow + rect.Width / 3;  }  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,DrawLegendKey,The following statement contains a magic number: if (pane._barSettings.Base == BarBase.X) {  	pixBase = rect.Left + rect.Width / 2.0F;  	pixHigh = rect.Top;  	pixLow = rect.Bottom;  	pixOpen = pixHigh + rect.Height / 3;  	pixClose = pixLow - rect.Height / 3;  }  else {  	pixBase = rect.Top + rect.Height / 2.0F;  	pixHigh = rect.Right;  	pixLow = rect.Left;  	pixOpen = pixHigh - rect.Width / 3;  	pixClose = pixLow + rect.Width / 3;  }  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,DrawLegendKey,The following statement contains a magic number: pixOpen = pixHigh + rect.Height / 3;  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,DrawLegendKey,The following statement contains a magic number: pixClose = pixLow - rect.Height / 3;  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,DrawLegendKey,The following statement contains a magic number: pixOpen = pixHigh - rect.Width / 3;  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,DrawLegendKey,The following statement contains a magic number: pixClose = pixLow + rect.Width / 3;  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,GetCoords,The following statement contains a magic number: if (!pt.IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  	float pixBase' pixHigh' pixLow;  	pixBase = baseAxis.Scale.Transform (_isOverrideOrdinal' i' date);  	pixHigh = valueAxis.Scale.Transform (_isOverrideOrdinal' i' high);  	pixLow = valueAxis.Scale.Transform (_isOverrideOrdinal' i' low);  	// Calculate the pixel location for the side of the bar (on the base axis)  	float pixSide = pixBase - halfSize;  	// Draw the bar  	if (baseAxis is XAxis || baseAxis is X2Axis)  		coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixSide' pixLow' pixSide + halfSize * 2' pixHigh);  	else  		coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixLow' pixSide' pixHigh' pixSide + halfSize * 2);  	return true;  }  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,GetCoords,The following statement contains a magic number: if (!pt.IsInvalid3D && (date > 0 || !baseAxis._scale.IsLog) && ((high > 0 && low > 0) || !valueAxis._scale.IsLog)) {  	float pixBase' pixHigh' pixLow;  	pixBase = baseAxis.Scale.Transform (_isOverrideOrdinal' i' date);  	pixHigh = valueAxis.Scale.Transform (_isOverrideOrdinal' i' high);  	pixLow = valueAxis.Scale.Transform (_isOverrideOrdinal' i' low);  	// Calculate the pixel location for the side of the bar (on the base axis)  	float pixSide = pixBase - halfSize;  	// Draw the bar  	if (baseAxis is XAxis || baseAxis is X2Axis)  		coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixSide' pixLow' pixSide + halfSize * 2' pixHigh);  	else  		coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixLow' pixSide' pixHigh' pixSide + halfSize * 2);  	return true;  }  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,GetCoords,The following statement contains a magic number: if (baseAxis is XAxis || baseAxis is X2Axis)  	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixSide' pixLow' pixSide + halfSize * 2' pixHigh);  else  	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixLow' pixSide' pixHigh' pixSide + halfSize * 2);  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,GetCoords,The following statement contains a magic number: if (baseAxis is XAxis || baseAxis is X2Axis)  	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixSide' pixLow' pixSide + halfSize * 2' pixHigh);  else  	coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixLow' pixSide' pixHigh' pixSide + halfSize * 2);  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixSide' pixLow' pixSide + halfSize * 2' pixHigh);  
Magic Number,ZedGraph,JapaneseCandleStickItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\JapaneseCandleStickItem.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}"' pixLow' pixSide' pixHigh' pixSide + halfSize * 2);  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Legend,The following statement contains a magic number: if (schema >= 11)  	_isReverse = info.GetBoolean ("isReverse");  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Legend,The following statement contains a magic number: if (schema >= 12)  	_isShowLegendSymbols = info.GetBoolean ("isShowLegendSymbols");  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Draw,The following statement contains a magic number: if (_legendItemWidth <= 0)  	_legendItemWidth = 100;  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Draw,The following statement contains a magic number: _legendItemWidth = 100;  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Draw,The following statement contains a magic number: using (SolidBrush brushB = new SolidBrush (Color.Black)) {  	foreach (GraphPane tmpPane in paneList) {  		// Loop for each curve in the CurveList collection  		//foreach ( CurveItem curve in tmpPane.CurveList )  		int count = tmpPane.CurveList.Count;  		for (int i = 0; i < count; i++) {  			CurveItem curve = tmpPane.CurveList [_isReverse ? count - i - 1 : i];  			if (curve._label._text != "" && curve._label._isVisible) {  				// Calculate the x'y (TopLeft) location of the current  				// curve legend label  				// assuming:  				//  charHeight/2 for the left margin' plus legendWidth for each  				//    horizontal column  				//  legendHeight is the line spacing' with no extra margin above  				x = _rect.Left + halfGap / 2.0F + (iEntry % _hStack) * _legendItemWidth;  				y = _rect.Top + (int)(iEntry / _hStack) * _legendItemHeight;  				// Draw the legend label for the current curve  				FontSpec tmpFont = (curve._label._fontSpec != null) ? curve._label._fontSpec : this.FontSpec;  				// This is required because' for long labels' the centering can affect the  				// position in GDI+.  				tmpFont.StringAlignment = StringAlignment.Near;  				if (_isShowLegendSymbols) {  					tmpFont.Draw (g' pane' curve._label._text' x + 2.5F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor);  					RectangleF rect = new RectangleF (x' y + _legendItemHeight / 4.0F' 2 * _tmpSize' _legendItemHeight / 2.0F);  					curve.DrawLegendKey (g' tmpPane' rect' scaleFactor);  				}  				else {  					if (curve._label._fontSpec == null)  						tmpFont.FontColor = curve.Color;  					tmpFont.Draw (g' pane' curve._label._text' x + 0.0F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor);  				}  				// maintain a curve count for positioning  				iEntry++;  			}  		}  		if (pane is MasterPane && ((MasterPane)pane).IsUniformLegendEntries)  			break;  	}  	// Draw a border around the legend if required  	if (iEntry > 0)  		this.Border.Draw (g' pane' scaleFactor' _rect);  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Draw,The following statement contains a magic number: foreach (GraphPane tmpPane in paneList) {  	// Loop for each curve in the CurveList collection  	//foreach ( CurveItem curve in tmpPane.CurveList )  	int count = tmpPane.CurveList.Count;  	for (int i = 0; i < count; i++) {  		CurveItem curve = tmpPane.CurveList [_isReverse ? count - i - 1 : i];  		if (curve._label._text != "" && curve._label._isVisible) {  			// Calculate the x'y (TopLeft) location of the current  			// curve legend label  			// assuming:  			//  charHeight/2 for the left margin' plus legendWidth for each  			//    horizontal column  			//  legendHeight is the line spacing' with no extra margin above  			x = _rect.Left + halfGap / 2.0F + (iEntry % _hStack) * _legendItemWidth;  			y = _rect.Top + (int)(iEntry / _hStack) * _legendItemHeight;  			// Draw the legend label for the current curve  			FontSpec tmpFont = (curve._label._fontSpec != null) ? curve._label._fontSpec : this.FontSpec;  			// This is required because' for long labels' the centering can affect the  			// position in GDI+.  			tmpFont.StringAlignment = StringAlignment.Near;  			if (_isShowLegendSymbols) {  				tmpFont.Draw (g' pane' curve._label._text' x + 2.5F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor);  				RectangleF rect = new RectangleF (x' y + _legendItemHeight / 4.0F' 2 * _tmpSize' _legendItemHeight / 2.0F);  				curve.DrawLegendKey (g' tmpPane' rect' scaleFactor);  			}  			else {  				if (curve._label._fontSpec == null)  					tmpFont.FontColor = curve.Color;  				tmpFont.Draw (g' pane' curve._label._text' x + 0.0F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor);  			}  			// maintain a curve count for positioning  			iEntry++;  		}  	}  	if (pane is MasterPane && ((MasterPane)pane).IsUniformLegendEntries)  		break;  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Draw,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	CurveItem curve = tmpPane.CurveList [_isReverse ? count - i - 1 : i];  	if (curve._label._text != "" && curve._label._isVisible) {  		// Calculate the x'y (TopLeft) location of the current  		// curve legend label  		// assuming:  		//  charHeight/2 for the left margin' plus legendWidth for each  		//    horizontal column  		//  legendHeight is the line spacing' with no extra margin above  		x = _rect.Left + halfGap / 2.0F + (iEntry % _hStack) * _legendItemWidth;  		y = _rect.Top + (int)(iEntry / _hStack) * _legendItemHeight;  		// Draw the legend label for the current curve  		FontSpec tmpFont = (curve._label._fontSpec != null) ? curve._label._fontSpec : this.FontSpec;  		// This is required because' for long labels' the centering can affect the  		// position in GDI+.  		tmpFont.StringAlignment = StringAlignment.Near;  		if (_isShowLegendSymbols) {  			tmpFont.Draw (g' pane' curve._label._text' x + 2.5F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor);  			RectangleF rect = new RectangleF (x' y + _legendItemHeight / 4.0F' 2 * _tmpSize' _legendItemHeight / 2.0F);  			curve.DrawLegendKey (g' tmpPane' rect' scaleFactor);  		}  		else {  			if (curve._label._fontSpec == null)  				tmpFont.FontColor = curve.Color;  			tmpFont.Draw (g' pane' curve._label._text' x + 0.0F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor);  		}  		// maintain a curve count for positioning  		iEntry++;  	}  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Draw,The following statement contains a magic number: if (curve._label._text != "" && curve._label._isVisible) {  	// Calculate the x'y (TopLeft) location of the current  	// curve legend label  	// assuming:  	//  charHeight/2 for the left margin' plus legendWidth for each  	//    horizontal column  	//  legendHeight is the line spacing' with no extra margin above  	x = _rect.Left + halfGap / 2.0F + (iEntry % _hStack) * _legendItemWidth;  	y = _rect.Top + (int)(iEntry / _hStack) * _legendItemHeight;  	// Draw the legend label for the current curve  	FontSpec tmpFont = (curve._label._fontSpec != null) ? curve._label._fontSpec : this.FontSpec;  	// This is required because' for long labels' the centering can affect the  	// position in GDI+.  	tmpFont.StringAlignment = StringAlignment.Near;  	if (_isShowLegendSymbols) {  		tmpFont.Draw (g' pane' curve._label._text' x + 2.5F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor);  		RectangleF rect = new RectangleF (x' y + _legendItemHeight / 4.0F' 2 * _tmpSize' _legendItemHeight / 2.0F);  		curve.DrawLegendKey (g' tmpPane' rect' scaleFactor);  	}  	else {  		if (curve._label._fontSpec == null)  			tmpFont.FontColor = curve.Color;  		tmpFont.Draw (g' pane' curve._label._text' x + 0.0F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor);  	}  	// maintain a curve count for positioning  	iEntry++;  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,Draw,The following statement contains a magic number: if (_isShowLegendSymbols) {  	tmpFont.Draw (g' pane' curve._label._text' x + 2.5F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor);  	RectangleF rect = new RectangleF (x' y + _legendItemHeight / 4.0F' 2 * _tmpSize' _legendItemHeight / 2.0F);  	curve.DrawLegendKey (g' tmpPane' rect' scaleFactor);  }  else {  	if (curve._label._fontSpec == null)  		tmpFont.FontColor = curve.Color;  	tmpFont.Draw (g' pane' curve._label._text' x + 0.0F * _tmpSize' y + _legendItemHeight / 2.0F' AlignH.Left' AlignV.Center' scaleFactor);  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The following statement contains a magic number: if (_isHStack) {  	// Determine the available space for horizontal stacking  	switch (_position) {  	// Never stack if the legend is to the right or left  	case LegendPos.Right:  	case LegendPos.Left:  		widthAvail = 0;  		break;  	// for the top & bottom' the axis border width is available  	case LegendPos.Top:  	case LegendPos.TopCenter:  	case LegendPos.Bottom:  	case LegendPos.BottomCenter:  		widthAvail = tChartRect.Width;  		break;  	// for the top & bottom flush left' the panerect less margins is available  	case LegendPos.TopFlushLeft:  	case LegendPos.BottomFlushLeft:  		widthAvail = clientRect.Width;  		break;  	// for inside the axis area or Float' use 1/2 of the axis border width  	case LegendPos.InsideTopRight:  	case LegendPos.InsideTopLeft:  	case LegendPos.InsideBotRight:  	case LegendPos.InsideBotLeft:  	case LegendPos.Float:  		widthAvail = tChartRect.Width / 2;  		break;  	// shouldn't ever happen  	default:  		widthAvail = 0;  		break;  	}  	// width of one legend entry  	if (_isShowLegendSymbols)  		_legendItemWidth = 3.0f * _tmpSize + maxWidth;  	else  		_legendItemWidth = 0.5f * _tmpSize + maxWidth;  	// Calculate the number of columns in the legend  	// Normally' the legend is:  	//     available width / ( max width of any entry + space for line&symbol )  	if (maxWidth > 0)  		_hStack = (int)((widthAvail - halfGap) / _legendItemWidth);  	// You can never have more columns than legend entries  	if (_hStack > nCurve)  		_hStack = nCurve;  	// a saftey check  	if (_hStack == 0)  		_hStack = 1;  }  else {  	if (_isShowLegendSymbols)  		_legendItemWidth = 3.0F * _tmpSize + maxWidth;  	else  		_legendItemWidth = 0.5F * _tmpSize + maxWidth;  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The following statement contains a magic number: switch (_position) {  // Never stack if the legend is to the right or left  case LegendPos.Right:  case LegendPos.Left:  	widthAvail = 0;  	break;  // for the top & bottom' the axis border width is available  case LegendPos.Top:  case LegendPos.TopCenter:  case LegendPos.Bottom:  case LegendPos.BottomCenter:  	widthAvail = tChartRect.Width;  	break;  // for the top & bottom flush left' the panerect less margins is available  case LegendPos.TopFlushLeft:  case LegendPos.BottomFlushLeft:  	widthAvail = clientRect.Width;  	break;  // for inside the axis area or Float' use 1/2 of the axis border width  case LegendPos.InsideTopRight:  case LegendPos.InsideTopLeft:  case LegendPos.InsideBotRight:  case LegendPos.InsideBotLeft:  case LegendPos.Float:  	widthAvail = tChartRect.Width / 2;  	break;  // shouldn't ever happen  default:  	widthAvail = 0;  	break;  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The following statement contains a magic number: widthAvail = tChartRect.Width / 2;  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The following statement contains a magic number: if (nCurve > 0) {  	newRect = new RectangleF (0' 0' totLegWidth' totLegHeight);  	// The switch statement assigns the left and top edges' and adjusts the ChartRect  	// as required.  The right and bottom edges are calculated at the bottom of the switch.  	switch (_position) {  	case LegendPos.Right:  		newRect.X = clientRect.Right - totLegWidth;  		newRect.Y = tChartRect.Top;  		tChartRect.Width -= totLegWidth + gapPix;  		break;  	case LegendPos.Top:  		newRect.X = tChartRect.Left;  		newRect.Y = clientRect.Top;  		tChartRect.Y += totLegHeight + gapPix;  		tChartRect.Height -= totLegHeight + gapPix;  		break;  	case LegendPos.TopFlushLeft:  		newRect.X = clientRect.Left;  		newRect.Y = clientRect.Top;  		tChartRect.Y += totLegHeight + gapPix * 1.5f;  		tChartRect.Height -= totLegHeight + gapPix * 1.5f;  		break;  	case LegendPos.TopCenter:  		newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  		newRect.Y = tChartRect.Top;  		tChartRect.Y += totLegHeight + gapPix;  		tChartRect.Height -= totLegHeight + gapPix;  		break;  	case LegendPos.Bottom:  		newRect.X = tChartRect.Left;  		newRect.Y = clientRect.Bottom - totLegHeight;  		tChartRect.Height -= totLegHeight + gapPix;  		break;  	case LegendPos.BottomFlushLeft:  		newRect.X = clientRect.Left;  		newRect.Y = clientRect.Bottom - totLegHeight;  		tChartRect.Height -= totLegHeight + gapPix;  		break;  	case LegendPos.BottomCenter:  		newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  		newRect.Y = clientRect.Bottom - totLegHeight;  		tChartRect.Height -= totLegHeight + gapPix;  		break;  	case LegendPos.Left:  		newRect.X = clientRect.Left;  		newRect.Y = tChartRect.Top;  		tChartRect.X += totLegWidth + halfGap;  		tChartRect.Width -= totLegWidth + gapPix;  		break;  	case LegendPos.InsideTopRight:  		newRect.X = tChartRect.Right - totLegWidth;  		newRect.Y = tChartRect.Top;  		break;  	case LegendPos.InsideTopLeft:  		newRect.X = tChartRect.Left;  		newRect.Y = tChartRect.Top;  		break;  	case LegendPos.InsideBotRight:  		newRect.X = tChartRect.Right - totLegWidth;  		newRect.Y = tChartRect.Bottom - totLegHeight;  		break;  	case LegendPos.InsideBotLeft:  		newRect.X = tChartRect.Left;  		newRect.Y = tChartRect.Bottom - totLegHeight;  		break;  	case LegendPos.Float:  		newRect.Location = this.Location.TransformTopLeft (pane' totLegWidth' totLegHeight);  		break;  	}  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The following statement contains a magic number: if (nCurve > 0) {  	newRect = new RectangleF (0' 0' totLegWidth' totLegHeight);  	// The switch statement assigns the left and top edges' and adjusts the ChartRect  	// as required.  The right and bottom edges are calculated at the bottom of the switch.  	switch (_position) {  	case LegendPos.Right:  		newRect.X = clientRect.Right - totLegWidth;  		newRect.Y = tChartRect.Top;  		tChartRect.Width -= totLegWidth + gapPix;  		break;  	case LegendPos.Top:  		newRect.X = tChartRect.Left;  		newRect.Y = clientRect.Top;  		tChartRect.Y += totLegHeight + gapPix;  		tChartRect.Height -= totLegHeight + gapPix;  		break;  	case LegendPos.TopFlushLeft:  		newRect.X = clientRect.Left;  		newRect.Y = clientRect.Top;  		tChartRect.Y += totLegHeight + gapPix * 1.5f;  		tChartRect.Height -= totLegHeight + gapPix * 1.5f;  		break;  	case LegendPos.TopCenter:  		newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  		newRect.Y = tChartRect.Top;  		tChartRect.Y += totLegHeight + gapPix;  		tChartRect.Height -= totLegHeight + gapPix;  		break;  	case LegendPos.Bottom:  		newRect.X = tChartRect.Left;  		newRect.Y = clientRect.Bottom - totLegHeight;  		tChartRect.Height -= totLegHeight + gapPix;  		break;  	case LegendPos.BottomFlushLeft:  		newRect.X = clientRect.Left;  		newRect.Y = clientRect.Bottom - totLegHeight;  		tChartRect.Height -= totLegHeight + gapPix;  		break;  	case LegendPos.BottomCenter:  		newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  		newRect.Y = clientRect.Bottom - totLegHeight;  		tChartRect.Height -= totLegHeight + gapPix;  		break;  	case LegendPos.Left:  		newRect.X = clientRect.Left;  		newRect.Y = tChartRect.Top;  		tChartRect.X += totLegWidth + halfGap;  		tChartRect.Width -= totLegWidth + gapPix;  		break;  	case LegendPos.InsideTopRight:  		newRect.X = tChartRect.Right - totLegWidth;  		newRect.Y = tChartRect.Top;  		break;  	case LegendPos.InsideTopLeft:  		newRect.X = tChartRect.Left;  		newRect.Y = tChartRect.Top;  		break;  	case LegendPos.InsideBotRight:  		newRect.X = tChartRect.Right - totLegWidth;  		newRect.Y = tChartRect.Bottom - totLegHeight;  		break;  	case LegendPos.InsideBotLeft:  		newRect.X = tChartRect.Left;  		newRect.Y = tChartRect.Bottom - totLegHeight;  		break;  	case LegendPos.Float:  		newRect.Location = this.Location.TransformTopLeft (pane' totLegWidth' totLegHeight);  		break;  	}  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The following statement contains a magic number: switch (_position) {  case LegendPos.Right:  	newRect.X = clientRect.Right - totLegWidth;  	newRect.Y = tChartRect.Top;  	tChartRect.Width -= totLegWidth + gapPix;  	break;  case LegendPos.Top:  	newRect.X = tChartRect.Left;  	newRect.Y = clientRect.Top;  	tChartRect.Y += totLegHeight + gapPix;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.TopFlushLeft:  	newRect.X = clientRect.Left;  	newRect.Y = clientRect.Top;  	tChartRect.Y += totLegHeight + gapPix * 1.5f;  	tChartRect.Height -= totLegHeight + gapPix * 1.5f;  	break;  case LegendPos.TopCenter:  	newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  	newRect.Y = tChartRect.Top;  	tChartRect.Y += totLegHeight + gapPix;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.Bottom:  	newRect.X = tChartRect.Left;  	newRect.Y = clientRect.Bottom - totLegHeight;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.BottomFlushLeft:  	newRect.X = clientRect.Left;  	newRect.Y = clientRect.Bottom - totLegHeight;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.BottomCenter:  	newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  	newRect.Y = clientRect.Bottom - totLegHeight;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.Left:  	newRect.X = clientRect.Left;  	newRect.Y = tChartRect.Top;  	tChartRect.X += totLegWidth + halfGap;  	tChartRect.Width -= totLegWidth + gapPix;  	break;  case LegendPos.InsideTopRight:  	newRect.X = tChartRect.Right - totLegWidth;  	newRect.Y = tChartRect.Top;  	break;  case LegendPos.InsideTopLeft:  	newRect.X = tChartRect.Left;  	newRect.Y = tChartRect.Top;  	break;  case LegendPos.InsideBotRight:  	newRect.X = tChartRect.Right - totLegWidth;  	newRect.Y = tChartRect.Bottom - totLegHeight;  	break;  case LegendPos.InsideBotLeft:  	newRect.X = tChartRect.Left;  	newRect.Y = tChartRect.Bottom - totLegHeight;  	break;  case LegendPos.Float:  	newRect.Location = this.Location.TransformTopLeft (pane' totLegWidth' totLegHeight);  	break;  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The following statement contains a magic number: switch (_position) {  case LegendPos.Right:  	newRect.X = clientRect.Right - totLegWidth;  	newRect.Y = tChartRect.Top;  	tChartRect.Width -= totLegWidth + gapPix;  	break;  case LegendPos.Top:  	newRect.X = tChartRect.Left;  	newRect.Y = clientRect.Top;  	tChartRect.Y += totLegHeight + gapPix;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.TopFlushLeft:  	newRect.X = clientRect.Left;  	newRect.Y = clientRect.Top;  	tChartRect.Y += totLegHeight + gapPix * 1.5f;  	tChartRect.Height -= totLegHeight + gapPix * 1.5f;  	break;  case LegendPos.TopCenter:  	newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  	newRect.Y = tChartRect.Top;  	tChartRect.Y += totLegHeight + gapPix;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.Bottom:  	newRect.X = tChartRect.Left;  	newRect.Y = clientRect.Bottom - totLegHeight;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.BottomFlushLeft:  	newRect.X = clientRect.Left;  	newRect.Y = clientRect.Bottom - totLegHeight;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.BottomCenter:  	newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  	newRect.Y = clientRect.Bottom - totLegHeight;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.Left:  	newRect.X = clientRect.Left;  	newRect.Y = tChartRect.Top;  	tChartRect.X += totLegWidth + halfGap;  	tChartRect.Width -= totLegWidth + gapPix;  	break;  case LegendPos.InsideTopRight:  	newRect.X = tChartRect.Right - totLegWidth;  	newRect.Y = tChartRect.Top;  	break;  case LegendPos.InsideTopLeft:  	newRect.X = tChartRect.Left;  	newRect.Y = tChartRect.Top;  	break;  case LegendPos.InsideBotRight:  	newRect.X = tChartRect.Right - totLegWidth;  	newRect.Y = tChartRect.Bottom - totLegHeight;  	break;  case LegendPos.InsideBotLeft:  	newRect.X = tChartRect.Left;  	newRect.Y = tChartRect.Bottom - totLegHeight;  	break;  case LegendPos.Float:  	newRect.Location = this.Location.TransformTopLeft (pane' totLegWidth' totLegHeight);  	break;  }  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The following statement contains a magic number: newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  
Magic Number,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The following statement contains a magic number: newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,Line,The following statement contains a magic number: if (sch >= 13)  	_isOptimizedDraw = info.GetBoolean ("isOptimizedDraw");  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The following statement contains a magic number: if (this.IsVisible && !this.Color.IsEmpty && points != null && BuildPointsArray (pane' curve' out arrPoints' out count) && count > 2) {  	float tension = _isSmooth ? _smoothTension : 0f;  	// Fill the curve if needed  	if (this.Fill.IsVisible) {  		Axis yAxis = curve.GetYAxis (pane);  		using (GraphicsPath path = new GraphicsPath (FillMode.Winding)) {  			path.AddCurve (arrPoints' 0' count - 2' tension);  			double yMin = yAxis._scale._min < 0 ? 0.0 : yAxis._scale._min;  			CloseCurve (pane' curve' arrPoints' count' yMin' path);  			RectangleF rect = path.GetBounds ();  			using (Brush brush = source._fill.MakeBrush (rect)) {  				if (pane.LineType == LineType.Stack && yAxis.Scale._min < 0 && this.IsFirstLine (pane' curve)) {  					float zeroPix = yAxis.Scale.Transform (0);  					RectangleF tRect = pane.Chart._rect;  					tRect.Height = zeroPix - tRect.Top;  					if (tRect.Height > 0) {  						Region reg = g.Clip;  						g.SetClip (tRect);  						g.FillPath (brush' path);  						g.SetClip (pane.Chart._rect);  					}  				}  				else  					g.FillPath (brush' path);  				//brush.Dispose();  			}  			// restore the zero line if needed (since the fill tends to cover it up)  			yAxis.FixZeroLine (g' pane' scaleFactor' rect.Left' rect.Right);  		}  	}  	// If it's a smooth curve' go ahead and render the path.  Otherwise' use the  	// standard drawcurve method just in case there are missing values.  	if (_isSmooth) {  		using (Pen pen = GetPen (pane' scaleFactor)) {  			// Stroke the curve  			g.DrawCurve (pen' arrPoints' 0' count - 2' tension);  			//pen.Dispose();  		}  	}  	else  		DrawCurve (g' pane' curve' scaleFactor);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The following statement contains a magic number: if (this.IsVisible && !this.Color.IsEmpty && points != null && BuildPointsArray (pane' curve' out arrPoints' out count) && count > 2) {  	float tension = _isSmooth ? _smoothTension : 0f;  	// Fill the curve if needed  	if (this.Fill.IsVisible) {  		Axis yAxis = curve.GetYAxis (pane);  		using (GraphicsPath path = new GraphicsPath (FillMode.Winding)) {  			path.AddCurve (arrPoints' 0' count - 2' tension);  			double yMin = yAxis._scale._min < 0 ? 0.0 : yAxis._scale._min;  			CloseCurve (pane' curve' arrPoints' count' yMin' path);  			RectangleF rect = path.GetBounds ();  			using (Brush brush = source._fill.MakeBrush (rect)) {  				if (pane.LineType == LineType.Stack && yAxis.Scale._min < 0 && this.IsFirstLine (pane' curve)) {  					float zeroPix = yAxis.Scale.Transform (0);  					RectangleF tRect = pane.Chart._rect;  					tRect.Height = zeroPix - tRect.Top;  					if (tRect.Height > 0) {  						Region reg = g.Clip;  						g.SetClip (tRect);  						g.FillPath (brush' path);  						g.SetClip (pane.Chart._rect);  					}  				}  				else  					g.FillPath (brush' path);  				//brush.Dispose();  			}  			// restore the zero line if needed (since the fill tends to cover it up)  			yAxis.FixZeroLine (g' pane' scaleFactor' rect.Left' rect.Right);  		}  	}  	// If it's a smooth curve' go ahead and render the path.  Otherwise' use the  	// standard drawcurve method just in case there are missing values.  	if (_isSmooth) {  		using (Pen pen = GetPen (pane' scaleFactor)) {  			// Stroke the curve  			g.DrawCurve (pen' arrPoints' 0' count - 2' tension);  			//pen.Dispose();  		}  	}  	else  		DrawCurve (g' pane' curve' scaleFactor);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The following statement contains a magic number: if (this.IsVisible && !this.Color.IsEmpty && points != null && BuildPointsArray (pane' curve' out arrPoints' out count) && count > 2) {  	float tension = _isSmooth ? _smoothTension : 0f;  	// Fill the curve if needed  	if (this.Fill.IsVisible) {  		Axis yAxis = curve.GetYAxis (pane);  		using (GraphicsPath path = new GraphicsPath (FillMode.Winding)) {  			path.AddCurve (arrPoints' 0' count - 2' tension);  			double yMin = yAxis._scale._min < 0 ? 0.0 : yAxis._scale._min;  			CloseCurve (pane' curve' arrPoints' count' yMin' path);  			RectangleF rect = path.GetBounds ();  			using (Brush brush = source._fill.MakeBrush (rect)) {  				if (pane.LineType == LineType.Stack && yAxis.Scale._min < 0 && this.IsFirstLine (pane' curve)) {  					float zeroPix = yAxis.Scale.Transform (0);  					RectangleF tRect = pane.Chart._rect;  					tRect.Height = zeroPix - tRect.Top;  					if (tRect.Height > 0) {  						Region reg = g.Clip;  						g.SetClip (tRect);  						g.FillPath (brush' path);  						g.SetClip (pane.Chart._rect);  					}  				}  				else  					g.FillPath (brush' path);  				//brush.Dispose();  			}  			// restore the zero line if needed (since the fill tends to cover it up)  			yAxis.FixZeroLine (g' pane' scaleFactor' rect.Left' rect.Right);  		}  	}  	// If it's a smooth curve' go ahead and render the path.  Otherwise' use the  	// standard drawcurve method just in case there are missing values.  	if (_isSmooth) {  		using (Pen pen = GetPen (pane' scaleFactor)) {  			// Stroke the curve  			g.DrawCurve (pen' arrPoints' 0' count - 2' tension);  			//pen.Dispose();  		}  	}  	else  		DrawCurve (g' pane' curve' scaleFactor);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The following statement contains a magic number: if (this.Fill.IsVisible) {  	Axis yAxis = curve.GetYAxis (pane);  	using (GraphicsPath path = new GraphicsPath (FillMode.Winding)) {  		path.AddCurve (arrPoints' 0' count - 2' tension);  		double yMin = yAxis._scale._min < 0 ? 0.0 : yAxis._scale._min;  		CloseCurve (pane' curve' arrPoints' count' yMin' path);  		RectangleF rect = path.GetBounds ();  		using (Brush brush = source._fill.MakeBrush (rect)) {  			if (pane.LineType == LineType.Stack && yAxis.Scale._min < 0 && this.IsFirstLine (pane' curve)) {  				float zeroPix = yAxis.Scale.Transform (0);  				RectangleF tRect = pane.Chart._rect;  				tRect.Height = zeroPix - tRect.Top;  				if (tRect.Height > 0) {  					Region reg = g.Clip;  					g.SetClip (tRect);  					g.FillPath (brush' path);  					g.SetClip (pane.Chart._rect);  				}  			}  			else  				g.FillPath (brush' path);  			//brush.Dispose();  		}  		// restore the zero line if needed (since the fill tends to cover it up)  		yAxis.FixZeroLine (g' pane' scaleFactor' rect.Left' rect.Right);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath (FillMode.Winding)) {  	path.AddCurve (arrPoints' 0' count - 2' tension);  	double yMin = yAxis._scale._min < 0 ? 0.0 : yAxis._scale._min;  	CloseCurve (pane' curve' arrPoints' count' yMin' path);  	RectangleF rect = path.GetBounds ();  	using (Brush brush = source._fill.MakeBrush (rect)) {  		if (pane.LineType == LineType.Stack && yAxis.Scale._min < 0 && this.IsFirstLine (pane' curve)) {  			float zeroPix = yAxis.Scale.Transform (0);  			RectangleF tRect = pane.Chart._rect;  			tRect.Height = zeroPix - tRect.Top;  			if (tRect.Height > 0) {  				Region reg = g.Clip;  				g.SetClip (tRect);  				g.FillPath (brush' path);  				g.SetClip (pane.Chart._rect);  			}  		}  		else  			g.FillPath (brush' path);  		//brush.Dispose();  	}  	// restore the zero line if needed (since the fill tends to cover it up)  	yAxis.FixZeroLine (g' pane' scaleFactor' rect.Left' rect.Right);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The following statement contains a magic number: path.AddCurve (arrPoints' 0' count - 2' tension);  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The following statement contains a magic number: if (_isSmooth) {  	using (Pen pen = GetPen (pane' scaleFactor)) {  		// Stroke the curve  		g.DrawCurve (pen' arrPoints' 0' count - 2' tension);  		//pen.Dispose();  	}  }  else  	DrawCurve (g' pane' curve' scaleFactor);  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The following statement contains a magic number: using (Pen pen = GetPen (pane' scaleFactor)) {  	// Stroke the curve  	g.DrawCurve (pen' arrPoints' 0' count - 2' tension);  	//pen.Dispose();  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawSmoothFilledCurve,The following statement contains a magic number: g.DrawCurve (pen' arrPoints' 0' count - 2' tension);  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  		// (Dale-a-b) we'll set an element to true when it has been drawn	  		bool['] isPixelDrawn = null;  		if (isOptDraw)  			isPixelDrawn = new bool[maxX + 1' maxY + 1];  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  				// contributed by Dale-a-b  				if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  				 {  					if (isPixelDrawn [tmpX' tmpY])  						continue;  					isPixelDrawn [tmpX' tmpY] = true;  				}  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  		// (Dale-a-b) we'll set an element to true when it has been drawn	  		bool['] isPixelDrawn = null;  		if (isOptDraw)  			isPixelDrawn = new bool[maxX + 1' maxY + 1];  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  				// contributed by Dale-a-b  				if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  				 {  					if (isPixelDrawn [tmpX' tmpY])  						continue;  					isPixelDrawn [tmpX' tmpY] = true;  				}  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  		// (Dale-a-b) we'll set an element to true when it has been drawn	  		bool['] isPixelDrawn = null;  		if (isOptDraw)  			isPixelDrawn = new bool[maxX + 1' maxY + 1];  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  				// contributed by Dale-a-b  				if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  				 {  					if (isPixelDrawn [tmpX' tmpY])  						continue;  					isPixelDrawn [tmpX' tmpY] = true;  				}  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  		// (Dale-a-b) we'll set an element to true when it has been drawn	  		bool['] isPixelDrawn = null;  		if (isOptDraw)  			isPixelDrawn = new bool[maxX + 1' maxY + 1];  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  				// contributed by Dale-a-b  				if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  				 {  					if (isPixelDrawn [tmpX' tmpY])  						continue;  					isPixelDrawn [tmpX' tmpY] = true;  				}  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  		// (Dale-a-b) we'll set an element to true when it has been drawn	  		bool['] isPixelDrawn = null;  		if (isOptDraw)  			isPixelDrawn = new bool[maxX + 1' maxY + 1];  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  				// contributed by Dale-a-b  				if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  				 {  					if (isPixelDrawn [tmpX' tmpY])  						continue;  					isPixelDrawn [tmpX' tmpY] = true;  				}  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  		// (Dale-a-b) we'll set an element to true when it has been drawn	  		bool['] isPixelDrawn = null;  		if (isOptDraw)  			isPixelDrawn = new bool[maxX + 1' maxY + 1];  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  				// contributed by Dale-a-b  				if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  				 {  					if (isPixelDrawn [tmpX' tmpY])  						continue;  					isPixelDrawn [tmpX' tmpY] = true;  				}  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  		// (Dale-a-b) we'll set an element to true when it has been drawn	  		bool['] isPixelDrawn = null;  		if (isOptDraw)  			isPixelDrawn = new bool[maxX + 1' maxY + 1];  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  				// contributed by Dale-a-b  				if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  				 {  					if (isPixelDrawn [tmpX' tmpY])  						continue;  					isPixelDrawn [tmpX' tmpY] = true;  				}  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  		// (Dale-a-b) we'll set an element to true when it has been drawn	  		bool['] isPixelDrawn = null;  		if (isOptDraw)  			isPixelDrawn = new bool[maxX + 1' maxY + 1];  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  				// contributed by Dale-a-b  				if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  				 {  					if (isPixelDrawn [tmpX' tmpY])  						continue;  					isPixelDrawn [tmpX' tmpY] = true;  				}  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  		// (Dale-a-b) we'll set an element to true when it has been drawn	  		bool['] isPixelDrawn = null;  		if (isOptDraw)  			isPixelDrawn = new bool[maxX + 1' maxY + 1];  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  				// contributed by Dale-a-b  				if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  				 {  					if (isPixelDrawn [tmpX' tmpY])  						continue;  					isPixelDrawn [tmpX' tmpY] = true;  				}  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  	// (Dale-a-b) we'll set an element to true when it has been drawn	  	bool['] isPixelDrawn = null;  	if (isOptDraw)  		isPixelDrawn = new bool[maxX + 1' maxY + 1];  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  			// contributed by Dale-a-b  			if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  			 {  				if (isPixelDrawn [tmpX' tmpY])  					continue;  				isPixelDrawn [tmpX' tmpY] = true;  			}  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  	// (Dale-a-b) we'll set an element to true when it has been drawn	  	bool['] isPixelDrawn = null;  	if (isOptDraw)  		isPixelDrawn = new bool[maxX + 1' maxY + 1];  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  			// contributed by Dale-a-b  			if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  			 {  				if (isPixelDrawn [tmpX' tmpY])  					continue;  				isPixelDrawn [tmpX' tmpY] = true;  			}  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  	// (Dale-a-b) we'll set an element to true when it has been drawn	  	bool['] isPixelDrawn = null;  	if (isOptDraw)  		isPixelDrawn = new bool[maxX + 1' maxY + 1];  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  			// contributed by Dale-a-b  			if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  			 {  				if (isPixelDrawn [tmpX' tmpY])  					continue;  				isPixelDrawn [tmpX' tmpY] = true;  			}  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  	// (Dale-a-b) we'll set an element to true when it has been drawn	  	bool['] isPixelDrawn = null;  	if (isOptDraw)  		isPixelDrawn = new bool[maxX + 1' maxY + 1];  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  			// contributed by Dale-a-b  			if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  			 {  				if (isPixelDrawn [tmpX' tmpY])  					continue;  				isPixelDrawn [tmpX' tmpY] = true;  			}  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  	// (Dale-a-b) we'll set an element to true when it has been drawn	  	bool['] isPixelDrawn = null;  	if (isOptDraw)  		isPixelDrawn = new bool[maxX + 1' maxY + 1];  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  			// contributed by Dale-a-b  			if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  			 {  				if (isPixelDrawn [tmpX' tmpY])  					continue;  				isPixelDrawn [tmpX' tmpY] = true;  			}  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  	// (Dale-a-b) we'll set an element to true when it has been drawn	  	bool['] isPixelDrawn = null;  	if (isOptDraw)  		isPixelDrawn = new bool[maxX + 1' maxY + 1];  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  			// contributed by Dale-a-b  			if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  			 {  				if (isPixelDrawn [tmpX' tmpY])  					continue;  				isPixelDrawn [tmpX' tmpY] = true;  			}  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  	// (Dale-a-b) we'll set an element to true when it has been drawn	  	bool['] isPixelDrawn = null;  	if (isOptDraw)  		isPixelDrawn = new bool[maxX + 1' maxY + 1];  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  			// contributed by Dale-a-b  			if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  			 {  				if (isPixelDrawn [tmpX' tmpY])  					continue;  				isPixelDrawn [tmpX' tmpY] = true;  			}  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  	// (Dale-a-b) we'll set an element to true when it has been drawn	  	bool['] isPixelDrawn = null;  	if (isOptDraw)  		isPixelDrawn = new bool[maxX + 1' maxY + 1];  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  			// contributed by Dale-a-b  			if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  			 {  				if (isPixelDrawn [tmpX' tmpY])  					continue;  				isPixelDrawn [tmpX' tmpY] = true;  			}  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	bool isOptDraw = _isOptimizedDraw && points.Count > 1000;  	// (Dale-a-b) we'll set an element to true when it has been drawn	  	bool['] isPixelDrawn = null;  	if (isOptDraw)  		isPixelDrawn = new bool[maxX + 1' maxY + 1];  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  			// contributed by Dale-a-b  			if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  			 {  				if (isPixelDrawn [tmpX' tmpY])  					continue;  				isPixelDrawn [tmpX' tmpY] = true;  			}  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  		// contributed by Dale-a-b  		if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  		 {  			if (isPixelDrawn [tmpX' tmpY])  				continue;  			isPixelDrawn [tmpX' tmpY] = true;  		}  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  		// contributed by Dale-a-b  		if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  		 {  			if (isPixelDrawn [tmpX' tmpY])  				continue;  			isPixelDrawn [tmpX' tmpY] = true;  		}  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  		// contributed by Dale-a-b  		if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  		 {  			if (isPixelDrawn [tmpX' tmpY])  				continue;  			isPixelDrawn [tmpX' tmpY] = true;  		}  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  		// contributed by Dale-a-b  		if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  		 {  			if (isPixelDrawn [tmpX' tmpY])  				continue;  			isPixelDrawn [tmpX' tmpY] = true;  		}  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  		// contributed by Dale-a-b  		if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  		 {  			if (isPixelDrawn [tmpX' tmpY])  				continue;  			isPixelDrawn [tmpX' tmpY] = true;  		}  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  		// contributed by Dale-a-b  		if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  		 {  			if (isPixelDrawn [tmpX' tmpY])  				continue;  			isPixelDrawn [tmpX' tmpY] = true;  		}  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  		// contributed by Dale-a-b  		if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  		 {  			if (isPixelDrawn [tmpX' tmpY])  				continue;  			isPixelDrawn [tmpX' tmpY] = true;  		}  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  		// contributed by Dale-a-b  		if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  		 {  			if (isPixelDrawn [tmpX' tmpY])  				continue;  			isPixelDrawn [tmpX' tmpY] = true;  		}  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  	// contributed by Dale-a-b  	if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  	 {  		if (isPixelDrawn [tmpX' tmpY])  			continue;  		isPixelDrawn [tmpX' tmpY] = true;  	}  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  	// contributed by Dale-a-b  	if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  	 {  		if (isPixelDrawn [tmpX' tmpY])  			continue;  		isPixelDrawn [tmpX' tmpY] = true;  	}  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  	// contributed by Dale-a-b  	if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  	 {  		if (isPixelDrawn [tmpX' tmpY])  			continue;  		isPixelDrawn [tmpX' tmpY] = true;  	}  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  	// contributed by Dale-a-b  	if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  	 {  		if (isPixelDrawn [tmpX' tmpY])  			continue;  		isPixelDrawn [tmpX' tmpY] = true;  	}  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  	// contributed by Dale-a-b  	if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  	 {  		if (isPixelDrawn [tmpX' tmpY])  			continue;  		isPixelDrawn [tmpX' tmpY] = true;  	}  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  	// contributed by Dale-a-b  	if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  	 {  		if (isPixelDrawn [tmpX' tmpY])  			continue;  		isPixelDrawn [tmpX' tmpY] = true;  	}  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  	// contributed by Dale-a-b  	if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  	 {  		if (isPixelDrawn [tmpX' tmpY])  			continue;  		isPixelDrawn [tmpX' tmpY] = true;  	}  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = (int)xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = (int)yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	// Maintain an array of "used" pixel locations to avoid duplicate drawing operations  	// contributed by Dale-a-b  	if (isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY)// guard against the zoom-in case  	 {  		if (isPixelDrawn [tmpX' tmpY])  			continue;  		isPixelDrawn [tmpX' tmpY] = true;  	}  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurve,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: using (Pen pen = source.GetPen (pane' scaleFactor)) {  	if (points != null && !_color.IsEmpty && this.IsVisible) {  		//bool lastOut = false;  		bool isOut;  		// Loop over each point in the curve  		for (int i = 0; i < points.Count; i++) {  			curPt = points [i];  			if (pane.LineType == LineType.Stack) {  				if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  					curX = PointPair.Missing;  					curY = PointPair.Missing;  				}  			}  			else {  				curX = curPt.X;  				curY = curPt.Y;  			}  			// Any value set to double max is invalid and should be skipped  			// This is used for calculated values that are out of range' divide  			//   by zero' etc.  			// Also' any value <= zero on a log scale is invalid  			if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  				// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  				// LastX and LastY are always the last valid point' so this works out  				lastBad = lastBad || !pane.IsIgnoreMissing;  				isOut = true;  			}  			else {  				// Transform the current point from user scale units to  				// screen coordinates  				tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  				tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  				isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  				if (!lastBad) {  					try {  						// GDI+ plots the data wrong and/or throws an exception for  						// outrageous coordinates' so we do a sanity check here  						if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  							InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  						else if (!isOut) {  							if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  								using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  									if (this.StepType == StepType.NonStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardStep) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  										g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.RearwardStep) {  										g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  									else if (this.StepType == StepType.ForwardSegment) {  										g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									}  									else {  										g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  									}  								}  							}  							else {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  									g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (pen' lastX' lastY' lastX' tmpY);  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								}  								else if (this.StepType == StepType.RearwardSegment) {  									g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  					}  					catch {  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					}  				}  				lastPt = curPt;  				lastX = tmpX;  				lastY = tmpY;  				lastBad = false;  				//lastOut = isOut;  			}  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (points != null && !_color.IsEmpty && this.IsVisible) {  	//bool lastOut = false;  	bool isOut;  	// Loop over each point in the curve  	for (int i = 0; i < points.Count; i++) {  		curPt = points [i];  		if (pane.LineType == LineType.Stack) {  			if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  				curX = PointPair.Missing;  				curY = PointPair.Missing;  			}  		}  		else {  			curX = curPt.X;  			curY = curPt.Y;  		}  		// Any value set to double max is invalid and should be skipped  		// This is used for calculated values that are out of range' divide  		//   by zero' etc.  		// Also' any value <= zero on a log scale is invalid  		if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  			// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  			// LastX and LastY are always the last valid point' so this works out  			lastBad = lastBad || !pane.IsIgnoreMissing;  			isOut = true;  		}  		else {  			// Transform the current point from user scale units to  			// screen coordinates  			tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  			tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  			isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  			if (!lastBad) {  				try {  					// GDI+ plots the data wrong and/or throws an exception for  					// outrageous coordinates' so we do a sanity check here  					if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  						InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  					else if (!isOut) {  						if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  							using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  								if (this.StepType == StepType.NonStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardStep) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  									g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.RearwardStep) {  									g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  								else if (this.StepType == StepType.ForwardSegment) {  									g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								}  								else {  									g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  								}  							}  						}  						else {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  								g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (pen' lastX' lastY' lastX' tmpY);  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							}  							else if (this.StepType == StepType.RearwardSegment) {  								g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  				}  				catch {  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				}  			}  			lastPt = curPt;  			lastX = tmpX;  			lastY = tmpY;  			lastBad = false;  			//lastOut = isOut;  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	curPt = points [i];  	if (pane.LineType == LineType.Stack) {  		if (!valueHandler.GetValues (curve' i' out curX' out lowVal' out curY)) {  			curX = PointPair.Missing;  			curY = PointPair.Missing;  		}  	}  	else {  		curX = curPt.X;  		curY = curPt.Y;  	}  	// Any value set to double max is invalid and should be skipped  	// This is used for calculated values that are out of range' divide  	//   by zero' etc.  	// Also' any value <= zero on a log scale is invalid  	if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  		// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  		// LastX and LastY are always the last valid point' so this works out  		lastBad = lastBad || !pane.IsIgnoreMissing;  		isOut = true;  	}  	else {  		// Transform the current point from user scale units to  		// screen coordinates  		tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  		tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  		isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  		if (!lastBad) {  			try {  				// GDI+ plots the data wrong and/or throws an exception for  				// outrageous coordinates' so we do a sanity check here  				if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  					InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  				else if (!isOut) {  					if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  						using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  							if (this.StepType == StepType.NonStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardStep) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  								g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.RearwardStep) {  								g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  							else if (this.StepType == StepType.ForwardSegment) {  								g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							}  							else {  								g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  							}  						}  					}  					else {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  							g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (pen' lastX' lastY' lastX' tmpY);  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						}  						else if (this.StepType == StepType.RearwardSegment) {  							g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  			}  			catch {  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			}  		}  		lastPt = curPt;  		lastX = tmpX;  		lastY = tmpY;  		lastBad = false;  		//lastOut = isOut;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN (curX) || System.Double.IsNaN (curY) || System.Double.IsInfinity (curX) || System.Double.IsInfinity (curY) || (xIsLog && curX <= 0.0) || (yIsLog && curY <= 0.0)) {  	// If the point is invalid' then make a linebreak only if IsIgnoreMissing is false  	// LastX and LastY are always the last valid point' so this works out  	lastBad = lastBad || !pane.IsIgnoreMissing;  	isOut = true;  }  else {  	// Transform the current point from user scale units to  	// screen coordinates  	tmpX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curX);  	tmpY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' curY);  	isOut = (tmpX < minX && lastX < minX) || (tmpX > maxX && lastX > maxX) || (tmpY < minY && lastY < minY) || (tmpY > maxY && lastY > maxY);  	if (!lastBad) {  		try {  			// GDI+ plots the data wrong and/or throws an exception for  			// outrageous coordinates' so we do a sanity check here  			if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  				InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  			else if (!isOut) {  				if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  					using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  						if (this.StepType == StepType.NonStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardStep) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  							g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.RearwardStep) {  							g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  						else if (this.StepType == StepType.ForwardSegment) {  							g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						}  						else {  							g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  						}  					}  				}  				else {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  						g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (pen' lastX' lastY' lastX' tmpY);  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					}  					else if (this.StepType == StepType.RearwardSegment) {  						g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  		}  		catch {  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		}  	}  	lastPt = curPt;  	lastX = tmpX;  	lastY = tmpY;  	lastBad = false;  	//lastOut = isOut;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (!lastBad) {  	try {  		// GDI+ plots the data wrong and/or throws an exception for  		// outrageous coordinates' so we do a sanity check here  		if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  			InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  		else if (!isOut) {  			if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  				using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  					if (this.StepType == StepType.NonStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardStep) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  						g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.RearwardStep) {  						g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  					else if (this.StepType == StepType.ForwardSegment) {  						g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					}  					else {  						g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  					}  				}  			}  			else {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  					g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (pen' lastX' lastY' lastX' tmpY);  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				}  				else if (this.StepType == StepType.RearwardSegment) {  					g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  	}  	catch {  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: try {  	// GDI+ plots the data wrong and/or throws an exception for  	// outrageous coordinates' so we do a sanity check here  	if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  		InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  	else if (!isOut) {  		if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  			using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  				if (this.StepType == StepType.NonStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardStep) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  					g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.RearwardStep) {  					g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  				else if (this.StepType == StepType.ForwardSegment) {  					g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				}  				else {  					g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  				}  			}  		}  		else {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  				g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (pen' lastX' lastY' lastX' tmpY);  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			}  			else if (this.StepType == StepType.RearwardSegment) {  				g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  }  catch {  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,DrawCurveOriginal,The following statement contains a magic number: if (lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000)  	InterpolatePoint (g' pane' curve' lastPt' scaleFactor' pen' lastX' lastY' tmpX' tmpY);  else if (!isOut) {  	if (!curve.IsSelected && this._gradientFill.IsGradientValueType) {  		using (Pen tPen = GetPen (pane' scaleFactor' lastPt)) {  			if (this.StepType == StepType.NonStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardStep) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  				g.DrawLine (tPen' tmpX' lastY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.RearwardStep) {  				g.DrawLine (tPen' lastX' lastY' lastX' tmpY);  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  			else if (this.StepType == StepType.ForwardSegment) {  				g.DrawLine (tPen' lastX' lastY' tmpX' lastY);  			}  			else {  				g.DrawLine (tPen' lastX' tmpY' tmpX' tmpY);  			}  		}  	}  	else {  		if (this.StepType == StepType.NonStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardStep) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  			g.DrawLine (pen' tmpX' lastY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.RearwardStep) {  			g.DrawLine (pen' lastX' lastY' lastX' tmpY);  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  		else if (this.StepType == StepType.ForwardSegment) {  			g.DrawLine (pen' lastX' lastY' tmpX' lastY);  		}  		else if (this.StepType == StepType.RearwardSegment) {  			g.DrawLine (pen' lastX' tmpY' tmpX' tmpY);  		}  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (this.IsVisible && !this.Color.IsEmpty && points != null) {  	int index = 0;  	float curX' curY' lastX = 0' lastY = 0;  	double x' y' lowVal;  	ValueHandler valueHandler = new ValueHandler (pane' false);  	// Step type plots get twice as many points.  Always add three points so there is  	// room to close out the curve for area fills.  	arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * points.Count + 1];  	// Loop over all points in the curve  	for (int i = 0; i < points.Count; i++) {  		// make sure that the current point is valid  		if (!points [i].IsInvalid) {  			// Get the user scale values for the current point  			// use the valueHandler only for stacked types  			if (pane.LineType == LineType.Stack) {  				valueHandler.GetValues (curve' i' out x' out lowVal' out y);  			}  			// otherwise' just access the values directly.  Avoiding the valueHandler for  			// non-stacked types is an optimization to minimize overhead in case there are  			// a large number of points.  			else {  				x = points [i].X;  				y = points [i].Y;  			}  			if (x == PointPair.Missing || y == PointPair.Missing)  				continue;  			// Transform the user scale values to pixel locations  			Axis xAxis = curve.GetXAxis (pane);  			curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  			Axis yAxis = curve.GetYAxis (pane);  			curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  			if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  				continue;  			// Add the pixel value pair into the points array  			// Two points are added for step type curves  			// ignore step-type setting for smooth curves  			if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = lastY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  				arrPoints [index].X = lastX;  				arrPoints [index].Y = curY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			lastX = curX;  			lastY = curY;  			index++;  		}  	}  	// Make sure there is at least one valid point  	if (index == 0)  		return false;  	// Add an extra point at the end' since the smoothing algorithm requires it  	arrPoints [index] = arrPoints [index - 1];  	index++;  	count = index;  	return true;  }  else {  	return false;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (this.IsVisible && !this.Color.IsEmpty && points != null) {  	int index = 0;  	float curX' curY' lastX = 0' lastY = 0;  	double x' y' lowVal;  	ValueHandler valueHandler = new ValueHandler (pane' false);  	// Step type plots get twice as many points.  Always add three points so there is  	// room to close out the curve for area fills.  	arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * points.Count + 1];  	// Loop over all points in the curve  	for (int i = 0; i < points.Count; i++) {  		// make sure that the current point is valid  		if (!points [i].IsInvalid) {  			// Get the user scale values for the current point  			// use the valueHandler only for stacked types  			if (pane.LineType == LineType.Stack) {  				valueHandler.GetValues (curve' i' out x' out lowVal' out y);  			}  			// otherwise' just access the values directly.  Avoiding the valueHandler for  			// non-stacked types is an optimization to minimize overhead in case there are  			// a large number of points.  			else {  				x = points [i].X;  				y = points [i].Y;  			}  			if (x == PointPair.Missing || y == PointPair.Missing)  				continue;  			// Transform the user scale values to pixel locations  			Axis xAxis = curve.GetXAxis (pane);  			curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  			Axis yAxis = curve.GetYAxis (pane);  			curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  			if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  				continue;  			// Add the pixel value pair into the points array  			// Two points are added for step type curves  			// ignore step-type setting for smooth curves  			if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = lastY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  				arrPoints [index].X = lastX;  				arrPoints [index].Y = curY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			lastX = curX;  			lastY = curY;  			index++;  		}  	}  	// Make sure there is at least one valid point  	if (index == 0)  		return false;  	// Add an extra point at the end' since the smoothing algorithm requires it  	arrPoints [index] = arrPoints [index - 1];  	index++;  	count = index;  	return true;  }  else {  	return false;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (this.IsVisible && !this.Color.IsEmpty && points != null) {  	int index = 0;  	float curX' curY' lastX = 0' lastY = 0;  	double x' y' lowVal;  	ValueHandler valueHandler = new ValueHandler (pane' false);  	// Step type plots get twice as many points.  Always add three points so there is  	// room to close out the curve for area fills.  	arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * points.Count + 1];  	// Loop over all points in the curve  	for (int i = 0; i < points.Count; i++) {  		// make sure that the current point is valid  		if (!points [i].IsInvalid) {  			// Get the user scale values for the current point  			// use the valueHandler only for stacked types  			if (pane.LineType == LineType.Stack) {  				valueHandler.GetValues (curve' i' out x' out lowVal' out y);  			}  			// otherwise' just access the values directly.  Avoiding the valueHandler for  			// non-stacked types is an optimization to minimize overhead in case there are  			// a large number of points.  			else {  				x = points [i].X;  				y = points [i].Y;  			}  			if (x == PointPair.Missing || y == PointPair.Missing)  				continue;  			// Transform the user scale values to pixel locations  			Axis xAxis = curve.GetXAxis (pane);  			curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  			Axis yAxis = curve.GetYAxis (pane);  			curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  			if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  				continue;  			// Add the pixel value pair into the points array  			// Two points are added for step type curves  			// ignore step-type setting for smooth curves  			if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = lastY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  				arrPoints [index].X = lastX;  				arrPoints [index].Y = curY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			lastX = curX;  			lastY = curY;  			index++;  		}  	}  	// Make sure there is at least one valid point  	if (index == 0)  		return false;  	// Add an extra point at the end' since the smoothing algorithm requires it  	arrPoints [index] = arrPoints [index - 1];  	index++;  	count = index;  	return true;  }  else {  	return false;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (this.IsVisible && !this.Color.IsEmpty && points != null) {  	int index = 0;  	float curX' curY' lastX = 0' lastY = 0;  	double x' y' lowVal;  	ValueHandler valueHandler = new ValueHandler (pane' false);  	// Step type plots get twice as many points.  Always add three points so there is  	// room to close out the curve for area fills.  	arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * points.Count + 1];  	// Loop over all points in the curve  	for (int i = 0; i < points.Count; i++) {  		// make sure that the current point is valid  		if (!points [i].IsInvalid) {  			// Get the user scale values for the current point  			// use the valueHandler only for stacked types  			if (pane.LineType == LineType.Stack) {  				valueHandler.GetValues (curve' i' out x' out lowVal' out y);  			}  			// otherwise' just access the values directly.  Avoiding the valueHandler for  			// non-stacked types is an optimization to minimize overhead in case there are  			// a large number of points.  			else {  				x = points [i].X;  				y = points [i].Y;  			}  			if (x == PointPair.Missing || y == PointPair.Missing)  				continue;  			// Transform the user scale values to pixel locations  			Axis xAxis = curve.GetXAxis (pane);  			curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  			Axis yAxis = curve.GetYAxis (pane);  			curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  			if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  				continue;  			// Add the pixel value pair into the points array  			// Two points are added for step type curves  			// ignore step-type setting for smooth curves  			if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = lastY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  				arrPoints [index].X = lastX;  				arrPoints [index].Y = curY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			lastX = curX;  			lastY = curY;  			index++;  		}  	}  	// Make sure there is at least one valid point  	if (index == 0)  		return false;  	// Add an extra point at the end' since the smoothing algorithm requires it  	arrPoints [index] = arrPoints [index - 1];  	index++;  	count = index;  	return true;  }  else {  	return false;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (this.IsVisible && !this.Color.IsEmpty && points != null) {  	int index = 0;  	float curX' curY' lastX = 0' lastY = 0;  	double x' y' lowVal;  	ValueHandler valueHandler = new ValueHandler (pane' false);  	// Step type plots get twice as many points.  Always add three points so there is  	// room to close out the curve for area fills.  	arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * points.Count + 1];  	// Loop over all points in the curve  	for (int i = 0; i < points.Count; i++) {  		// make sure that the current point is valid  		if (!points [i].IsInvalid) {  			// Get the user scale values for the current point  			// use the valueHandler only for stacked types  			if (pane.LineType == LineType.Stack) {  				valueHandler.GetValues (curve' i' out x' out lowVal' out y);  			}  			// otherwise' just access the values directly.  Avoiding the valueHandler for  			// non-stacked types is an optimization to minimize overhead in case there are  			// a large number of points.  			else {  				x = points [i].X;  				y = points [i].Y;  			}  			if (x == PointPair.Missing || y == PointPair.Missing)  				continue;  			// Transform the user scale values to pixel locations  			Axis xAxis = curve.GetXAxis (pane);  			curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  			Axis yAxis = curve.GetYAxis (pane);  			curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  			if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  				continue;  			// Add the pixel value pair into the points array  			// Two points are added for step type curves  			// ignore step-type setting for smooth curves  			if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = lastY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  				arrPoints [index].X = lastX;  				arrPoints [index].Y = curY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			lastX = curX;  			lastY = curY;  			index++;  		}  	}  	// Make sure there is at least one valid point  	if (index == 0)  		return false;  	// Add an extra point at the end' since the smoothing algorithm requires it  	arrPoints [index] = arrPoints [index - 1];  	index++;  	count = index;  	return true;  }  else {  	return false;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * points.Count + 1];  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	// make sure that the current point is valid  	if (!points [i].IsInvalid) {  		// Get the user scale values for the current point  		// use the valueHandler only for stacked types  		if (pane.LineType == LineType.Stack) {  			valueHandler.GetValues (curve' i' out x' out lowVal' out y);  		}  		// otherwise' just access the values directly.  Avoiding the valueHandler for  		// non-stacked types is an optimization to minimize overhead in case there are  		// a large number of points.  		else {  			x = points [i].X;  			y = points [i].Y;  		}  		if (x == PointPair.Missing || y == PointPair.Missing)  			continue;  		// Transform the user scale values to pixel locations  		Axis xAxis = curve.GetXAxis (pane);  		curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  		Axis yAxis = curve.GetYAxis (pane);  		curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  		if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  			continue;  		// Add the pixel value pair into the points array  		// Two points are added for step type curves  		// ignore step-type setting for smooth curves  		if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  			arrPoints [index].X = curX;  			arrPoints [index].Y = lastY;  			index++;  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  			arrPoints [index].X = lastX;  			arrPoints [index].Y = curY;  			index++;  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		lastX = curX;  		lastY = curY;  		index++;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	// make sure that the current point is valid  	if (!points [i].IsInvalid) {  		// Get the user scale values for the current point  		// use the valueHandler only for stacked types  		if (pane.LineType == LineType.Stack) {  			valueHandler.GetValues (curve' i' out x' out lowVal' out y);  		}  		// otherwise' just access the values directly.  Avoiding the valueHandler for  		// non-stacked types is an optimization to minimize overhead in case there are  		// a large number of points.  		else {  			x = points [i].X;  			y = points [i].Y;  		}  		if (x == PointPair.Missing || y == PointPair.Missing)  			continue;  		// Transform the user scale values to pixel locations  		Axis xAxis = curve.GetXAxis (pane);  		curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  		Axis yAxis = curve.GetYAxis (pane);  		curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  		if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  			continue;  		// Add the pixel value pair into the points array  		// Two points are added for step type curves  		// ignore step-type setting for smooth curves  		if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  			arrPoints [index].X = curX;  			arrPoints [index].Y = lastY;  			index++;  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  			arrPoints [index].X = lastX;  			arrPoints [index].Y = curY;  			index++;  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		lastX = curX;  		lastY = curY;  		index++;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	// make sure that the current point is valid  	if (!points [i].IsInvalid) {  		// Get the user scale values for the current point  		// use the valueHandler only for stacked types  		if (pane.LineType == LineType.Stack) {  			valueHandler.GetValues (curve' i' out x' out lowVal' out y);  		}  		// otherwise' just access the values directly.  Avoiding the valueHandler for  		// non-stacked types is an optimization to minimize overhead in case there are  		// a large number of points.  		else {  			x = points [i].X;  			y = points [i].Y;  		}  		if (x == PointPair.Missing || y == PointPair.Missing)  			continue;  		// Transform the user scale values to pixel locations  		Axis xAxis = curve.GetXAxis (pane);  		curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  		Axis yAxis = curve.GetYAxis (pane);  		curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  		if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  			continue;  		// Add the pixel value pair into the points array  		// Two points are added for step type curves  		// ignore step-type setting for smooth curves  		if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  			arrPoints [index].X = curX;  			arrPoints [index].Y = lastY;  			index++;  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  			arrPoints [index].X = lastX;  			arrPoints [index].Y = curY;  			index++;  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		lastX = curX;  		lastY = curY;  		index++;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: for (int i = 0; i < points.Count; i++) {  	// make sure that the current point is valid  	if (!points [i].IsInvalid) {  		// Get the user scale values for the current point  		// use the valueHandler only for stacked types  		if (pane.LineType == LineType.Stack) {  			valueHandler.GetValues (curve' i' out x' out lowVal' out y);  		}  		// otherwise' just access the values directly.  Avoiding the valueHandler for  		// non-stacked types is an optimization to minimize overhead in case there are  		// a large number of points.  		else {  			x = points [i].X;  			y = points [i].Y;  		}  		if (x == PointPair.Missing || y == PointPair.Missing)  			continue;  		// Transform the user scale values to pixel locations  		Axis xAxis = curve.GetXAxis (pane);  		curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  		Axis yAxis = curve.GetYAxis (pane);  		curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  		if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  			continue;  		// Add the pixel value pair into the points array  		// Two points are added for step type curves  		// ignore step-type setting for smooth curves  		if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  			arrPoints [index].X = curX;  			arrPoints [index].Y = lastY;  			index++;  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  			arrPoints [index].X = lastX;  			arrPoints [index].Y = curY;  			index++;  			arrPoints [index].X = curX;  			arrPoints [index].Y = curY;  		}  		lastX = curX;  		lastY = curY;  		index++;  	}  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (!points [i].IsInvalid) {  	// Get the user scale values for the current point  	// use the valueHandler only for stacked types  	if (pane.LineType == LineType.Stack) {  		valueHandler.GetValues (curve' i' out x' out lowVal' out y);  	}  	// otherwise' just access the values directly.  Avoiding the valueHandler for  	// non-stacked types is an optimization to minimize overhead in case there are  	// a large number of points.  	else {  		x = points [i].X;  		y = points [i].Y;  	}  	if (x == PointPair.Missing || y == PointPair.Missing)  		continue;  	// Transform the user scale values to pixel locations  	Axis xAxis = curve.GetXAxis (pane);  	curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  	Axis yAxis = curve.GetYAxis (pane);  	curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  	if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  		continue;  	// Add the pixel value pair into the points array  	// Two points are added for step type curves  	// ignore step-type setting for smooth curves  	if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  		arrPoints [index].X = curX;  		arrPoints [index].Y = lastY;  		index++;  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  		arrPoints [index].X = lastX;  		arrPoints [index].Y = curY;  		index++;  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	lastX = curX;  	lastY = curY;  	index++;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (!points [i].IsInvalid) {  	// Get the user scale values for the current point  	// use the valueHandler only for stacked types  	if (pane.LineType == LineType.Stack) {  		valueHandler.GetValues (curve' i' out x' out lowVal' out y);  	}  	// otherwise' just access the values directly.  Avoiding the valueHandler for  	// non-stacked types is an optimization to minimize overhead in case there are  	// a large number of points.  	else {  		x = points [i].X;  		y = points [i].Y;  	}  	if (x == PointPair.Missing || y == PointPair.Missing)  		continue;  	// Transform the user scale values to pixel locations  	Axis xAxis = curve.GetXAxis (pane);  	curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  	Axis yAxis = curve.GetYAxis (pane);  	curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  	if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  		continue;  	// Add the pixel value pair into the points array  	// Two points are added for step type curves  	// ignore step-type setting for smooth curves  	if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  		arrPoints [index].X = curX;  		arrPoints [index].Y = lastY;  		index++;  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  		arrPoints [index].X = lastX;  		arrPoints [index].Y = curY;  		index++;  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	lastX = curX;  	lastY = curY;  	index++;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (!points [i].IsInvalid) {  	// Get the user scale values for the current point  	// use the valueHandler only for stacked types  	if (pane.LineType == LineType.Stack) {  		valueHandler.GetValues (curve' i' out x' out lowVal' out y);  	}  	// otherwise' just access the values directly.  Avoiding the valueHandler for  	// non-stacked types is an optimization to minimize overhead in case there are  	// a large number of points.  	else {  		x = points [i].X;  		y = points [i].Y;  	}  	if (x == PointPair.Missing || y == PointPair.Missing)  		continue;  	// Transform the user scale values to pixel locations  	Axis xAxis = curve.GetXAxis (pane);  	curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  	Axis yAxis = curve.GetYAxis (pane);  	curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  	if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  		continue;  	// Add the pixel value pair into the points array  	// Two points are added for step type curves  	// ignore step-type setting for smooth curves  	if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  		arrPoints [index].X = curX;  		arrPoints [index].Y = lastY;  		index++;  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  		arrPoints [index].X = lastX;  		arrPoints [index].Y = curY;  		index++;  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	lastX = curX;  	lastY = curY;  	index++;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (!points [i].IsInvalid) {  	// Get the user scale values for the current point  	// use the valueHandler only for stacked types  	if (pane.LineType == LineType.Stack) {  		valueHandler.GetValues (curve' i' out x' out lowVal' out y);  	}  	// otherwise' just access the values directly.  Avoiding the valueHandler for  	// non-stacked types is an optimization to minimize overhead in case there are  	// a large number of points.  	else {  		x = points [i].X;  		y = points [i].Y;  	}  	if (x == PointPair.Missing || y == PointPair.Missing)  		continue;  	// Transform the user scale values to pixel locations  	Axis xAxis = curve.GetXAxis (pane);  	curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  	Axis yAxis = curve.GetYAxis (pane);  	curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  	if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  		continue;  	// Add the pixel value pair into the points array  	// Two points are added for step type curves  	// ignore step-type setting for smooth curves  	if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	else if (this.StepType == StepType.ForwardStep || this.StepType == StepType.ForwardSegment) {  		arrPoints [index].X = curX;  		arrPoints [index].Y = lastY;  		index++;  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	else if (this.StepType == StepType.RearwardStep || this.StepType == StepType.RearwardSegment) {  		arrPoints [index].X = lastX;  		arrPoints [index].Y = curY;  		index++;  		arrPoints [index].X = curX;  		arrPoints [index].Y = curY;  	}  	lastX = curX;  	lastY = curY;  	index++;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  	continue;  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  	continue;  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  	continue;  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildPointsArray,The following statement contains a magic number: if (curX < -1000000 || curY < -1000000 || curX > 1000000 || curY > 1000000)  	continue;  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildLowPointsArray,The following statement contains a magic number: if (this.IsVisible && !this.Color.IsEmpty && points != null) {  	int index = 0;  	float curX' curY' lastX = 0' lastY = 0;  	double x' y' hiVal;  	ValueHandler valueHandler = new ValueHandler (pane' false);  	// Step type plots get twice as many points.  Always add three points so there is  	// room to close out the curve for area fills.  	arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * (pane.LineType == LineType.Stack ? 2 : 1) * points.Count + 1];  	// Loop backwards over all points in the curve  	// In this case an array of points was already built forward by BuildPointsArray().  	// This time we build backwards to complete a loop around the area between two curves.  	for (int i = points.Count - 1; i >= 0; i--) {  		// Make sure the current point is valid  		if (!points [i].IsInvalid) {  			// Get the user scale values for the current point  			valueHandler.GetValues (curve' i' out x' out y' out hiVal);  			if (x == PointPair.Missing || y == PointPair.Missing)  				continue;  			// Transform the user scale values to pixel locations  			Axis xAxis = curve.GetXAxis (pane);  			curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  			Axis yAxis = curve.GetYAxis (pane);  			curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  			// Add the pixel value pair into the points array  			// Two points are added for step type curves  			// ignore step-type setting for smooth curves  			if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.ForwardStep) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = lastY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.RearwardStep) {  				arrPoints [index].X = lastX;  				arrPoints [index].Y = curY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			lastX = curX;  			lastY = curY;  			index++;  		}  	}  	// Make sure there is at least one valid point  	if (index == 0)  		return false;  	// Add an extra point at the end' since the smoothing algorithm requires it  	arrPoints [index] = arrPoints [index - 1];  	index++;  	count = index;  	return true;  }  else {  	return false;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildLowPointsArray,The following statement contains a magic number: if (this.IsVisible && !this.Color.IsEmpty && points != null) {  	int index = 0;  	float curX' curY' lastX = 0' lastY = 0;  	double x' y' hiVal;  	ValueHandler valueHandler = new ValueHandler (pane' false);  	// Step type plots get twice as many points.  Always add three points so there is  	// room to close out the curve for area fills.  	arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * (pane.LineType == LineType.Stack ? 2 : 1) * points.Count + 1];  	// Loop backwards over all points in the curve  	// In this case an array of points was already built forward by BuildPointsArray().  	// This time we build backwards to complete a loop around the area between two curves.  	for (int i = points.Count - 1; i >= 0; i--) {  		// Make sure the current point is valid  		if (!points [i].IsInvalid) {  			// Get the user scale values for the current point  			valueHandler.GetValues (curve' i' out x' out y' out hiVal);  			if (x == PointPair.Missing || y == PointPair.Missing)  				continue;  			// Transform the user scale values to pixel locations  			Axis xAxis = curve.GetXAxis (pane);  			curX = xAxis.Scale.Transform (curve.IsOverrideOrdinal' i' x);  			Axis yAxis = curve.GetYAxis (pane);  			curY = yAxis.Scale.Transform (curve.IsOverrideOrdinal' i' y);  			// Add the pixel value pair into the points array  			// Two points are added for step type curves  			// ignore step-type setting for smooth curves  			if (_isSmooth || index == 0 || this.StepType == StepType.NonStep) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.ForwardStep) {  				arrPoints [index].X = curX;  				arrPoints [index].Y = lastY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			else if (this.StepType == StepType.RearwardStep) {  				arrPoints [index].X = lastX;  				arrPoints [index].Y = curY;  				index++;  				arrPoints [index].X = curX;  				arrPoints [index].Y = curY;  			}  			lastX = curX;  			lastY = curY;  			index++;  		}  	}  	// Make sure there is at least one valid point  	if (index == 0)  		return false;  	// Add an extra point at the end' since the smoothing algorithm requires it  	arrPoints [index] = arrPoints [index - 1];  	index++;  	count = index;  	return true;  }  else {  	return false;  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildLowPointsArray,The following statement contains a magic number: arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * (pane.LineType == LineType.Stack ? 2 : 1) * points.Count + 1];  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,BuildLowPointsArray,The following statement contains a magic number: arrPoints = new PointF[(_stepType == ZedGraph.StepType.NonStep ? 1 : 2) * (pane.LineType == LineType.Stack ? 2 : 1) * points.Count + 1];  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,CloseCurve,The following statement contains a magic number: if (pane.LineType != LineType.Stack) {  	// Determine the current value for the bottom of the curve (usually the Y value where  	// the X axis crosses)  	float yBase;  	Axis yAxis = curve.GetYAxis (pane);  	yBase = yAxis.Scale.Transform (yMin);  	// Add three points to the path to move from the end of the curve (as defined by  	// arrPoints) to the X axis' from there to the start of the curve at the X axis'  	// and from there back up to the beginning of the curve.  	path.AddLine (arrPoints [count - 1].X' arrPoints [count - 1].Y' arrPoints [count - 1].X' yBase);  	path.AddLine (arrPoints [count - 1].X' yBase' arrPoints [0].X' yBase);  	path.AddLine (arrPoints [0].X' yBase' arrPoints [0].X' arrPoints [0].Y);  }  // For stacked line types' the fill area is the area between this curve and the curve below it  else {  	PointF[] arrPoints2;  	int count2;  	float tension = _isSmooth ? _smoothTension : 0f;  	// Find the next lower curve in the curveList that is also a LineItem type' and use  	// its smoothing properties for the lower side of the filled area.  	int index = pane.CurveList.IndexOf (curve);  	if (index > 0) {  		CurveItem tmpCurve;  		for (int i = index - 1; i >= 0; i--) {  			tmpCurve = pane.CurveList [i];  			if (tmpCurve is LineItem) {  				tension = ((LineItem)tmpCurve).Line.IsSmooth ? ((LineItem)tmpCurve).Line.SmoothTension : 0f;  				break;  			}  		}  	}  	// Build another points array consisting of the low points (which are actually the points for  	// the curve below the current curve)  	BuildLowPointsArray (pane' curve' out arrPoints2' out count2);  	// Add the new points to the GraphicsPath  	path.AddCurve (arrPoints2' 0' count2 - 2' tension);  }  
Magic Number,ZedGraph,Line,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Line.cs,CloseCurve,The following statement contains a magic number: path.AddCurve (arrPoints2' 0' count2 - 2' tension);  
Magic Number,ZedGraph,LinearAsOrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearAsOrdinalScale.cs,MakeLabel,The following statement contains a magic number: if (pane.CurveList.Count > 0 && pane.CurveList [0].Points.Count > tmpIndex) {  	val = pane.CurveList [0].Points [tmpIndex].X;  	double scaleMult = Math.Pow ((double)10.0' _mag);  	return (val / scaleMult).ToString (_format);  }  else  	return string.Empty;  
Magic Number,ZedGraph,LinearScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-30) {  	if (_maxAuto)  		_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  	if (_minAuto)  		_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  }  
Magic Number,ZedGraph,LinearScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-30) {  	if (_maxAuto)  		_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  	if (_minAuto)  		_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  }  
Magic Number,ZedGraph,LinearScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-30) {  	if (_maxAuto)  		_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  	if (_minAuto)  		_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  }  
Magic Number,ZedGraph,LinearScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearScale.cs,PickScale,The following statement contains a magic number: if (_maxAuto)  	_max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  
Magic Number,ZedGraph,LinearScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearScale.cs,PickScale,The following statement contains a magic number: _max = _max + 0.2 * (_max == 0 ? 1.0 : Math.Abs (_max));  
Magic Number,ZedGraph,LinearScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearScale.cs,PickScale,The following statement contains a magic number: if (_minAuto)  	_min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  
Magic Number,ZedGraph,LinearScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LinearScale.cs,PickScale,The following statement contains a magic number: _min = _min - 0.2 * (_min == 0 ? 1.0 : Math.Abs (_min));  
Magic Number,ZedGraph,LineBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineBase.cs,GetPen,The following statement contains a magic number: if (_style == DashStyle.Custom) {  	if (_dashOff > 1e-10 && _dashOn > 1e-10) {  		pen.DashStyle = DashStyle.Custom;  		float[] pattern = new float[2];  		pattern [0] = _dashOn;  		pattern [1] = _dashOff;  		pen.DashPattern = pattern;  	}  	else  		pen.DashStyle = DashStyle.Solid;  }  
Magic Number,ZedGraph,LineBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineBase.cs,GetPen,The following statement contains a magic number: if (_style == DashStyle.Custom) {  	if (_dashOff > 1e-10 && _dashOn > 1e-10) {  		pen.DashStyle = DashStyle.Custom;  		float[] pattern = new float[2];  		pattern [0] = _dashOn;  		pattern [1] = _dashOff;  		pen.DashPattern = pattern;  	}  	else  		pen.DashStyle = DashStyle.Solid;  }  
Magic Number,ZedGraph,LineBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineBase.cs,GetPen,The following statement contains a magic number: if (_style == DashStyle.Custom) {  	if (_dashOff > 1e-10 && _dashOn > 1e-10) {  		pen.DashStyle = DashStyle.Custom;  		float[] pattern = new float[2];  		pattern [0] = _dashOn;  		pattern [1] = _dashOff;  		pen.DashPattern = pattern;  	}  	else  		pen.DashStyle = DashStyle.Solid;  }  
Magic Number,ZedGraph,LineBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineBase.cs,GetPen,The following statement contains a magic number: if (_dashOff > 1e-10 && _dashOn > 1e-10) {  	pen.DashStyle = DashStyle.Custom;  	float[] pattern = new float[2];  	pattern [0] = _dashOn;  	pattern [1] = _dashOff;  	pen.DashPattern = pattern;  }  else  	pen.DashStyle = DashStyle.Solid;  
Magic Number,ZedGraph,LineBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineBase.cs,GetPen,The following statement contains a magic number: if (_dashOff > 1e-10 && _dashOn > 1e-10) {  	pen.DashStyle = DashStyle.Custom;  	float[] pattern = new float[2];  	pattern [0] = _dashOn;  	pattern [1] = _dashOff;  	pen.DashPattern = pattern;  }  else  	pen.DashStyle = DashStyle.Solid;  
Magic Number,ZedGraph,LineBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineBase.cs,GetPen,The following statement contains a magic number: if (_dashOff > 1e-10 && _dashOn > 1e-10) {  	pen.DashStyle = DashStyle.Custom;  	float[] pattern = new float[2];  	pattern [0] = _dashOn;  	pattern [1] = _dashOff;  	pen.DashPattern = pattern;  }  else  	pen.DashStyle = DashStyle.Solid;  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _line._color' pane.ScaledPenWidth( _line._width' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _line._color' pane.ScaledPenWidth( _line._width' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _line._color' pane.ScaledPenWidth( _line._width' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _line._color' pane.ScaledPenWidth( _line._width' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _line._color' pane.ScaledPenWidth( _line._width' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _line._color' pane.ScaledPenWidth( _line._width' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _line._color' pane.ScaledPenWidth( _line._width' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,Draw,The following statement contains a magic number: if (pix1.X > -10000 && pix1.X < 100000 && pix1.Y > -100000 && pix1.Y < 100000 && pix2.X > -10000 && pix2.X < 100000 && pix2.Y > -100000 && pix2.Y < 100000) {  	// calculate the length and the angle of the arrow "vector"  	double dy = pix2.Y - pix1.Y;  	double dx = pix2.X - pix1.X;  	float angle = (float)Math.Atan2 (dy' dx) * 180.0F / (float)Math.PI;  	float length = (float)Math.Sqrt (dx * dx + dy * dy);  	// Save the old transform matrix  	Matrix transform = g.Transform;  	// Move the coordinate system so it is located at the starting point  	// of this arrow  	g.TranslateTransform (pix1.X' pix1.Y);  	// Rotate the coordinate system according to the angle of this arrow  	// about the starting point  	g.RotateTransform (angle);  	// get a pen according to this arrow properties  	using (Pen pen = _line.GetPen (pane' scaleFactor))//new Pen( _line._color' pane.ScaledPenWidth( _line._width' scaleFactor ) ) )  	 {  		//pen.DashStyle = _style;  		g.DrawLine (pen' 0' 0' length' 0);  	}  	// Restore the transform matrix back to its original state  	g.Transform = transform;  }  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The following statement contains a magic number: pts [0] = new PointF (0' 3);  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The following statement contains a magic number: pts [1] = new PointF (pixRect.Width' 3);  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The following statement contains a magic number: pts [2] = new PointF (pixRect.Width' -3);  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The following statement contains a magic number: pts [2] = new PointF (pixRect.Width' -3);  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The following statement contains a magic number: pts [3] = new PointF (0' -3);  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The following statement contains a magic number: pts [3] = new PointF (0' -3);  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}'{4:f0}'{5:f0}'{6:f0}'{7:f0}'"' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y' pts [2].X' pts [2].Y' pts [3].X' pts [3].Y);  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}'{4:f0}'{5:f0}'{6:f0}'{7:f0}'"' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y' pts [2].X' pts [2].Y' pts [3].X' pts [3].Y);  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}'{4:f0}'{5:f0}'{6:f0}'{7:f0}'"' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y' pts [2].X' pts [2].Y' pts [3].X' pts [3].Y);  
Magic Number,ZedGraph,LineObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LineObj.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}'{4:f0}'{5:f0}'{6:f0}'{7:f0}'"' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y' pts [2].X' pts [2].Y' pts [3].X' pts [3].Y);  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,DeLinearize,The following statement contains a magic number: return Math.Pow (10.0' val);  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcMinorTicValue,The following statement contains a magic number: return baseVal + Math.Floor ((double)iTic / 9.0) + dLogVal [(iTic + 9) % 9];  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcMinorTicValue,The following statement contains a magic number: return baseVal + Math.Floor ((double)iTic / 9.0) + dLogVal [(iTic + 9) % 9];  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcMinorTicValue,The following statement contains a magic number: return baseVal + Math.Floor ((double)iTic / 9.0) + dLogVal [(iTic + 9) % 9];  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcMinorStart,The following statement contains a magic number: return -9;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcBaseTic,The following statement contains a magic number: if (_baseTic != PointPair.Missing)  	return _baseTic;  else {  	// go to the nearest even multiple of the step size  	return Math.Ceiling (Scale.SafeLog (_min) - 0.00000001);  }  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcBaseTic,The following statement contains a magic number: return Math.Ceiling (Scale.SafeLog (_min) - 0.00000001);  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics < 1)  	nTics = 1;  else if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics < 1)  	nTics = 1;  else if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,CalcNumTics,The following statement contains a magic number: nTics = 1000;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_min <= 0.0 && _max <= 0.0) {  	_min = 1.0;  	_max = 10.0;  }  else if (_min <= 0.0) {  	_min = _max / 10.0;  }  else if (_max <= 0.0) {  	_max = _min * 10.0;  }  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_min <= 0.0 && _max <= 0.0) {  	_min = 1.0;  	_max = 10.0;  }  else if (_min <= 0.0) {  	_min = _max / 10.0;  }  else if (_max <= 0.0) {  	_max = _min * 10.0;  }  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_min <= 0.0 && _max <= 0.0) {  	_min = 1.0;  	_max = 10.0;  }  else if (_min <= 0.0) {  	_min = _max / 10.0;  }  else if (_max <= 0.0) {  	_max = _min * 10.0;  }  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: _max = 10.0;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_min <= 0.0) {  	_min = _max / 10.0;  }  else if (_max <= 0.0) {  	_max = _min * 10.0;  }  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_min <= 0.0) {  	_min = _max / 10.0;  }  else if (_max <= 0.0) {  	_max = _min * 10.0;  }  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: _min = _max / 10.0;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_max <= 0.0) {  	_max = _min * 10.0;  }  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: _max = _min * 10.0;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-20) {  	if (_maxAuto)  		_max = _max * 2.0;  	if (_minAuto)  		_min = _min / 2.0;  }  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-20) {  	if (_maxAuto)  		_max = _max * 2.0;  	if (_minAuto)  		_min = _min / 2.0;  }  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < 1.0e-20) {  	if (_maxAuto)  		_max = _max * 2.0;  	if (_minAuto)  		_min = _min / 2.0;  }  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_maxAuto)  	_max = _max * 2.0;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: _max = _max * 2.0;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_minAuto)  	_min = _min / 2.0;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: _min = _min / 2.0;  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_minAuto)  	_min = Math.Pow ((double)10.0' Math.Floor (Math.Log10 (_min)));  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: _min = Math.Pow ((double)10.0' Math.Floor (Math.Log10 (_min)));  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: if (_maxAuto)  	_max = Math.Pow ((double)10.0' Math.Ceiling (Math.Log10 (_max)));  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,PickScale,The following statement contains a magic number: _max = Math.Pow ((double)10.0' Math.Ceiling (Math.Log10 (_max)));  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,MakeLabel,The following statement contains a magic number: if (_isUseTenPower)  	return string.Format ("{0:F0}"' dVal);  else  	return Math.Pow (10.0' dVal).ToString (_format);  
Magic Number,ZedGraph,LogScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\LogScale.cs,MakeLabel,The following statement contains a magic number: return Math.Pow (10.0' dVal).ToString (_format);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,MasterPane,The following statement contains a magic number: if (sch >= 11)  	_isAntiAlias = info.GetBoolean ("isAntiAlias");  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,SetLayout,The following statement contains a magic number: if (countList != null && countList.Length > 0) {  	_prop = new float[countList.Length];  	// Sum up the total proportional factors  	float sumProp = 0.0f;  	for (int i = 0; i < countList.Length; i++) {  		_prop [i] = (proportion == null || proportion.Length <= i || proportion [i] < 1e-10) ? 1.0f : proportion [i];  		sumProp += _prop [i];  	}  	// Make prop sum to 1.0  	for (int i = 0; i < countList.Length; i++)  		_prop [i] /= sumProp;  	_isColumnSpecified = isColumnSpecified;  	_countList = countList;  	DoLayout (g);  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,SetLayout,The following statement contains a magic number: for (int i = 0; i < countList.Length; i++) {  	_prop [i] = (proportion == null || proportion.Length <= i || proportion [i] < 1e-10) ? 1.0f : proportion [i];  	sumProp += _prop [i];  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,SetLayout,The following statement contains a magic number: _prop [i] = (proportion == null || proportion.Length <= i || proportion [i] < 1e-10) ? 1.0f : proportion [i];  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: if (_countList != null)  	DoLayout (g' _isColumnSpecified' _countList' _prop);  else {  	int count = _paneList.Count;  	if (count == 0)  		return;  	int rows' cols' root = (int)(Math.Sqrt ((double)count) + 0.9999999);  	//float[] widthList = new float[5];  	switch (_paneLayout) {  	case PaneLayout.ForceSquare:  		rows = root;  		cols = root;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleColumn:  		rows = count;  		cols = 1;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SingleRow:  		rows = 1;  		cols = count;  		DoLayout (g' rows' cols);  		break;  	default:  	case PaneLayout.SquareColPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			rows--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.SquareRowPreferred:  		rows = root;  		cols = root;  		if (count <= root * (root - 1))  			cols--;  		DoLayout (g' rows' cols);  		break;  	case PaneLayout.ExplicitCol12:  		DoLayout (g' true' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitCol21:  		DoLayout (g' true' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitCol23:  		DoLayout (g' true' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitCol32:  		DoLayout (g' true' new int[2] {  			3'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow12:  		DoLayout (g' false' new int[2] {  			1'  			2  		}' null);  		break;  	case PaneLayout.ExplicitRow21:  		DoLayout (g' false' new int[2] {  			2'  			1  		}' null);  		break;  	case PaneLayout.ExplicitRow23:  		DoLayout (g' false' new int[2] {  			2'  			3  		}' null);  		break;  	case PaneLayout.ExplicitRow32:  		DoLayout (g' false' new int[2] {  			3'  			2  		}' null);  		break;  	}  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: switch (_paneLayout) {  case PaneLayout.ForceSquare:  	rows = root;  	cols = root;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleColumn:  	rows = count;  	cols = 1;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SingleRow:  	rows = 1;  	cols = count;  	DoLayout (g' rows' cols);  	break;  default:  case PaneLayout.SquareColPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		rows--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.SquareRowPreferred:  	rows = root;  	cols = root;  	if (count <= root * (root - 1))  		cols--;  	DoLayout (g' rows' cols);  	break;  case PaneLayout.ExplicitCol12:  	DoLayout (g' true' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitCol21:  	DoLayout (g' true' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitCol23:  	DoLayout (g' true' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitCol32:  	DoLayout (g' true' new int[2] {  		3'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow12:  	DoLayout (g' false' new int[2] {  		1'  		2  	}' null);  	break;  case PaneLayout.ExplicitRow21:  	DoLayout (g' false' new int[2] {  		2'  		1  	}' null);  	break;  case PaneLayout.ExplicitRow23:  	DoLayout (g' false' new int[2] {  		2'  		3  	}' null);  	break;  case PaneLayout.ExplicitRow32:  	DoLayout (g' false' new int[2] {  		3'  		2  	}' null);  	break;  }  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' true' new int[2] {  	1'  	2  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' true' new int[2] {  	1'  	2  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' true' new int[2] {  	2'  	1  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' true' new int[2] {  	2'  	1  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' true' new int[2] {  	2'  	3  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' true' new int[2] {  	2'  	3  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' true' new int[2] {  	2'  	3  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' true' new int[2] {  	3'  	2  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' true' new int[2] {  	3'  	2  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' true' new int[2] {  	3'  	2  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' false' new int[2] {  	1'  	2  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' false' new int[2] {  	1'  	2  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' false' new int[2] {  	2'  	1  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' false' new int[2] {  	2'  	1  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' false' new int[2] {  	2'  	3  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' false' new int[2] {  	2'  	3  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' false' new int[2] {  	2'  	3  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' false' new int[2] {  	3'  	2  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' false' new int[2] {  	3'  	2  }' null);  
Magic Number,ZedGraph,MasterPane,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MasterPane.cs,DoLayout,The following statement contains a magic number: DoLayout (g' false' new int[2] {  	3'  	2  }' null);  
Magic Number,ZedGraph,MinorGrid,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MinorGrid.cs,GetPen,The following statement contains a magic number: if (_dashOff > 1e-10 && _dashOn > 1e-10) {  	pen.DashStyle = DashStyle.Custom;  	float[] pattern = new float[2];  	pattern [0] = _dashOn;  	pattern [1] = _dashOff;  	pen.DashPattern = pattern;  }  
Magic Number,ZedGraph,MinorGrid,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MinorGrid.cs,GetPen,The following statement contains a magic number: if (_dashOff > 1e-10 && _dashOn > 1e-10) {  	pen.DashStyle = DashStyle.Custom;  	float[] pattern = new float[2];  	pattern [0] = _dashOn;  	pattern [1] = _dashOff;  	pen.DashPattern = pattern;  }  
Magic Number,ZedGraph,MinorGrid,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\MinorGrid.cs,GetPen,The following statement contains a magic number: if (_dashOff > 1e-10 && _dashOn > 1e-10) {  	pen.DashStyle = DashStyle.Custom;  	float[] pattern = new float[2];  	pattern [0] = _dashOn;  	pattern [1] = _dashOff;  	pen.DashPattern = pattern;  }  
Magic Number,ZedGraph,NoDupePointList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\NoDupePointList.cs,FilterData,The following statement contains a magic number: for (int i = 0; i < base.Count; i++) {  	DataPoint dp = base [i];  	int x = (int)(xAxis.Scale.Transform (dp.X) + 0.5) - left;  	int y = (int)(yAxis.Scale.Transform (dp.Y) + 0.5) - top;  	if (x >= 0 && x < width && y >= 0 && y < height) {  		bool used = false;  		if (n <= 0)  			used = usedArray [x' y];  		else {  			for (int ix = x - n; ix <= x + n; ix++)  				for (int iy = y - n; iy <= y + n; iy++)  					used |= (ix >= 0 && ix < width && iy >= 0 && iy < height && usedArray [ix' iy]);  		}  		if (!used) {  			usedArray [x' y] = true;  			_visibleIndicies [_filteredCount] = i;  			_filteredCount++;  		}  	}  }  
Magic Number,ZedGraph,NoDupePointList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\NoDupePointList.cs,FilterData,The following statement contains a magic number: for (int i = 0; i < base.Count; i++) {  	DataPoint dp = base [i];  	int x = (int)(xAxis.Scale.Transform (dp.X) + 0.5) - left;  	int y = (int)(yAxis.Scale.Transform (dp.Y) + 0.5) - top;  	if (x >= 0 && x < width && y >= 0 && y < height) {  		bool used = false;  		if (n <= 0)  			used = usedArray [x' y];  		else {  			for (int ix = x - n; ix <= x + n; ix++)  				for (int iy = y - n; iy <= y + n; iy++)  					used |= (ix >= 0 && ix < width && iy >= 0 && iy < height && usedArray [ix' iy]);  		}  		if (!used) {  			usedArray [x' y] = true;  			_visibleIndicies [_filteredCount] = i;  			_filteredCount++;  		}  	}  }  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: if (scale._max - scale._min < 1.0) {  	if (scale._maxAuto)  		scale._max = scale._min + 0.5;  	else  		scale._min = scale._max - 0.5;  }  else {  	// Calculate the new step size  	if (scale._majorStepAuto) {  		// Calculate the step size based on targetSteps  		scale._majorStep = Scale.CalcStepSize (scale._max - scale._min' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetXSteps : Default.TargetYSteps);  		if (scale.IsPreventLabelOverlap) {  			// Calculate the maximum number of labels  			double maxLabels = (double)scale.CalcMaxLabels (g' pane' scaleFactor);  			// Calculate a step size based on the width of the labels  			double tmpStep = Math.Ceiling ((scale._max - scale._min) / maxLabels);  			// Use the greater of the two step sizes  			if (tmpStep > scale._majorStep)  				scale._majorStep = tmpStep;  		}  	}  	scale._majorStep = (int)scale._majorStep;  	if (scale._majorStep < 1.0)  		scale._majorStep = 1.0;  	// Calculate the new minor step size  	if (scale._minorStepAuto)  		scale._minorStep = Scale.CalcStepSize (scale._majorStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  	if (scale._minAuto)  		scale._min -= 0.5;  	if (scale._maxAuto)  		scale._max += 0.5;  }  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: if (scale._max - scale._min < 1.0) {  	if (scale._maxAuto)  		scale._max = scale._min + 0.5;  	else  		scale._min = scale._max - 0.5;  }  else {  	// Calculate the new step size  	if (scale._majorStepAuto) {  		// Calculate the step size based on targetSteps  		scale._majorStep = Scale.CalcStepSize (scale._max - scale._min' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetXSteps : Default.TargetYSteps);  		if (scale.IsPreventLabelOverlap) {  			// Calculate the maximum number of labels  			double maxLabels = (double)scale.CalcMaxLabels (g' pane' scaleFactor);  			// Calculate a step size based on the width of the labels  			double tmpStep = Math.Ceiling ((scale._max - scale._min) / maxLabels);  			// Use the greater of the two step sizes  			if (tmpStep > scale._majorStep)  				scale._majorStep = tmpStep;  		}  	}  	scale._majorStep = (int)scale._majorStep;  	if (scale._majorStep < 1.0)  		scale._majorStep = 1.0;  	// Calculate the new minor step size  	if (scale._minorStepAuto)  		scale._minorStep = Scale.CalcStepSize (scale._majorStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  	if (scale._minAuto)  		scale._min -= 0.5;  	if (scale._maxAuto)  		scale._max += 0.5;  }  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: if (scale._max - scale._min < 1.0) {  	if (scale._maxAuto)  		scale._max = scale._min + 0.5;  	else  		scale._min = scale._max - 0.5;  }  else {  	// Calculate the new step size  	if (scale._majorStepAuto) {  		// Calculate the step size based on targetSteps  		scale._majorStep = Scale.CalcStepSize (scale._max - scale._min' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetXSteps : Default.TargetYSteps);  		if (scale.IsPreventLabelOverlap) {  			// Calculate the maximum number of labels  			double maxLabels = (double)scale.CalcMaxLabels (g' pane' scaleFactor);  			// Calculate a step size based on the width of the labels  			double tmpStep = Math.Ceiling ((scale._max - scale._min) / maxLabels);  			// Use the greater of the two step sizes  			if (tmpStep > scale._majorStep)  				scale._majorStep = tmpStep;  		}  	}  	scale._majorStep = (int)scale._majorStep;  	if (scale._majorStep < 1.0)  		scale._majorStep = 1.0;  	// Calculate the new minor step size  	if (scale._minorStepAuto)  		scale._minorStep = Scale.CalcStepSize (scale._majorStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  	if (scale._minAuto)  		scale._min -= 0.5;  	if (scale._maxAuto)  		scale._max += 0.5;  }  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: if (scale._max - scale._min < 1.0) {  	if (scale._maxAuto)  		scale._max = scale._min + 0.5;  	else  		scale._min = scale._max - 0.5;  }  else {  	// Calculate the new step size  	if (scale._majorStepAuto) {  		// Calculate the step size based on targetSteps  		scale._majorStep = Scale.CalcStepSize (scale._max - scale._min' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetXSteps : Default.TargetYSteps);  		if (scale.IsPreventLabelOverlap) {  			// Calculate the maximum number of labels  			double maxLabels = (double)scale.CalcMaxLabels (g' pane' scaleFactor);  			// Calculate a step size based on the width of the labels  			double tmpStep = Math.Ceiling ((scale._max - scale._min) / maxLabels);  			// Use the greater of the two step sizes  			if (tmpStep > scale._majorStep)  				scale._majorStep = tmpStep;  		}  	}  	scale._majorStep = (int)scale._majorStep;  	if (scale._majorStep < 1.0)  		scale._majorStep = 1.0;  	// Calculate the new minor step size  	if (scale._minorStepAuto)  		scale._minorStep = Scale.CalcStepSize (scale._majorStep' (scale._ownerAxis is XAxis || scale._ownerAxis is X2Axis) ? Default.TargetMinorXSteps : Default.TargetMinorYSteps);  	if (scale._minAuto)  		scale._min -= 0.5;  	if (scale._maxAuto)  		scale._max += 0.5;  }  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: if (scale._maxAuto)  	scale._max = scale._min + 0.5;  else  	scale._min = scale._max - 0.5;  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: if (scale._maxAuto)  	scale._max = scale._min + 0.5;  else  	scale._min = scale._max - 0.5;  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: scale._max = scale._min + 0.5;  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: scale._min = scale._max - 0.5;  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: if (scale._minAuto)  	scale._min -= 0.5;  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: scale._min -= 0.5;  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: if (scale._maxAuto)  	scale._max += 0.5;  
Magic Number,ZedGraph,OrdinalScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\OrdinalScale.cs,PickScale,The following statement contains a magic number: scale._max += 0.5;  
Magic Number,ZedGraph,PaneBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PaneBase.cs,DrawTitle,The following statement contains a magic number: if (_title._isVisible) {  	SizeF size = _title._fontSpec.BoundingBox (g' _title._text' scaleFactor);  	// use the internal fontSpec class to draw the text using user-specified and/or  	// default attributes.  	_title._fontSpec.Draw (g' this' _title._text' (_rect.Left + _rect.Right) / 2' _rect.Top + _margin.Top * (float)scaleFactor + size.Height / 2.0F' AlignH.Center' AlignV.Center' scaleFactor);  }  
Magic Number,ZedGraph,PaneBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PaneBase.cs,DrawTitle,The following statement contains a magic number: _title._fontSpec.Draw (g' this' _title._text' (_rect.Left + _rect.Right) / 2' _rect.Top + _margin.Top * (float)scaleFactor + size.Height / 2.0F' AlignH.Center' AlignV.Center' scaleFactor);  
Magic Number,ZedGraph,PaneBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PaneBase.cs,TransformCoord,The following statement contains a magic number: if (!(this is GraphPane) && !(coord == CoordType.PaneFraction)) {  	coord = CoordType.PaneFraction;  	x = 0.5;  	y = 0.5;  }  
Magic Number,ZedGraph,PaneBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PaneBase.cs,TransformCoord,The following statement contains a magic number: if (!(this is GraphPane) && !(coord == CoordType.PaneFraction)) {  	coord = CoordType.PaneFraction;  	x = 0.5;  	y = 0.5;  }  
Magic Number,ZedGraph,PaneBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PaneBase.cs,TransformCoord,The following statement contains a magic number: x = 0.5;  
Magic Number,ZedGraph,PaneBase,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PaneBase.cs,TransformCoord,The following statement contains a magic number: y = 0.5;  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (pane.CurveList.IsPieOnly) {  	if (nonExplRect.Width < nonExplRect.Height) {  		//create slack rect  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		//get the difference between dimensions  		float delta = (nonExplRect.Height - nonExplRect.Width) / 2;  		//make a square	so we end up with circular pie  		nonExplRect.Height = nonExplRect.Width;  		//keep the center point  the same  		nonExplRect.Y += delta;  	}  	else {  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		float delta = (nonExplRect.Width - nonExplRect.Height) / 2;  		nonExplRect.Width = nonExplRect.Height;  		nonExplRect.X += delta;  	}  	//check aspect ratio  	double aspectRatio = chartRect.Width / chartRect.Height;  	//make an adjustment in rect size'as aspect ratio varies  	if (aspectRatio < 1.5)  		nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  	//modify the rect to determine if any of the labels need to be wrapped....  	//first see if there's any exploded slices and if so' what's the max displacement...  	//also' might as well get all the display params we can  	PieItem.CalculatePieChartParams (pane' ref maxDisplacement);  	if (maxDisplacement != 0)  		//need new rectangle if any slice exploded	  		CalcNewBaseRect (maxDisplacement' ref nonExplRect);  	foreach (PieItem slice in pane.CurveList) {  		slice._boundingRectangle = nonExplRect;  		//if exploded' need to re-calculate rectangle for slice  		if (slice.Displacement != 0) {  			tempRect = nonExplRect;  			slice.CalcExplodedRect (ref tempRect);  			slice._boundingRectangle = tempRect;  		}  		//now get all the other slice specific drawing details' including need for wrapping label  		slice.DesignLabel (g' pane' slice._boundingRectangle' scaleFactor);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (pane.CurveList.IsPieOnly) {  	if (nonExplRect.Width < nonExplRect.Height) {  		//create slack rect  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		//get the difference between dimensions  		float delta = (nonExplRect.Height - nonExplRect.Width) / 2;  		//make a square	so we end up with circular pie  		nonExplRect.Height = nonExplRect.Width;  		//keep the center point  the same  		nonExplRect.Y += delta;  	}  	else {  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		float delta = (nonExplRect.Width - nonExplRect.Height) / 2;  		nonExplRect.Width = nonExplRect.Height;  		nonExplRect.X += delta;  	}  	//check aspect ratio  	double aspectRatio = chartRect.Width / chartRect.Height;  	//make an adjustment in rect size'as aspect ratio varies  	if (aspectRatio < 1.5)  		nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  	//modify the rect to determine if any of the labels need to be wrapped....  	//first see if there's any exploded slices and if so' what's the max displacement...  	//also' might as well get all the display params we can  	PieItem.CalculatePieChartParams (pane' ref maxDisplacement);  	if (maxDisplacement != 0)  		//need new rectangle if any slice exploded	  		CalcNewBaseRect (maxDisplacement' ref nonExplRect);  	foreach (PieItem slice in pane.CurveList) {  		slice._boundingRectangle = nonExplRect;  		//if exploded' need to re-calculate rectangle for slice  		if (slice.Displacement != 0) {  			tempRect = nonExplRect;  			slice.CalcExplodedRect (ref tempRect);  			slice._boundingRectangle = tempRect;  		}  		//now get all the other slice specific drawing details' including need for wrapping label  		slice.DesignLabel (g' pane' slice._boundingRectangle' scaleFactor);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (pane.CurveList.IsPieOnly) {  	if (nonExplRect.Width < nonExplRect.Height) {  		//create slack rect  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		//get the difference between dimensions  		float delta = (nonExplRect.Height - nonExplRect.Width) / 2;  		//make a square	so we end up with circular pie  		nonExplRect.Height = nonExplRect.Width;  		//keep the center point  the same  		nonExplRect.Y += delta;  	}  	else {  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		float delta = (nonExplRect.Width - nonExplRect.Height) / 2;  		nonExplRect.Width = nonExplRect.Height;  		nonExplRect.X += delta;  	}  	//check aspect ratio  	double aspectRatio = chartRect.Width / chartRect.Height;  	//make an adjustment in rect size'as aspect ratio varies  	if (aspectRatio < 1.5)  		nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  	//modify the rect to determine if any of the labels need to be wrapped....  	//first see if there's any exploded slices and if so' what's the max displacement...  	//also' might as well get all the display params we can  	PieItem.CalculatePieChartParams (pane' ref maxDisplacement);  	if (maxDisplacement != 0)  		//need new rectangle if any slice exploded	  		CalcNewBaseRect (maxDisplacement' ref nonExplRect);  	foreach (PieItem slice in pane.CurveList) {  		slice._boundingRectangle = nonExplRect;  		//if exploded' need to re-calculate rectangle for slice  		if (slice.Displacement != 0) {  			tempRect = nonExplRect;  			slice.CalcExplodedRect (ref tempRect);  			slice._boundingRectangle = tempRect;  		}  		//now get all the other slice specific drawing details' including need for wrapping label  		slice.DesignLabel (g' pane' slice._boundingRectangle' scaleFactor);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (pane.CurveList.IsPieOnly) {  	if (nonExplRect.Width < nonExplRect.Height) {  		//create slack rect  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		//get the difference between dimensions  		float delta = (nonExplRect.Height - nonExplRect.Width) / 2;  		//make a square	so we end up with circular pie  		nonExplRect.Height = nonExplRect.Width;  		//keep the center point  the same  		nonExplRect.Y += delta;  	}  	else {  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		float delta = (nonExplRect.Width - nonExplRect.Height) / 2;  		nonExplRect.Width = nonExplRect.Height;  		nonExplRect.X += delta;  	}  	//check aspect ratio  	double aspectRatio = chartRect.Width / chartRect.Height;  	//make an adjustment in rect size'as aspect ratio varies  	if (aspectRatio < 1.5)  		nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  	//modify the rect to determine if any of the labels need to be wrapped....  	//first see if there's any exploded slices and if so' what's the max displacement...  	//also' might as well get all the display params we can  	PieItem.CalculatePieChartParams (pane' ref maxDisplacement);  	if (maxDisplacement != 0)  		//need new rectangle if any slice exploded	  		CalcNewBaseRect (maxDisplacement' ref nonExplRect);  	foreach (PieItem slice in pane.CurveList) {  		slice._boundingRectangle = nonExplRect;  		//if exploded' need to re-calculate rectangle for slice  		if (slice.Displacement != 0) {  			tempRect = nonExplRect;  			slice.CalcExplodedRect (ref tempRect);  			slice._boundingRectangle = tempRect;  		}  		//now get all the other slice specific drawing details' including need for wrapping label  		slice.DesignLabel (g' pane' slice._boundingRectangle' scaleFactor);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (pane.CurveList.IsPieOnly) {  	if (nonExplRect.Width < nonExplRect.Height) {  		//create slack rect  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		//get the difference between dimensions  		float delta = (nonExplRect.Height - nonExplRect.Width) / 2;  		//make a square	so we end up with circular pie  		nonExplRect.Height = nonExplRect.Width;  		//keep the center point  the same  		nonExplRect.Y += delta;  	}  	else {  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		float delta = (nonExplRect.Width - nonExplRect.Height) / 2;  		nonExplRect.Width = nonExplRect.Height;  		nonExplRect.X += delta;  	}  	//check aspect ratio  	double aspectRatio = chartRect.Width / chartRect.Height;  	//make an adjustment in rect size'as aspect ratio varies  	if (aspectRatio < 1.5)  		nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  	//modify the rect to determine if any of the labels need to be wrapped....  	//first see if there's any exploded slices and if so' what's the max displacement...  	//also' might as well get all the display params we can  	PieItem.CalculatePieChartParams (pane' ref maxDisplacement);  	if (maxDisplacement != 0)  		//need new rectangle if any slice exploded	  		CalcNewBaseRect (maxDisplacement' ref nonExplRect);  	foreach (PieItem slice in pane.CurveList) {  		slice._boundingRectangle = nonExplRect;  		//if exploded' need to re-calculate rectangle for slice  		if (slice.Displacement != 0) {  			tempRect = nonExplRect;  			slice.CalcExplodedRect (ref tempRect);  			slice._boundingRectangle = tempRect;  		}  		//now get all the other slice specific drawing details' including need for wrapping label  		slice.DesignLabel (g' pane' slice._boundingRectangle' scaleFactor);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (pane.CurveList.IsPieOnly) {  	if (nonExplRect.Width < nonExplRect.Height) {  		//create slack rect  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		//get the difference between dimensions  		float delta = (nonExplRect.Height - nonExplRect.Width) / 2;  		//make a square	so we end up with circular pie  		nonExplRect.Height = nonExplRect.Width;  		//keep the center point  the same  		nonExplRect.Y += delta;  	}  	else {  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		float delta = (nonExplRect.Width - nonExplRect.Height) / 2;  		nonExplRect.Width = nonExplRect.Height;  		nonExplRect.X += delta;  	}  	//check aspect ratio  	double aspectRatio = chartRect.Width / chartRect.Height;  	//make an adjustment in rect size'as aspect ratio varies  	if (aspectRatio < 1.5)  		nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  	//modify the rect to determine if any of the labels need to be wrapped....  	//first see if there's any exploded slices and if so' what's the max displacement...  	//also' might as well get all the display params we can  	PieItem.CalculatePieChartParams (pane' ref maxDisplacement);  	if (maxDisplacement != 0)  		//need new rectangle if any slice exploded	  		CalcNewBaseRect (maxDisplacement' ref nonExplRect);  	foreach (PieItem slice in pane.CurveList) {  		slice._boundingRectangle = nonExplRect;  		//if exploded' need to re-calculate rectangle for slice  		if (slice.Displacement != 0) {  			tempRect = nonExplRect;  			slice.CalcExplodedRect (ref tempRect);  			slice._boundingRectangle = tempRect;  		}  		//now get all the other slice specific drawing details' including need for wrapping label  		slice.DesignLabel (g' pane' slice._boundingRectangle' scaleFactor);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (pane.CurveList.IsPieOnly) {  	if (nonExplRect.Width < nonExplRect.Height) {  		//create slack rect  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		//get the difference between dimensions  		float delta = (nonExplRect.Height - nonExplRect.Width) / 2;  		//make a square	so we end up with circular pie  		nonExplRect.Height = nonExplRect.Width;  		//keep the center point  the same  		nonExplRect.Y += delta;  	}  	else {  		nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  		float delta = (nonExplRect.Width - nonExplRect.Height) / 2;  		nonExplRect.Width = nonExplRect.Height;  		nonExplRect.X += delta;  	}  	//check aspect ratio  	double aspectRatio = chartRect.Width / chartRect.Height;  	//make an adjustment in rect size'as aspect ratio varies  	if (aspectRatio < 1.5)  		nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  	//modify the rect to determine if any of the labels need to be wrapped....  	//first see if there's any exploded slices and if so' what's the max displacement...  	//also' might as well get all the display params we can  	PieItem.CalculatePieChartParams (pane' ref maxDisplacement);  	if (maxDisplacement != 0)  		//need new rectangle if any slice exploded	  		CalcNewBaseRect (maxDisplacement' ref nonExplRect);  	foreach (PieItem slice in pane.CurveList) {  		slice._boundingRectangle = nonExplRect;  		//if exploded' need to re-calculate rectangle for slice  		if (slice.Displacement != 0) {  			tempRect = nonExplRect;  			slice.CalcExplodedRect (ref tempRect);  			slice._boundingRectangle = tempRect;  		}  		//now get all the other slice specific drawing details' including need for wrapping label  		slice.DesignLabel (g' pane' slice._boundingRectangle' scaleFactor);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (nonExplRect.Width < nonExplRect.Height) {  	//create slack rect  	nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  	//get the difference between dimensions  	float delta = (nonExplRect.Height - nonExplRect.Width) / 2;  	//make a square	so we end up with circular pie  	nonExplRect.Height = nonExplRect.Width;  	//keep the center point  the same  	nonExplRect.Y += delta;  }  else {  	nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  	float delta = (nonExplRect.Width - nonExplRect.Height) / 2;  	nonExplRect.Width = nonExplRect.Height;  	nonExplRect.X += delta;  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (nonExplRect.Width < nonExplRect.Height) {  	//create slack rect  	nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  	//get the difference between dimensions  	float delta = (nonExplRect.Height - nonExplRect.Width) / 2;  	//make a square	so we end up with circular pie  	nonExplRect.Height = nonExplRect.Width;  	//keep the center point  the same  	nonExplRect.Y += delta;  }  else {  	nonExplRect.Inflate (-(float)0.05F * nonExplRect.Height' -(float)0.05F * nonExplRect.Width);  	float delta = (nonExplRect.Width - nonExplRect.Height) / 2;  	nonExplRect.Width = nonExplRect.Height;  	nonExplRect.X += delta;  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (aspectRatio < 1.5)  	nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (aspectRatio < 1.5)  	nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (aspectRatio < 1.5)  	nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (aspectRatio < 1.5)  	nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: if (aspectRatio < 1.5)  	nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcPieRect,The following statement contains a magic number: nonExplRect.Inflate (-(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width)' -(float)(.1 * (1.5 / aspectRatio) * nonExplRect.Width));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcExplodedRect,The following statement contains a magic number: explRect.X += (float)(this.Displacement * explRect.Width / 2 * Math.Cos (_midAngle * Math.PI / 180));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcExplodedRect,The following statement contains a magic number: explRect.X += (float)(this.Displacement * explRect.Width / 2 * Math.Cos (_midAngle * Math.PI / 180));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcExplodedRect,The following statement contains a magic number: explRect.Y += (float)(this.Displacement * explRect.Height / 2 * Math.Sin (_midAngle * Math.PI / 180));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcExplodedRect,The following statement contains a magic number: explRect.Y += (float)(this.Displacement * explRect.Height / 2 * Math.Sin (_midAngle * Math.PI / 180));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculatePieChartParams,The following statement contains a magic number: foreach (PieItem curve in pane.CurveList) {  	lblStr = curve._labelStr;  	curve.StartAngle = (float)nextStartAngle;  	curve.SweepAngle = (float)(360 * curve.Value / pieTotalValue);  	curve.MidAngle = curve.StartAngle + curve.SweepAngle / 2;  	nextStartAngle = curve._startAngle + curve._sweepAngle;  	PieItem.BuildLabelString (curve);  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculatePieChartParams,The following statement contains a magic number: foreach (PieItem curve in pane.CurveList) {  	lblStr = curve._labelStr;  	curve.StartAngle = (float)nextStartAngle;  	curve.SweepAngle = (float)(360 * curve.Value / pieTotalValue);  	curve.MidAngle = curve.StartAngle + curve.SweepAngle / 2;  	nextStartAngle = curve._startAngle + curve._sweepAngle;  	PieItem.BuildLabelString (curve);  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculatePieChartParams,The following statement contains a magic number: curve.SweepAngle = (float)(360 * curve.Value / pieTotalValue);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculatePieChartParams,The following statement contains a magic number: curve.MidAngle = curve.StartAngle + curve.SweepAngle / 2;  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 315 || _midAngle <= 45) {  	//correct by wrapping text  	fill = chartRect.X + chartRect.Width - _endPoint.X - 5;  	if (size.Width > fill) {  		//need to wrap' so create label rectangle for overloaded DrawString - two rows' max  		_labelDetail.LayoutArea = new SizeF (fill' size.Height * 3.0F);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 315 || _midAngle <= 45) {  	//correct by wrapping text  	fill = chartRect.X + chartRect.Width - _endPoint.X - 5;  	if (size.Width > fill) {  		//need to wrap' so create label rectangle for overloaded DrawString - two rows' max  		_labelDetail.LayoutArea = new SizeF (fill' size.Height * 3.0F);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 315 || _midAngle <= 45) {  	//correct by wrapping text  	fill = chartRect.X + chartRect.Width - _endPoint.X - 5;  	if (size.Width > fill) {  		//need to wrap' so create label rectangle for overloaded DrawString - two rows' max  		_labelDetail.LayoutArea = new SizeF (fill' size.Height * 3.0F);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: fill = chartRect.X + chartRect.Width - _endPoint.X - 5;  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 45 && _midAngle <= 135) {  	//correct by moving radial line toward one or the other end of the range  	fill = chartRect.Y + chartRect.Height - _endPoint.Y - 5;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle > 90)  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 45 && _midAngle <= 135) {  	//correct by moving radial line toward one or the other end of the range  	fill = chartRect.Y + chartRect.Height - _endPoint.Y - 5;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle > 90)  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 45 && _midAngle <= 135) {  	//correct by moving radial line toward one or the other end of the range  	fill = chartRect.Y + chartRect.Height - _endPoint.Y - 5;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle > 90)  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 45 && _midAngle <= 135) {  	//correct by moving radial line toward one or the other end of the range  	fill = chartRect.Y + chartRect.Height - _endPoint.Y - 5;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle > 90)  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 45 && _midAngle <= 135) {  	//correct by moving radial line toward one or the other end of the range  	fill = chartRect.Y + chartRect.Height - _endPoint.Y - 5;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle > 90)  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 45 && _midAngle <= 135) {  	//correct by moving radial line toward one or the other end of the range  	fill = chartRect.Y + chartRect.Height - _endPoint.Y - 5;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle > 90)  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 45 && _midAngle <= 135) {  	//correct by moving radial line toward one or the other end of the range  	fill = chartRect.Y + chartRect.Height - _endPoint.Y - 5;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle > 90)  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: fill = chartRect.Y + chartRect.Height - _endPoint.Y - 5;  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (size.Height / 2 > fill) {  	//no' so got to move explosion radius  	if (_midAngle > 90)  		//move _label clockwise one-third of way to the end of the arc  		CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  	else  		//move _label counter-clockwise one-third of way to the start of the arc  		CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (size.Height / 2 > fill) {  	//no' so got to move explosion radius  	if (_midAngle > 90)  		//move _label clockwise one-third of way to the end of the arc  		CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  	else  		//move _label counter-clockwise one-third of way to the start of the arc  		CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (size.Height / 2 > fill) {  	//no' so got to move explosion radius  	if (_midAngle > 90)  		//move _label clockwise one-third of way to the end of the arc  		CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  	else  		//move _label counter-clockwise one-third of way to the start of the arc  		CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (size.Height / 2 > fill) {  	//no' so got to move explosion radius  	if (_midAngle > 90)  		//move _label clockwise one-third of way to the end of the arc  		CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  	else  		//move _label counter-clockwise one-third of way to the start of the arc  		CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 90)  	//move _label clockwise one-third of way to the end of the arc  	CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  else  	//move _label counter-clockwise one-third of way to the start of the arc  	CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 90)  	//move _label clockwise one-third of way to the end of the arc  	CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  else  	//move _label counter-clockwise one-third of way to the start of the arc  	CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 90)  	//move _label clockwise one-third of way to the end of the arc  	CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  else  	//move _label counter-clockwise one-third of way to the start of the arc  	CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: CalculateLinePoints (rect' _midAngle + (_sweepAngle + _startAngle - _midAngle) / 3);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: CalculateLinePoints (rect' _midAngle - (_midAngle - (_midAngle - _startAngle) / 3));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 135 && _midAngle <= 225) {  	//wrap text   	fill = _endPoint.X - chartRect.X - 5;  	//need to wrap' so create label rectangle for overloaded DrawString - two rows' max  	if (size.Width > fill) {  		_labelDetail.LayoutArea = new SizeF (fill' size.Height * 3.0F);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 135 && _midAngle <= 225) {  	//wrap text   	fill = _endPoint.X - chartRect.X - 5;  	//need to wrap' so create label rectangle for overloaded DrawString - two rows' max  	if (size.Width > fill) {  		_labelDetail.LayoutArea = new SizeF (fill' size.Height * 3.0F);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 135 && _midAngle <= 225) {  	//wrap text   	fill = _endPoint.X - chartRect.X - 5;  	//need to wrap' so create label rectangle for overloaded DrawString - two rows' max  	if (size.Width > fill) {  		_labelDetail.LayoutArea = new SizeF (fill' size.Height * 3.0F);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: fill = _endPoint.X - chartRect.X - 5;  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 225 && _midAngle <= 315) {  	//correct by moving radial line toward one or the other end of the range  	fill = _endPoint.Y - 5 - chartRect.Y;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle < 270)  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 225 && _midAngle <= 315) {  	//correct by moving radial line toward one or the other end of the range  	fill = _endPoint.Y - 5 - chartRect.Y;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle < 270)  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 225 && _midAngle <= 315) {  	//correct by moving radial line toward one or the other end of the range  	fill = _endPoint.Y - 5 - chartRect.Y;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle < 270)  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 225 && _midAngle <= 315) {  	//correct by moving radial line toward one or the other end of the range  	fill = _endPoint.Y - 5 - chartRect.Y;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle < 270)  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 225 && _midAngle <= 315) {  	//correct by moving radial line toward one or the other end of the range  	fill = _endPoint.Y - 5 - chartRect.Y;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle < 270)  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 225 && _midAngle <= 315) {  	//correct by moving radial line toward one or the other end of the range  	fill = _endPoint.Y - 5 - chartRect.Y;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle < 270)  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle > 225 && _midAngle <= 315) {  	//correct by moving radial line toward one or the other end of the range  	fill = _endPoint.Y - 5 - chartRect.Y;  	//is there enuf room for the label  	if (size.Height / 2 > fill) {  		//no' so got to move explosion radius  		if (_midAngle < 270)  			//move _label counter-clockwise one-third of way to the start of the arc  			CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  		else  			//move _label clockwise one-third of way to the end of the arc  			CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  	}  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: fill = _endPoint.Y - 5 - chartRect.Y;  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (size.Height / 2 > fill) {  	//no' so got to move explosion radius  	if (_midAngle < 270)  		//move _label counter-clockwise one-third of way to the start of the arc  		CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  	else  		//move _label clockwise one-third of way to the end of the arc  		CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (size.Height / 2 > fill) {  	//no' so got to move explosion radius  	if (_midAngle < 270)  		//move _label counter-clockwise one-third of way to the start of the arc  		CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  	else  		//move _label clockwise one-third of way to the end of the arc  		CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (size.Height / 2 > fill) {  	//no' so got to move explosion radius  	if (_midAngle < 270)  		//move _label counter-clockwise one-third of way to the start of the arc  		CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  	else  		//move _label clockwise one-third of way to the end of the arc  		CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (size.Height / 2 > fill) {  	//no' so got to move explosion radius  	if (_midAngle < 270)  		//move _label counter-clockwise one-third of way to the start of the arc  		CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  	else  		//move _label clockwise one-third of way to the end of the arc  		CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle < 270)  	//move _label counter-clockwise one-third of way to the start of the arc  	CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  else  	//move _label clockwise one-third of way to the end of the arc  	CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle < 270)  	//move _label counter-clockwise one-third of way to the start of the arc  	CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  else  	//move _label clockwise one-third of way to the end of the arc  	CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: if (_midAngle < 270)  	//move _label counter-clockwise one-third of way to the start of the arc  	CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  else  	//move _label clockwise one-third of way to the end of the arc  	CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: CalculateLinePoints (rect' _midAngle - (_sweepAngle + _startAngle - _midAngle) / 3);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,DesignLabel,The following statement contains a magic number: CalculateLinePoints (rect' _midAngle + (_midAngle - _startAngle) / 3);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: _intersectionPoint = new PointF ((float)(rectCenter.X + (rect.Width / 2 * Math.Cos ((midAngle) * Math.PI / 180)))' (float)(rectCenter.Y + (rect.Height / 2 * Math.Sin ((midAngle) * Math.PI / 180))));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: _intersectionPoint = new PointF ((float)(rectCenter.X + (rect.Width / 2 * Math.Cos ((midAngle) * Math.PI / 180)))' (float)(rectCenter.Y + (rect.Height / 2 * Math.Sin ((midAngle) * Math.PI / 180))));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: _intersectionPoint = new PointF ((float)(rectCenter.X + (rect.Width / 2 * Math.Cos ((midAngle) * Math.PI / 180)))' (float)(rectCenter.Y + (rect.Height / 2 * Math.Sin ((midAngle) * Math.PI / 180))));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: _intersectionPoint = new PointF ((float)(rectCenter.X + (rect.Width / 2 * Math.Cos ((midAngle) * Math.PI / 180)))' (float)(rectCenter.Y + (rect.Height / 2 * Math.Sin ((midAngle) * Math.PI / 180))));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: _pivotPoint = new PointF ((float)(_intersectionPoint.X + .05 * rect.Width * Math.Cos ((midAngle) * Math.PI / 180))' (float)(_intersectionPoint.Y + .05 * rect.Width * Math.Sin ((midAngle) * Math.PI / 180)));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: _pivotPoint = new PointF ((float)(_intersectionPoint.X + .05 * rect.Width * Math.Cos ((midAngle) * Math.PI / 180))' (float)(_intersectionPoint.Y + .05 * rect.Width * Math.Sin ((midAngle) * Math.PI / 180)));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: _pivotPoint = new PointF ((float)(_intersectionPoint.X + .05 * rect.Width * Math.Cos ((midAngle) * Math.PI / 180))' (float)(_intersectionPoint.Y + .05 * rect.Width * Math.Sin ((midAngle) * Math.PI / 180)));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: _pivotPoint = new PointF ((float)(_intersectionPoint.X + .05 * rect.Width * Math.Cos ((midAngle) * Math.PI / 180))' (float)(_intersectionPoint.Y + .05 * rect.Width * Math.Sin ((midAngle) * Math.PI / 180)));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: if (_pivotPoint.X >= rectCenter.X)//goes to right   {  	_endPoint = new PointF ((float)(_pivotPoint.X + .05 * rect.Width)' _pivotPoint.Y);  	_labelDetail.Location.AlignH = AlignH.Left;  }  else {  	_endPoint = new PointF ((float)(_pivotPoint.X - .05 * rect.Width)' _pivotPoint.Y);  	_labelDetail.Location.AlignH = AlignH.Right;  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: if (_pivotPoint.X >= rectCenter.X)//goes to right   {  	_endPoint = new PointF ((float)(_pivotPoint.X + .05 * rect.Width)' _pivotPoint.Y);  	_labelDetail.Location.AlignH = AlignH.Left;  }  else {  	_endPoint = new PointF ((float)(_pivotPoint.X - .05 * rect.Width)' _pivotPoint.Y);  	_labelDetail.Location.AlignH = AlignH.Right;  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: _endPoint = new PointF ((float)(_pivotPoint.X + .05 * rect.Width)' _pivotPoint.Y);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalculateLinePoints,The following statement contains a magic number: _endPoint = new PointF ((float)(_pivotPoint.X - .05 * rect.Width)' _pivotPoint.Y);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,BuildLabelString,The following statement contains a magic number: switch (curve._labelType) {  case PieLabelType.Value:  	curve._labelStr = curve._pieValue.ToString ("F"' labelFormat);  	break;  case PieLabelType.Percent:  	curve._labelStr = (curve._sweepAngle / 360).ToString ("P"' labelFormat);  	break;  case PieLabelType.Name_Value:  	curve._labelStr = curve._label._text + ": " + curve._pieValue.ToString ("F"' labelFormat);  	break;  case PieLabelType.Name_Percent:  	curve._labelStr = curve._label._text + ": " + (curve._sweepAngle / 360).ToString ("P"' labelFormat);  	break;  case PieLabelType.Name_Value_Percent:  	curve._labelStr = curve._label._text + ": " + curve._pieValue.ToString ("F"' labelFormat) + " (" + (curve._sweepAngle / 360).ToString ("P"' labelFormat) + ")";  	break;  case PieLabelType.Name:  	curve._labelStr = curve._label._text;  	break;  case PieLabelType.None:  default:  	break;  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,BuildLabelString,The following statement contains a magic number: switch (curve._labelType) {  case PieLabelType.Value:  	curve._labelStr = curve._pieValue.ToString ("F"' labelFormat);  	break;  case PieLabelType.Percent:  	curve._labelStr = (curve._sweepAngle / 360).ToString ("P"' labelFormat);  	break;  case PieLabelType.Name_Value:  	curve._labelStr = curve._label._text + ": " + curve._pieValue.ToString ("F"' labelFormat);  	break;  case PieLabelType.Name_Percent:  	curve._labelStr = curve._label._text + ": " + (curve._sweepAngle / 360).ToString ("P"' labelFormat);  	break;  case PieLabelType.Name_Value_Percent:  	curve._labelStr = curve._label._text + ": " + curve._pieValue.ToString ("F"' labelFormat) + " (" + (curve._sweepAngle / 360).ToString ("P"' labelFormat) + ")";  	break;  case PieLabelType.Name:  	curve._labelStr = curve._label._text;  	break;  case PieLabelType.None:  default:  	break;  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,BuildLabelString,The following statement contains a magic number: switch (curve._labelType) {  case PieLabelType.Value:  	curve._labelStr = curve._pieValue.ToString ("F"' labelFormat);  	break;  case PieLabelType.Percent:  	curve._labelStr = (curve._sweepAngle / 360).ToString ("P"' labelFormat);  	break;  case PieLabelType.Name_Value:  	curve._labelStr = curve._label._text + ": " + curve._pieValue.ToString ("F"' labelFormat);  	break;  case PieLabelType.Name_Percent:  	curve._labelStr = curve._label._text + ": " + (curve._sweepAngle / 360).ToString ("P"' labelFormat);  	break;  case PieLabelType.Name_Value_Percent:  	curve._labelStr = curve._label._text + ": " + curve._pieValue.ToString ("F"' labelFormat) + " (" + (curve._sweepAngle / 360).ToString ("P"' labelFormat) + ")";  	break;  case PieLabelType.Name:  	curve._labelStr = curve._label._text;  	break;  case PieLabelType.None:  default:  	break;  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,BuildLabelString,The following statement contains a magic number: curve._labelStr = (curve._sweepAngle / 360).ToString ("P"' labelFormat);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,BuildLabelString,The following statement contains a magic number: curve._labelStr = curve._label._text + ": " + (curve._sweepAngle / 360).ToString ("P"' labelFormat);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,BuildLabelString,The following statement contains a magic number: curve._labelStr = curve._label._text + ": " + curve._pieValue.ToString ("F"' labelFormat) + " (" + (curve._sweepAngle / 360).ToString ("P"' labelFormat) + ")";  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcNewBaseRect,The following statement contains a magic number: baseRect.Inflate (-(float)((xDispl / 10))' -(float)((xDispl / 10)));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,CalcNewBaseRect,The following statement contains a magic number: baseRect.Inflate (-(float)((xDispl / 10))' -(float)((xDispl / 10)));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,GetCoords,The following statement contains a magic number: for (int j = 2; j < count + 2; j++) {  	angle += SweepAngle / count;  	pts [j] = new PointF (radius * (float)Math.Cos (angle * Math.PI / 180.0)' radius * (float)Math.Sin (angle * Math.PI / 180.0));  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,GetCoords,The following statement contains a magic number: for (int j = 2; j < count + 2; j++) {  	angle += SweepAngle / count;  	pts [j] = new PointF (radius * (float)Math.Cos (angle * Math.PI / 180.0)' radius * (float)Math.Sin (angle * Math.PI / 180.0));  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,GetCoords,The following statement contains a magic number: for (int j = 2; j < count + 2; j++) {  	angle += SweepAngle / count;  	pts [j] = new PointF (radius * (float)Math.Cos (angle * Math.PI / 180.0)' radius * (float)Math.Sin (angle * Math.PI / 180.0));  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,GetCoords,The following statement contains a magic number: for (int j = 2; j < count + 2; j++) {  	angle += SweepAngle / count;  	pts [j] = new PointF (radius * (float)Math.Cos (angle * Math.PI / 180.0)' radius * (float)Math.Sin (angle * Math.PI / 180.0));  }  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,GetCoords,The following statement contains a magic number: pts [j] = new PointF (radius * (float)Math.Cos (angle * Math.PI / 180.0)' radius * (float)Math.Sin (angle * Math.PI / 180.0));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,GetCoords,The following statement contains a magic number: pts [j] = new PointF (radius * (float)Math.Cos (angle * Math.PI / 180.0)' radius * (float)Math.Sin (angle * Math.PI / 180.0));  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,GetCoords,The following statement contains a magic number: for (int j = 2; j < count + 2; j++)  	coords += String.Format (j > count ? "{0:f0}'{1:f0}" : "{0:f0}'{1:f0}'"' pts [j].X' pts [j].Y);  
Magic Number,ZedGraph,PieItem,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PieItem.cs,GetCoords,The following statement contains a magic number: for (int j = 2; j < count + 2; j++)  	coords += String.Format (j > count ? "{0:f0}'{1:f0}" : "{0:f0}'{1:f0}'"' pts [j].X' pts [j].Y);  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: if (this.Count < 2)  	throw new Exception ("Error: Not enough points in curve to interpolate");  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: if (xTarget <= this [0].X) {  	lo = 0;  	hi = 1;  }  else if (xTarget >= this [this.Count - 1].X) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: if (xTarget <= this [0].X) {  	lo = 0;  	hi = 1;  }  else if (xTarget >= this [this.Count - 1].X) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: if (xTarget <= this [0].X) {  	lo = 0;  	hi = 1;  }  else if (xTarget >= this [this.Count - 1].X) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: if (xTarget <= this [0].X) {  	lo = 0;  	hi = 1;  }  else if (xTarget >= this [this.Count - 1].X) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: if (xTarget >= this [this.Count - 1].X) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: if (xTarget >= this [this.Count - 1].X) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: if (xTarget >= this [this.Count - 1].X) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: if (xTarget >= this [this.Count - 1].X) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: lo = this.Count - 2;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: for (j = 0; j < 1000 && hi > lo + 1; j++) {  	mid = (hi + lo) / 2;  	if (xTarget > this [mid].X)  		lo = mid;  	else  		hi = mid;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: for (j = 0; j < 1000 && hi > lo + 1; j++) {  	mid = (hi + lo) / 2;  	if (xTarget > this [mid].X)  		lo = mid;  	else  		hi = mid;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: mid = (hi + lo) / 2;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateX,The following statement contains a magic number: if (j >= 1000)  	throw new Exception ("Error: Infinite loop in interpolation");  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: tension /= 3.0;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: if (this.Count < 2)  	throw new Exception ("Error: Not enough points in curve to interpolate");  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: if (xTarget <= this [0].X || xTarget >= this [this.Count - 1].X)  	return PointPair.Missing;  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: if (xTarget <= this [0].X || xTarget >= this [this.Count - 1].X)  	return PointPair.Missing;  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: if (xTarget <= this [0].X || xTarget >= this [this.Count - 1].X)  	return PointPair.Missing;  else {  	// if x is within the bounds of the x table' then do a binary search  	// in the x table to find table entries that bound the x value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (xTarget > this [mid].X)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: for (j = 0; j < 1000 && hi > lo + 1; j++) {  	mid = (hi + lo) / 2;  	if (xTarget > this [mid].X)  		lo = mid;  	else  		hi = mid;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: for (j = 0; j < 1000 && hi > lo + 1; j++) {  	mid = (hi + lo) / 2;  	if (xTarget > this [mid].X)  		lo = mid;  	else  		hi = mid;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: mid = (hi + lo) / 2;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: if (j >= 1000)  	throw new Exception ("Error: Infinite loop in interpolation");  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: if (lo == 0) {  	X0 = X1 - (X2 - X1) / 3;  	Y0 = Y1 - (Y2 - Y1) / 3;  }  else {  	X0 = this [lo - 1].X;  	Y0 = this [lo - 1].Y;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: if (lo == 0) {  	X0 = X1 - (X2 - X1) / 3;  	Y0 = Y1 - (Y2 - Y1) / 3;  }  else {  	X0 = this [lo - 1].X;  	Y0 = this [lo - 1].Y;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: X0 = X1 - (X2 - X1) / 3;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: Y0 = Y1 - (Y2 - Y1) / 3;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: if (hi == this.Count - 1) {  	X3 = X2 + (X2 - X1) / 3;  	Y3 = Y2 + (Y2 - Y1) / 3;  }  else {  	X3 = this [hi + 1].X;  	Y3 = this [hi + 1].Y;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: if (hi == this.Count - 1) {  	X3 = X2 + (X2 - X1) / 3;  	Y3 = Y2 + (Y2 - Y1) / 3;  }  else {  	X3 = this [hi + 1].X;  	Y3 = this [hi + 1].Y;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: X3 = X2 + (X2 - X1) / 3;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: Y3 = Y2 + (Y2 - Y1) / 3;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: for (double t = 0.01; t <= 1; t += 0.01) {  	B0 = (1 - t) * (1 - t) * (1 - t);  	B1 = 3.0 * t * (1 - t) * (1 - t);  	B2 = 3.0 * t * t * (1 - t);  	B3 = t * t * t;  	newX = X1 * B0 + (X1 + (X2 - X0) * tension) * B1 + (X2 - (X3 - X1) * tension) * B2 + X2 * B3;  	newY = Y1 * B0 + (Y1 + (Y2 - Y0) * tension) * B1 + (Y2 - (Y3 - Y1) * tension) * B2 + Y2 * B3;  	// We are looking for the first X that exceeds the target  	if (newX >= xTarget) {  		// We now have two bounding X values around our target  		// use linear interpolation to minimize the discretization  		// error.  		return (xTarget - lastX) / (newX - lastX) * (newY - lastY) + lastY;  	}  	lastX = newX;  	lastY = newY;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: for (double t = 0.01; t <= 1; t += 0.01) {  	B0 = (1 - t) * (1 - t) * (1 - t);  	B1 = 3.0 * t * (1 - t) * (1 - t);  	B2 = 3.0 * t * t * (1 - t);  	B3 = t * t * t;  	newX = X1 * B0 + (X1 + (X2 - X0) * tension) * B1 + (X2 - (X3 - X1) * tension) * B2 + X2 * B3;  	newY = Y1 * B0 + (Y1 + (Y2 - Y0) * tension) * B1 + (Y2 - (Y3 - Y1) * tension) * B2 + Y2 * B3;  	// We are looking for the first X that exceeds the target  	if (newX >= xTarget) {  		// We now have two bounding X values around our target  		// use linear interpolation to minimize the discretization  		// error.  		return (xTarget - lastX) / (newX - lastX) * (newY - lastY) + lastY;  	}  	lastX = newX;  	lastY = newY;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: for (double t = 0.01; t <= 1; t += 0.01) {  	B0 = (1 - t) * (1 - t) * (1 - t);  	B1 = 3.0 * t * (1 - t) * (1 - t);  	B2 = 3.0 * t * t * (1 - t);  	B3 = t * t * t;  	newX = X1 * B0 + (X1 + (X2 - X0) * tension) * B1 + (X2 - (X3 - X1) * tension) * B2 + X2 * B3;  	newY = Y1 * B0 + (Y1 + (Y2 - Y0) * tension) * B1 + (Y2 - (Y3 - Y1) * tension) * B2 + Y2 * B3;  	// We are looking for the first X that exceeds the target  	if (newX >= xTarget) {  		// We now have two bounding X values around our target  		// use linear interpolation to minimize the discretization  		// error.  		return (xTarget - lastX) / (newX - lastX) * (newY - lastY) + lastY;  	}  	lastX = newX;  	lastY = newY;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: for (double t = 0.01; t <= 1; t += 0.01) {  	B0 = (1 - t) * (1 - t) * (1 - t);  	B1 = 3.0 * t * (1 - t) * (1 - t);  	B2 = 3.0 * t * t * (1 - t);  	B3 = t * t * t;  	newX = X1 * B0 + (X1 + (X2 - X0) * tension) * B1 + (X2 - (X3 - X1) * tension) * B2 + X2 * B3;  	newY = Y1 * B0 + (Y1 + (Y2 - Y0) * tension) * B1 + (Y2 - (Y3 - Y1) * tension) * B2 + Y2 * B3;  	// We are looking for the first X that exceeds the target  	if (newX >= xTarget) {  		// We now have two bounding X values around our target  		// use linear interpolation to minimize the discretization  		// error.  		return (xTarget - lastX) / (newX - lastX) * (newY - lastY) + lastY;  	}  	lastX = newX;  	lastY = newY;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: t += 0.01
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: B1 = 3.0 * t * (1 - t) * (1 - t);  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,SplineInterpolateX,The following statement contains a magic number: B2 = 3.0 * t * t * (1 - t);  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: if (this.Count < 2)  	throw new Exception ("Error: Not enough points in curve to interpolate");  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: if (yTarget <= this [0].Y) {  	lo = 0;  	hi = 1;  }  else if (yTarget >= this [this.Count - 1].Y) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if y is within the bounds of the y table' then do a binary search  	// in the y table to find table entries that bound the y value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (yTarget > this [mid].Y)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: if (yTarget <= this [0].Y) {  	lo = 0;  	hi = 1;  }  else if (yTarget >= this [this.Count - 1].Y) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if y is within the bounds of the y table' then do a binary search  	// in the y table to find table entries that bound the y value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (yTarget > this [mid].Y)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: if (yTarget <= this [0].Y) {  	lo = 0;  	hi = 1;  }  else if (yTarget >= this [this.Count - 1].Y) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if y is within the bounds of the y table' then do a binary search  	// in the y table to find table entries that bound the y value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (yTarget > this [mid].Y)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: if (yTarget <= this [0].Y) {  	lo = 0;  	hi = 1;  }  else if (yTarget >= this [this.Count - 1].Y) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if y is within the bounds of the y table' then do a binary search  	// in the y table to find table entries that bound the y value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (yTarget > this [mid].Y)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: if (yTarget >= this [this.Count - 1].Y) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if y is within the bounds of the y table' then do a binary search  	// in the y table to find table entries that bound the y value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (yTarget > this [mid].Y)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: if (yTarget >= this [this.Count - 1].Y) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if y is within the bounds of the y table' then do a binary search  	// in the y table to find table entries that bound the y value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (yTarget > this [mid].Y)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: if (yTarget >= this [this.Count - 1].Y) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if y is within the bounds of the y table' then do a binary search  	// in the y table to find table entries that bound the y value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (yTarget > this [mid].Y)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: if (yTarget >= this [this.Count - 1].Y) {  	lo = this.Count - 2;  	hi = this.Count - 1;  }  else {  	// if y is within the bounds of the y table' then do a binary search  	// in the y table to find table entries that bound the y value  	lo = 0;  	hi = this.Count - 1;  	// limit to 1000 loops to avoid an infinite loop problem  	int j;  	for (j = 0; j < 1000 && hi > lo + 1; j++) {  		mid = (hi + lo) / 2;  		if (yTarget > this [mid].Y)  			lo = mid;  		else  			hi = mid;  	}  	if (j >= 1000)  		throw new Exception ("Error: Infinite loop in interpolation");  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: lo = this.Count - 2;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: for (j = 0; j < 1000 && hi > lo + 1; j++) {  	mid = (hi + lo) / 2;  	if (yTarget > this [mid].Y)  		lo = mid;  	else  		hi = mid;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: for (j = 0; j < 1000 && hi > lo + 1; j++) {  	mid = (hi + lo) / 2;  	if (yTarget > this [mid].Y)  		lo = mid;  	else  		hi = mid;  }  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: mid = (hi + lo) / 2;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,InterpolateY,The following statement contains a magic number: if (j >= 1000)  	throw new Exception ("Error: Infinite loop in interpolation");  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,LinearRegression,The following statement contains a magic number: if (count < 2 || maxX - minX < 1e-20)  	return null;  
Magic Number,ZedGraph,PointPairList,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PointPairList.cs,LinearRegression,The following statement contains a magic number: if (count < 2 || maxX - minX < 1e-20)  	return null;  
Magic Number,ZedGraph,PolyObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PolyObj.cs,PolyObj,The following statement contains a magic number: if (schema3 >= 11)  	_isClosedFigure = info.GetBoolean ("isClosedFigure");  
Magic Number,ZedGraph,PolyObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PolyObj.cs,MakePath,The following statement contains a magic number: foreach (PointD pt in _points) {  	// Convert the coordinates from the user coordinate system  	// to the screen coordinate system  	// Offset the points by the location value  	PointF pixPt = Location.Transform (pane' pt.X + _location.X' pt.Y + _location.Y' _location.CoordinateFrame);  	if (Math.Abs (pixPt.X) < 100000 && Math.Abs (pixPt.Y) < 100000) {  		if (first)  			first = false;  		else  			path.AddLine (lastPt' pixPt);  		lastPt = pixPt;  	}  }  
Magic Number,ZedGraph,PolyObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PolyObj.cs,MakePath,The following statement contains a magic number: foreach (PointD pt in _points) {  	// Convert the coordinates from the user coordinate system  	// to the screen coordinate system  	// Offset the points by the location value  	PointF pixPt = Location.Transform (pane' pt.X + _location.X' pt.Y + _location.Y' _location.CoordinateFrame);  	if (Math.Abs (pixPt.X) < 100000 && Math.Abs (pixPt.Y) < 100000) {  		if (first)  			first = false;  		else  			path.AddLine (lastPt' pixPt);  		lastPt = pixPt;  	}  }  
Magic Number,ZedGraph,PolyObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PolyObj.cs,MakePath,The following statement contains a magic number: if (Math.Abs (pixPt.X) < 100000 && Math.Abs (pixPt.Y) < 100000) {  	if (first)  		first = false;  	else  		path.AddLine (lastPt' pixPt);  	lastPt = pixPt;  }  
Magic Number,ZedGraph,PolyObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\PolyObj.cs,MakePath,The following statement contains a magic number: if (Math.Abs (pixPt.X) < 100000 && Math.Abs (pixPt.Y) < 100000) {  	if (first)  		first = false;  	else  		path.AddLine (lastPt' pixPt);  	lastPt = pixPt;  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,Scale,The following statement contains a magic number: _majorStep = 0.1;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,Scale,The following statement contains a magic number: _minorStep = 0.1;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,Scale,The following statement contains a magic number: if (schema >= 11)  	_alignH = (AlignH)info.GetValue ("alignH"' typeof(AlignH));  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,GetScaleMaxSpace,The following statement contains a magic number: if (_isVisible) {  	double dVal' scaleMult = Math.Pow ((double)10.0' _mag);  	int i;  	float saveAngle = _fontSpec.Angle;  	if (!applyAngle)  		_fontSpec.Angle = 0;  	int nTics = CalcNumTics ();  	double startVal = CalcBaseTic ();  	SizeF maxSpace = new SizeF (0' 0);  	// Repeat for each tic  	for (i = 0; i < nTics; i++) {  		dVal = CalcMajorTicValue (startVal' i);  		// draw the label  		//string tmpStr = MakeLabel( pane' i' dVal );  		string tmpStr = _ownerAxis.MakeLabelEventWorks (pane' i' dVal);  		SizeF sizeF;  		if (this.IsLog && _isUseTenPower)  			sizeF = _fontSpec.BoundingBoxTenPower (g' tmpStr' scaleFactor);  		else  			sizeF = _fontSpec.BoundingBox (g' tmpStr' scaleFactor);  		if (sizeF.Height > maxSpace.Height)  			maxSpace.Height = sizeF.Height;  		if (sizeF.Width > maxSpace.Width)  			maxSpace.Width = sizeF.Width;  	}  	_fontSpec.Angle = saveAngle;  	return maxSpace;  }  else  	return new SizeF (0' 0);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBaseTic,The following statement contains a magic number: if (_baseTic != PointPair.Missing)  	return _baseTic;  else if (IsAnyOrdinal) {  	// basetic is always 1 for ordinal types  	return 1;  }  else {  	// default behavior is linear or ordinal type  	// go to the nearest even multiple of the step size  	return Math.Ceiling ((double)_min / (double)_majorStep - 0.00000001) * (double)_majorStep;  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBaseTic,The following statement contains a magic number: if (IsAnyOrdinal) {  	// basetic is always 1 for ordinal types  	return 1;  }  else {  	// default behavior is linear or ordinal type  	// go to the nearest even multiple of the step size  	return Math.Ceiling ((double)_min / (double)_majorStep - 0.00000001) * (double)_majorStep;  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBaseTic,The following statement contains a magic number: return Math.Ceiling ((double)_min / (double)_majorStep - 0.00000001) * (double)_majorStep;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: using (Pen ticPen = tic.GetPen (pane' scaleFactor))//			using ( Pen gridPen = grid.GetPen( pane' scaleFactor ) )   {  	// get the Y position of the center of the axis labels  	// (the axis itself is referenced at zero)  	SizeF maxLabelSize = GetScaleMaxSpace (g' pane' scaleFactor' true);  	float charHeight = _fontSpec.GetHeight (scaleFactor);  	float maxSpace = maxLabelSize.Height;  	float edgeTolerance = Default.EdgeTolerance * scaleFactor;  	double rangeTol = (_maxLinTemp - _minLinTemp) * 0.001;  	int firstTic = (int)((_minLinTemp - baseVal) / _majorStep + 0.99);  	if (firstTic < 0)  		firstTic = 0;  	// save the position of the previous tic  	float lastPixVal = -10000;  	// loop for each major tic  	for (int i = firstTic; i < nTics + firstTic; i++) {  		dVal = CalcMajorTicValue (baseVal' i);  		// If we're before the start of the scale' just go to the next tic  		if (dVal < _minLinTemp)  			continue;  		// if we've already past the end of the scale' then we're done  		if (dVal > _maxLinTemp + rangeTol)  			break;  		// convert the value to a pixel position  		pixVal = LocalTransform (dVal);  		// see if the tic marks will be drawn between the labels instead of at the labels  		// (this applies only to AxisType.Text  		if (tic._isBetweenLabels && IsText) {  			// We need one extra tic in order to draw the tics between labels  			// so provide an exception here  			if (i == 0) {  				dVal2 = CalcMajorTicValue (baseVal' -0.5);  				if (dVal2 >= _minLinTemp) {  					pixVal2 = LocalTransform (dVal2);  					tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  					//								grid.Draw( g' gridPen' pixVal2' topPix );  				}  			}  			dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  			if (dVal2 > _maxLinTemp)  				break;  			pixVal2 = LocalTransform (dVal2);  		}  		else  			pixVal2 = pixVal;  		tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  		// draw the grid  		//					grid.Draw( g' gridPen' pixVal2' topPix );  		bool isMaxValueAtMaxPix = ((_ownerAxis is XAxis || _ownerAxis is Y2Axis) && !IsReverse) || (_ownerAxis is Y2Axis && IsReverse);  		bool isSkipZone = (((_isSkipFirstLabel && isMaxValueAtMaxPix) || (_isSkipLastLabel && !isMaxValueAtMaxPix)) && pixVal < edgeTolerance) || (((_isSkipLastLabel && isMaxValueAtMaxPix) || (_isSkipFirstLabel && !isMaxValueAtMaxPix)) && pixVal > _maxPix - _minPix - edgeTolerance);  		bool isSkipCross = _isSkipCrossLabel && !_ownerAxis._crossAuto && Math.Abs (_ownerAxis._cross - dVal) < rangeTol * 10.0;  		isSkipZone = isSkipZone || isSkipCross;  		if (_isVisible && !isSkipZone) {  			// For exponential scales' just skip any label that would overlap with the previous one  			// This is because exponential scales have varying label spacing  			if (IsPreventLabelOverlap && Math.Abs (pixVal - lastPixVal) < maxLabelSize.Width)  				continue;  			DrawLabel (g' pane' i' dVal' pixVal' shift' maxSpace' scaledTic' charHeight' scaleFactor);  			lastPixVal = pixVal;  		}  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: using (Pen ticPen = tic.GetPen (pane' scaleFactor))//			using ( Pen gridPen = grid.GetPen( pane' scaleFactor ) )   {  	// get the Y position of the center of the axis labels  	// (the axis itself is referenced at zero)  	SizeF maxLabelSize = GetScaleMaxSpace (g' pane' scaleFactor' true);  	float charHeight = _fontSpec.GetHeight (scaleFactor);  	float maxSpace = maxLabelSize.Height;  	float edgeTolerance = Default.EdgeTolerance * scaleFactor;  	double rangeTol = (_maxLinTemp - _minLinTemp) * 0.001;  	int firstTic = (int)((_minLinTemp - baseVal) / _majorStep + 0.99);  	if (firstTic < 0)  		firstTic = 0;  	// save the position of the previous tic  	float lastPixVal = -10000;  	// loop for each major tic  	for (int i = firstTic; i < nTics + firstTic; i++) {  		dVal = CalcMajorTicValue (baseVal' i);  		// If we're before the start of the scale' just go to the next tic  		if (dVal < _minLinTemp)  			continue;  		// if we've already past the end of the scale' then we're done  		if (dVal > _maxLinTemp + rangeTol)  			break;  		// convert the value to a pixel position  		pixVal = LocalTransform (dVal);  		// see if the tic marks will be drawn between the labels instead of at the labels  		// (this applies only to AxisType.Text  		if (tic._isBetweenLabels && IsText) {  			// We need one extra tic in order to draw the tics between labels  			// so provide an exception here  			if (i == 0) {  				dVal2 = CalcMajorTicValue (baseVal' -0.5);  				if (dVal2 >= _minLinTemp) {  					pixVal2 = LocalTransform (dVal2);  					tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  					//								grid.Draw( g' gridPen' pixVal2' topPix );  				}  			}  			dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  			if (dVal2 > _maxLinTemp)  				break;  			pixVal2 = LocalTransform (dVal2);  		}  		else  			pixVal2 = pixVal;  		tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  		// draw the grid  		//					grid.Draw( g' gridPen' pixVal2' topPix );  		bool isMaxValueAtMaxPix = ((_ownerAxis is XAxis || _ownerAxis is Y2Axis) && !IsReverse) || (_ownerAxis is Y2Axis && IsReverse);  		bool isSkipZone = (((_isSkipFirstLabel && isMaxValueAtMaxPix) || (_isSkipLastLabel && !isMaxValueAtMaxPix)) && pixVal < edgeTolerance) || (((_isSkipLastLabel && isMaxValueAtMaxPix) || (_isSkipFirstLabel && !isMaxValueAtMaxPix)) && pixVal > _maxPix - _minPix - edgeTolerance);  		bool isSkipCross = _isSkipCrossLabel && !_ownerAxis._crossAuto && Math.Abs (_ownerAxis._cross - dVal) < rangeTol * 10.0;  		isSkipZone = isSkipZone || isSkipCross;  		if (_isVisible && !isSkipZone) {  			// For exponential scales' just skip any label that would overlap with the previous one  			// This is because exponential scales have varying label spacing  			if (IsPreventLabelOverlap && Math.Abs (pixVal - lastPixVal) < maxLabelSize.Width)  				continue;  			DrawLabel (g' pane' i' dVal' pixVal' shift' maxSpace' scaledTic' charHeight' scaleFactor);  			lastPixVal = pixVal;  		}  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: using (Pen ticPen = tic.GetPen (pane' scaleFactor))//			using ( Pen gridPen = grid.GetPen( pane' scaleFactor ) )   {  	// get the Y position of the center of the axis labels  	// (the axis itself is referenced at zero)  	SizeF maxLabelSize = GetScaleMaxSpace (g' pane' scaleFactor' true);  	float charHeight = _fontSpec.GetHeight (scaleFactor);  	float maxSpace = maxLabelSize.Height;  	float edgeTolerance = Default.EdgeTolerance * scaleFactor;  	double rangeTol = (_maxLinTemp - _minLinTemp) * 0.001;  	int firstTic = (int)((_minLinTemp - baseVal) / _majorStep + 0.99);  	if (firstTic < 0)  		firstTic = 0;  	// save the position of the previous tic  	float lastPixVal = -10000;  	// loop for each major tic  	for (int i = firstTic; i < nTics + firstTic; i++) {  		dVal = CalcMajorTicValue (baseVal' i);  		// If we're before the start of the scale' just go to the next tic  		if (dVal < _minLinTemp)  			continue;  		// if we've already past the end of the scale' then we're done  		if (dVal > _maxLinTemp + rangeTol)  			break;  		// convert the value to a pixel position  		pixVal = LocalTransform (dVal);  		// see if the tic marks will be drawn between the labels instead of at the labels  		// (this applies only to AxisType.Text  		if (tic._isBetweenLabels && IsText) {  			// We need one extra tic in order to draw the tics between labels  			// so provide an exception here  			if (i == 0) {  				dVal2 = CalcMajorTicValue (baseVal' -0.5);  				if (dVal2 >= _minLinTemp) {  					pixVal2 = LocalTransform (dVal2);  					tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  					//								grid.Draw( g' gridPen' pixVal2' topPix );  				}  			}  			dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  			if (dVal2 > _maxLinTemp)  				break;  			pixVal2 = LocalTransform (dVal2);  		}  		else  			pixVal2 = pixVal;  		tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  		// draw the grid  		//					grid.Draw( g' gridPen' pixVal2' topPix );  		bool isMaxValueAtMaxPix = ((_ownerAxis is XAxis || _ownerAxis is Y2Axis) && !IsReverse) || (_ownerAxis is Y2Axis && IsReverse);  		bool isSkipZone = (((_isSkipFirstLabel && isMaxValueAtMaxPix) || (_isSkipLastLabel && !isMaxValueAtMaxPix)) && pixVal < edgeTolerance) || (((_isSkipLastLabel && isMaxValueAtMaxPix) || (_isSkipFirstLabel && !isMaxValueAtMaxPix)) && pixVal > _maxPix - _minPix - edgeTolerance);  		bool isSkipCross = _isSkipCrossLabel && !_ownerAxis._crossAuto && Math.Abs (_ownerAxis._cross - dVal) < rangeTol * 10.0;  		isSkipZone = isSkipZone || isSkipCross;  		if (_isVisible && !isSkipZone) {  			// For exponential scales' just skip any label that would overlap with the previous one  			// This is because exponential scales have varying label spacing  			if (IsPreventLabelOverlap && Math.Abs (pixVal - lastPixVal) < maxLabelSize.Width)  				continue;  			DrawLabel (g' pane' i' dVal' pixVal' shift' maxSpace' scaledTic' charHeight' scaleFactor);  			lastPixVal = pixVal;  		}  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: using (Pen ticPen = tic.GetPen (pane' scaleFactor))//			using ( Pen gridPen = grid.GetPen( pane' scaleFactor ) )   {  	// get the Y position of the center of the axis labels  	// (the axis itself is referenced at zero)  	SizeF maxLabelSize = GetScaleMaxSpace (g' pane' scaleFactor' true);  	float charHeight = _fontSpec.GetHeight (scaleFactor);  	float maxSpace = maxLabelSize.Height;  	float edgeTolerance = Default.EdgeTolerance * scaleFactor;  	double rangeTol = (_maxLinTemp - _minLinTemp) * 0.001;  	int firstTic = (int)((_minLinTemp - baseVal) / _majorStep + 0.99);  	if (firstTic < 0)  		firstTic = 0;  	// save the position of the previous tic  	float lastPixVal = -10000;  	// loop for each major tic  	for (int i = firstTic; i < nTics + firstTic; i++) {  		dVal = CalcMajorTicValue (baseVal' i);  		// If we're before the start of the scale' just go to the next tic  		if (dVal < _minLinTemp)  			continue;  		// if we've already past the end of the scale' then we're done  		if (dVal > _maxLinTemp + rangeTol)  			break;  		// convert the value to a pixel position  		pixVal = LocalTransform (dVal);  		// see if the tic marks will be drawn between the labels instead of at the labels  		// (this applies only to AxisType.Text  		if (tic._isBetweenLabels && IsText) {  			// We need one extra tic in order to draw the tics between labels  			// so provide an exception here  			if (i == 0) {  				dVal2 = CalcMajorTicValue (baseVal' -0.5);  				if (dVal2 >= _minLinTemp) {  					pixVal2 = LocalTransform (dVal2);  					tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  					//								grid.Draw( g' gridPen' pixVal2' topPix );  				}  			}  			dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  			if (dVal2 > _maxLinTemp)  				break;  			pixVal2 = LocalTransform (dVal2);  		}  		else  			pixVal2 = pixVal;  		tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  		// draw the grid  		//					grid.Draw( g' gridPen' pixVal2' topPix );  		bool isMaxValueAtMaxPix = ((_ownerAxis is XAxis || _ownerAxis is Y2Axis) && !IsReverse) || (_ownerAxis is Y2Axis && IsReverse);  		bool isSkipZone = (((_isSkipFirstLabel && isMaxValueAtMaxPix) || (_isSkipLastLabel && !isMaxValueAtMaxPix)) && pixVal < edgeTolerance) || (((_isSkipLastLabel && isMaxValueAtMaxPix) || (_isSkipFirstLabel && !isMaxValueAtMaxPix)) && pixVal > _maxPix - _minPix - edgeTolerance);  		bool isSkipCross = _isSkipCrossLabel && !_ownerAxis._crossAuto && Math.Abs (_ownerAxis._cross - dVal) < rangeTol * 10.0;  		isSkipZone = isSkipZone || isSkipCross;  		if (_isVisible && !isSkipZone) {  			// For exponential scales' just skip any label that would overlap with the previous one  			// This is because exponential scales have varying label spacing  			if (IsPreventLabelOverlap && Math.Abs (pixVal - lastPixVal) < maxLabelSize.Width)  				continue;  			DrawLabel (g' pane' i' dVal' pixVal' shift' maxSpace' scaledTic' charHeight' scaleFactor);  			lastPixVal = pixVal;  		}  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: using (Pen ticPen = tic.GetPen (pane' scaleFactor))//			using ( Pen gridPen = grid.GetPen( pane' scaleFactor ) )   {  	// get the Y position of the center of the axis labels  	// (the axis itself is referenced at zero)  	SizeF maxLabelSize = GetScaleMaxSpace (g' pane' scaleFactor' true);  	float charHeight = _fontSpec.GetHeight (scaleFactor);  	float maxSpace = maxLabelSize.Height;  	float edgeTolerance = Default.EdgeTolerance * scaleFactor;  	double rangeTol = (_maxLinTemp - _minLinTemp) * 0.001;  	int firstTic = (int)((_minLinTemp - baseVal) / _majorStep + 0.99);  	if (firstTic < 0)  		firstTic = 0;  	// save the position of the previous tic  	float lastPixVal = -10000;  	// loop for each major tic  	for (int i = firstTic; i < nTics + firstTic; i++) {  		dVal = CalcMajorTicValue (baseVal' i);  		// If we're before the start of the scale' just go to the next tic  		if (dVal < _minLinTemp)  			continue;  		// if we've already past the end of the scale' then we're done  		if (dVal > _maxLinTemp + rangeTol)  			break;  		// convert the value to a pixel position  		pixVal = LocalTransform (dVal);  		// see if the tic marks will be drawn between the labels instead of at the labels  		// (this applies only to AxisType.Text  		if (tic._isBetweenLabels && IsText) {  			// We need one extra tic in order to draw the tics between labels  			// so provide an exception here  			if (i == 0) {  				dVal2 = CalcMajorTicValue (baseVal' -0.5);  				if (dVal2 >= _minLinTemp) {  					pixVal2 = LocalTransform (dVal2);  					tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  					//								grid.Draw( g' gridPen' pixVal2' topPix );  				}  			}  			dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  			if (dVal2 > _maxLinTemp)  				break;  			pixVal2 = LocalTransform (dVal2);  		}  		else  			pixVal2 = pixVal;  		tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  		// draw the grid  		//					grid.Draw( g' gridPen' pixVal2' topPix );  		bool isMaxValueAtMaxPix = ((_ownerAxis is XAxis || _ownerAxis is Y2Axis) && !IsReverse) || (_ownerAxis is Y2Axis && IsReverse);  		bool isSkipZone = (((_isSkipFirstLabel && isMaxValueAtMaxPix) || (_isSkipLastLabel && !isMaxValueAtMaxPix)) && pixVal < edgeTolerance) || (((_isSkipLastLabel && isMaxValueAtMaxPix) || (_isSkipFirstLabel && !isMaxValueAtMaxPix)) && pixVal > _maxPix - _minPix - edgeTolerance);  		bool isSkipCross = _isSkipCrossLabel && !_ownerAxis._crossAuto && Math.Abs (_ownerAxis._cross - dVal) < rangeTol * 10.0;  		isSkipZone = isSkipZone || isSkipCross;  		if (_isVisible && !isSkipZone) {  			// For exponential scales' just skip any label that would overlap with the previous one  			// This is because exponential scales have varying label spacing  			if (IsPreventLabelOverlap && Math.Abs (pixVal - lastPixVal) < maxLabelSize.Width)  				continue;  			DrawLabel (g' pane' i' dVal' pixVal' shift' maxSpace' scaledTic' charHeight' scaleFactor);  			lastPixVal = pixVal;  		}  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: using (Pen ticPen = tic.GetPen (pane' scaleFactor))//			using ( Pen gridPen = grid.GetPen( pane' scaleFactor ) )   {  	// get the Y position of the center of the axis labels  	// (the axis itself is referenced at zero)  	SizeF maxLabelSize = GetScaleMaxSpace (g' pane' scaleFactor' true);  	float charHeight = _fontSpec.GetHeight (scaleFactor);  	float maxSpace = maxLabelSize.Height;  	float edgeTolerance = Default.EdgeTolerance * scaleFactor;  	double rangeTol = (_maxLinTemp - _minLinTemp) * 0.001;  	int firstTic = (int)((_minLinTemp - baseVal) / _majorStep + 0.99);  	if (firstTic < 0)  		firstTic = 0;  	// save the position of the previous tic  	float lastPixVal = -10000;  	// loop for each major tic  	for (int i = firstTic; i < nTics + firstTic; i++) {  		dVal = CalcMajorTicValue (baseVal' i);  		// If we're before the start of the scale' just go to the next tic  		if (dVal < _minLinTemp)  			continue;  		// if we've already past the end of the scale' then we're done  		if (dVal > _maxLinTemp + rangeTol)  			break;  		// convert the value to a pixel position  		pixVal = LocalTransform (dVal);  		// see if the tic marks will be drawn between the labels instead of at the labels  		// (this applies only to AxisType.Text  		if (tic._isBetweenLabels && IsText) {  			// We need one extra tic in order to draw the tics between labels  			// so provide an exception here  			if (i == 0) {  				dVal2 = CalcMajorTicValue (baseVal' -0.5);  				if (dVal2 >= _minLinTemp) {  					pixVal2 = LocalTransform (dVal2);  					tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  					//								grid.Draw( g' gridPen' pixVal2' topPix );  				}  			}  			dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  			if (dVal2 > _maxLinTemp)  				break;  			pixVal2 = LocalTransform (dVal2);  		}  		else  			pixVal2 = pixVal;  		tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  		// draw the grid  		//					grid.Draw( g' gridPen' pixVal2' topPix );  		bool isMaxValueAtMaxPix = ((_ownerAxis is XAxis || _ownerAxis is Y2Axis) && !IsReverse) || (_ownerAxis is Y2Axis && IsReverse);  		bool isSkipZone = (((_isSkipFirstLabel && isMaxValueAtMaxPix) || (_isSkipLastLabel && !isMaxValueAtMaxPix)) && pixVal < edgeTolerance) || (((_isSkipLastLabel && isMaxValueAtMaxPix) || (_isSkipFirstLabel && !isMaxValueAtMaxPix)) && pixVal > _maxPix - _minPix - edgeTolerance);  		bool isSkipCross = _isSkipCrossLabel && !_ownerAxis._crossAuto && Math.Abs (_ownerAxis._cross - dVal) < rangeTol * 10.0;  		isSkipZone = isSkipZone || isSkipCross;  		if (_isVisible && !isSkipZone) {  			// For exponential scales' just skip any label that would overlap with the previous one  			// This is because exponential scales have varying label spacing  			if (IsPreventLabelOverlap && Math.Abs (pixVal - lastPixVal) < maxLabelSize.Width)  				continue;  			DrawLabel (g' pane' i' dVal' pixVal' shift' maxSpace' scaledTic' charHeight' scaleFactor);  			lastPixVal = pixVal;  		}  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: for (int i = firstTic; i < nTics + firstTic; i++) {  	dVal = CalcMajorTicValue (baseVal' i);  	// If we're before the start of the scale' just go to the next tic  	if (dVal < _minLinTemp)  		continue;  	// if we've already past the end of the scale' then we're done  	if (dVal > _maxLinTemp + rangeTol)  		break;  	// convert the value to a pixel position  	pixVal = LocalTransform (dVal);  	// see if the tic marks will be drawn between the labels instead of at the labels  	// (this applies only to AxisType.Text  	if (tic._isBetweenLabels && IsText) {  		// We need one extra tic in order to draw the tics between labels  		// so provide an exception here  		if (i == 0) {  			dVal2 = CalcMajorTicValue (baseVal' -0.5);  			if (dVal2 >= _minLinTemp) {  				pixVal2 = LocalTransform (dVal2);  				tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  				//								grid.Draw( g' gridPen' pixVal2' topPix );  			}  		}  		dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  		if (dVal2 > _maxLinTemp)  			break;  		pixVal2 = LocalTransform (dVal2);  	}  	else  		pixVal2 = pixVal;  	tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  	// draw the grid  	//					grid.Draw( g' gridPen' pixVal2' topPix );  	bool isMaxValueAtMaxPix = ((_ownerAxis is XAxis || _ownerAxis is Y2Axis) && !IsReverse) || (_ownerAxis is Y2Axis && IsReverse);  	bool isSkipZone = (((_isSkipFirstLabel && isMaxValueAtMaxPix) || (_isSkipLastLabel && !isMaxValueAtMaxPix)) && pixVal < edgeTolerance) || (((_isSkipLastLabel && isMaxValueAtMaxPix) || (_isSkipFirstLabel && !isMaxValueAtMaxPix)) && pixVal > _maxPix - _minPix - edgeTolerance);  	bool isSkipCross = _isSkipCrossLabel && !_ownerAxis._crossAuto && Math.Abs (_ownerAxis._cross - dVal) < rangeTol * 10.0;  	isSkipZone = isSkipZone || isSkipCross;  	if (_isVisible && !isSkipZone) {  		// For exponential scales' just skip any label that would overlap with the previous one  		// This is because exponential scales have varying label spacing  		if (IsPreventLabelOverlap && Math.Abs (pixVal - lastPixVal) < maxLabelSize.Width)  			continue;  		DrawLabel (g' pane' i' dVal' pixVal' shift' maxSpace' scaledTic' charHeight' scaleFactor);  		lastPixVal = pixVal;  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: for (int i = firstTic; i < nTics + firstTic; i++) {  	dVal = CalcMajorTicValue (baseVal' i);  	// If we're before the start of the scale' just go to the next tic  	if (dVal < _minLinTemp)  		continue;  	// if we've already past the end of the scale' then we're done  	if (dVal > _maxLinTemp + rangeTol)  		break;  	// convert the value to a pixel position  	pixVal = LocalTransform (dVal);  	// see if the tic marks will be drawn between the labels instead of at the labels  	// (this applies only to AxisType.Text  	if (tic._isBetweenLabels && IsText) {  		// We need one extra tic in order to draw the tics between labels  		// so provide an exception here  		if (i == 0) {  			dVal2 = CalcMajorTicValue (baseVal' -0.5);  			if (dVal2 >= _minLinTemp) {  				pixVal2 = LocalTransform (dVal2);  				tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  				//								grid.Draw( g' gridPen' pixVal2' topPix );  			}  		}  		dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  		if (dVal2 > _maxLinTemp)  			break;  		pixVal2 = LocalTransform (dVal2);  	}  	else  		pixVal2 = pixVal;  	tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  	// draw the grid  	//					grid.Draw( g' gridPen' pixVal2' topPix );  	bool isMaxValueAtMaxPix = ((_ownerAxis is XAxis || _ownerAxis is Y2Axis) && !IsReverse) || (_ownerAxis is Y2Axis && IsReverse);  	bool isSkipZone = (((_isSkipFirstLabel && isMaxValueAtMaxPix) || (_isSkipLastLabel && !isMaxValueAtMaxPix)) && pixVal < edgeTolerance) || (((_isSkipLastLabel && isMaxValueAtMaxPix) || (_isSkipFirstLabel && !isMaxValueAtMaxPix)) && pixVal > _maxPix - _minPix - edgeTolerance);  	bool isSkipCross = _isSkipCrossLabel && !_ownerAxis._crossAuto && Math.Abs (_ownerAxis._cross - dVal) < rangeTol * 10.0;  	isSkipZone = isSkipZone || isSkipCross;  	if (_isVisible && !isSkipZone) {  		// For exponential scales' just skip any label that would overlap with the previous one  		// This is because exponential scales have varying label spacing  		if (IsPreventLabelOverlap && Math.Abs (pixVal - lastPixVal) < maxLabelSize.Width)  			continue;  		DrawLabel (g' pane' i' dVal' pixVal' shift' maxSpace' scaledTic' charHeight' scaleFactor);  		lastPixVal = pixVal;  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: for (int i = firstTic; i < nTics + firstTic; i++) {  	dVal = CalcMajorTicValue (baseVal' i);  	// If we're before the start of the scale' just go to the next tic  	if (dVal < _minLinTemp)  		continue;  	// if we've already past the end of the scale' then we're done  	if (dVal > _maxLinTemp + rangeTol)  		break;  	// convert the value to a pixel position  	pixVal = LocalTransform (dVal);  	// see if the tic marks will be drawn between the labels instead of at the labels  	// (this applies only to AxisType.Text  	if (tic._isBetweenLabels && IsText) {  		// We need one extra tic in order to draw the tics between labels  		// so provide an exception here  		if (i == 0) {  			dVal2 = CalcMajorTicValue (baseVal' -0.5);  			if (dVal2 >= _minLinTemp) {  				pixVal2 = LocalTransform (dVal2);  				tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  				//								grid.Draw( g' gridPen' pixVal2' topPix );  			}  		}  		dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  		if (dVal2 > _maxLinTemp)  			break;  		pixVal2 = LocalTransform (dVal2);  	}  	else  		pixVal2 = pixVal;  	tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  	// draw the grid  	//					grid.Draw( g' gridPen' pixVal2' topPix );  	bool isMaxValueAtMaxPix = ((_ownerAxis is XAxis || _ownerAxis is Y2Axis) && !IsReverse) || (_ownerAxis is Y2Axis && IsReverse);  	bool isSkipZone = (((_isSkipFirstLabel && isMaxValueAtMaxPix) || (_isSkipLastLabel && !isMaxValueAtMaxPix)) && pixVal < edgeTolerance) || (((_isSkipLastLabel && isMaxValueAtMaxPix) || (_isSkipFirstLabel && !isMaxValueAtMaxPix)) && pixVal > _maxPix - _minPix - edgeTolerance);  	bool isSkipCross = _isSkipCrossLabel && !_ownerAxis._crossAuto && Math.Abs (_ownerAxis._cross - dVal) < rangeTol * 10.0;  	isSkipZone = isSkipZone || isSkipCross;  	if (_isVisible && !isSkipZone) {  		// For exponential scales' just skip any label that would overlap with the previous one  		// This is because exponential scales have varying label spacing  		if (IsPreventLabelOverlap && Math.Abs (pixVal - lastPixVal) < maxLabelSize.Width)  			continue;  		DrawLabel (g' pane' i' dVal' pixVal' shift' maxSpace' scaledTic' charHeight' scaleFactor);  		lastPixVal = pixVal;  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: if (tic._isBetweenLabels && IsText) {  	// We need one extra tic in order to draw the tics between labels  	// so provide an exception here  	if (i == 0) {  		dVal2 = CalcMajorTicValue (baseVal' -0.5);  		if (dVal2 >= _minLinTemp) {  			pixVal2 = LocalTransform (dVal2);  			tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  			//								grid.Draw( g' gridPen' pixVal2' topPix );  		}  	}  	dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  	if (dVal2 > _maxLinTemp)  		break;  	pixVal2 = LocalTransform (dVal2);  }  else  	pixVal2 = pixVal;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: if (tic._isBetweenLabels && IsText) {  	// We need one extra tic in order to draw the tics between labels  	// so provide an exception here  	if (i == 0) {  		dVal2 = CalcMajorTicValue (baseVal' -0.5);  		if (dVal2 >= _minLinTemp) {  			pixVal2 = LocalTransform (dVal2);  			tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  			//								grid.Draw( g' gridPen' pixVal2' topPix );  		}  	}  	dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  	if (dVal2 > _maxLinTemp)  		break;  	pixVal2 = LocalTransform (dVal2);  }  else  	pixVal2 = pixVal;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: if (i == 0) {  	dVal2 = CalcMajorTicValue (baseVal' -0.5);  	if (dVal2 >= _minLinTemp) {  		pixVal2 = LocalTransform (dVal2);  		tic.Draw (g' pane' ticPen' pixVal2' topPix' shift' scaledTic);  		//								grid.Draw( g' gridPen' pixVal2' topPix );  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: dVal2 = CalcMajorTicValue (baseVal' -0.5);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawLabels,The following statement contains a magic number: dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: using (Pen gridPen = grid.GetPen (pane' scaleFactor)) {  	// get the Y position of the center of the axis labels  	// (the axis itself is referenced at zero)  	//				SizeF maxLabelSize = GetScaleMaxSpace( g' pane' scaleFactor' true );  	//				float charHeight = _fontSpec.GetHeight( scaleFactor );  	//				float maxSpace = maxLabelSize.Height;  	//				float edgeTolerance = Default.EdgeTolerance * scaleFactor;  	double rangeTol = (_maxLinTemp - _minLinTemp) * 0.001;  	int firstTic = (int)((_minLinTemp - baseVal) / _majorStep + 0.99);  	if (firstTic < 0)  		firstTic = 0;  	// save the position of the previous tic  	//				float lastPixVal = -10000;  	// loop for each major tic  	for (int i = firstTic; i < nTics + firstTic; i++) {  		dVal = CalcMajorTicValue (baseVal' i);  		// If we're before the start of the scale' just go to the next tic  		if (dVal < _minLinTemp)  			continue;  		// if we've already past the end of the scale' then we're done  		if (dVal > _maxLinTemp + rangeTol)  			break;  		// convert the value to a pixel position  		pixVal = LocalTransform (dVal);  		// see if the tic marks will be drawn between the labels instead of at the labels  		// (this applies only to AxisType.Text  		if (tic._isBetweenLabels && IsText) {  			// We need one extra tic in order to draw the tics between labels  			// so provide an exception here  			if (i == 0) {  				dVal2 = CalcMajorTicValue (baseVal' -0.5);  				if (dVal2 >= _minLinTemp) {  					pixVal2 = LocalTransform (dVal2);  					grid.Draw (g' gridPen' pixVal2' topPix);  				}  			}  			dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  			if (dVal2 > _maxLinTemp)  				break;  			pixVal2 = LocalTransform (dVal2);  		}  		else  			pixVal2 = pixVal;  		// draw the grid  		grid.Draw (g' gridPen' pixVal2' topPix);  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: using (Pen gridPen = grid.GetPen (pane' scaleFactor)) {  	// get the Y position of the center of the axis labels  	// (the axis itself is referenced at zero)  	//				SizeF maxLabelSize = GetScaleMaxSpace( g' pane' scaleFactor' true );  	//				float charHeight = _fontSpec.GetHeight( scaleFactor );  	//				float maxSpace = maxLabelSize.Height;  	//				float edgeTolerance = Default.EdgeTolerance * scaleFactor;  	double rangeTol = (_maxLinTemp - _minLinTemp) * 0.001;  	int firstTic = (int)((_minLinTemp - baseVal) / _majorStep + 0.99);  	if (firstTic < 0)  		firstTic = 0;  	// save the position of the previous tic  	//				float lastPixVal = -10000;  	// loop for each major tic  	for (int i = firstTic; i < nTics + firstTic; i++) {  		dVal = CalcMajorTicValue (baseVal' i);  		// If we're before the start of the scale' just go to the next tic  		if (dVal < _minLinTemp)  			continue;  		// if we've already past the end of the scale' then we're done  		if (dVal > _maxLinTemp + rangeTol)  			break;  		// convert the value to a pixel position  		pixVal = LocalTransform (dVal);  		// see if the tic marks will be drawn between the labels instead of at the labels  		// (this applies only to AxisType.Text  		if (tic._isBetweenLabels && IsText) {  			// We need one extra tic in order to draw the tics between labels  			// so provide an exception here  			if (i == 0) {  				dVal2 = CalcMajorTicValue (baseVal' -0.5);  				if (dVal2 >= _minLinTemp) {  					pixVal2 = LocalTransform (dVal2);  					grid.Draw (g' gridPen' pixVal2' topPix);  				}  			}  			dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  			if (dVal2 > _maxLinTemp)  				break;  			pixVal2 = LocalTransform (dVal2);  		}  		else  			pixVal2 = pixVal;  		// draw the grid  		grid.Draw (g' gridPen' pixVal2' topPix);  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: using (Pen gridPen = grid.GetPen (pane' scaleFactor)) {  	// get the Y position of the center of the axis labels  	// (the axis itself is referenced at zero)  	//				SizeF maxLabelSize = GetScaleMaxSpace( g' pane' scaleFactor' true );  	//				float charHeight = _fontSpec.GetHeight( scaleFactor );  	//				float maxSpace = maxLabelSize.Height;  	//				float edgeTolerance = Default.EdgeTolerance * scaleFactor;  	double rangeTol = (_maxLinTemp - _minLinTemp) * 0.001;  	int firstTic = (int)((_minLinTemp - baseVal) / _majorStep + 0.99);  	if (firstTic < 0)  		firstTic = 0;  	// save the position of the previous tic  	//				float lastPixVal = -10000;  	// loop for each major tic  	for (int i = firstTic; i < nTics + firstTic; i++) {  		dVal = CalcMajorTicValue (baseVal' i);  		// If we're before the start of the scale' just go to the next tic  		if (dVal < _minLinTemp)  			continue;  		// if we've already past the end of the scale' then we're done  		if (dVal > _maxLinTemp + rangeTol)  			break;  		// convert the value to a pixel position  		pixVal = LocalTransform (dVal);  		// see if the tic marks will be drawn between the labels instead of at the labels  		// (this applies only to AxisType.Text  		if (tic._isBetweenLabels && IsText) {  			// We need one extra tic in order to draw the tics between labels  			// so provide an exception here  			if (i == 0) {  				dVal2 = CalcMajorTicValue (baseVal' -0.5);  				if (dVal2 >= _minLinTemp) {  					pixVal2 = LocalTransform (dVal2);  					grid.Draw (g' gridPen' pixVal2' topPix);  				}  			}  			dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  			if (dVal2 > _maxLinTemp)  				break;  			pixVal2 = LocalTransform (dVal2);  		}  		else  			pixVal2 = pixVal;  		// draw the grid  		grid.Draw (g' gridPen' pixVal2' topPix);  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: using (Pen gridPen = grid.GetPen (pane' scaleFactor)) {  	// get the Y position of the center of the axis labels  	// (the axis itself is referenced at zero)  	//				SizeF maxLabelSize = GetScaleMaxSpace( g' pane' scaleFactor' true );  	//				float charHeight = _fontSpec.GetHeight( scaleFactor );  	//				float maxSpace = maxLabelSize.Height;  	//				float edgeTolerance = Default.EdgeTolerance * scaleFactor;  	double rangeTol = (_maxLinTemp - _minLinTemp) * 0.001;  	int firstTic = (int)((_minLinTemp - baseVal) / _majorStep + 0.99);  	if (firstTic < 0)  		firstTic = 0;  	// save the position of the previous tic  	//				float lastPixVal = -10000;  	// loop for each major tic  	for (int i = firstTic; i < nTics + firstTic; i++) {  		dVal = CalcMajorTicValue (baseVal' i);  		// If we're before the start of the scale' just go to the next tic  		if (dVal < _minLinTemp)  			continue;  		// if we've already past the end of the scale' then we're done  		if (dVal > _maxLinTemp + rangeTol)  			break;  		// convert the value to a pixel position  		pixVal = LocalTransform (dVal);  		// see if the tic marks will be drawn between the labels instead of at the labels  		// (this applies only to AxisType.Text  		if (tic._isBetweenLabels && IsText) {  			// We need one extra tic in order to draw the tics between labels  			// so provide an exception here  			if (i == 0) {  				dVal2 = CalcMajorTicValue (baseVal' -0.5);  				if (dVal2 >= _minLinTemp) {  					pixVal2 = LocalTransform (dVal2);  					grid.Draw (g' gridPen' pixVal2' topPix);  				}  			}  			dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  			if (dVal2 > _maxLinTemp)  				break;  			pixVal2 = LocalTransform (dVal2);  		}  		else  			pixVal2 = pixVal;  		// draw the grid  		grid.Draw (g' gridPen' pixVal2' topPix);  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: for (int i = firstTic; i < nTics + firstTic; i++) {  	dVal = CalcMajorTicValue (baseVal' i);  	// If we're before the start of the scale' just go to the next tic  	if (dVal < _minLinTemp)  		continue;  	// if we've already past the end of the scale' then we're done  	if (dVal > _maxLinTemp + rangeTol)  		break;  	// convert the value to a pixel position  	pixVal = LocalTransform (dVal);  	// see if the tic marks will be drawn between the labels instead of at the labels  	// (this applies only to AxisType.Text  	if (tic._isBetweenLabels && IsText) {  		// We need one extra tic in order to draw the tics between labels  		// so provide an exception here  		if (i == 0) {  			dVal2 = CalcMajorTicValue (baseVal' -0.5);  			if (dVal2 >= _minLinTemp) {  				pixVal2 = LocalTransform (dVal2);  				grid.Draw (g' gridPen' pixVal2' topPix);  			}  		}  		dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  		if (dVal2 > _maxLinTemp)  			break;  		pixVal2 = LocalTransform (dVal2);  	}  	else  		pixVal2 = pixVal;  	// draw the grid  	grid.Draw (g' gridPen' pixVal2' topPix);  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: for (int i = firstTic; i < nTics + firstTic; i++) {  	dVal = CalcMajorTicValue (baseVal' i);  	// If we're before the start of the scale' just go to the next tic  	if (dVal < _minLinTemp)  		continue;  	// if we've already past the end of the scale' then we're done  	if (dVal > _maxLinTemp + rangeTol)  		break;  	// convert the value to a pixel position  	pixVal = LocalTransform (dVal);  	// see if the tic marks will be drawn between the labels instead of at the labels  	// (this applies only to AxisType.Text  	if (tic._isBetweenLabels && IsText) {  		// We need one extra tic in order to draw the tics between labels  		// so provide an exception here  		if (i == 0) {  			dVal2 = CalcMajorTicValue (baseVal' -0.5);  			if (dVal2 >= _minLinTemp) {  				pixVal2 = LocalTransform (dVal2);  				grid.Draw (g' gridPen' pixVal2' topPix);  			}  		}  		dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  		if (dVal2 > _maxLinTemp)  			break;  		pixVal2 = LocalTransform (dVal2);  	}  	else  		pixVal2 = pixVal;  	// draw the grid  	grid.Draw (g' gridPen' pixVal2' topPix);  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: if (tic._isBetweenLabels && IsText) {  	// We need one extra tic in order to draw the tics between labels  	// so provide an exception here  	if (i == 0) {  		dVal2 = CalcMajorTicValue (baseVal' -0.5);  		if (dVal2 >= _minLinTemp) {  			pixVal2 = LocalTransform (dVal2);  			grid.Draw (g' gridPen' pixVal2' topPix);  		}  	}  	dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  	if (dVal2 > _maxLinTemp)  		break;  	pixVal2 = LocalTransform (dVal2);  }  else  	pixVal2 = pixVal;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: if (tic._isBetweenLabels && IsText) {  	// We need one extra tic in order to draw the tics between labels  	// so provide an exception here  	if (i == 0) {  		dVal2 = CalcMajorTicValue (baseVal' -0.5);  		if (dVal2 >= _minLinTemp) {  			pixVal2 = LocalTransform (dVal2);  			grid.Draw (g' gridPen' pixVal2' topPix);  		}  	}  	dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  	if (dVal2 > _maxLinTemp)  		break;  	pixVal2 = LocalTransform (dVal2);  }  else  	pixVal2 = pixVal;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: if (i == 0) {  	dVal2 = CalcMajorTicValue (baseVal' -0.5);  	if (dVal2 >= _minLinTemp) {  		pixVal2 = LocalTransform (dVal2);  		grid.Draw (g' gridPen' pixVal2' topPix);  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: dVal2 = CalcMajorTicValue (baseVal' -0.5);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,DrawGrid,The following statement contains a magic number: dVal2 = CalcMajorTicValue (baseVal' (double)i + 0.5);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,GetTopRightPix,The following statement contains a magic number: if (!IsLog) {  	if (_majorStep <= 0 || _minorStep <= 0)  		return;  	double tMajor = (_max - _min) / (_majorStep * MajorUnitMultiplier);  	double tMinor = (_max - _min) / (_minorStep * MinorUnitMultiplier);  	MinorTic minorTic = _ownerAxis._minorTic;  	if (tMajor > 1000 || ((minorTic.IsOutside || minorTic.IsInside || minorTic.IsOpposite) && tMinor > 5000))  		return;  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,GetTopRightPix,The following statement contains a magic number: if (!IsLog) {  	if (_majorStep <= 0 || _minorStep <= 0)  		return;  	double tMajor = (_max - _min) / (_majorStep * MajorUnitMultiplier);  	double tMinor = (_max - _min) / (_minorStep * MinorUnitMultiplier);  	MinorTic minorTic = _ownerAxis._minorTic;  	if (tMajor > 1000 || ((minorTic.IsOutside || minorTic.IsInside || minorTic.IsOpposite) && tMinor > 5000))  		return;  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,GetTopRightPix,The following statement contains a magic number: if (tMajor > 1000 || ((minorTic.IsOutside || minorTic.IsInside || minorTic.IsOpposite) && tMinor > 5000))  	return;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,GetTopRightPix,The following statement contains a magic number: if (tMajor > 1000 || ((minorTic.IsOutside || minorTic.IsInside || minorTic.IsOpposite) && tMinor > 5000))  	return;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: if (_max == _min && _maxAuto && _minAuto) {  	if (Math.Abs (_max) > 1e-100) {  		_max *= (_min < 0 ? 0.95 : 1.05);  		_min *= (_min < 0 ? 1.05 : 0.95);  	}  	else {  		_max = 1.0;  		_min = -1.0;  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: if (_max == _min && _maxAuto && _minAuto) {  	if (Math.Abs (_max) > 1e-100) {  		_max *= (_min < 0 ? 0.95 : 1.05);  		_min *= (_min < 0 ? 1.05 : 0.95);  	}  	else {  		_max = 1.0;  		_min = -1.0;  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: if (_max == _min && _maxAuto && _minAuto) {  	if (Math.Abs (_max) > 1e-100) {  		_max *= (_min < 0 ? 0.95 : 1.05);  		_min *= (_min < 0 ? 1.05 : 0.95);  	}  	else {  		_max = 1.0;  		_min = -1.0;  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: if (_max == _min && _maxAuto && _minAuto) {  	if (Math.Abs (_max) > 1e-100) {  		_max *= (_min < 0 ? 0.95 : 1.05);  		_min *= (_min < 0 ? 1.05 : 0.95);  	}  	else {  		_max = 1.0;  		_min = -1.0;  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: if (_max == _min && _maxAuto && _minAuto) {  	if (Math.Abs (_max) > 1e-100) {  		_max *= (_min < 0 ? 0.95 : 1.05);  		_min *= (_min < 0 ? 1.05 : 0.95);  	}  	else {  		_max = 1.0;  		_min = -1.0;  	}  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: if (Math.Abs (_max) > 1e-100) {  	_max *= (_min < 0 ? 0.95 : 1.05);  	_min *= (_min < 0 ? 1.05 : 0.95);  }  else {  	_max = 1.0;  	_min = -1.0;  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: if (Math.Abs (_max) > 1e-100) {  	_max *= (_min < 0 ? 0.95 : 1.05);  	_min *= (_min < 0 ? 1.05 : 0.95);  }  else {  	_max = 1.0;  	_min = -1.0;  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: if (Math.Abs (_max) > 1e-100) {  	_max *= (_min < 0 ? 0.95 : 1.05);  	_min *= (_min < 0 ? 1.05 : 0.95);  }  else {  	_max = 1.0;  	_min = -1.0;  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: if (Math.Abs (_max) > 1e-100) {  	_max *= (_min < 0 ? 0.95 : 1.05);  	_min *= (_min < 0 ? 1.05 : 0.95);  }  else {  	_max = 1.0;  	_min = -1.0;  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: if (Math.Abs (_max) > 1e-100) {  	_max *= (_min < 0 ? 0.95 : 1.05);  	_min *= (_min < 0 ? 1.05 : 0.95);  }  else {  	_max = 1.0;  	_min = -1.0;  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: _max *= (_min < 0 ? 0.95 : 1.05);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: _max *= (_min < 0 ? 0.95 : 1.05);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: _min *= (_min < 0 ? 1.05 : 0.95);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,PickScale,The following statement contains a magic number: _min *= (_min < 0 ? 1.05 : 0.95);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcMaxLabels,The following statement contains a magic number: if (costh > 0.001)  	maxWidth = size.Width / costh;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcMaxLabels,The following statement contains a magic number: if (sinth > 0.001)  	temp = size.Height / sinth;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcMaxLabels,The following statement contains a magic number: if (_ownerAxis is XAxis || _ownerAxis is X2Axis)  	width = (chartRect.Width == 0) ? pane.Rect.Width * 0.75 : chartRect.Width;  else  	width = (chartRect.Height == 0) ? pane.Rect.Height * 0.75 : chartRect.Height;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcMaxLabels,The following statement contains a magic number: if (_ownerAxis is XAxis || _ownerAxis is X2Axis)  	width = (chartRect.Width == 0) ? pane.Rect.Width * 0.75 : chartRect.Width;  else  	width = (chartRect.Height == 0) ? pane.Rect.Height * 0.75 : chartRect.Height;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcMaxLabels,The following statement contains a magic number: width = (chartRect.Width == 0) ? pane.Rect.Width * 0.75 : chartRect.Width;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcMaxLabels,The following statement contains a magic number: width = (chartRect.Height == 0) ? pane.Rect.Height * 0.75 : chartRect.Height;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = -100;  	double mag2 = -100;  	if (Math.Abs (_min) > 1.0e-30)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-30)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	mag = Math.Max (mag2' mag);  	// Do not use scale multiples for magnitudes below 4  	if (mag == -100 || Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = -100;  	double mag2 = -100;  	if (Math.Abs (_min) > 1.0e-30)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-30)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	mag = Math.Max (mag2' mag);  	// Do not use scale multiples for magnitudes below 4  	if (mag == -100 || Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = -100;  	double mag2 = -100;  	if (Math.Abs (_min) > 1.0e-30)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-30)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	mag = Math.Max (mag2' mag);  	// Do not use scale multiples for magnitudes below 4  	if (mag == -100 || Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = -100;  	double mag2 = -100;  	if (Math.Abs (_min) > 1.0e-30)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-30)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	mag = Math.Max (mag2' mag);  	// Do not use scale multiples for magnitudes below 4  	if (mag == -100 || Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = -100;  	double mag2 = -100;  	if (Math.Abs (_min) > 1.0e-30)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-30)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	mag = Math.Max (mag2' mag);  	// Do not use scale multiples for magnitudes below 4  	if (mag == -100 || Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = -100;  	double mag2 = -100;  	if (Math.Abs (_min) > 1.0e-30)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-30)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	mag = Math.Max (mag2' mag);  	// Do not use scale multiples for magnitudes below 4  	if (mag == -100 || Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = -100;  	double mag2 = -100;  	if (Math.Abs (_min) > 1.0e-30)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-30)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	mag = Math.Max (mag2' mag);  	// Do not use scale multiples for magnitudes below 4  	if (mag == -100 || Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (_magAuto) {  	// Find the optimal scale display multiple  	double mag = -100;  	double mag2 = -100;  	if (Math.Abs (_min) > 1.0e-30)  		mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  	if (Math.Abs (_max) > 1.0e-30)  		mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  	mag = Math.Max (mag2' mag);  	// Do not use scale multiples for magnitudes below 4  	if (mag == -100 || Math.Abs (mag) <= 3)  		mag = 0;  	// Use a power of 10 that is a multiple of 3 (engineering scale)  	_mag = (int)(Math.Floor (mag / 3.0) * 3.0);  }  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (Math.Abs (_min) > 1.0e-30)  	mag = Math.Floor (Math.Log10 (Math.Abs (_min)));  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (Math.Abs (_max) > 1.0e-30)  	mag2 = Math.Floor (Math.Log10 (Math.Abs (_max)));  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (mag == -100 || Math.Abs (mag) <= 3)  	mag = 0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: if (mag == -100 || Math.Abs (mag) <= 3)  	mag = 0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: _mag = (int)(Math.Floor (mag / 3.0) * 3.0);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SetScaleMag,The following statement contains a magic number: _mag = (int)(Math.Floor (mag / 3.0) * 3.0);  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: if (magMsd > 5.0)  	magMsd = 10.0;  else if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: if (magMsd > 5.0)  	magMsd = 10.0;  else if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: if (magMsd > 5.0)  	magMsd = 10.0;  else if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: if (magMsd > 5.0)  	magMsd = 10.0;  else if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: if (magMsd > 5.0)  	magMsd = 10.0;  else if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: magMsd = 10.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: magMsd = 5.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcStepSize,The following statement contains a magic number: magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: if (magMsd > 5.0)  	magMsd = 10.0;  else if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: if (magMsd > 5.0)  	magMsd = 10.0;  else if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: if (magMsd > 5.0)  	magMsd = 10.0;  else if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: if (magMsd > 5.0)  	magMsd = 10.0;  else if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: if (magMsd > 5.0)  	magMsd = 10.0;  else if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: magMsd = 10.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: if (magMsd > 2.0)  	magMsd = 5.0;  else if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: magMsd = 5.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: if (magMsd > 1.0)  	magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcBoundedStepSize,The following statement contains a magic number: magMsd = 2.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcNumTics,The following statement contains a magic number: nTics = (int)((_max - _min) / _majorStep + 0.01) + 1;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcNumTics,The following statement contains a magic number: if (nTics < 1)  	nTics = 1;  else if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcNumTics,The following statement contains a magic number: if (nTics < 1)  	nTics = 1;  else if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcNumTics,The following statement contains a magic number: if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcNumTics,The following statement contains a magic number: if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,CalcNumTics,The following statement contains a magic number: nTics = 1000;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,Transform,The following statement contains a magic number: if (denom > 1e-100)  	ratio = (Linearize (x) - _minLinTemp) / denom;  else  	ratio = 0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SafeLog,The following statement contains a magic number: if (x > 1.0e-20)  	return Math.Log10 (x);  else  	return 0.0;  
Magic Number,ZedGraph,Scale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Scale.cs,SafeExp,The following statement contains a magic number: if (x > 1.0e-20)  	return Math.Pow (x' exponent);  else  	return 0.0;  
Magic Number,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,Symbol,The following statement contains a magic number: if (sch >= 11)  	_userSymbol = (GraphicsPath)info.GetValue ("userSymbol"' typeof(GraphicsPath));  else  	_userSymbol = null;  
Magic Number,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The following statement contains a magic number: if (_isVisible && this.Type != SymbolType.None && x < 100000 && x > -100000 && y < 100000 && y > -100000) {  	Matrix saveMatrix = g.Transform;  	g.TranslateTransform (x' y);  	// Fill or draw the symbol as required  	if (_fill.IsVisible)  		g.FillPath (brush' path);  	//FillPoint( g' x' y' scaleFactor' pen' brush );  	if (_border.IsVisible)  		g.DrawPath (pen' path);  	//DrawPoint( g' x' y' scaleFactor' pen );  	g.Transform = saveMatrix;  }  
Magic Number,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The following statement contains a magic number: if (_isVisible && this.Type != SymbolType.None && x < 100000 && x > -100000 && y < 100000 && y > -100000) {  	Matrix saveMatrix = g.Transform;  	g.TranslateTransform (x' y);  	// Fill or draw the symbol as required  	if (_fill.IsVisible)  		g.FillPath (brush' path);  	//FillPoint( g' x' y' scaleFactor' pen' brush );  	if (_border.IsVisible)  		g.DrawPath (pen' path);  	//DrawPoint( g' x' y' scaleFactor' pen );  	g.Transform = saveMatrix;  }  
Magic Number,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The following statement contains a magic number: if (_isVisible && this.Type != SymbolType.None && x < 100000 && x > -100000 && y < 100000 && y > -100000) {  	Matrix saveMatrix = g.Transform;  	g.TranslateTransform (x' y);  	// Fill or draw the symbol as required  	if (_fill.IsVisible)  		g.FillPath (brush' path);  	//FillPoint( g' x' y' scaleFactor' pen' brush );  	if (_border.IsVisible)  		g.DrawPath (pen' path);  	//DrawPoint( g' x' y' scaleFactor' pen );  	g.Transform = saveMatrix;  }  
Magic Number,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The following statement contains a magic number: if (_isVisible && this.Type != SymbolType.None && x < 100000 && x > -100000 && y < 100000 && y > -100000) {  	Matrix saveMatrix = g.Transform;  	g.TranslateTransform (x' y);  	// Fill or draw the symbol as required  	if (_fill.IsVisible)  		g.FillPath (brush' path);  	//FillPoint( g' x' y' scaleFactor' pen' brush );  	if (_border.IsVisible)  		g.DrawPath (pen' path);  	//DrawPoint( g' x' y' scaleFactor' pen );  	g.Transform = saveMatrix;  }  
Magic Number,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The following statement contains a magic number: if (_isVisible && this.Type != SymbolType.None && x < 100000 && x > -100000 && y < 100000 && y > -100000) {  	SmoothingMode sModeSave = g.SmoothingMode;  	if (_isAntiAlias)  		g.SmoothingMode = SmoothingMode.HighQuality;  	using (Pen pen = _border.GetPen (pane' scaleFactor' dataValue))  		using (GraphicsPath path = this.MakePath (g' scaleFactor))  			using (Brush brush = this.Fill.MakeBrush (path.GetBounds ()' dataValue)) {  				DrawSymbol (g' x' y' path' pen' brush);  			}  	g.SmoothingMode = sModeSave;  }  
Magic Number,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The following statement contains a magic number: if (_isVisible && this.Type != SymbolType.None && x < 100000 && x > -100000 && y < 100000 && y > -100000) {  	SmoothingMode sModeSave = g.SmoothingMode;  	if (_isAntiAlias)  		g.SmoothingMode = SmoothingMode.HighQuality;  	using (Pen pen = _border.GetPen (pane' scaleFactor' dataValue))  		using (GraphicsPath path = this.MakePath (g' scaleFactor))  			using (Brush brush = this.Fill.MakeBrush (path.GetBounds ()' dataValue)) {  				DrawSymbol (g' x' y' path' pen' brush);  			}  	g.SmoothingMode = sModeSave;  }  
Magic Number,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The following statement contains a magic number: if (_isVisible && this.Type != SymbolType.None && x < 100000 && x > -100000 && y < 100000 && y > -100000) {  	SmoothingMode sModeSave = g.SmoothingMode;  	if (_isAntiAlias)  		g.SmoothingMode = SmoothingMode.HighQuality;  	using (Pen pen = _border.GetPen (pane' scaleFactor' dataValue))  		using (GraphicsPath path = this.MakePath (g' scaleFactor))  			using (Brush brush = this.Fill.MakeBrush (path.GetBounds ()' dataValue)) {  				DrawSymbol (g' x' y' path' pen' brush);  			}  	g.SmoothingMode = sModeSave;  }  
Magic Number,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,DrawSymbol,The following statement contains a magic number: if (_isVisible && this.Type != SymbolType.None && x < 100000 && x > -100000 && y < 100000 && y > -100000) {  	SmoothingMode sModeSave = g.SmoothingMode;  	if (_isAntiAlias)  		g.SmoothingMode = SmoothingMode.HighQuality;  	using (Pen pen = _border.GetPen (pane' scaleFactor' dataValue))  		using (GraphicsPath path = this.MakePath (g' scaleFactor))  			using (Brush brush = this.Fill.MakeBrush (path.GetBounds ()' dataValue)) {  				DrawSymbol (g' x' y' path' pen' brush);  			}  	g.SmoothingMode = sModeSave;  }  
Magic Number,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,Draw,The following statement contains a magic number: if (pix.X > -100000 && pix.X < 100000 && pix.Y > -100000 && pix.Y < 100000) {  	//if ( this.layoutSize.IsEmpty )  	//	this.FontSpec.Draw( g' pane.IsPenWidthScaled' this.text' pix.X' pix.Y'  	//		this.location.AlignH' this.location.AlignV' scaleFactor );  	//else  	this.FontSpec.Draw (g' pane' _text' pix.X' pix.Y' _location.AlignH' _location.AlignV' scaleFactor' _layoutArea);  }  
Magic Number,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,Draw,The following statement contains a magic number: if (pix.X > -100000 && pix.X < 100000 && pix.Y > -100000 && pix.Y < 100000) {  	//if ( this.layoutSize.IsEmpty )  	//	this.FontSpec.Draw( g' pane.IsPenWidthScaled' this.text' pix.X' pix.Y'  	//		this.location.AlignH' this.location.AlignV' scaleFactor );  	//else  	this.FontSpec.Draw (g' pane' _text' pix.X' pix.Y' _location.AlignH' _location.AlignV' scaleFactor' _layoutArea);  }  
Magic Number,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,Draw,The following statement contains a magic number: if (pix.X > -100000 && pix.X < 100000 && pix.Y > -100000 && pix.Y < 100000) {  	//if ( this.layoutSize.IsEmpty )  	//	this.FontSpec.Draw( g' pane.IsPenWidthScaled' this.text' pix.X' pix.Y'  	//		this.location.AlignH' this.location.AlignV' scaleFactor );  	//else  	this.FontSpec.Draw (g' pane' _text' pix.X' pix.Y' _location.AlignH' _location.AlignV' scaleFactor' _layoutArea);  }  
Magic Number,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,Draw,The following statement contains a magic number: if (pix.X > -100000 && pix.X < 100000 && pix.Y > -100000 && pix.Y < 100000) {  	//if ( this.layoutSize.IsEmpty )  	//	this.FontSpec.Draw( g' pane.IsPenWidthScaled' this.text' pix.X' pix.Y'  	//		this.location.AlignH' this.location.AlignV' scaleFactor );  	//else  	this.FontSpec.Draw (g' pane' _text' pix.X' pix.Y' _location.AlignH' _location.AlignV' scaleFactor' _layoutArea);  }  
Magic Number,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}'{4:f0}'{5:f0}'{6:f0}'{7:f0}'"' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y' pts [2].X' pts [2].Y' pts [3].X' pts [3].Y);  
Magic Number,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}'{4:f0}'{5:f0}'{6:f0}'{7:f0}'"' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y' pts [2].X' pts [2].Y' pts [3].X' pts [3].Y);  
Magic Number,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}'{4:f0}'{5:f0}'{6:f0}'{7:f0}'"' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y' pts [2].X' pts [2].Y' pts [3].X' pts [3].Y);  
Magic Number,ZedGraph,TextObj,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextObj.cs,GetCoords,The following statement contains a magic number: coords = String.Format ("{0:f0}'{1:f0}'{2:f0}'{3:f0}'{4:f0}'{5:f0}'{6:f0}'{7:f0}'"' pts [0].X' pts [0].Y' pts [1].X' pts [1].Y' pts [2].X' pts [2].Y' pts [3].X' pts [3].Y);  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,CalcNumTics,The following statement contains a magic number: if (_textLabels == null)  	nTics = 10;  else  	nTics = _textLabels.Length;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,CalcNumTics,The following statement contains a magic number: nTics = 10;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics < 1)  	nTics = 1;  else if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics < 1)  	nTics = 1;  else if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,CalcNumTics,The following statement contains a magic number: if (nTics > 1000)  	nTics = 1000;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,CalcNumTics,The following statement contains a magic number: nTics = 1000;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_textLabels != null) {  	if (_minAuto)  		_min = 0.5;  	if (_maxAuto)  		_max = _textLabels.Length + 0.5;  }  else {  	if (_minAuto)  		_min -= 0.5;  	if (_maxAuto)  		_max += 0.5;  }  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_textLabels != null) {  	if (_minAuto)  		_min = 0.5;  	if (_maxAuto)  		_max = _textLabels.Length + 0.5;  }  else {  	if (_minAuto)  		_min -= 0.5;  	if (_maxAuto)  		_max += 0.5;  }  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_textLabels != null) {  	if (_minAuto)  		_min = 0.5;  	if (_maxAuto)  		_max = _textLabels.Length + 0.5;  }  else {  	if (_minAuto)  		_min -= 0.5;  	if (_maxAuto)  		_max += 0.5;  }  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_textLabels != null) {  	if (_minAuto)  		_min = 0.5;  	if (_maxAuto)  		_max = _textLabels.Length + 0.5;  }  else {  	if (_minAuto)  		_min -= 0.5;  	if (_maxAuto)  		_max += 0.5;  }  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_minAuto)  	_min = 0.5;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: _min = 0.5;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_maxAuto)  	_max = _textLabels.Length + 0.5;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: _max = _textLabels.Length + 0.5;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_minAuto)  	_min -= 0.5;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: _min -= 0.5;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_maxAuto)  	_max += 0.5;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: _max += 0.5;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < .1) {  	if (_maxAuto)  		_max = _min + 10.0;  	else  		_min = _max - 10.0;  }  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < .1) {  	if (_maxAuto)  		_max = _min + 10.0;  	else  		_min = _max - 10.0;  }  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_max - _min < .1) {  	if (_maxAuto)  		_max = _min + 10.0;  	else  		_min = _max - 10.0;  }  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_maxAuto)  	_max = _min + 10.0;  else  	_min = _max - 10.0;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_maxAuto)  	_max = _min + 10.0;  else  	_min = _max - 10.0;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: _max = _min + 10.0;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: _min = _max - 10.0;  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: if (_minorStepAuto) {  	_minorStep = _majorStep / 10;  	//_minorStep = CalcStepSize( _majorStep' 10 );  	if (_minorStep < 1)  		_minorStep = 1;  }  
Magic Number,ZedGraph,TextScale,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\TextScale.cs,PickScale,The following statement contains a magic number: _minorStep = _majorStep / 10;  
Magic Number,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The following statement contains a magic number: if (curve is BarItem && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) {  	double positiveStack = 0;  	double negativeStack = 0;  	double curVal;  	// loop through all the curves' summing up the values to get a total (only  	// for the current ordinal position iPt)  	foreach (CurveItem tmpCurve in pane.CurveList) {  		// Sum the value for the current curve only if it is a bar  		if (tmpCurve.IsBar && tmpCurve.IsVisible) {  			curVal = PointPair.Missing;  			// For non-ordinal curves' find a matching base value (must match exactly)  			if (curve.IsOverrideOrdinal || !baseAxis._scale.IsAnyOrdinal) {  				IPointList points = tmpCurve.Points;  				for (int i = 0; i < points.Count; i++) {  					if ((baseAxis is XAxis || baseAxis is X2Axis) && points [i].X == baseVal) {  						curVal = points [i].Y;  						break;  					}  					else if (!(baseAxis is XAxis || baseAxis is X2Axis) && points [i].Y == baseVal) {  						curVal = points [i].X;  						break;  					}  				}  			}  			// otherwise' it's an ordinal type so use the value at the same ordinal position  			else if (iPt < tmpCurve.Points.Count) {  				// Get the value for the appropriate value axis  				if (baseAxis is XAxis || baseAxis is X2Axis)  					curVal = tmpCurve.Points [iPt].Y;  				else  					curVal = tmpCurve.Points [iPt].X;  			}  			// If it's a missing value' skip it  			if (curVal == PointPair.Missing) {  				positiveStack = PointPair.Missing;  				negativeStack = PointPair.Missing;  			}  			// the current curve is the target curve' save the summed values for later  			if (tmpCurve == curve) {  				// if the value is positive' use the positive stack  				if (curVal >= 0) {  					lowVal = positiveStack;  					hiVal = (curVal == PointPair.Missing || positiveStack == PointPair.Missing) ? PointPair.Missing : positiveStack + curVal;  				}  				// otherwise' use the negative stack  				else {  					hiVal = negativeStack;  					lowVal = (curVal == PointPair.Missing || negativeStack == PointPair.Missing) ? PointPair.Missing : negativeStack + curVal;  				}  			}  			// Add all positive values to the positive stack' and negative values to the  			// negative stack  			if (curVal >= 0)  				positiveStack = (curVal == PointPair.Missing || positiveStack == PointPair.Missing) ? PointPair.Missing : positiveStack + curVal;  			else  				negativeStack = (curVal == PointPair.Missing || negativeStack == PointPair.Missing) ? PointPair.Missing : negativeStack + curVal;  		}  	}  	// if the curve is a PercentStack type' then calculate the percent for this bar  	// based on the total height of the stack  	if (pane._barSettings.Type == BarType.PercentStack && hiVal != PointPair.Missing && lowVal != PointPair.Missing) {  		// Use the total magnitude of the positive plus negative bar stacks to determine  		// the percentage value  		positiveStack += Math.Abs (negativeStack);  		// just to avoid dividing by zero...  		if (positiveStack != 0) {  			// calculate the percentage values  			lowVal = lowVal / positiveStack * 100.0;  			hiVal = hiVal / positiveStack * 100.0;  		}  		else {  			lowVal = 0;  			hiVal = 0;  		}  	}  	if (baseVal == PointPair.Missing || lowVal == PointPair.Missing || hiVal == PointPair.Missing)  		return false;  	else  		return true;  }  // If the curve is a stacked line type' then sum up the values similar to the stacked bar type  else if (curve is LineItem && pane.LineType == LineType.Stack) {  	double stack = 0;  	double curVal;  	// loop through all the curves' summing up the values to get a total (only  	// for the current ordinal position iPt)  	foreach (CurveItem tmpCurve in pane.CurveList) {  		// make sure the curve is a Line type  		if (tmpCurve is LineItem && tmpCurve.IsVisible) {  			curVal = PointPair.Missing;  			// For non-ordinal curves' find a matching base value (must match exactly)  			if (curve.IsOverrideOrdinal || !baseAxis._scale.IsAnyOrdinal) {  				IPointList points = tmpCurve.Points;  				for (int i = 0; i < points.Count; i++) {  					if (points [i].X == baseVal) {  						curVal = points [i].Y;  						break;  					}  				}  			}  			// otherwise' it's an ordinal type so use the value at the same ordinal position  			else if (iPt < tmpCurve.Points.Count) {  				// For line types' the Y axis is always the value axis  				curVal = tmpCurve.Points [iPt].Y;  			}  			// if the current value is missing' then the rest of the stack is missing  			if (curVal == PointPair.Missing)  				stack = PointPair.Missing;  			// if the current curve is the target curve' save the values  			if (tmpCurve == curve) {  				lowVal = stack;  				//							if ( curVal < 0 && stack == 0 )  				//							{  				//								stack = curVal;  				//								lowVal = curVal;  				//								hiVal = curVal;  				//							}  				//							else  				hiVal = (curVal == PointPair.Missing || stack == PointPair.Missing) ? PointPair.Missing : stack + curVal;  			}  			// sum all the curves to a single total.  This includes both positive and  			// negative values (unlike the bar stack type).  			stack = (curVal == PointPair.Missing || stack == PointPair.Missing) ? PointPair.Missing : stack + curVal;  		}  	}  	if (baseVal == PointPair.Missing || lowVal == PointPair.Missing || hiVal == PointPair.Missing)  		return false;  	else  		return true;  }  // otherwise' the curve is not a stacked type (not a stacked bar or stacked line)  else {  	if ((!(curve is HiLowBarItem)) && (!(curve is ErrorBarItem)))  		lowVal = 0;  	else  		lowVal = curve.Points [iPt].LowValue;  	if (baseAxis is XAxis || baseAxis is X2Axis)  		hiVal = curve.Points [iPt].Y;  	else  		hiVal = curve.Points [iPt].X;  }  
Magic Number,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The following statement contains a magic number: if (curve is BarItem && (pane._barSettings.Type == BarType.Stack || pane._barSettings.Type == BarType.PercentStack)) {  	double positiveStack = 0;  	double negativeStack = 0;  	double curVal;  	// loop through all the curves' summing up the values to get a total (only  	// for the current ordinal position iPt)  	foreach (CurveItem tmpCurve in pane.CurveList) {  		// Sum the value for the current curve only if it is a bar  		if (tmpCurve.IsBar && tmpCurve.IsVisible) {  			curVal = PointPair.Missing;  			// For non-ordinal curves' find a matching base value (must match exactly)  			if (curve.IsOverrideOrdinal || !baseAxis._scale.IsAnyOrdinal) {  				IPointList points = tmpCurve.Points;  				for (int i = 0; i < points.Count; i++) {  					if ((baseAxis is XAxis || baseAxis is X2Axis) && points [i].X == baseVal) {  						curVal = points [i].Y;  						break;  					}  					else if (!(baseAxis is XAxis || baseAxis is X2Axis) && points [i].Y == baseVal) {  						curVal = points [i].X;  						break;  					}  				}  			}  			// otherwise' it's an ordinal type so use the value at the same ordinal position  			else if (iPt < tmpCurve.Points.Count) {  				// Get the value for the appropriate value axis  				if (baseAxis is XAxis || baseAxis is X2Axis)  					curVal = tmpCurve.Points [iPt].Y;  				else  					curVal = tmpCurve.Points [iPt].X;  			}  			// If it's a missing value' skip it  			if (curVal == PointPair.Missing) {  				positiveStack = PointPair.Missing;  				negativeStack = PointPair.Missing;  			}  			// the current curve is the target curve' save the summed values for later  			if (tmpCurve == curve) {  				// if the value is positive' use the positive stack  				if (curVal >= 0) {  					lowVal = positiveStack;  					hiVal = (curVal == PointPair.Missing || positiveStack == PointPair.Missing) ? PointPair.Missing : positiveStack + curVal;  				}  				// otherwise' use the negative stack  				else {  					hiVal = negativeStack;  					lowVal = (curVal == PointPair.Missing || negativeStack == PointPair.Missing) ? PointPair.Missing : negativeStack + curVal;  				}  			}  			// Add all positive values to the positive stack' and negative values to the  			// negative stack  			if (curVal >= 0)  				positiveStack = (curVal == PointPair.Missing || positiveStack == PointPair.Missing) ? PointPair.Missing : positiveStack + curVal;  			else  				negativeStack = (curVal == PointPair.Missing || negativeStack == PointPair.Missing) ? PointPair.Missing : negativeStack + curVal;  		}  	}  	// if the curve is a PercentStack type' then calculate the percent for this bar  	// based on the total height of the stack  	if (pane._barSettings.Type == BarType.PercentStack && hiVal != PointPair.Missing && lowVal != PointPair.Missing) {  		// Use the total magnitude of the positive plus negative bar stacks to determine  		// the percentage value  		positiveStack += Math.Abs (negativeStack);  		// just to avoid dividing by zero...  		if (positiveStack != 0) {  			// calculate the percentage values  			lowVal = lowVal / positiveStack * 100.0;  			hiVal = hiVal / positiveStack * 100.0;  		}  		else {  			lowVal = 0;  			hiVal = 0;  		}  	}  	if (baseVal == PointPair.Missing || lowVal == PointPair.Missing || hiVal == PointPair.Missing)  		return false;  	else  		return true;  }  // If the curve is a stacked line type' then sum up the values similar to the stacked bar type  else if (curve is LineItem && pane.LineType == LineType.Stack) {  	double stack = 0;  	double curVal;  	// loop through all the curves' summing up the values to get a total (only  	// for the current ordinal position iPt)  	foreach (CurveItem tmpCurve in pane.CurveList) {  		// make sure the curve is a Line type  		if (tmpCurve is LineItem && tmpCurve.IsVisible) {  			curVal = PointPair.Missing;  			// For non-ordinal curves' find a matching base value (must match exactly)  			if (curve.IsOverrideOrdinal || !baseAxis._scale.IsAnyOrdinal) {  				IPointList points = tmpCurve.Points;  				for (int i = 0; i < points.Count; i++) {  					if (points [i].X == baseVal) {  						curVal = points [i].Y;  						break;  					}  				}  			}  			// otherwise' it's an ordinal type so use the value at the same ordinal position  			else if (iPt < tmpCurve.Points.Count) {  				// For line types' the Y axis is always the value axis  				curVal = tmpCurve.Points [iPt].Y;  			}  			// if the current value is missing' then the rest of the stack is missing  			if (curVal == PointPair.Missing)  				stack = PointPair.Missing;  			// if the current curve is the target curve' save the values  			if (tmpCurve == curve) {  				lowVal = stack;  				//							if ( curVal < 0 && stack == 0 )  				//							{  				//								stack = curVal;  				//								lowVal = curVal;  				//								hiVal = curVal;  				//							}  				//							else  				hiVal = (curVal == PointPair.Missing || stack == PointPair.Missing) ? PointPair.Missing : stack + curVal;  			}  			// sum all the curves to a single total.  This includes both positive and  			// negative values (unlike the bar stack type).  			stack = (curVal == PointPair.Missing || stack == PointPair.Missing) ? PointPair.Missing : stack + curVal;  		}  	}  	if (baseVal == PointPair.Missing || lowVal == PointPair.Missing || hiVal == PointPair.Missing)  		return false;  	else  		return true;  }  // otherwise' the curve is not a stacked type (not a stacked bar or stacked line)  else {  	if ((!(curve is HiLowBarItem)) && (!(curve is ErrorBarItem)))  		lowVal = 0;  	else  		lowVal = curve.Points [iPt].LowValue;  	if (baseAxis is XAxis || baseAxis is X2Axis)  		hiVal = curve.Points [iPt].Y;  	else  		hiVal = curve.Points [iPt].X;  }  
Magic Number,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The following statement contains a magic number: if (pane._barSettings.Type == BarType.PercentStack && hiVal != PointPair.Missing && lowVal != PointPair.Missing) {  	// Use the total magnitude of the positive plus negative bar stacks to determine  	// the percentage value  	positiveStack += Math.Abs (negativeStack);  	// just to avoid dividing by zero...  	if (positiveStack != 0) {  		// calculate the percentage values  		lowVal = lowVal / positiveStack * 100.0;  		hiVal = hiVal / positiveStack * 100.0;  	}  	else {  		lowVal = 0;  		hiVal = 0;  	}  }  
Magic Number,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The following statement contains a magic number: if (pane._barSettings.Type == BarType.PercentStack && hiVal != PointPair.Missing && lowVal != PointPair.Missing) {  	// Use the total magnitude of the positive plus negative bar stacks to determine  	// the percentage value  	positiveStack += Math.Abs (negativeStack);  	// just to avoid dividing by zero...  	if (positiveStack != 0) {  		// calculate the percentage values  		lowVal = lowVal / positiveStack * 100.0;  		hiVal = hiVal / positiveStack * 100.0;  	}  	else {  		lowVal = 0;  		hiVal = 0;  	}  }  
Magic Number,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The following statement contains a magic number: if (positiveStack != 0) {  	// calculate the percentage values  	lowVal = lowVal / positiveStack * 100.0;  	hiVal = hiVal / positiveStack * 100.0;  }  else {  	lowVal = 0;  	hiVal = 0;  }  
Magic Number,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The following statement contains a magic number: if (positiveStack != 0) {  	// calculate the percentage values  	lowVal = lowVal / positiveStack * 100.0;  	hiVal = hiVal / positiveStack * 100.0;  }  else {  	lowVal = 0;  	hiVal = 0;  }  
Magic Number,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The following statement contains a magic number: lowVal = lowVal / positiveStack * 100.0;  
Magic Number,ZedGraph,ValueHandler,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ValueHandler.cs,GetValues,The following statement contains a magic number: hiVal = hiVal / positiveStack * 100.0;  
Magic Number,ZedGraph,X2Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\X2Axis.cs,SetTransformMatrix,The following statement contains a magic number: g.RotateTransform (180);  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,_CalendarDateToJulianDay,The following statement contains a magic number: if (month <= 2) {  	year -= 1;  	month += 12;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,_CalendarDateToJulianDay,The following statement contains a magic number: if (month <= 2) {  	year -= 1;  	month += 12;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,_CalendarDateToJulianDay,The following statement contains a magic number: month += 12;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,_CalendarDateToJulianDay,The following statement contains a magic number: return Math.Floor (365.25 * ((double)year + 4716.0)) + Math.Floor (30.6001 * (double)(month + 1)) + (double)day + B - 1524.5 + hour / HoursPerDay + minute / MinutesPerDay + second / SecondsPerDay + millisecond / MillisecondsPerDay;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,_CalendarDateToJulianDay,The following statement contains a magic number: return Math.Floor (365.25 * ((double)year + 4716.0)) + Math.Floor (30.6001 * (double)(month + 1)) + (double)day + B - 1524.5 + hour / HoursPerDay + minute / MinutesPerDay + second / SecondsPerDay + millisecond / MillisecondsPerDay;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,_CalendarDateToJulianDay,The following statement contains a magic number: return Math.Floor (365.25 * ((double)year + 4716.0)) + Math.Floor (30.6001 * (double)(month + 1)) + (double)day + B - 1524.5 + hour / HoursPerDay + minute / MinutesPerDay + second / SecondsPerDay + millisecond / MillisecondsPerDay;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,_CalendarDateToJulianDay,The following statement contains a magic number: return Math.Floor (365.25 * ((double)year + 4716.0)) + Math.Floor (30.6001 * (double)(month + 1)) + (double)day + B - 1524.5 + hour / HoursPerDay + minute / MinutesPerDay + second / SecondsPerDay + millisecond / MillisecondsPerDay;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,JulianDayToCalendarDate,The following statement contains a magic number: jDay += 0.0005 / SecondsPerDay;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,JulianDayToCalendarDate,The following statement contains a magic number: day = (int)Math.Floor (B - D - Math.Floor (30.6001 * E) + f);  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,JulianDayToCalendarDate,The following statement contains a magic number: month = (int)((E < 14.0) ? E - 1.0 : E - 13.0);  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,JulianDayToCalendarDate,The following statement contains a magic number: month = (int)((E < 14.0) ? E - 1.0 : E - 13.0);  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,JulianDayToCalendarDate,The following statement contains a magic number: year = (int)((month > 2) ? C - 4716 : C - 4715);  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,JulianDayToCalendarDate,The following statement contains a magic number: year = (int)((month > 2) ? C - 4716 : C - 4715);  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,JulianDayToCalendarDate,The following statement contains a magic number: year = (int)((month > 2) ? C - 4716 : C - 4715);  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,XLDateToDayOfWeek,The following statement contains a magic number: return (int)(XLDateToJulianDay (xlDate) + 1.5) % 7;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,XLDateToDayOfWeek,The following statement contains a magic number: return (int)(XLDateToJulianDay (xlDate) + 1.5) % 7;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[h]") >= 0 || fmtStr.IndexOf ("[hh]") >= 0) {  	fmtStr = fmtStr.Replace ("[h]"' ((int)(xlDate * 24)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[hh]"' ((int)(xlDate * 24)).ToString ("d2"));  	xlDate = (xlDate * 24 - (int)(xlDate * 24)) / 24.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[h]") >= 0 || fmtStr.IndexOf ("[hh]") >= 0) {  	fmtStr = fmtStr.Replace ("[h]"' ((int)(xlDate * 24)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[hh]"' ((int)(xlDate * 24)).ToString ("d2"));  	xlDate = (xlDate * 24 - (int)(xlDate * 24)) / 24.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[h]") >= 0 || fmtStr.IndexOf ("[hh]") >= 0) {  	fmtStr = fmtStr.Replace ("[h]"' ((int)(xlDate * 24)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[hh]"' ((int)(xlDate * 24)).ToString ("d2"));  	xlDate = (xlDate * 24 - (int)(xlDate * 24)) / 24.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[h]") >= 0 || fmtStr.IndexOf ("[hh]") >= 0) {  	fmtStr = fmtStr.Replace ("[h]"' ((int)(xlDate * 24)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[hh]"' ((int)(xlDate * 24)).ToString ("d2"));  	xlDate = (xlDate * 24 - (int)(xlDate * 24)) / 24.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[h]") >= 0 || fmtStr.IndexOf ("[hh]") >= 0) {  	fmtStr = fmtStr.Replace ("[h]"' ((int)(xlDate * 24)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[hh]"' ((int)(xlDate * 24)).ToString ("d2"));  	xlDate = (xlDate * 24 - (int)(xlDate * 24)) / 24.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[h]"' ((int)(xlDate * 24)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[hh]"' ((int)(xlDate * 24)).ToString ("d2"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: xlDate = (xlDate * 24 - (int)(xlDate * 24)) / 24.0;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: xlDate = (xlDate * 24 - (int)(xlDate * 24)) / 24.0;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: xlDate = (xlDate * 24 - (int)(xlDate * 24)) / 24.0;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[m]") >= 0 || fmtStr.IndexOf ("[mm]") >= 0) {  	fmtStr = fmtStr.Replace ("[m]"' ((int)(xlDate * 1440)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[mm]"' ((int)(xlDate * 1440)).ToString ("d2"));  	xlDate = (xlDate * 1440 - (int)(xlDate * 1440)) / 1440.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[m]") >= 0 || fmtStr.IndexOf ("[mm]") >= 0) {  	fmtStr = fmtStr.Replace ("[m]"' ((int)(xlDate * 1440)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[mm]"' ((int)(xlDate * 1440)).ToString ("d2"));  	xlDate = (xlDate * 1440 - (int)(xlDate * 1440)) / 1440.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[m]") >= 0 || fmtStr.IndexOf ("[mm]") >= 0) {  	fmtStr = fmtStr.Replace ("[m]"' ((int)(xlDate * 1440)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[mm]"' ((int)(xlDate * 1440)).ToString ("d2"));  	xlDate = (xlDate * 1440 - (int)(xlDate * 1440)) / 1440.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[m]") >= 0 || fmtStr.IndexOf ("[mm]") >= 0) {  	fmtStr = fmtStr.Replace ("[m]"' ((int)(xlDate * 1440)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[mm]"' ((int)(xlDate * 1440)).ToString ("d2"));  	xlDate = (xlDate * 1440 - (int)(xlDate * 1440)) / 1440.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[m]") >= 0 || fmtStr.IndexOf ("[mm]") >= 0) {  	fmtStr = fmtStr.Replace ("[m]"' ((int)(xlDate * 1440)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[mm]"' ((int)(xlDate * 1440)).ToString ("d2"));  	xlDate = (xlDate * 1440 - (int)(xlDate * 1440)) / 1440.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[m]"' ((int)(xlDate * 1440)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[mm]"' ((int)(xlDate * 1440)).ToString ("d2"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: xlDate = (xlDate * 1440 - (int)(xlDate * 1440)) / 1440.0;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: xlDate = (xlDate * 1440 - (int)(xlDate * 1440)) / 1440.0;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: xlDate = (xlDate * 1440 - (int)(xlDate * 1440)) / 1440.0;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[s]") >= 0 || fmtStr.IndexOf ("[ss]") >= 0) {  	fmtStr = fmtStr.Replace ("[s]"' ((int)(xlDate * 86400)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[ss]"' ((int)(xlDate * 86400)).ToString ("d2"));  	xlDate = (xlDate * 86400 - (int)(xlDate * 86400)) / 86400.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[s]") >= 0 || fmtStr.IndexOf ("[ss]") >= 0) {  	fmtStr = fmtStr.Replace ("[s]"' ((int)(xlDate * 86400)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[ss]"' ((int)(xlDate * 86400)).ToString ("d2"));  	xlDate = (xlDate * 86400 - (int)(xlDate * 86400)) / 86400.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[s]") >= 0 || fmtStr.IndexOf ("[ss]") >= 0) {  	fmtStr = fmtStr.Replace ("[s]"' ((int)(xlDate * 86400)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[ss]"' ((int)(xlDate * 86400)).ToString ("d2"));  	xlDate = (xlDate * 86400 - (int)(xlDate * 86400)) / 86400.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[s]") >= 0 || fmtStr.IndexOf ("[ss]") >= 0) {  	fmtStr = fmtStr.Replace ("[s]"' ((int)(xlDate * 86400)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[ss]"' ((int)(xlDate * 86400)).ToString ("d2"));  	xlDate = (xlDate * 86400 - (int)(xlDate * 86400)) / 86400.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[s]") >= 0 || fmtStr.IndexOf ("[ss]") >= 0) {  	fmtStr = fmtStr.Replace ("[s]"' ((int)(xlDate * 86400)).ToString ("d"));  	fmtStr = fmtStr.Replace ("[ss]"' ((int)(xlDate * 86400)).ToString ("d2"));  	xlDate = (xlDate * 86400 - (int)(xlDate * 86400)) / 86400.0;  }  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[s]"' ((int)(xlDate * 86400)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[ss]"' ((int)(xlDate * 86400)).ToString ("d2"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: xlDate = (xlDate * 86400 - (int)(xlDate * 86400)) / 86400.0;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: xlDate = (xlDate * 86400 - (int)(xlDate * 86400)) / 86400.0;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: xlDate = (xlDate * 86400 - (int)(xlDate * 86400)) / 86400.0;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[f]") >= 0)  	fmtStr = fmtStr.Replace ("[f]"' ((int)(xlDate * 864000)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[f]"' ((int)(xlDate * 864000)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[ff]") >= 0)  	fmtStr = fmtStr.Replace ("[ff]"' ((int)(xlDate * 8640000)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[ff]"' ((int)(xlDate * 8640000)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[fff]") >= 0)  	fmtStr = fmtStr.Replace ("[fff]"' ((int)(xlDate * 86400000)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[fff]"' ((int)(xlDate * 86400000)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[ffff]") >= 0)  	fmtStr = fmtStr.Replace ("[ffff]"' ((int)(xlDate * 864000000)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[ffff]"' ((int)(xlDate * 864000000)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (fmtStr.IndexOf ("[fffff]") >= 0)  	fmtStr = fmtStr.Replace ("[fffff]"' ((int)(xlDate * 8640000000)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: fmtStr = fmtStr.Replace ("[fffff]"' ((int)(xlDate * 8640000000)).ToString ("d"));  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (year > 9999)  	year = 9999;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: if (year > 9999)  	year = 9999;  
Magic Number,ZedGraph,XDate,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\XDate.cs,ToString,The following statement contains a magic number: year = 9999;  
Magic Number,ZedGraph,Y2Axis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Y2Axis.cs,SetTransformMatrix,The following statement contains a magic number: g.RotateTransform (-90);  
Magic Number,ZedGraph,YAxis,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\YAxis.cs,SetTransformMatrix,The following statement contains a magic number: g.RotateTransform (90);  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (DefaultFileName != null && DefaultFileName.Length > 0) {  		String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  		switch (ext) {  		case ".emf":  			_saveFileDialog.FilterIndex = 1;  			break;  		case ".png":  			_saveFileDialog.FilterIndex = 2;  			break;  		case ".gif":  			_saveFileDialog.FilterIndex = 3;  			break;  		case ".jpeg":  		case ".jpg":  			_saveFileDialog.FilterIndex = 4;  			break;  		case ".tiff":  		case ".tif":  			_saveFileDialog.FilterIndex = 5;  			break;  		case ".bmp":  			_saveFileDialog.FilterIndex = 6;  			break;  		}  		//If we were passed a file name' not just an extension' use it  		if (DefaultFileName.Length > ext.Length) {  			_saveFileDialog.FileName = DefaultFileName;  		}  	}  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			if (_saveFileDialog.FilterIndex == 1) {  				myStream.Close ();  				SaveEmfFile (_saveFileDialog.FileName);  			}  			else {  				ImageFormat format = ImageFormat.Png;  				switch (_saveFileDialog.FilterIndex) {  				case 2:  					format = ImageFormat.Png;  					break;  				case 3:  					format = ImageFormat.Gif;  					break;  				case 4:  					format = ImageFormat.Jpeg;  					break;  				case 5:  					format = ImageFormat.Tiff;  					break;  				case 6:  					format = ImageFormat.Bmp;  					break;  				}  				ImageRender ().Save (myStream' format);  				//_masterPane.GetImage().Save( myStream' format );  				myStream.Close ();  			}  			return _saveFileDialog.FileName;  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (DefaultFileName != null && DefaultFileName.Length > 0) {  		String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  		switch (ext) {  		case ".emf":  			_saveFileDialog.FilterIndex = 1;  			break;  		case ".png":  			_saveFileDialog.FilterIndex = 2;  			break;  		case ".gif":  			_saveFileDialog.FilterIndex = 3;  			break;  		case ".jpeg":  		case ".jpg":  			_saveFileDialog.FilterIndex = 4;  			break;  		case ".tiff":  		case ".tif":  			_saveFileDialog.FilterIndex = 5;  			break;  		case ".bmp":  			_saveFileDialog.FilterIndex = 6;  			break;  		}  		//If we were passed a file name' not just an extension' use it  		if (DefaultFileName.Length > ext.Length) {  			_saveFileDialog.FileName = DefaultFileName;  		}  	}  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			if (_saveFileDialog.FilterIndex == 1) {  				myStream.Close ();  				SaveEmfFile (_saveFileDialog.FileName);  			}  			else {  				ImageFormat format = ImageFormat.Png;  				switch (_saveFileDialog.FilterIndex) {  				case 2:  					format = ImageFormat.Png;  					break;  				case 3:  					format = ImageFormat.Gif;  					break;  				case 4:  					format = ImageFormat.Jpeg;  					break;  				case 5:  					format = ImageFormat.Tiff;  					break;  				case 6:  					format = ImageFormat.Bmp;  					break;  				}  				ImageRender ().Save (myStream' format);  				//_masterPane.GetImage().Save( myStream' format );  				myStream.Close ();  			}  			return _saveFileDialog.FileName;  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (DefaultFileName != null && DefaultFileName.Length > 0) {  		String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  		switch (ext) {  		case ".emf":  			_saveFileDialog.FilterIndex = 1;  			break;  		case ".png":  			_saveFileDialog.FilterIndex = 2;  			break;  		case ".gif":  			_saveFileDialog.FilterIndex = 3;  			break;  		case ".jpeg":  		case ".jpg":  			_saveFileDialog.FilterIndex = 4;  			break;  		case ".tiff":  		case ".tif":  			_saveFileDialog.FilterIndex = 5;  			break;  		case ".bmp":  			_saveFileDialog.FilterIndex = 6;  			break;  		}  		//If we were passed a file name' not just an extension' use it  		if (DefaultFileName.Length > ext.Length) {  			_saveFileDialog.FileName = DefaultFileName;  		}  	}  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			if (_saveFileDialog.FilterIndex == 1) {  				myStream.Close ();  				SaveEmfFile (_saveFileDialog.FileName);  			}  			else {  				ImageFormat format = ImageFormat.Png;  				switch (_saveFileDialog.FilterIndex) {  				case 2:  					format = ImageFormat.Png;  					break;  				case 3:  					format = ImageFormat.Gif;  					break;  				case 4:  					format = ImageFormat.Jpeg;  					break;  				case 5:  					format = ImageFormat.Tiff;  					break;  				case 6:  					format = ImageFormat.Bmp;  					break;  				}  				ImageRender ().Save (myStream' format);  				//_masterPane.GetImage().Save( myStream' format );  				myStream.Close ();  			}  			return _saveFileDialog.FileName;  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (DefaultFileName != null && DefaultFileName.Length > 0) {  		String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  		switch (ext) {  		case ".emf":  			_saveFileDialog.FilterIndex = 1;  			break;  		case ".png":  			_saveFileDialog.FilterIndex = 2;  			break;  		case ".gif":  			_saveFileDialog.FilterIndex = 3;  			break;  		case ".jpeg":  		case ".jpg":  			_saveFileDialog.FilterIndex = 4;  			break;  		case ".tiff":  		case ".tif":  			_saveFileDialog.FilterIndex = 5;  			break;  		case ".bmp":  			_saveFileDialog.FilterIndex = 6;  			break;  		}  		//If we were passed a file name' not just an extension' use it  		if (DefaultFileName.Length > ext.Length) {  			_saveFileDialog.FileName = DefaultFileName;  		}  	}  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			if (_saveFileDialog.FilterIndex == 1) {  				myStream.Close ();  				SaveEmfFile (_saveFileDialog.FileName);  			}  			else {  				ImageFormat format = ImageFormat.Png;  				switch (_saveFileDialog.FilterIndex) {  				case 2:  					format = ImageFormat.Png;  					break;  				case 3:  					format = ImageFormat.Gif;  					break;  				case 4:  					format = ImageFormat.Jpeg;  					break;  				case 5:  					format = ImageFormat.Tiff;  					break;  				case 6:  					format = ImageFormat.Bmp;  					break;  				}  				ImageRender ().Save (myStream' format);  				//_masterPane.GetImage().Save( myStream' format );  				myStream.Close ();  			}  			return _saveFileDialog.FileName;  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (DefaultFileName != null && DefaultFileName.Length > 0) {  		String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  		switch (ext) {  		case ".emf":  			_saveFileDialog.FilterIndex = 1;  			break;  		case ".png":  			_saveFileDialog.FilterIndex = 2;  			break;  		case ".gif":  			_saveFileDialog.FilterIndex = 3;  			break;  		case ".jpeg":  		case ".jpg":  			_saveFileDialog.FilterIndex = 4;  			break;  		case ".tiff":  		case ".tif":  			_saveFileDialog.FilterIndex = 5;  			break;  		case ".bmp":  			_saveFileDialog.FilterIndex = 6;  			break;  		}  		//If we were passed a file name' not just an extension' use it  		if (DefaultFileName.Length > ext.Length) {  			_saveFileDialog.FileName = DefaultFileName;  		}  	}  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			if (_saveFileDialog.FilterIndex == 1) {  				myStream.Close ();  				SaveEmfFile (_saveFileDialog.FileName);  			}  			else {  				ImageFormat format = ImageFormat.Png;  				switch (_saveFileDialog.FilterIndex) {  				case 2:  					format = ImageFormat.Png;  					break;  				case 3:  					format = ImageFormat.Gif;  					break;  				case 4:  					format = ImageFormat.Jpeg;  					break;  				case 5:  					format = ImageFormat.Tiff;  					break;  				case 6:  					format = ImageFormat.Bmp;  					break;  				}  				ImageRender ().Save (myStream' format);  				//_masterPane.GetImage().Save( myStream' format );  				myStream.Close ();  			}  			return _saveFileDialog.FileName;  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (DefaultFileName != null && DefaultFileName.Length > 0) {  		String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  		switch (ext) {  		case ".emf":  			_saveFileDialog.FilterIndex = 1;  			break;  		case ".png":  			_saveFileDialog.FilterIndex = 2;  			break;  		case ".gif":  			_saveFileDialog.FilterIndex = 3;  			break;  		case ".jpeg":  		case ".jpg":  			_saveFileDialog.FilterIndex = 4;  			break;  		case ".tiff":  		case ".tif":  			_saveFileDialog.FilterIndex = 5;  			break;  		case ".bmp":  			_saveFileDialog.FilterIndex = 6;  			break;  		}  		//If we were passed a file name' not just an extension' use it  		if (DefaultFileName.Length > ext.Length) {  			_saveFileDialog.FileName = DefaultFileName;  		}  	}  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			if (_saveFileDialog.FilterIndex == 1) {  				myStream.Close ();  				SaveEmfFile (_saveFileDialog.FileName);  			}  			else {  				ImageFormat format = ImageFormat.Png;  				switch (_saveFileDialog.FilterIndex) {  				case 2:  					format = ImageFormat.Png;  					break;  				case 3:  					format = ImageFormat.Gif;  					break;  				case 4:  					format = ImageFormat.Jpeg;  					break;  				case 5:  					format = ImageFormat.Tiff;  					break;  				case 6:  					format = ImageFormat.Bmp;  					break;  				}  				ImageRender ().Save (myStream' format);  				//_masterPane.GetImage().Save( myStream' format );  				myStream.Close ();  			}  			return _saveFileDialog.FileName;  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (DefaultFileName != null && DefaultFileName.Length > 0) {  		String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  		switch (ext) {  		case ".emf":  			_saveFileDialog.FilterIndex = 1;  			break;  		case ".png":  			_saveFileDialog.FilterIndex = 2;  			break;  		case ".gif":  			_saveFileDialog.FilterIndex = 3;  			break;  		case ".jpeg":  		case ".jpg":  			_saveFileDialog.FilterIndex = 4;  			break;  		case ".tiff":  		case ".tif":  			_saveFileDialog.FilterIndex = 5;  			break;  		case ".bmp":  			_saveFileDialog.FilterIndex = 6;  			break;  		}  		//If we were passed a file name' not just an extension' use it  		if (DefaultFileName.Length > ext.Length) {  			_saveFileDialog.FileName = DefaultFileName;  		}  	}  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			if (_saveFileDialog.FilterIndex == 1) {  				myStream.Close ();  				SaveEmfFile (_saveFileDialog.FileName);  			}  			else {  				ImageFormat format = ImageFormat.Png;  				switch (_saveFileDialog.FilterIndex) {  				case 2:  					format = ImageFormat.Png;  					break;  				case 3:  					format = ImageFormat.Gif;  					break;  				case 4:  					format = ImageFormat.Jpeg;  					break;  				case 5:  					format = ImageFormat.Tiff;  					break;  				case 6:  					format = ImageFormat.Bmp;  					break;  				}  				ImageRender ().Save (myStream' format);  				//_masterPane.GetImage().Save( myStream' format );  				myStream.Close ();  			}  			return _saveFileDialog.FileName;  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (DefaultFileName != null && DefaultFileName.Length > 0) {  		String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  		switch (ext) {  		case ".emf":  			_saveFileDialog.FilterIndex = 1;  			break;  		case ".png":  			_saveFileDialog.FilterIndex = 2;  			break;  		case ".gif":  			_saveFileDialog.FilterIndex = 3;  			break;  		case ".jpeg":  		case ".jpg":  			_saveFileDialog.FilterIndex = 4;  			break;  		case ".tiff":  		case ".tif":  			_saveFileDialog.FilterIndex = 5;  			break;  		case ".bmp":  			_saveFileDialog.FilterIndex = 6;  			break;  		}  		//If we were passed a file name' not just an extension' use it  		if (DefaultFileName.Length > ext.Length) {  			_saveFileDialog.FileName = DefaultFileName;  		}  	}  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			if (_saveFileDialog.FilterIndex == 1) {  				myStream.Close ();  				SaveEmfFile (_saveFileDialog.FileName);  			}  			else {  				ImageFormat format = ImageFormat.Png;  				switch (_saveFileDialog.FilterIndex) {  				case 2:  					format = ImageFormat.Png;  					break;  				case 3:  					format = ImageFormat.Gif;  					break;  				case 4:  					format = ImageFormat.Jpeg;  					break;  				case 5:  					format = ImageFormat.Tiff;  					break;  				case 6:  					format = ImageFormat.Bmp;  					break;  				}  				ImageRender ().Save (myStream' format);  				//_masterPane.GetImage().Save( myStream' format );  				myStream.Close ();  			}  			return _saveFileDialog.FileName;  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (DefaultFileName != null && DefaultFileName.Length > 0) {  		String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  		switch (ext) {  		case ".emf":  			_saveFileDialog.FilterIndex = 1;  			break;  		case ".png":  			_saveFileDialog.FilterIndex = 2;  			break;  		case ".gif":  			_saveFileDialog.FilterIndex = 3;  			break;  		case ".jpeg":  		case ".jpg":  			_saveFileDialog.FilterIndex = 4;  			break;  		case ".tiff":  		case ".tif":  			_saveFileDialog.FilterIndex = 5;  			break;  		case ".bmp":  			_saveFileDialog.FilterIndex = 6;  			break;  		}  		//If we were passed a file name' not just an extension' use it  		if (DefaultFileName.Length > ext.Length) {  			_saveFileDialog.FileName = DefaultFileName;  		}  	}  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			if (_saveFileDialog.FilterIndex == 1) {  				myStream.Close ();  				SaveEmfFile (_saveFileDialog.FileName);  			}  			else {  				ImageFormat format = ImageFormat.Png;  				switch (_saveFileDialog.FilterIndex) {  				case 2:  					format = ImageFormat.Png;  					break;  				case 3:  					format = ImageFormat.Gif;  					break;  				case 4:  					format = ImageFormat.Jpeg;  					break;  				case 5:  					format = ImageFormat.Tiff;  					break;  				case 6:  					format = ImageFormat.Bmp;  					break;  				}  				ImageRender ().Save (myStream' format);  				//_masterPane.GetImage().Save( myStream' format );  				myStream.Close ();  			}  			return _saveFileDialog.FileName;  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "Emf Format (*.emf)|*.emf|" + "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (DefaultFileName != null && DefaultFileName.Length > 0) {  		String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  		switch (ext) {  		case ".emf":  			_saveFileDialog.FilterIndex = 1;  			break;  		case ".png":  			_saveFileDialog.FilterIndex = 2;  			break;  		case ".gif":  			_saveFileDialog.FilterIndex = 3;  			break;  		case ".jpeg":  		case ".jpg":  			_saveFileDialog.FilterIndex = 4;  			break;  		case ".tiff":  		case ".tif":  			_saveFileDialog.FilterIndex = 5;  			break;  		case ".bmp":  			_saveFileDialog.FilterIndex = 6;  			break;  		}  		//If we were passed a file name' not just an extension' use it  		if (DefaultFileName.Length > ext.Length) {  			_saveFileDialog.FileName = DefaultFileName;  		}  	}  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			if (_saveFileDialog.FilterIndex == 1) {  				myStream.Close ();  				SaveEmfFile (_saveFileDialog.FileName);  			}  			else {  				ImageFormat format = ImageFormat.Png;  				switch (_saveFileDialog.FilterIndex) {  				case 2:  					format = ImageFormat.Png;  					break;  				case 3:  					format = ImageFormat.Gif;  					break;  				case 4:  					format = ImageFormat.Jpeg;  					break;  				case 5:  					format = ImageFormat.Tiff;  					break;  				case 6:  					format = ImageFormat.Bmp;  					break;  				}  				ImageRender ().Save (myStream' format);  				//_masterPane.GetImage().Save( myStream' format );  				myStream.Close ();  			}  			return _saveFileDialog.FileName;  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (DefaultFileName != null && DefaultFileName.Length > 0) {  	String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  	switch (ext) {  	case ".emf":  		_saveFileDialog.FilterIndex = 1;  		break;  	case ".png":  		_saveFileDialog.FilterIndex = 2;  		break;  	case ".gif":  		_saveFileDialog.FilterIndex = 3;  		break;  	case ".jpeg":  	case ".jpg":  		_saveFileDialog.FilterIndex = 4;  		break;  	case ".tiff":  	case ".tif":  		_saveFileDialog.FilterIndex = 5;  		break;  	case ".bmp":  		_saveFileDialog.FilterIndex = 6;  		break;  	}  	//If we were passed a file name' not just an extension' use it  	if (DefaultFileName.Length > ext.Length) {  		_saveFileDialog.FileName = DefaultFileName;  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (DefaultFileName != null && DefaultFileName.Length > 0) {  	String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  	switch (ext) {  	case ".emf":  		_saveFileDialog.FilterIndex = 1;  		break;  	case ".png":  		_saveFileDialog.FilterIndex = 2;  		break;  	case ".gif":  		_saveFileDialog.FilterIndex = 3;  		break;  	case ".jpeg":  	case ".jpg":  		_saveFileDialog.FilterIndex = 4;  		break;  	case ".tiff":  	case ".tif":  		_saveFileDialog.FilterIndex = 5;  		break;  	case ".bmp":  		_saveFileDialog.FilterIndex = 6;  		break;  	}  	//If we were passed a file name' not just an extension' use it  	if (DefaultFileName.Length > ext.Length) {  		_saveFileDialog.FileName = DefaultFileName;  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (DefaultFileName != null && DefaultFileName.Length > 0) {  	String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  	switch (ext) {  	case ".emf":  		_saveFileDialog.FilterIndex = 1;  		break;  	case ".png":  		_saveFileDialog.FilterIndex = 2;  		break;  	case ".gif":  		_saveFileDialog.FilterIndex = 3;  		break;  	case ".jpeg":  	case ".jpg":  		_saveFileDialog.FilterIndex = 4;  		break;  	case ".tiff":  	case ".tif":  		_saveFileDialog.FilterIndex = 5;  		break;  	case ".bmp":  		_saveFileDialog.FilterIndex = 6;  		break;  	}  	//If we were passed a file name' not just an extension' use it  	if (DefaultFileName.Length > ext.Length) {  		_saveFileDialog.FileName = DefaultFileName;  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (DefaultFileName != null && DefaultFileName.Length > 0) {  	String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  	switch (ext) {  	case ".emf":  		_saveFileDialog.FilterIndex = 1;  		break;  	case ".png":  		_saveFileDialog.FilterIndex = 2;  		break;  	case ".gif":  		_saveFileDialog.FilterIndex = 3;  		break;  	case ".jpeg":  	case ".jpg":  		_saveFileDialog.FilterIndex = 4;  		break;  	case ".tiff":  	case ".tif":  		_saveFileDialog.FilterIndex = 5;  		break;  	case ".bmp":  		_saveFileDialog.FilterIndex = 6;  		break;  	}  	//If we were passed a file name' not just an extension' use it  	if (DefaultFileName.Length > ext.Length) {  		_saveFileDialog.FileName = DefaultFileName;  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (DefaultFileName != null && DefaultFileName.Length > 0) {  	String ext = System.IO.Path.GetExtension (DefaultFileName).ToLower ();  	switch (ext) {  	case ".emf":  		_saveFileDialog.FilterIndex = 1;  		break;  	case ".png":  		_saveFileDialog.FilterIndex = 2;  		break;  	case ".gif":  		_saveFileDialog.FilterIndex = 3;  		break;  	case ".jpeg":  	case ".jpg":  		_saveFileDialog.FilterIndex = 4;  		break;  	case ".tiff":  	case ".tif":  		_saveFileDialog.FilterIndex = 5;  		break;  	case ".bmp":  		_saveFileDialog.FilterIndex = 6;  		break;  	}  	//If we were passed a file name' not just an extension' use it  	if (DefaultFileName.Length > ext.Length) {  		_saveFileDialog.FileName = DefaultFileName;  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: switch (ext) {  case ".emf":  	_saveFileDialog.FilterIndex = 1;  	break;  case ".png":  	_saveFileDialog.FilterIndex = 2;  	break;  case ".gif":  	_saveFileDialog.FilterIndex = 3;  	break;  case ".jpeg":  case ".jpg":  	_saveFileDialog.FilterIndex = 4;  	break;  case ".tiff":  case ".tif":  	_saveFileDialog.FilterIndex = 5;  	break;  case ".bmp":  	_saveFileDialog.FilterIndex = 6;  	break;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: switch (ext) {  case ".emf":  	_saveFileDialog.FilterIndex = 1;  	break;  case ".png":  	_saveFileDialog.FilterIndex = 2;  	break;  case ".gif":  	_saveFileDialog.FilterIndex = 3;  	break;  case ".jpeg":  case ".jpg":  	_saveFileDialog.FilterIndex = 4;  	break;  case ".tiff":  case ".tif":  	_saveFileDialog.FilterIndex = 5;  	break;  case ".bmp":  	_saveFileDialog.FilterIndex = 6;  	break;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: switch (ext) {  case ".emf":  	_saveFileDialog.FilterIndex = 1;  	break;  case ".png":  	_saveFileDialog.FilterIndex = 2;  	break;  case ".gif":  	_saveFileDialog.FilterIndex = 3;  	break;  case ".jpeg":  case ".jpg":  	_saveFileDialog.FilterIndex = 4;  	break;  case ".tiff":  case ".tif":  	_saveFileDialog.FilterIndex = 5;  	break;  case ".bmp":  	_saveFileDialog.FilterIndex = 6;  	break;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: switch (ext) {  case ".emf":  	_saveFileDialog.FilterIndex = 1;  	break;  case ".png":  	_saveFileDialog.FilterIndex = 2;  	break;  case ".gif":  	_saveFileDialog.FilterIndex = 3;  	break;  case ".jpeg":  case ".jpg":  	_saveFileDialog.FilterIndex = 4;  	break;  case ".tiff":  case ".tif":  	_saveFileDialog.FilterIndex = 5;  	break;  case ".bmp":  	_saveFileDialog.FilterIndex = 6;  	break;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: switch (ext) {  case ".emf":  	_saveFileDialog.FilterIndex = 1;  	break;  case ".png":  	_saveFileDialog.FilterIndex = 2;  	break;  case ".gif":  	_saveFileDialog.FilterIndex = 3;  	break;  case ".jpeg":  case ".jpg":  	_saveFileDialog.FilterIndex = 4;  	break;  case ".tiff":  case ".tif":  	_saveFileDialog.FilterIndex = 5;  	break;  case ".bmp":  	_saveFileDialog.FilterIndex = 6;  	break;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: _saveFileDialog.FilterIndex = 2;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: _saveFileDialog.FilterIndex = 3;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: _saveFileDialog.FilterIndex = 4;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: _saveFileDialog.FilterIndex = 5;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: _saveFileDialog.FilterIndex = 6;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  	Stream myStream = _saveFileDialog.OpenFile ();  	if (myStream != null) {  		if (_saveFileDialog.FilterIndex == 1) {  			myStream.Close ();  			SaveEmfFile (_saveFileDialog.FileName);  		}  		else {  			ImageFormat format = ImageFormat.Png;  			switch (_saveFileDialog.FilterIndex) {  			case 2:  				format = ImageFormat.Png;  				break;  			case 3:  				format = ImageFormat.Gif;  				break;  			case 4:  				format = ImageFormat.Jpeg;  				break;  			case 5:  				format = ImageFormat.Tiff;  				break;  			case 6:  				format = ImageFormat.Bmp;  				break;  			}  			ImageRender ().Save (myStream' format);  			//_masterPane.GetImage().Save( myStream' format );  			myStream.Close ();  		}  		return _saveFileDialog.FileName;  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  	Stream myStream = _saveFileDialog.OpenFile ();  	if (myStream != null) {  		if (_saveFileDialog.FilterIndex == 1) {  			myStream.Close ();  			SaveEmfFile (_saveFileDialog.FileName);  		}  		else {  			ImageFormat format = ImageFormat.Png;  			switch (_saveFileDialog.FilterIndex) {  			case 2:  				format = ImageFormat.Png;  				break;  			case 3:  				format = ImageFormat.Gif;  				break;  			case 4:  				format = ImageFormat.Jpeg;  				break;  			case 5:  				format = ImageFormat.Tiff;  				break;  			case 6:  				format = ImageFormat.Bmp;  				break;  			}  			ImageRender ().Save (myStream' format);  			//_masterPane.GetImage().Save( myStream' format );  			myStream.Close ();  		}  		return _saveFileDialog.FileName;  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  	Stream myStream = _saveFileDialog.OpenFile ();  	if (myStream != null) {  		if (_saveFileDialog.FilterIndex == 1) {  			myStream.Close ();  			SaveEmfFile (_saveFileDialog.FileName);  		}  		else {  			ImageFormat format = ImageFormat.Png;  			switch (_saveFileDialog.FilterIndex) {  			case 2:  				format = ImageFormat.Png;  				break;  			case 3:  				format = ImageFormat.Gif;  				break;  			case 4:  				format = ImageFormat.Jpeg;  				break;  			case 5:  				format = ImageFormat.Tiff;  				break;  			case 6:  				format = ImageFormat.Bmp;  				break;  			}  			ImageRender ().Save (myStream' format);  			//_masterPane.GetImage().Save( myStream' format );  			myStream.Close ();  		}  		return _saveFileDialog.FileName;  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  	Stream myStream = _saveFileDialog.OpenFile ();  	if (myStream != null) {  		if (_saveFileDialog.FilterIndex == 1) {  			myStream.Close ();  			SaveEmfFile (_saveFileDialog.FileName);  		}  		else {  			ImageFormat format = ImageFormat.Png;  			switch (_saveFileDialog.FilterIndex) {  			case 2:  				format = ImageFormat.Png;  				break;  			case 3:  				format = ImageFormat.Gif;  				break;  			case 4:  				format = ImageFormat.Jpeg;  				break;  			case 5:  				format = ImageFormat.Tiff;  				break;  			case 6:  				format = ImageFormat.Bmp;  				break;  			}  			ImageRender ().Save (myStream' format);  			//_masterPane.GetImage().Save( myStream' format );  			myStream.Close ();  		}  		return _saveFileDialog.FileName;  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  	Stream myStream = _saveFileDialog.OpenFile ();  	if (myStream != null) {  		if (_saveFileDialog.FilterIndex == 1) {  			myStream.Close ();  			SaveEmfFile (_saveFileDialog.FileName);  		}  		else {  			ImageFormat format = ImageFormat.Png;  			switch (_saveFileDialog.FilterIndex) {  			case 2:  				format = ImageFormat.Png;  				break;  			case 3:  				format = ImageFormat.Gif;  				break;  			case 4:  				format = ImageFormat.Jpeg;  				break;  			case 5:  				format = ImageFormat.Tiff;  				break;  			case 6:  				format = ImageFormat.Bmp;  				break;  			}  			ImageRender ().Save (myStream' format);  			//_masterPane.GetImage().Save( myStream' format );  			myStream.Close ();  		}  		return _saveFileDialog.FileName;  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (myStream != null) {  	if (_saveFileDialog.FilterIndex == 1) {  		myStream.Close ();  		SaveEmfFile (_saveFileDialog.FileName);  	}  	else {  		ImageFormat format = ImageFormat.Png;  		switch (_saveFileDialog.FilterIndex) {  		case 2:  			format = ImageFormat.Png;  			break;  		case 3:  			format = ImageFormat.Gif;  			break;  		case 4:  			format = ImageFormat.Jpeg;  			break;  		case 5:  			format = ImageFormat.Tiff;  			break;  		case 6:  			format = ImageFormat.Bmp;  			break;  		}  		ImageRender ().Save (myStream' format);  		//_masterPane.GetImage().Save( myStream' format );  		myStream.Close ();  	}  	return _saveFileDialog.FileName;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (myStream != null) {  	if (_saveFileDialog.FilterIndex == 1) {  		myStream.Close ();  		SaveEmfFile (_saveFileDialog.FileName);  	}  	else {  		ImageFormat format = ImageFormat.Png;  		switch (_saveFileDialog.FilterIndex) {  		case 2:  			format = ImageFormat.Png;  			break;  		case 3:  			format = ImageFormat.Gif;  			break;  		case 4:  			format = ImageFormat.Jpeg;  			break;  		case 5:  			format = ImageFormat.Tiff;  			break;  		case 6:  			format = ImageFormat.Bmp;  			break;  		}  		ImageRender ().Save (myStream' format);  		//_masterPane.GetImage().Save( myStream' format );  		myStream.Close ();  	}  	return _saveFileDialog.FileName;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (myStream != null) {  	if (_saveFileDialog.FilterIndex == 1) {  		myStream.Close ();  		SaveEmfFile (_saveFileDialog.FileName);  	}  	else {  		ImageFormat format = ImageFormat.Png;  		switch (_saveFileDialog.FilterIndex) {  		case 2:  			format = ImageFormat.Png;  			break;  		case 3:  			format = ImageFormat.Gif;  			break;  		case 4:  			format = ImageFormat.Jpeg;  			break;  		case 5:  			format = ImageFormat.Tiff;  			break;  		case 6:  			format = ImageFormat.Bmp;  			break;  		}  		ImageRender ().Save (myStream' format);  		//_masterPane.GetImage().Save( myStream' format );  		myStream.Close ();  	}  	return _saveFileDialog.FileName;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (myStream != null) {  	if (_saveFileDialog.FilterIndex == 1) {  		myStream.Close ();  		SaveEmfFile (_saveFileDialog.FileName);  	}  	else {  		ImageFormat format = ImageFormat.Png;  		switch (_saveFileDialog.FilterIndex) {  		case 2:  			format = ImageFormat.Png;  			break;  		case 3:  			format = ImageFormat.Gif;  			break;  		case 4:  			format = ImageFormat.Jpeg;  			break;  		case 5:  			format = ImageFormat.Tiff;  			break;  		case 6:  			format = ImageFormat.Bmp;  			break;  		}  		ImageRender ().Save (myStream' format);  		//_masterPane.GetImage().Save( myStream' format );  		myStream.Close ();  	}  	return _saveFileDialog.FileName;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (myStream != null) {  	if (_saveFileDialog.FilterIndex == 1) {  		myStream.Close ();  		SaveEmfFile (_saveFileDialog.FileName);  	}  	else {  		ImageFormat format = ImageFormat.Png;  		switch (_saveFileDialog.FilterIndex) {  		case 2:  			format = ImageFormat.Png;  			break;  		case 3:  			format = ImageFormat.Gif;  			break;  		case 4:  			format = ImageFormat.Jpeg;  			break;  		case 5:  			format = ImageFormat.Tiff;  			break;  		case 6:  			format = ImageFormat.Bmp;  			break;  		}  		ImageRender ().Save (myStream' format);  		//_masterPane.GetImage().Save( myStream' format );  		myStream.Close ();  	}  	return _saveFileDialog.FileName;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 1) {  	myStream.Close ();  	SaveEmfFile (_saveFileDialog.FileName);  }  else {  	ImageFormat format = ImageFormat.Png;  	switch (_saveFileDialog.FilterIndex) {  	case 2:  		format = ImageFormat.Png;  		break;  	case 3:  		format = ImageFormat.Gif;  		break;  	case 4:  		format = ImageFormat.Jpeg;  		break;  	case 5:  		format = ImageFormat.Tiff;  		break;  	case 6:  		format = ImageFormat.Bmp;  		break;  	}  	ImageRender ().Save (myStream' format);  	//_masterPane.GetImage().Save( myStream' format );  	myStream.Close ();  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 1) {  	myStream.Close ();  	SaveEmfFile (_saveFileDialog.FileName);  }  else {  	ImageFormat format = ImageFormat.Png;  	switch (_saveFileDialog.FilterIndex) {  	case 2:  		format = ImageFormat.Png;  		break;  	case 3:  		format = ImageFormat.Gif;  		break;  	case 4:  		format = ImageFormat.Jpeg;  		break;  	case 5:  		format = ImageFormat.Tiff;  		break;  	case 6:  		format = ImageFormat.Bmp;  		break;  	}  	ImageRender ().Save (myStream' format);  	//_masterPane.GetImage().Save( myStream' format );  	myStream.Close ();  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 1) {  	myStream.Close ();  	SaveEmfFile (_saveFileDialog.FileName);  }  else {  	ImageFormat format = ImageFormat.Png;  	switch (_saveFileDialog.FilterIndex) {  	case 2:  		format = ImageFormat.Png;  		break;  	case 3:  		format = ImageFormat.Gif;  		break;  	case 4:  		format = ImageFormat.Jpeg;  		break;  	case 5:  		format = ImageFormat.Tiff;  		break;  	case 6:  		format = ImageFormat.Bmp;  		break;  	}  	ImageRender ().Save (myStream' format);  	//_masterPane.GetImage().Save( myStream' format );  	myStream.Close ();  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 1) {  	myStream.Close ();  	SaveEmfFile (_saveFileDialog.FileName);  }  else {  	ImageFormat format = ImageFormat.Png;  	switch (_saveFileDialog.FilterIndex) {  	case 2:  		format = ImageFormat.Png;  		break;  	case 3:  		format = ImageFormat.Gif;  		break;  	case 4:  		format = ImageFormat.Jpeg;  		break;  	case 5:  		format = ImageFormat.Tiff;  		break;  	case 6:  		format = ImageFormat.Bmp;  		break;  	}  	ImageRender ().Save (myStream' format);  	//_masterPane.GetImage().Save( myStream' format );  	myStream.Close ();  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 1) {  	myStream.Close ();  	SaveEmfFile (_saveFileDialog.FileName);  }  else {  	ImageFormat format = ImageFormat.Png;  	switch (_saveFileDialog.FilterIndex) {  	case 2:  		format = ImageFormat.Png;  		break;  	case 3:  		format = ImageFormat.Gif;  		break;  	case 4:  		format = ImageFormat.Jpeg;  		break;  	case 5:  		format = ImageFormat.Tiff;  		break;  	case 6:  		format = ImageFormat.Bmp;  		break;  	}  	ImageRender ().Save (myStream' format);  	//_masterPane.GetImage().Save( myStream' format );  	myStream.Close ();  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: switch (_saveFileDialog.FilterIndex) {  case 2:  	format = ImageFormat.Png;  	break;  case 3:  	format = ImageFormat.Gif;  	break;  case 4:  	format = ImageFormat.Jpeg;  	break;  case 5:  	format = ImageFormat.Tiff;  	break;  case 6:  	format = ImageFormat.Bmp;  	break;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: switch (_saveFileDialog.FilterIndex) {  case 2:  	format = ImageFormat.Png;  	break;  case 3:  	format = ImageFormat.Gif;  	break;  case 4:  	format = ImageFormat.Jpeg;  	break;  case 5:  	format = ImageFormat.Tiff;  	break;  case 6:  	format = ImageFormat.Bmp;  	break;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: switch (_saveFileDialog.FilterIndex) {  case 2:  	format = ImageFormat.Png;  	break;  case 3:  	format = ImageFormat.Gif;  	break;  case 4:  	format = ImageFormat.Jpeg;  	break;  case 5:  	format = ImageFormat.Tiff;  	break;  case 6:  	format = ImageFormat.Bmp;  	break;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: switch (_saveFileDialog.FilterIndex) {  case 2:  	format = ImageFormat.Png;  	break;  case 3:  	format = ImageFormat.Gif;  	break;  case 4:  	format = ImageFormat.Jpeg;  	break;  case 5:  	format = ImageFormat.Tiff;  	break;  case 6:  	format = ImageFormat.Bmp;  	break;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following statement contains a magic number: switch (_saveFileDialog.FilterIndex) {  case 2:  	format = ImageFormat.Png;  	break;  case 3:  	format = ImageFormat.Gif;  	break;  case 4:  	format = ImageFormat.Jpeg;  	break;  case 5:  	format = ImageFormat.Tiff;  	break;  case 6:  	format = ImageFormat.Bmp;  	break;  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		ImageFormat format = ImageFormat.Png;  		if (_saveFileDialog.FilterIndex == 2)  			format = ImageFormat.Gif;  		else if (_saveFileDialog.FilterIndex == 3)  			format = ImageFormat.Jpeg;  		else if (_saveFileDialog.FilterIndex == 4)  			format = ImageFormat.Tiff;  		else if (_saveFileDialog.FilterIndex == 5)  			format = ImageFormat.Bmp;  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			//_masterPane.GetImage().Save( myStream' format );  			ImageRender ().Save (myStream' format);  			myStream.Close ();  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		ImageFormat format = ImageFormat.Png;  		if (_saveFileDialog.FilterIndex == 2)  			format = ImageFormat.Gif;  		else if (_saveFileDialog.FilterIndex == 3)  			format = ImageFormat.Jpeg;  		else if (_saveFileDialog.FilterIndex == 4)  			format = ImageFormat.Tiff;  		else if (_saveFileDialog.FilterIndex == 5)  			format = ImageFormat.Bmp;  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			//_masterPane.GetImage().Save( myStream' format );  			ImageRender ().Save (myStream' format);  			myStream.Close ();  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		ImageFormat format = ImageFormat.Png;  		if (_saveFileDialog.FilterIndex == 2)  			format = ImageFormat.Gif;  		else if (_saveFileDialog.FilterIndex == 3)  			format = ImageFormat.Jpeg;  		else if (_saveFileDialog.FilterIndex == 4)  			format = ImageFormat.Tiff;  		else if (_saveFileDialog.FilterIndex == 5)  			format = ImageFormat.Bmp;  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			//_masterPane.GetImage().Save( myStream' format );  			ImageRender ().Save (myStream' format);  			myStream.Close ();  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_masterPane != null) {  	_saveFileDialog.Filter = "PNG Format (*.png)|*.png|" + "Gif Format (*.gif)|*.gif|" + "Jpeg Format (*.jpg)|*.jpg|" + "Tiff Format (*.tif)|*.tif|" + "Bmp Format (*.bmp)|*.bmp";  	if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  		ImageFormat format = ImageFormat.Png;  		if (_saveFileDialog.FilterIndex == 2)  			format = ImageFormat.Gif;  		else if (_saveFileDialog.FilterIndex == 3)  			format = ImageFormat.Jpeg;  		else if (_saveFileDialog.FilterIndex == 4)  			format = ImageFormat.Tiff;  		else if (_saveFileDialog.FilterIndex == 5)  			format = ImageFormat.Bmp;  		Stream myStream = _saveFileDialog.OpenFile ();  		if (myStream != null) {  			//_masterPane.GetImage().Save( myStream' format );  			ImageRender ().Save (myStream' format);  			myStream.Close ();  		}  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  	ImageFormat format = ImageFormat.Png;  	if (_saveFileDialog.FilterIndex == 2)  		format = ImageFormat.Gif;  	else if (_saveFileDialog.FilterIndex == 3)  		format = ImageFormat.Jpeg;  	else if (_saveFileDialog.FilterIndex == 4)  		format = ImageFormat.Tiff;  	else if (_saveFileDialog.FilterIndex == 5)  		format = ImageFormat.Bmp;  	Stream myStream = _saveFileDialog.OpenFile ();  	if (myStream != null) {  		//_masterPane.GetImage().Save( myStream' format );  		ImageRender ().Save (myStream' format);  		myStream.Close ();  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  	ImageFormat format = ImageFormat.Png;  	if (_saveFileDialog.FilterIndex == 2)  		format = ImageFormat.Gif;  	else if (_saveFileDialog.FilterIndex == 3)  		format = ImageFormat.Jpeg;  	else if (_saveFileDialog.FilterIndex == 4)  		format = ImageFormat.Tiff;  	else if (_saveFileDialog.FilterIndex == 5)  		format = ImageFormat.Bmp;  	Stream myStream = _saveFileDialog.OpenFile ();  	if (myStream != null) {  		//_masterPane.GetImage().Save( myStream' format );  		ImageRender ().Save (myStream' format);  		myStream.Close ();  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  	ImageFormat format = ImageFormat.Png;  	if (_saveFileDialog.FilterIndex == 2)  		format = ImageFormat.Gif;  	else if (_saveFileDialog.FilterIndex == 3)  		format = ImageFormat.Jpeg;  	else if (_saveFileDialog.FilterIndex == 4)  		format = ImageFormat.Tiff;  	else if (_saveFileDialog.FilterIndex == 5)  		format = ImageFormat.Bmp;  	Stream myStream = _saveFileDialog.OpenFile ();  	if (myStream != null) {  		//_masterPane.GetImage().Save( myStream' format );  		ImageRender ().Save (myStream' format);  		myStream.Close ();  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.ShowDialog () == DialogResult.OK) {  	ImageFormat format = ImageFormat.Png;  	if (_saveFileDialog.FilterIndex == 2)  		format = ImageFormat.Gif;  	else if (_saveFileDialog.FilterIndex == 3)  		format = ImageFormat.Jpeg;  	else if (_saveFileDialog.FilterIndex == 4)  		format = ImageFormat.Tiff;  	else if (_saveFileDialog.FilterIndex == 5)  		format = ImageFormat.Bmp;  	Stream myStream = _saveFileDialog.OpenFile ();  	if (myStream != null) {  		//_masterPane.GetImage().Save( myStream' format );  		ImageRender ().Save (myStream' format);  		myStream.Close ();  	}  }  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 2)  	format = ImageFormat.Gif;  else if (_saveFileDialog.FilterIndex == 3)  	format = ImageFormat.Jpeg;  else if (_saveFileDialog.FilterIndex == 4)  	format = ImageFormat.Tiff;  else if (_saveFileDialog.FilterIndex == 5)  	format = ImageFormat.Bmp;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 2)  	format = ImageFormat.Gif;  else if (_saveFileDialog.FilterIndex == 3)  	format = ImageFormat.Jpeg;  else if (_saveFileDialog.FilterIndex == 4)  	format = ImageFormat.Tiff;  else if (_saveFileDialog.FilterIndex == 5)  	format = ImageFormat.Bmp;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 2)  	format = ImageFormat.Gif;  else if (_saveFileDialog.FilterIndex == 3)  	format = ImageFormat.Jpeg;  else if (_saveFileDialog.FilterIndex == 4)  	format = ImageFormat.Tiff;  else if (_saveFileDialog.FilterIndex == 5)  	format = ImageFormat.Bmp;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 2)  	format = ImageFormat.Gif;  else if (_saveFileDialog.FilterIndex == 3)  	format = ImageFormat.Jpeg;  else if (_saveFileDialog.FilterIndex == 4)  	format = ImageFormat.Tiff;  else if (_saveFileDialog.FilterIndex == 5)  	format = ImageFormat.Bmp;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 3)  	format = ImageFormat.Jpeg;  else if (_saveFileDialog.FilterIndex == 4)  	format = ImageFormat.Tiff;  else if (_saveFileDialog.FilterIndex == 5)  	format = ImageFormat.Bmp;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 3)  	format = ImageFormat.Jpeg;  else if (_saveFileDialog.FilterIndex == 4)  	format = ImageFormat.Tiff;  else if (_saveFileDialog.FilterIndex == 5)  	format = ImageFormat.Bmp;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 3)  	format = ImageFormat.Jpeg;  else if (_saveFileDialog.FilterIndex == 4)  	format = ImageFormat.Tiff;  else if (_saveFileDialog.FilterIndex == 5)  	format = ImageFormat.Bmp;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 4)  	format = ImageFormat.Tiff;  else if (_saveFileDialog.FilterIndex == 5)  	format = ImageFormat.Bmp;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 4)  	format = ImageFormat.Tiff;  else if (_saveFileDialog.FilterIndex == 5)  	format = ImageFormat.Bmp;  
Magic Number,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAsBitmap,The following statement contains a magic number: if (_saveFileDialog.FilterIndex == 5)  	format = ImageFormat.Bmp;  
Missing Default,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,ScaleBrush,The following switch statement is missing a default case: switch (_alignH) {  case AlignH.Left:  	dx = rect.Left - linBrush.Rectangle.Left;  	break;  case AlignH.Center:  	dx = (rect.Left + rect.Width / 2.0F) - linBrush.Rectangle.Left;  	break;  case AlignH.Right:  	dx = (rect.Left + rect.Width) - linBrush.Rectangle.Left;  	break;  }  
Missing Default,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,ScaleBrush,The following switch statement is missing a default case: switch (_alignV) {  case AlignV.Top:  	dy = rect.Top - linBrush.Rectangle.Top;  	break;  case AlignV.Center:  	dy = (rect.Top + rect.Height / 2.0F) - linBrush.Rectangle.Top;  	break;  case AlignV.Bottom:  	dy = (rect.Top + rect.Height) - linBrush.Rectangle.Top;  	break;  }  
Missing Default,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,ScaleBrush,The following switch statement is missing a default case: switch (_alignH) {  case AlignH.Left:  	dx = rect.Left;  	break;  case AlignH.Center:  	dx = (rect.Left + rect.Width / 2.0F);  	break;  case AlignH.Right:  	dx = (rect.Left + rect.Width);  	break;  }  
Missing Default,ZedGraph,Fill,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Fill.cs,ScaleBrush,The following switch statement is missing a default case: switch (_alignV) {  case AlignV.Top:  	dy = rect.Top;  	break;  case AlignV.Center:  	dy = (rect.Top + rect.Height / 2.0F);  	break;  case AlignV.Bottom:  	dy = (rect.Top + rect.Height);  	break;  }  
Missing Default,ZedGraph,Legend,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Legend.cs,CalcRect,The following switch statement is missing a default case: switch (_position) {  case LegendPos.Right:  	newRect.X = clientRect.Right - totLegWidth;  	newRect.Y = tChartRect.Top;  	tChartRect.Width -= totLegWidth + gapPix;  	break;  case LegendPos.Top:  	newRect.X = tChartRect.Left;  	newRect.Y = clientRect.Top;  	tChartRect.Y += totLegHeight + gapPix;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.TopFlushLeft:  	newRect.X = clientRect.Left;  	newRect.Y = clientRect.Top;  	tChartRect.Y += totLegHeight + gapPix * 1.5f;  	tChartRect.Height -= totLegHeight + gapPix * 1.5f;  	break;  case LegendPos.TopCenter:  	newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  	newRect.Y = tChartRect.Top;  	tChartRect.Y += totLegHeight + gapPix;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.Bottom:  	newRect.X = tChartRect.Left;  	newRect.Y = clientRect.Bottom - totLegHeight;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.BottomFlushLeft:  	newRect.X = clientRect.Left;  	newRect.Y = clientRect.Bottom - totLegHeight;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.BottomCenter:  	newRect.X = tChartRect.Left + (tChartRect.Width - totLegWidth) / 2;  	newRect.Y = clientRect.Bottom - totLegHeight;  	tChartRect.Height -= totLegHeight + gapPix;  	break;  case LegendPos.Left:  	newRect.X = clientRect.Left;  	newRect.Y = tChartRect.Top;  	tChartRect.X += totLegWidth + halfGap;  	tChartRect.Width -= totLegWidth + gapPix;  	break;  case LegendPos.InsideTopRight:  	newRect.X = tChartRect.Right - totLegWidth;  	newRect.Y = tChartRect.Top;  	break;  case LegendPos.InsideTopLeft:  	newRect.X = tChartRect.Left;  	newRect.Y = tChartRect.Top;  	break;  case LegendPos.InsideBotRight:  	newRect.X = tChartRect.Right - totLegWidth;  	newRect.Y = tChartRect.Bottom - totLegHeight;  	break;  case LegendPos.InsideBotLeft:  	newRect.X = tChartRect.Left;  	newRect.Y = tChartRect.Bottom - totLegHeight;  	break;  case LegendPos.Float:  	newRect.Location = this.Location.TransformTopLeft (pane' totLegWidth' totLegHeight);  	break;  }  
Missing Default,ZedGraph,Symbol,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\Symbol.cs,MakePath,The following switch statement is missing a default case: switch (_type == SymbolType.Default || (_type == SymbolType.UserDefined && _userSymbol == null) ? Default.Type : _type) {  case SymbolType.Square:  	path.AddLine (-hsize' -hsize' hsize' -hsize);  	path.AddLine (hsize' -hsize' hsize' hsize);  	path.AddLine (hsize' hsize' -hsize' hsize);  	path.AddLine (-hsize' hsize' -hsize' -hsize);  	break;  case SymbolType.Diamond:  	path.AddLine (0' -hsize' hsize' 0);  	path.AddLine (hsize' 0' 0' hsize);  	path.AddLine (0' hsize' -hsize' 0);  	path.AddLine (-hsize' 0' 0' -hsize);  	break;  case SymbolType.Triangle:  	path.AddLine (0' -hsize' hsize' hsize);  	path.AddLine (hsize' hsize' -hsize' hsize);  	path.AddLine (-hsize' hsize' 0' -hsize);  	break;  case SymbolType.Circle:  	path.AddEllipse (-hsize' -hsize' scaledSize' scaledSize);  	break;  case SymbolType.XCross:  	path.AddLine (-hsize' -hsize' hsize1' hsize1);  	path.StartFigure ();  	path.AddLine (hsize' -hsize' -hsize1' hsize1);  	break;  case SymbolType.Plus:  	path.AddLine (0' -hsize' 0' hsize1);  	path.StartFigure ();  	path.AddLine (-hsize' 0' hsize1' 0);  	break;  case SymbolType.Star:  	path.AddLine (0' -hsize' 0' hsize1);  	path.StartFigure ();  	path.AddLine (-hsize' 0' hsize1' 0);  	path.StartFigure ();  	path.AddLine (-hsize' -hsize' hsize1' hsize1);  	path.StartFigure ();  	path.AddLine (hsize' -hsize' -hsize1' hsize1);  	break;  case SymbolType.TriangleDown:  	path.AddLine (0' hsize' hsize' -hsize);  	path.AddLine (hsize' -hsize' -hsize' -hsize);  	path.AddLine (-hsize' -hsize' 0' hsize);  	break;  case SymbolType.HDash:  	path.AddLine (-hsize' 0' hsize1' 0);  	break;  case SymbolType.VDash:  	path.AddLine (0' -hsize' 0' hsize1);  	break;  case SymbolType.UserDefined:  	path = _userSymbol.Clone () as GraphicsPath;  	Matrix scaleTransform = new Matrix (scaledSize' 0.0f' 0.0f' scaledSize' 0.0f' 0.0f);  	path.Transform (scaleTransform);  	break;  }  
Missing Default,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,contextMenuStrip1_Opening,The following switch statement is missing a default case: switch (pane.ZoomStack.Top.Type) {  case ZoomState.StateType.Zoom:  case ZoomState.StateType.WheelZoom:  	menuStr = _resourceManager.GetString ("unzoom");  	break;  case ZoomState.StateType.Pan:  	menuStr = _resourceManager.GetString ("unpan");  	break;  case ZoomState.StateType.Scroll:  	menuStr = _resourceManager.GetString ("unscroll");  	break;  }  
Missing Default,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following switch statement is missing a default case: switch (ext) {  case ".emf":  	_saveFileDialog.FilterIndex = 1;  	break;  case ".png":  	_saveFileDialog.FilterIndex = 2;  	break;  case ".gif":  	_saveFileDialog.FilterIndex = 3;  	break;  case ".jpeg":  case ".jpg":  	_saveFileDialog.FilterIndex = 4;  	break;  case ".tiff":  case ".tif":  	_saveFileDialog.FilterIndex = 5;  	break;  case ".bmp":  	_saveFileDialog.FilterIndex = 6;  	break;  }  
Missing Default,ZedGraph,ZedGraphControl,C:\repos\spark-div_signalanalyzer2\3rdparty\zedgraph-svn-trunk\Backup\source\ZedGraph\ZedGraphControl.ContextMenu.cs,SaveAs,The following switch statement is missing a default case: switch (_saveFileDialog.FilterIndex) {  case 2:  	format = ImageFormat.Png;  	break;  case 3:  	format = ImageFormat.Gif;  	break;  case 4:  	format = ImageFormat.Jpeg;  	break;  case 5:  	format = ImageFormat.Tiff;  	break;  case 6:  	format = ImageFormat.Bmp;  	break;  }  
