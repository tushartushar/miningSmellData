Implementation smell,Namespace,Class,File,Method,Description
Long Method,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The method has 203 lines of code.
Long Method,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The method has 162 lines of code.
Long Method,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The method has 253 lines of code.
Complex Method,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,Cyclomatic complexity of the method is 38
Complex Method,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,Cyclomatic complexity of the method is 47
Complex Method,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ByteSearch,Cyclomatic complexity of the method is 8
Complex Method,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,Cyclomatic complexity of the method is 25
Complex Method,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,CheckHeaders,Cyclomatic complexity of the method is 11
Long Parameter List,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,BonCodeAJP13ForwardRequest,The method has 9 parameters.
Long Parameter List,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,BonCodeAJP13ForwardRequest,The method has 5 parameters.
Long Parameter List,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The method has 13 parameters.
Long Parameter List,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacketTest,The method has 9 parameters.
Long Statement,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,LogException,The length of the statement  "				logStream.WriteLine (DateTime.Now.ToString (p_timestampFormat) + BonCodeAJP13Consts.BONCODEAJP13_CONNECTOR_VERSION + " ERROR "); " is 128.
Long Statement,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,LogMessage,The length of the statement  "	if (BonCodeAJP13Settings.BONCODEAJP13_LOG_LEVEL > BonCodeAJP13LogLevels.BONCODEAJP13_NO_LOG && BonCodeAJP13Settings.BONCODEAJP13_LOG_LEVEL >= minLogLevel) { " is 156.
Long Statement,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,LogMessageAndType,The length of the statement  "	if (BonCodeAJP13Settings.BONCODEAJP13_LOG_LEVEL > BonCodeAJP13LogLevels.BONCODEAJP13_NO_LOG && BonCodeAJP13Settings.BONCODEAJP13_LOG_LEVEL >= minLogLevel) { " is 156.
Long Statement,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,LogPacket,The length of the statement  "	if (BonCodeAJP13Settings.BONCODEAJP13_LOG_LEVEL > BonCodeAJP13LogLevels.BONCODEAJP13_NO_LOG && BonCodeAJP13Settings.BONCODEAJP13_LOG_LEVEL >= minLogLevel || logAllways) { " is 170.
Long Statement,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,LogPacket,The length of the statement  "					logStream.WriteLine (DateTime.Now.ToString (p_timestampFormat) + packet.ToString () + " " + packet.PrintPacketHeader ()); " is 121.
Long Statement,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,LogPacket,The length of the statement  "					logStream.WriteLine (DateTime.Now.ToString (p_timestampFormat) + packet.ToString () + " " + packet.PrintPacketHeader ()); " is 121.
Long Statement,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,LogDebug,The length of the statement  "			logStream.WriteLine (String.Format ("{0}[T-{1}] {2}"' DateTime.Now.ToString (p_timestampFormat)' Thread.CurrentThread.ManagedThreadId' message)); " is 145.
Long Statement,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,SetString,The length of the statement  "		//the last byte of valueData is allways zero based on our initial declaration. This indicates the terminator byte as well. Copy this to the main byte array " is 155.
Long Statement,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateAttributeTranslation,The length of the statement  "		//p_ATranslator.Add("PATH_INFO"' BonCodeAJP13HTTPAttributes.BONCODEAJP13_SERVLET_PATH); //PATH_INFO though specified here is not implemented on tomcat side. This is currently is a known defect. Once tomcat implements this just change the name back. " is 248.
Long Statement,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateAttributeTranslation,The length of the statement  "		//SSL_CIPHER IS NOT IMPLEMENTED IN THIS FORM' IIS7+ Uses multiple data points. All SSL data is transferred via HTTP headers " is 123.
Long Statement,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateAttributeTranslation,The length of the statement  "		//indicate whether we are using HTTPS session. This impacts how the container responds. It will force SSL and all cookies will be secure. " is 137.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,CheckMutex,The length of the statement  "				MatchCollection matches = Regex.Matches (p_ClientIp' BonCodeAJP13Settings.BONCODEAJP13_LOG_IPFILTER' RegexOptions.IgnorePatternWhitespace); " is 139.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,CheckMutex,The length of the statement  "			p_Logger = new BonCodeAJP13Logger (BonCodeAJP13Settings.BONCODEAJP13_LOG_FILE + p_LogFilePostFix + DateTime.Now.ToString ("yyyyMMdd") + ".log"' p_ConnectionMutex); " is 163.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,p_CreateConnection,The length of the statement  "			errMsg = errMsg + "<br><small>Administrator: please enable logging with log level 1 or greater for detail problem capture if needed.</small>"; " is 142.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,HandleConnection,The length of the statement  "	//if (p_Logger != null) p_Logger.LogMessage(String.Format("New Connection {0} of {1} to tomcat: {2} ID: {3} [T-{4}]"'p_ConcurrentConnections'BonCodeAJP13Settings.MAX_BONCODEAJP13_CONCURRENT_CONNECTIONS' p_TCPClient.Client.RemoteEndPoint.ToString()' p_ThisConnectionID' Thread.CurrentThread.ManagedThreadId)' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC); " is 354.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,HandleConnection,The length of the statement  "		p_Logger.LogMessage (String.Format ("New Connection {0} of {1} to tomcat: {2} ID: {3} [T-{4}]"' p_ConcurrentConnections' BonCodeAJP13Settings.MAX_BONCODEAJP13_CONCURRENT_CONNECTIONS' p_TCPClient.Client.RemoteEndPoint.ToString ()' p_ThisConnectionID' AppDomain.GetCurrentThreadId ())' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC); " is 330.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "				//send first packet immediatly (most likely a post)' unless there is a delay write indicator (will be set during analysis) " is 122.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "				//after the second packet (first packet for Adobe) in a packet collection we have to listen and receive a TomcatGetBodyChunk " is 124.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "									p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC); " is 128.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "								p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC); " is 148.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "								p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC); " is 204.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "		// We have to do a complex type multi-comparison rather than using just one 'is' operator since c# seems to have an issue determining class type in collection " is 158.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "		if (p_PacketsReceived [p_PacketsReceived.Count - 1] is TomcatSendBodyChunk || p_PacketsReceived [p_PacketsReceived.Count - 1].GetType () == typeof(TomcatGetBodyChunk) || p_PacketsReceived [p_PacketsReceived.Count - 1] is BonCodeAJP13.TomcatPackets.TomcatSendBodyChunk) { " is 270.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "				//flush detection by bytes -- in case where time flush is also defined (ticks>0) we will wait until a time flush occurs (p_TimeFlushOccurred) " is 141.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "				if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS == 0 || (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 && p_TimeFlushOccurred))) { " is 229.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "				//analyze packet so far (adjust bytes from Receiving buffer):combine notProcessed with new Read bytes into new Received buffer if needed                         " is 136.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "					//create tempArray that contains new set of bytes to be send a combination of newly received bytes as well as bytes that we were not able to process yet " is 152.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "				p_Logger.LogMessageAndType ("Stream reading problem (2)(" + readCount.ToString () + ")' you may have shutdown Tomcat unexpectedly"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC); " is 189.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "		//check error condition that tomcat produces sometimes where additional data is sent after end_transmission has been indicated                 " is 126.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "			//we need to clear the tcp pipe so the next request does not pick up data we will do this up to 100 times and write warning " is 123.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "					p_Logger.LogMessageAndType ("extra data after transmission-end from tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS); " is 136.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The length of the statement  "		p_Logger.LogMessageAndType ("Empty packet received from tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC); " is 122.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ConnectionError,The length of the statement  "	//if (p_Logger != null) p_Logger.LogMessage("One Connection raised an error"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS); " is 125.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ConnectionError,The length of the statement  "		throw new InvalidOperationException ("Connection between Tomcat and IIS experienced error. If you restarted Tomcat this is expected. "); " is 136.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ConnectionError,The length of the statement  "		throw new InvalidOperationException ("Connection between Tomcat and IIS experienced error. If you restarted Tomcat this is expected. " + messageType + ":" + message); " is 166.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The length of the statement  "	//safety check for exit condition (with standard packets and a min packet size of 4 bytes max theoretical packets to be analyze is 8196/4) " is 138.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The length of the statement  "					//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package " is 139.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The length of the statement  "						//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                           " is 136.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The length of the statement  "						if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) { " is 161.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The length of the statement  "							p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG); " is 132.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The length of the statement  "						//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same. " is 166.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The length of the statement  "							//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."); " is 272.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The length of the statement  "								p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC); " is 308.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The length of the statement  "					//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                " is 122.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The length of the statement  "						p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS); " is 121.
Long Statement,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ByteSearch,The length of the statement  "	if (searchIn.Length > 0 && searchBytes.Length > 0 && start <= (searchIn.Length - searchBytes.Length) && searchIn.Length >= searchBytes.Length) { " is 144.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The length of the statement  "	//BonCodeAJP13Logger.LogDebug(String.Format("{0} {1} {2} {3} {4} {5} [{6}]"' this.ConnectionId' remote_addr' GetKeyValue(httpHeaders' "REQUEST_METHOD")' server_name' req_uri' GetKeyValue(httpHeaders' "QUERY_STRING")' GetKeyValue(httpHeaders' "HTTP_USER_AGENT"))); " is 263.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The length of the statement  "	//call alternate method to complete writing of forward request packet. Final data will be stored in in p_ByteStore instance var " is 127.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The length of the statement  "		WritePacket (method' protocol' req_uri' remote_addr' remote_host' server_name' server_port' is_ssl' num_headers' httpHeaders' pathInfo' sourcePort' vDirs); " is 155.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The length of the statement  "	//add a mapping prefix if one is provided unless the same prefix is already on the start of Uri (case sensitive comparison) " is 123.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The length of the statement  "	if (BonCodeAJP13Settings.BONCODEAJP13_PATH_PREFIX.Length > 2 && !BonCodeAJP13Settings.BONCODEAJP13_PATH_PREFIX.Equals (req_uri.Substring (0' BonCodeAJP13Settings.BONCODEAJP13_PATH_PREFIX.Length - 1)' StringComparison.Ordinal)) { " is 228.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The length of the statement  "			throw new Exception ("Invalid content length. Last header processed [" + keyName + "]. Please reconfigure BonCode Connector and Apache Tomcat to allow larger transfer packets. Your max allowed content length is " + BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH + " bytes. Provided content length would be at least " + expectedPacketSize + " bytes. Clearing cookies may allow you proceed."); " is 398.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The length of the statement  "		//addlAtts.Add("HTTPS_SECRETKEYSIZE"' httpHeaders["CERT_SECRETKEYSIZE"]);  // this is done later and extracted from http headers " is 128.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The length of the statement  "					throw new Exception ("Invalid content length. Last attribute processed [" + keyName + "]. Please reconfigure BonCode Connector and Apache Tomcat to allow larger transfer packets. Your max allowed content length is " + BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH + " bytes. Provided content length would be at least " + expectedPacketSize + " bytes."); " is 361.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The length of the statement  "	//Second iteration through headers Some header values have to be passed as attributes REMOTE_USER' AUTH_TYPE' QUERY_STRING " is 122.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The length of the statement  "				throw new Exception ("Invalid content length. Last header processed [" + keyName + "]. Please reconfigure BonCode Connector and Apache Tomcat to allow larger transfer packets. Your max allowed content length is " + BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH + " bytes. Provided content length would be at least " + expectedPacketSize + " bytes."); " is 358.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,CheckHeaders,The length of the statement  "	//"HTTP_CONNECTION"'"CONTENT_LENGTH"'"HTTP_ACCEPT"'"HTTP_ACCEPT_ENCODING"'"HTTP_ACCEPT_LANGUAGE"'"HTTP_COOKIE"'"HTTP_HOST"'"HTTP_USER_AGENT"'"HTTP_ACCEPT_CHARSET" " is 162.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,GetFingerprint,The length of the statement  "	//"REMOTE_ADDR'HTTP_ACCEPT'HTTP_ACCEPT_CHARSET'HTTP_ACCEPT_ENCODING'HTTP_ACCEPT_LANGUAGE'HTTP_USER_AGENT'UA_CPU'REMOTE_HOST"; " is 125.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,GetFingerprint,The length of the statement  "		lstFPHeaders = "REMOTE_ADDR'HTTP_ACCEPT'HTTP_ACCEPT_CHARSET'HTTP_ACCEPT_ENCODING'HTTP_ACCEPT_LANGUAGE'HTTP_USER_AGENT'UA_CPU'REMOTE_HOST"; " is 138.
Long Statement,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,CertExportToPEM,The length of the statement  "	builder.AppendLine (Convert.ToBase64String (cert.Export (X509ContentType.Cert)' Base64FormattingOptions.InsertLineBreaks)); " is 123.
Complex Conditional,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The conditional expression  "BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS == 0 || (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 && p_TimeFlushOccurred))"  is complex.
Complex Conditional,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ByteSearch,The conditional expression  "searchIn.Length > 0 && searchBytes.Length > 0 && start <= (searchIn.Length - searchBytes.Length) && searchIn.Length >= searchBytes.Length"  is complex.
Empty Catch Block,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,RecordSysEvent,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,BonCodeAJP13Packet,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,BonCodeAJP13Packet,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,GetRemoteAddr,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13.TomcatPackets,TomcatCPongReply,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatCPongReply.cs,TomcatCPongReply,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13.TomcatPackets,TomcatEndResponse,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatEndResponse.cs,TomcatEndResponse,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13.TomcatPackets,TomcatGetBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatGetBodyChunk.cs,TomcatGetBodyChunk,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13.TomcatPackets,TomcatPhysicalPathRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatPhysicalPathRequest.cs,TomcatPhysicalPathRequest,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13.TomcatPackets,TomcatReturn,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatReturn.cs,TomcatReturn,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13.TomcatPackets,TomcatSendBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendBodyChunk.cs,TomcatSendBodyChunk,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13.TomcatPackets,TomcatSendBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendBodyChunk.cs,TomcatSendBodyChunk,The method has an empty catch block.
Empty Catch Block,BonCodeAJP13.TomcatPackets,TomcatSendHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendHeaders.cs,TomcatSendHeaders,The method has an empty catch block.
Magic Number,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,GetLogDir,The following statement contains a magic number: if (BonCodeAJP13Settings.BONCODEAJP13_LOG_DIR.Length >= 3) {  	retValue = BonCodeAJP13Settings.BONCODEAJP13_LOG_DIR;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,RecordSysEvent,The following statement contains a magic number: if (EventLog.SourceExists (sSource)) {  	//record in event log  	try {  		EventLog.WriteEntry (sSource' sEvent' eType' 418);  	} catch {  		//do nothing for now  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,RecordSysEvent,The following statement contains a magic number: try {  	EventLog.WriteEntry (sSource' sEvent' eType' 418);  } catch {  	//do nothing for now  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Logger,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Logger.cs,RecordSysEvent,The following statement contains a magic number: EventLog.WriteEntry (sSource' sEvent' eType' 418);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,BonCodeAJP13Packet,The following statement contains a magic number: if (buffer != null && buffer.Length >= BonCodeAJP13Consts.MIN_BONCODEAJP13_PACKET_LENGTH && buffer.Length <= BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH) {  	try {  		p_UserDataLength = System.Convert.ToUInt16 (buffer.Length - 4);  	} catch {  	}  } else {  	// throw an exeption to mark reason  	throw new Exception ("Invalid BonCodeAJP13 Packet received. Wrong byte length or null buffer.");  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,BonCodeAJP13Packet,The following statement contains a magic number: try {  	p_UserDataLength = System.Convert.ToUInt16 (buffer.Length - 4);  } catch {  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,BonCodeAJP13Packet,The following statement contains a magic number: p_UserDataLength = System.Convert.ToUInt16 (buffer.Length - 4);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,BonCodeAJP13Packet,The following statement contains a magic number: if (content != null) {  	System.Text.UTF8Encoding encoder = new System.Text.UTF8Encoding ();  	byte[] buffer = encoder.GetBytes (content);  	if (buffer.Length >= BonCodeAJP13Consts.MIN_BONCODEAJP13_PACKET_LENGTH && buffer.Length <= BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH) {  		try {  			p_UserDataLength = System.Convert.ToUInt16 (buffer.Length - 4);  		} catch {  		}  	} else {  		// throw an exeption to mark reason  		throw new Exception ("Invalid BonCodeAJP13 Packet received. Wrong byte length.");  	}  } else {  	// throw an exeption to mark reason  	throw new Exception ("No content. Invalid BonCodeAJP13 Packet received. Zero byte length.");  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,BonCodeAJP13Packet,The following statement contains a magic number: if (buffer.Length >= BonCodeAJP13Consts.MIN_BONCODEAJP13_PACKET_LENGTH && buffer.Length <= BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH) {  	try {  		p_UserDataLength = System.Convert.ToUInt16 (buffer.Length - 4);  	} catch {  	}  } else {  	// throw an exeption to mark reason  	throw new Exception ("Invalid BonCodeAJP13 Packet received. Wrong byte length.");  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,BonCodeAJP13Packet,The following statement contains a magic number: try {  	p_UserDataLength = System.Convert.ToUInt16 (buffer.Length - 4);  } catch {  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,BonCodeAJP13Packet,The following statement contains a magic number: p_UserDataLength = System.Convert.ToUInt16 (buffer.Length - 4);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataBytes,The following statement contains a magic number: if (p_ByteStore.Length > 3) {  	byte[] userArray = new byte[p_ByteStore.Length - 4];  	Array.Copy (p_ByteStore' 3' userArray' 0' p_ByteStore.Length - 4);  	return userArray;  } else {  	//return empty marker if no user data  	return new byte[] {    	};  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataBytes,The following statement contains a magic number: if (p_ByteStore.Length > 3) {  	byte[] userArray = new byte[p_ByteStore.Length - 4];  	Array.Copy (p_ByteStore' 3' userArray' 0' p_ByteStore.Length - 4);  	return userArray;  } else {  	//return empty marker if no user data  	return new byte[] {    	};  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataBytes,The following statement contains a magic number: if (p_ByteStore.Length > 3) {  	byte[] userArray = new byte[p_ByteStore.Length - 4];  	Array.Copy (p_ByteStore' 3' userArray' 0' p_ByteStore.Length - 4);  	return userArray;  } else {  	//return empty marker if no user data  	return new byte[] {    	};  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataBytes,The following statement contains a magic number: if (p_ByteStore.Length > 3) {  	byte[] userArray = new byte[p_ByteStore.Length - 4];  	Array.Copy (p_ByteStore' 3' userArray' 0' p_ByteStore.Length - 4);  	return userArray;  } else {  	//return empty marker if no user data  	return new byte[] {    	};  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataBytes,The following statement contains a magic number: Array.Copy (p_ByteStore' 3' userArray' 0' p_ByteStore.Length - 4);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataBytes,The following statement contains a magic number: Array.Copy (p_ByteStore' 3' userArray' 0' p_ByteStore.Length - 4);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataString,The following statement contains a magic number: if (p_ByteStore.Length > 3) {  	return System.Text.Encoding.UTF8.GetString (p_ByteStore' 3' p_ByteStore.Length - 4);  } else {  	return "";  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataString,The following statement contains a magic number: if (p_ByteStore.Length > 3) {  	return System.Text.Encoding.UTF8.GetString (p_ByteStore' 3' p_ByteStore.Length - 4);  } else {  	return "";  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataString,The following statement contains a magic number: if (p_ByteStore.Length > 3) {  	return System.Text.Encoding.UTF8.GetString (p_ByteStore' 3' p_ByteStore.Length - 4);  } else {  	return "";  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataString,The following statement contains a magic number: return System.Text.Encoding.UTF8.GetString (p_ByteStore' 3' p_ByteStore.Length - 4);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetUserDataString,The following statement contains a magic number: return System.Text.Encoding.UTF8.GetString (p_ByteStore' 3' p_ByteStore.Length - 4);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,SetString,The following statement contains a magic number: if (data != null && pos > -1) {  	// ASCIIEncoding encodingLib = new System.Text.ASCIIEncoding();  	UTF8Encoding encodingLib = new System.Text.UTF8Encoding ();  	int valueByteSize = encodingLib.GetByteCount (value);  	byte[] valueData = new byte[valueByteSize + 3];  	// need space for character counter at the beginning of array and termination at end  	SetUInt16 (valueData' (UInt16)valueByteSize' 0);  	//first two bytes set the length of the string  	byte[] temp = new byte[valueByteSize];  	temp = encodingLib.GetBytes (value);  	Array.Copy (temp' 0' valueData' 2' temp.Length);  	//the last byte of valueData is allways zero based on our initial declaration. This indicates the terminator byte as well. Copy this to the main byte array  	Array.Copy (valueData' 0' data' pos' valueData.Length);  	return pos + valueByteSize + 3;  	//we added three more characters/bytes than passed in  } else {  	//we cannot write to null data reference or invalid pos' return zero pos or same pos as passed  	return pos == -1 ? 0 : pos;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,SetString,The following statement contains a magic number: if (data != null && pos > -1) {  	// ASCIIEncoding encodingLib = new System.Text.ASCIIEncoding();  	UTF8Encoding encodingLib = new System.Text.UTF8Encoding ();  	int valueByteSize = encodingLib.GetByteCount (value);  	byte[] valueData = new byte[valueByteSize + 3];  	// need space for character counter at the beginning of array and termination at end  	SetUInt16 (valueData' (UInt16)valueByteSize' 0);  	//first two bytes set the length of the string  	byte[] temp = new byte[valueByteSize];  	temp = encodingLib.GetBytes (value);  	Array.Copy (temp' 0' valueData' 2' temp.Length);  	//the last byte of valueData is allways zero based on our initial declaration. This indicates the terminator byte as well. Copy this to the main byte array  	Array.Copy (valueData' 0' data' pos' valueData.Length);  	return pos + valueByteSize + 3;  	//we added three more characters/bytes than passed in  } else {  	//we cannot write to null data reference or invalid pos' return zero pos or same pos as passed  	return pos == -1 ? 0 : pos;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,SetString,The following statement contains a magic number: if (data != null && pos > -1) {  	// ASCIIEncoding encodingLib = new System.Text.ASCIIEncoding();  	UTF8Encoding encodingLib = new System.Text.UTF8Encoding ();  	int valueByteSize = encodingLib.GetByteCount (value);  	byte[] valueData = new byte[valueByteSize + 3];  	// need space for character counter at the beginning of array and termination at end  	SetUInt16 (valueData' (UInt16)valueByteSize' 0);  	//first two bytes set the length of the string  	byte[] temp = new byte[valueByteSize];  	temp = encodingLib.GetBytes (value);  	Array.Copy (temp' 0' valueData' 2' temp.Length);  	//the last byte of valueData is allways zero based on our initial declaration. This indicates the terminator byte as well. Copy this to the main byte array  	Array.Copy (valueData' 0' data' pos' valueData.Length);  	return pos + valueByteSize + 3;  	//we added three more characters/bytes than passed in  } else {  	//we cannot write to null data reference or invalid pos' return zero pos or same pos as passed  	return pos == -1 ? 0 : pos;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,SetString,The following statement contains a magic number: Array.Copy (temp' 0' valueData' 2' temp.Length);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,SetString,The following statement contains a magic number: return pos + valueByteSize + 3;  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetString,The following statement contains a magic number: value = encodingLib.GetString (data' pos + 2' realLength);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetString,The following statement contains a magic number: return pos + realLength + 3;  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,SetByteArray,The following statement contains a magic number: Array.Copy (lengthOfArrayStore' 0' data' pos' 2);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,SetByteArray,The following statement contains a magic number: Array.Copy (value' 0' data' pos + 2' value.Length);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,SetByteArray,The following statement contains a magic number: return pos + value.Length + 2;  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetByteArray,The following statement contains a magic number: Array.Copy (data' pos + 2' value' 0' arrayLength);  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,GetByteArray,The following statement contains a magic number: return pos + arrayLength + 2;  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,PrintPacket,The following statement contains a magic number: if (p_ByteStore.Length > 2) {  	strPck = strPck + "\r\nUser Data High:" + p_ByteStore [1].ToString ();  	strPck = strPck + "\r\nUser Data Low:" + p_ByteStore [2].ToString ();  	strPck = strPck + "\r\n";  	if (p_ByteStore.Length > 4) {  		strPck = strPck + GetUserDataString ();  	}  } else {  	strPck = strPck + System.Text.Encoding.UTF8.GetString (p_ByteStore' 0' p_ByteStore.Length);  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,PrintPacket,The following statement contains a magic number: if (p_ByteStore.Length > 2) {  	strPck = strPck + "\r\nUser Data High:" + p_ByteStore [1].ToString ();  	strPck = strPck + "\r\nUser Data Low:" + p_ByteStore [2].ToString ();  	strPck = strPck + "\r\n";  	if (p_ByteStore.Length > 4) {  		strPck = strPck + GetUserDataString ();  	}  } else {  	strPck = strPck + System.Text.Encoding.UTF8.GetString (p_ByteStore' 0' p_ByteStore.Length);  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,PrintPacket,The following statement contains a magic number: if (p_ByteStore.Length > 2) {  	strPck = strPck + "\r\nUser Data High:" + p_ByteStore [1].ToString ();  	strPck = strPck + "\r\nUser Data Low:" + p_ByteStore [2].ToString ();  	strPck = strPck + "\r\n";  	if (p_ByteStore.Length > 4) {  		strPck = strPck + GetUserDataString ();  	}  } else {  	strPck = strPck + System.Text.Encoding.UTF8.GetString (p_ByteStore' 0' p_ByteStore.Length);  }  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,PrintPacket,The following statement contains a magic number: strPck = strPck + "\r\nUser Data Low:" + p_ByteStore [2].ToString ();  
Magic Number,BonCodeAJP13,BonCodeAJP13Packet,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13Packet.cs,PrintPacket,The following statement contains a magic number: if (p_ByteStore.Length > 4) {  	strPck = strPck + GetUserDataString ();  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: if (p_HTranslator == null) {  	p_HTranslator = new Hashtable ();  	p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  	});  	p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  	});  	p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  	});  	p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  	});  	p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  	});  	p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  	});  	p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  	});  	p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  	});  	p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  	});  	p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  	});  	//HTTP_COOKIE2 IS NOT IMPLEMENTED IN IIS7' included here for completeness sake                     	p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  	});  	p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  	});  	//HTTP_PRAGMA IS NOT IMPLEMENTED IN IIS7' included here for completeness sake  	p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  	});  	p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  		0xA0'  		BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  	});  }  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_ACCEPT"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_ACCEPT_CHARSET"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_CHARSET  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_ACCEPT_ENCODING"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_ENCODING  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_ACCEPT_LANGUAGE"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_ACCEPT_LANGUAGE  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_AUTHORIZATION"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_AUTHORIZATION  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_CONNECTION"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONNECTION  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("CONTENT_TYPE"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_TYPE  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("CONTENT_LENGTH"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_CONTENT_LENGTH  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_COOKIE"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_COOKIE2"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_COOKIE2  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_HOST"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_HOST  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_PRAGMA"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_PRAGMA  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_REFERER"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_REFERER  });  
Magic Number,BonCodeAJP13,BonCodeAJP13PacketHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13PacketHeaders.cs,PopulateHeaderTranslation,The following statement contains a magic number: p_HTranslator.Add ("HTTP_USER_AGENT"' new byte[2] {  	0xA0'  	BonCodeAJP13HTTPHeaders.BONCODEAJP13_USER_AGENT  });  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ProcessFlush,The following statement contains a magic number: if (p_FpDelegate != null) {  	//we have to wait until previous flush completes before flushing or until our timeout has expired  	if (p_FlushInProgress != null) {  		int maxWaitCount = (BonCodeAJP13Settings.BONCODEAJP13_FLUSH_TIMEOUT * 1000) / 50;  		int i = 0;  		if (p_Logger != null)  			p_Logger.LogMessage ("flush in progress detected. waiting."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  		while (p_FlushInProgress () && i < maxWaitCount) {  			i++;  			Thread.Sleep (50);  			//wait 50 miliseconds for flush to complete  		}  	}  	//pass on the packets received to delegate function for processing  	p_FpDelegate (p_PacketsReceived);  	//Delete all packets processed so far  	p_PacketsReceived.Clear ();  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ProcessFlush,The following statement contains a magic number: if (p_FpDelegate != null) {  	//we have to wait until previous flush completes before flushing or until our timeout has expired  	if (p_FlushInProgress != null) {  		int maxWaitCount = (BonCodeAJP13Settings.BONCODEAJP13_FLUSH_TIMEOUT * 1000) / 50;  		int i = 0;  		if (p_Logger != null)  			p_Logger.LogMessage ("flush in progress detected. waiting."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  		while (p_FlushInProgress () && i < maxWaitCount) {  			i++;  			Thread.Sleep (50);  			//wait 50 miliseconds for flush to complete  		}  	}  	//pass on the packets received to delegate function for processing  	p_FpDelegate (p_PacketsReceived);  	//Delete all packets processed so far  	p_PacketsReceived.Clear ();  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ProcessFlush,The following statement contains a magic number: if (p_FpDelegate != null) {  	//we have to wait until previous flush completes before flushing or until our timeout has expired  	if (p_FlushInProgress != null) {  		int maxWaitCount = (BonCodeAJP13Settings.BONCODEAJP13_FLUSH_TIMEOUT * 1000) / 50;  		int i = 0;  		if (p_Logger != null)  			p_Logger.LogMessage ("flush in progress detected. waiting."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  		while (p_FlushInProgress () && i < maxWaitCount) {  			i++;  			Thread.Sleep (50);  			//wait 50 miliseconds for flush to complete  		}  	}  	//pass on the packets received to delegate function for processing  	p_FpDelegate (p_PacketsReceived);  	//Delete all packets processed so far  	p_PacketsReceived.Clear ();  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ProcessFlush,The following statement contains a magic number: if (p_FlushInProgress != null) {  	int maxWaitCount = (BonCodeAJP13Settings.BONCODEAJP13_FLUSH_TIMEOUT * 1000) / 50;  	int i = 0;  	if (p_Logger != null)  		p_Logger.LogMessage ("flush in progress detected. waiting."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  	while (p_FlushInProgress () && i < maxWaitCount) {  		i++;  		Thread.Sleep (50);  		//wait 50 miliseconds for flush to complete  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ProcessFlush,The following statement contains a magic number: if (p_FlushInProgress != null) {  	int maxWaitCount = (BonCodeAJP13Settings.BONCODEAJP13_FLUSH_TIMEOUT * 1000) / 50;  	int i = 0;  	if (p_Logger != null)  		p_Logger.LogMessage ("flush in progress detected. waiting."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  	while (p_FlushInProgress () && i < maxWaitCount) {  		i++;  		Thread.Sleep (50);  		//wait 50 miliseconds for flush to complete  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ProcessFlush,The following statement contains a magic number: if (p_FlushInProgress != null) {  	int maxWaitCount = (BonCodeAJP13Settings.BONCODEAJP13_FLUSH_TIMEOUT * 1000) / 50;  	int i = 0;  	if (p_Logger != null)  		p_Logger.LogMessage ("flush in progress detected. waiting."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  	while (p_FlushInProgress () && i < maxWaitCount) {  		i++;  		Thread.Sleep (50);  		//wait 50 miliseconds for flush to complete  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ProcessFlush,The following statement contains a magic number: while (p_FlushInProgress () && i < maxWaitCount) {  	i++;  	Thread.Sleep (50);  	//wait 50 miliseconds for flush to complete  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ProcessFlush,The following statement contains a magic number: Thread.Sleep (50);  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: if (p_PacketsToSend.Count > 1) {  	bool delayWrite = false;  	//TODO: move this loop to a function by itself so we can reuse it.  	foreach (Object oIterate in p_PacketsToSend) {  		//we will continue sending all packets in queue unless tomcat sends us End Comm package  		if (!p_IsLastPacket) {  			sendPacketCount++;  			BonCodeAJP13Packet sendPacket = oIterate as BonCodeAJP13Packet;  			//only objects derived from this class should be in the collection  			//send first packet immediatly (most likely a post)' unless there is a delay write indicator (will be set during analysis)  			if (!delayWrite) {  				p_NetworkStream.Write (sendPacket.GetDataBytes ()' 0' sendPacket.PacketLength);  			} else {  				delayWrite = false;  			}  			//log packet  			if (p_Logger != null)  				p_Logger.LogPacket (sendPacket' false' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  			//after the second packet (first packet for Adobe) in a packet collection we have to listen and receive a TomcatGetBodyChunk  			if (sendPacketCount >= listenAfterPacket) {  				bool subRoutineReadInProgress = true;  				int sanityCheck = 0;  				while (subRoutineReadInProgress) {  					sanityCheck++;  					try {  						numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  						notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  						//no flush processing during sending of data  						//we expect a 7 byte response except for the last package record' if not record a warning                          						if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  							if (p_Logger != null)  								p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						}  						//check whether we are finished with subroutine  						if (delayWrite) {  							delayWrite = false;  							// assume that we will exit with next loop unless Analyze package resets this to true;  						} else {  							subRoutineReadInProgress = false;  						}  					} catch (Exception e) {  						if (p_Logger != null) {  							p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  							p_Logger.LogException (e);  						}  					}  					//in case we go in cycle without receiving data  					if (sanityCheck > 500) {  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						subRoutineReadInProgress = false;  					}  				}  			}  		} else {  			break;  		}  	}  	// if the last received message from tomcat is "GET_BODY_CHUNK" we need to send terminator package  	// We have to do a complex type multi-comparison rather than using just one 'is' operator since c# seems to have an issue determining class type in collection  	if (p_PacketsReceived [p_PacketsReceived.Count - 1] is TomcatSendBodyChunk || p_PacketsReceived [p_PacketsReceived.Count - 1].GetType () == typeof(TomcatGetBodyChunk) || p_PacketsReceived [p_PacketsReceived.Count - 1] is BonCodeAJP13.TomcatPackets.TomcatSendBodyChunk) {  		BonCodeAJP13Packet sendPacket = new BonCodeAJP13ForwardRequest (new byte[] {    		});  		//create terminator (empty) package  		p_NetworkStream.Write (sendPacket.GetDataBytes ()' 0' sendPacket.PacketLength);  		//log packet as it is sent  		if (p_Logger != null)  			p_Logger.LogPacket (sendPacket' false' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  	}  } else if (p_PacketsToSend.Count == 1) {  	//send package  	BonCodeAJP13Packet sendPacket = p_PacketsToSend [0] as BonCodeAJP13Packet;  	//only objects derived from this class should be in the collection  	p_NetworkStream.Write (sendPacket.GetDataBytes ()' 0' sendPacket.PacketLength);  	//log each packet as it is sent  	if (p_Logger != null)  		p_Logger.LogPacket (sendPacket' false' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  } else {  	//nothing to do  	CloseConnectionNoError ("Nothing to send. Closing Connection.");  	return;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: if (p_PacketsToSend.Count > 1) {  	bool delayWrite = false;  	//TODO: move this loop to a function by itself so we can reuse it.  	foreach (Object oIterate in p_PacketsToSend) {  		//we will continue sending all packets in queue unless tomcat sends us End Comm package  		if (!p_IsLastPacket) {  			sendPacketCount++;  			BonCodeAJP13Packet sendPacket = oIterate as BonCodeAJP13Packet;  			//only objects derived from this class should be in the collection  			//send first packet immediatly (most likely a post)' unless there is a delay write indicator (will be set during analysis)  			if (!delayWrite) {  				p_NetworkStream.Write (sendPacket.GetDataBytes ()' 0' sendPacket.PacketLength);  			} else {  				delayWrite = false;  			}  			//log packet  			if (p_Logger != null)  				p_Logger.LogPacket (sendPacket' false' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  			//after the second packet (first packet for Adobe) in a packet collection we have to listen and receive a TomcatGetBodyChunk  			if (sendPacketCount >= listenAfterPacket) {  				bool subRoutineReadInProgress = true;  				int sanityCheck = 0;  				while (subRoutineReadInProgress) {  					sanityCheck++;  					try {  						numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  						notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  						//no flush processing during sending of data  						//we expect a 7 byte response except for the last package record' if not record a warning                          						if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  							if (p_Logger != null)  								p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						}  						//check whether we are finished with subroutine  						if (delayWrite) {  							delayWrite = false;  							// assume that we will exit with next loop unless Analyze package resets this to true;  						} else {  							subRoutineReadInProgress = false;  						}  					} catch (Exception e) {  						if (p_Logger != null) {  							p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  							p_Logger.LogException (e);  						}  					}  					//in case we go in cycle without receiving data  					if (sanityCheck > 500) {  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						subRoutineReadInProgress = false;  					}  				}  			}  		} else {  			break;  		}  	}  	// if the last received message from tomcat is "GET_BODY_CHUNK" we need to send terminator package  	// We have to do a complex type multi-comparison rather than using just one 'is' operator since c# seems to have an issue determining class type in collection  	if (p_PacketsReceived [p_PacketsReceived.Count - 1] is TomcatSendBodyChunk || p_PacketsReceived [p_PacketsReceived.Count - 1].GetType () == typeof(TomcatGetBodyChunk) || p_PacketsReceived [p_PacketsReceived.Count - 1] is BonCodeAJP13.TomcatPackets.TomcatSendBodyChunk) {  		BonCodeAJP13Packet sendPacket = new BonCodeAJP13ForwardRequest (new byte[] {    		});  		//create terminator (empty) package  		p_NetworkStream.Write (sendPacket.GetDataBytes ()' 0' sendPacket.PacketLength);  		//log packet as it is sent  		if (p_Logger != null)  			p_Logger.LogPacket (sendPacket' false' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  	}  } else if (p_PacketsToSend.Count == 1) {  	//send package  	BonCodeAJP13Packet sendPacket = p_PacketsToSend [0] as BonCodeAJP13Packet;  	//only objects derived from this class should be in the collection  	p_NetworkStream.Write (sendPacket.GetDataBytes ()' 0' sendPacket.PacketLength);  	//log each packet as it is sent  	if (p_Logger != null)  		p_Logger.LogPacket (sendPacket' false' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  } else {  	//nothing to do  	CloseConnectionNoError ("Nothing to send. Closing Connection.");  	return;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: foreach (Object oIterate in p_PacketsToSend) {  	//we will continue sending all packets in queue unless tomcat sends us End Comm package  	if (!p_IsLastPacket) {  		sendPacketCount++;  		BonCodeAJP13Packet sendPacket = oIterate as BonCodeAJP13Packet;  		//only objects derived from this class should be in the collection  		//send first packet immediatly (most likely a post)' unless there is a delay write indicator (will be set during analysis)  		if (!delayWrite) {  			p_NetworkStream.Write (sendPacket.GetDataBytes ()' 0' sendPacket.PacketLength);  		} else {  			delayWrite = false;  		}  		//log packet  		if (p_Logger != null)  			p_Logger.LogPacket (sendPacket' false' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  		//after the second packet (first packet for Adobe) in a packet collection we have to listen and receive a TomcatGetBodyChunk  		if (sendPacketCount >= listenAfterPacket) {  			bool subRoutineReadInProgress = true;  			int sanityCheck = 0;  			while (subRoutineReadInProgress) {  				sanityCheck++;  				try {  					numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  					notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  					//no flush processing during sending of data  					//we expect a 7 byte response except for the last package record' if not record a warning                          					if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					}  					//check whether we are finished with subroutine  					if (delayWrite) {  						delayWrite = false;  						// assume that we will exit with next loop unless Analyze package resets this to true;  					} else {  						subRoutineReadInProgress = false;  					}  				} catch (Exception e) {  					if (p_Logger != null) {  						p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						p_Logger.LogException (e);  					}  				}  				//in case we go in cycle without receiving data  				if (sanityCheck > 500) {  					if (p_Logger != null)  						p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					subRoutineReadInProgress = false;  				}  			}  		}  	} else {  		break;  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: foreach (Object oIterate in p_PacketsToSend) {  	//we will continue sending all packets in queue unless tomcat sends us End Comm package  	if (!p_IsLastPacket) {  		sendPacketCount++;  		BonCodeAJP13Packet sendPacket = oIterate as BonCodeAJP13Packet;  		//only objects derived from this class should be in the collection  		//send first packet immediatly (most likely a post)' unless there is a delay write indicator (will be set during analysis)  		if (!delayWrite) {  			p_NetworkStream.Write (sendPacket.GetDataBytes ()' 0' sendPacket.PacketLength);  		} else {  			delayWrite = false;  		}  		//log packet  		if (p_Logger != null)  			p_Logger.LogPacket (sendPacket' false' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  		//after the second packet (first packet for Adobe) in a packet collection we have to listen and receive a TomcatGetBodyChunk  		if (sendPacketCount >= listenAfterPacket) {  			bool subRoutineReadInProgress = true;  			int sanityCheck = 0;  			while (subRoutineReadInProgress) {  				sanityCheck++;  				try {  					numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  					notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  					//no flush processing during sending of data  					//we expect a 7 byte response except for the last package record' if not record a warning                          					if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					}  					//check whether we are finished with subroutine  					if (delayWrite) {  						delayWrite = false;  						// assume that we will exit with next loop unless Analyze package resets this to true;  					} else {  						subRoutineReadInProgress = false;  					}  				} catch (Exception e) {  					if (p_Logger != null) {  						p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						p_Logger.LogException (e);  					}  				}  				//in case we go in cycle without receiving data  				if (sanityCheck > 500) {  					if (p_Logger != null)  						p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					subRoutineReadInProgress = false;  				}  			}  		}  	} else {  		break;  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: if (!p_IsLastPacket) {  	sendPacketCount++;  	BonCodeAJP13Packet sendPacket = oIterate as BonCodeAJP13Packet;  	//only objects derived from this class should be in the collection  	//send first packet immediatly (most likely a post)' unless there is a delay write indicator (will be set during analysis)  	if (!delayWrite) {  		p_NetworkStream.Write (sendPacket.GetDataBytes ()' 0' sendPacket.PacketLength);  	} else {  		delayWrite = false;  	}  	//log packet  	if (p_Logger != null)  		p_Logger.LogPacket (sendPacket' false' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  	//after the second packet (first packet for Adobe) in a packet collection we have to listen and receive a TomcatGetBodyChunk  	if (sendPacketCount >= listenAfterPacket) {  		bool subRoutineReadInProgress = true;  		int sanityCheck = 0;  		while (subRoutineReadInProgress) {  			sanityCheck++;  			try {  				numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  				notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  				//no flush processing during sending of data  				//we expect a 7 byte response except for the last package record' if not record a warning                          				if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  					if (p_Logger != null)  						p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				}  				//check whether we are finished with subroutine  				if (delayWrite) {  					delayWrite = false;  					// assume that we will exit with next loop unless Analyze package resets this to true;  				} else {  					subRoutineReadInProgress = false;  				}  			} catch (Exception e) {  				if (p_Logger != null) {  					p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					p_Logger.LogException (e);  				}  			}  			//in case we go in cycle without receiving data  			if (sanityCheck > 500) {  				if (p_Logger != null)  					p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				subRoutineReadInProgress = false;  			}  		}  	}  } else {  	break;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: if (!p_IsLastPacket) {  	sendPacketCount++;  	BonCodeAJP13Packet sendPacket = oIterate as BonCodeAJP13Packet;  	//only objects derived from this class should be in the collection  	//send first packet immediatly (most likely a post)' unless there is a delay write indicator (will be set during analysis)  	if (!delayWrite) {  		p_NetworkStream.Write (sendPacket.GetDataBytes ()' 0' sendPacket.PacketLength);  	} else {  		delayWrite = false;  	}  	//log packet  	if (p_Logger != null)  		p_Logger.LogPacket (sendPacket' false' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  	//after the second packet (first packet for Adobe) in a packet collection we have to listen and receive a TomcatGetBodyChunk  	if (sendPacketCount >= listenAfterPacket) {  		bool subRoutineReadInProgress = true;  		int sanityCheck = 0;  		while (subRoutineReadInProgress) {  			sanityCheck++;  			try {  				numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  				notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  				//no flush processing during sending of data  				//we expect a 7 byte response except for the last package record' if not record a warning                          				if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  					if (p_Logger != null)  						p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				}  				//check whether we are finished with subroutine  				if (delayWrite) {  					delayWrite = false;  					// assume that we will exit with next loop unless Analyze package resets this to true;  				} else {  					subRoutineReadInProgress = false;  				}  			} catch (Exception e) {  				if (p_Logger != null) {  					p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					p_Logger.LogException (e);  				}  			}  			//in case we go in cycle without receiving data  			if (sanityCheck > 500) {  				if (p_Logger != null)  					p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				subRoutineReadInProgress = false;  			}  		}  	}  } else {  	break;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: if (sendPacketCount >= listenAfterPacket) {  	bool subRoutineReadInProgress = true;  	int sanityCheck = 0;  	while (subRoutineReadInProgress) {  		sanityCheck++;  		try {  			numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  			notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  			//no flush processing during sending of data  			//we expect a 7 byte response except for the last package record' if not record a warning                          			if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  				if (p_Logger != null)  					p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  			}  			//check whether we are finished with subroutine  			if (delayWrite) {  				delayWrite = false;  				// assume that we will exit with next loop unless Analyze package resets this to true;  			} else {  				subRoutineReadInProgress = false;  			}  		} catch (Exception e) {  			if (p_Logger != null) {  				p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				p_Logger.LogException (e);  			}  		}  		//in case we go in cycle without receiving data  		if (sanityCheck > 500) {  			if (p_Logger != null)  				p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  			subRoutineReadInProgress = false;  		}  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: if (sendPacketCount >= listenAfterPacket) {  	bool subRoutineReadInProgress = true;  	int sanityCheck = 0;  	while (subRoutineReadInProgress) {  		sanityCheck++;  		try {  			numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  			notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  			//no flush processing during sending of data  			//we expect a 7 byte response except for the last package record' if not record a warning                          			if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  				if (p_Logger != null)  					p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  			}  			//check whether we are finished with subroutine  			if (delayWrite) {  				delayWrite = false;  				// assume that we will exit with next loop unless Analyze package resets this to true;  			} else {  				subRoutineReadInProgress = false;  			}  		} catch (Exception e) {  			if (p_Logger != null) {  				p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				p_Logger.LogException (e);  			}  		}  		//in case we go in cycle without receiving data  		if (sanityCheck > 500) {  			if (p_Logger != null)  				p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  			subRoutineReadInProgress = false;  		}  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: while (subRoutineReadInProgress) {  	sanityCheck++;  	try {  		numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  		notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  		//no flush processing during sending of data  		//we expect a 7 byte response except for the last package record' if not record a warning                          		if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  			if (p_Logger != null)  				p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  		}  		//check whether we are finished with subroutine  		if (delayWrite) {  			delayWrite = false;  			// assume that we will exit with next loop unless Analyze package resets this to true;  		} else {  			subRoutineReadInProgress = false;  		}  	} catch (Exception e) {  		if (p_Logger != null) {  			p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  			p_Logger.LogException (e);  		}  	}  	//in case we go in cycle without receiving data  	if (sanityCheck > 500) {  		if (p_Logger != null)  			p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  		subRoutineReadInProgress = false;  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: while (subRoutineReadInProgress) {  	sanityCheck++;  	try {  		numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  		notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  		//no flush processing during sending of data  		//we expect a 7 byte response except for the last package record' if not record a warning                          		if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  			if (p_Logger != null)  				p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  		}  		//check whether we are finished with subroutine  		if (delayWrite) {  			delayWrite = false;  			// assume that we will exit with next loop unless Analyze package resets this to true;  		} else {  			subRoutineReadInProgress = false;  		}  	} catch (Exception e) {  		if (p_Logger != null) {  			p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  			p_Logger.LogException (e);  		}  	}  	//in case we go in cycle without receiving data  	if (sanityCheck > 500) {  		if (p_Logger != null)  			p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  		subRoutineReadInProgress = false;  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: try {  	numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  	notProcessedBytes = AnalyzePackage (ref delayWrite' receivedPacketBuffer' true);  	//no flush processing during sending of data  	//we expect a 7 byte response except for the last package record' if not record a warning                          	if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  		if (p_Logger != null)  			p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  	}  	//check whether we are finished with subroutine  	if (delayWrite) {  		delayWrite = false;  		// assume that we will exit with next loop unless Analyze package resets this to true;  	} else {  		subRoutineReadInProgress = false;  	}  } catch (Exception e) {  	if (p_Logger != null) {  		p_Logger.LogMessageAndType ("Stream reading problem (1). Null packet received in stream."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  		p_Logger.LogException (e);  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: if (sendPacketCount != p_PacketsToSend.Count && numOfBytesReceived > 7) {  	if (p_Logger != null)  		p_Logger.LogMessageAndType ("Incorrect response received from Tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: if (sanityCheck > 500) {  	if (p_Logger != null)  		p_Logger.LogMessageAndType ("SubRoutine Communication Process suspicious iterations (>500). This indicates problems with communication to tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  	subRoutineReadInProgress = false;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: try {  	int readCount = 0;  	while (p_NetworkStream.CanRead && !p_AbortConnection && !p_IsLastPacket) {  		//check to see whether we need to send extra termination package  		if (p_SendTermPacket) {  			p_SendTermPacket = false;  			BonCodeAJP13ForwardRequest terminatorFR = new BonCodeAJP13ForwardRequest (new byte[] {    			});  			p_NetworkStream.Write (terminatorFR.GetDataBytes ()' 0' terminatorFR.PacketLength);  		}  		//clear reading array  		Array.Clear (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  		//flush detection by ticks check if we we have no data on channel                      		//check whether we need monitor for tomcat flush signs    		if (!p_NetworkStream.DataAvailable && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0) {  			long elapsedTicks = p_StopWatch.ElapsedTicks;  			p_TickDelta = elapsedTicks - p_LastTick;  			p_LastTick = elapsedTicks;  			if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS) {  				//flush has been detected set the flag. We should flush after this receiveBuffer has been processed.  				//no flush is needed if we see end marker during receiveBuffer processing since all data would have been transferred  				p_IsFlush = true;  				p_TimeFlushOccurred = true;  			}  		}  		//read incoming packets until timeout or last package has been received.  		readCount++;  		try {  			//read or wait on next package  			numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  			//flush detection by bytes -- in case where time flush is also defined (ticks>0) we will wait until a time flush occurs (p_TimeFlushOccurred)  			//before we trigger a byte flushes  			if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS == 0 || (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 && p_TimeFlushOccurred))) {  				p_BytesInBuffer = p_BytesInBuffer + numOfBytesReceived;  				if (p_BytesInBuffer > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES) {  					p_IsFlush = true;  					p_BytesInBuffer = 0;  				}  			}  			//analyze packet so far (adjust bytes from Receiving buffer):combine notProcessed with new Read bytes into new Received buffer if needed                          			if (notProcessedBytes != null) {  				//create tempArray that contains new set of bytes to be send a combination of newly received bytes as well as bytes that we were not able to process yet  				byte[] tempArray = new byte[numOfBytesReceived + notProcessedBytes.Length];  				Array.Copy (notProcessedBytes' 0' tempArray' 0' notProcessedBytes.Length);  				Array.Copy (receivedPacketBuffer' 0' tempArray' notProcessedBytes.Length' numOfBytesReceived);  				notProcessedBytes = AnalyzePackage (tempArray);  			} else {  				//send bytes we received for analysis  				byte[] tempArray = new byte[numOfBytesReceived];  				Array.Copy (receivedPacketBuffer' 0' tempArray' 0' numOfBytesReceived);  				notProcessedBytes = AnalyzePackage (tempArray);  			}  		} catch (Exception e) {  			p_AbortConnection = true;  			p_Logger.LogMessageAndType ("Stream reading problem (2)(" + readCount.ToString () + ")' you may have shutdown Tomcat unexpectedly"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  			//p_Logger.LogException(e);  		}  	}  	//check error condition that tomcat produces sometimes where additional data is sent after end_transmission has been indicated                  	int sanityCheck = 0;  	while (p_NetworkStream.DataAvailable && sanityCheck < 100) {  		//we need to clear the tcp pipe so the next request does not pick up data we will do this up to 100 times and write warning  		try {  			numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  		} catch {  			//do nothing here  		}  		if (sanityCheck == 0) {  			if (p_Logger != null)  				p_Logger.LogMessageAndType ("extra data after transmission-end from tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  		}  		sanityCheck++;  	}  } catch (System.IO.IOException ex) {  	ConnectionError ("Server Connection is closing' Read timeout reached and no tomcat activity was detected."' "TimeOut");  	if (p_Logger != null)  		p_Logger.LogException (ex);  	return;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,ComunicateWithTomcat,The following statement contains a magic number: while (p_NetworkStream.DataAvailable && sanityCheck < 100) {  	//we need to clear the tcp pipe so the next request does not pick up data we will do this up to 100 times and write warning  	try {  		numOfBytesReceived = p_NetworkStream.Read (receivedPacketBuffer' 0' receivedPacketBuffer.Length);  	} catch {  		//do nothing here  	}  	if (sanityCheck == 0) {  		if (p_Logger != null)  			p_Logger.LogMessageAndType ("extra data after transmission-end from tomcat"' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_HEADERS);  	}  	sanityCheck++;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: while (iStart >= 0 && iStart <= receiveBuffer.Length - 1 && iSafety <= 2050) {  	iSafety++;  	//find packet start bytes (41 42 or AB)  	iStart = ByteSearch (receiveBuffer' searchFor' iStart);  	if (iStart >= 0) {  		//determine end of packet if this is negative we need continue scanning   		try {  			packetLength = GetInt16B (receiveBuffer' iStart + 2);  		} catch (Exception e) {  			//log exception  			if (p_Logger != null)  				p_Logger.LogException (e' "packet length determination problem"' 1);  		}  		//check whether we have sufficient data in receive buffer to analyze package  		if (packetLength + iStart + 4 <= receiveBuffer.Length) {  			//TODO: check whether packet length is beyond maximum and throw error  			int packetType = (int)receiveBuffer [iStart + 4];  			byte[] userData = new byte[packetLength];  			string adobePath = "";  			string requestPath = "";  			//we skip 4-bytes:magic (AB) and packet length markers when determining user data  			Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  			//Detect Correct packet Type and create instance of store  			switch (packetType) {  			case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  				p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  				//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  				if (p_PacketsToSend.Count == 1) {  					p_SendTermPacket = true;  				}  				//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  				p_PacketsReceived.Add (new TomcatEndResponse (userData));  				//this is the termination indicator we need to stop processing from here on. This can happen   				//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  				p_PacketsReceived.Add (new TomcatSendHeaders (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  				p_PacketsReceived.Add (new TomcatCPongReply (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  				//only add user data if there is something so we don't create null packets (this condition may not occur)  				if (userData.Length > 0) {  					p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  					//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            					if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  						p_IsFlush = true;  					}  				} else {  					//warning  					if (p_Logger != null)  						p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  				}  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  				//this is Adobe specific we will need to send back a header  				p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  				requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  				adobePath = "";  				//this will contain the resolved absolute path  				//TODO: move the following into a response queue  				//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   				//The user did not ask for index.htm it is how CF marks docroot vs final path      				if (requestPath == "/index.htm") {  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  				} else {  					//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  					try {  						adobePath = ServerPath (requestPath);  						//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  					} catch (Exception e) {  						//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  					}  				}  				;  				//build a response package  				BonCodeFilePathPacket pathResponse = null;  				pathResponse = new BonCodeFilePathPacket (adobePath);  				p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  				if (p_Logger != null)  					p_Logger.LogPacket (pathResponse);  				delayWriteIndicator = true;  				//prevent main process from writing to network stream  				break;  			default:  				//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 				p_PacketsReceived.Add (new TomcatReturn (userData));  				if (p_Logger != null) {  					p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  					p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  				}  				;  				break;  			}  			//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  			if (p_Logger != null)  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  			//reset new iStart  			iStart = iStart + 4 + packetLength - 1;  			//detect end package  			if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  				p_IsLastPacket = true;  				p_IsFlush = false;  			} else {  				//old flush check position  				/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  		} else {  			//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  			unalyzedBytes = new byte[receiveBuffer.Length - iStart];  			Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  			//set breakout conditions  			iStart = iStart + packetLength - 1;  			break;  		}  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: while (iStart >= 0 && iStart <= receiveBuffer.Length - 1 && iSafety <= 2050) {  	iSafety++;  	//find packet start bytes (41 42 or AB)  	iStart = ByteSearch (receiveBuffer' searchFor' iStart);  	if (iStart >= 0) {  		//determine end of packet if this is negative we need continue scanning   		try {  			packetLength = GetInt16B (receiveBuffer' iStart + 2);  		} catch (Exception e) {  			//log exception  			if (p_Logger != null)  				p_Logger.LogException (e' "packet length determination problem"' 1);  		}  		//check whether we have sufficient data in receive buffer to analyze package  		if (packetLength + iStart + 4 <= receiveBuffer.Length) {  			//TODO: check whether packet length is beyond maximum and throw error  			int packetType = (int)receiveBuffer [iStart + 4];  			byte[] userData = new byte[packetLength];  			string adobePath = "";  			string requestPath = "";  			//we skip 4-bytes:magic (AB) and packet length markers when determining user data  			Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  			//Detect Correct packet Type and create instance of store  			switch (packetType) {  			case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  				p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  				//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  				if (p_PacketsToSend.Count == 1) {  					p_SendTermPacket = true;  				}  				//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  				p_PacketsReceived.Add (new TomcatEndResponse (userData));  				//this is the termination indicator we need to stop processing from here on. This can happen   				//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  				p_PacketsReceived.Add (new TomcatSendHeaders (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  				p_PacketsReceived.Add (new TomcatCPongReply (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  				//only add user data if there is something so we don't create null packets (this condition may not occur)  				if (userData.Length > 0) {  					p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  					//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            					if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  						p_IsFlush = true;  					}  				} else {  					//warning  					if (p_Logger != null)  						p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  				}  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  				//this is Adobe specific we will need to send back a header  				p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  				requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  				adobePath = "";  				//this will contain the resolved absolute path  				//TODO: move the following into a response queue  				//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   				//The user did not ask for index.htm it is how CF marks docroot vs final path      				if (requestPath == "/index.htm") {  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  				} else {  					//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  					try {  						adobePath = ServerPath (requestPath);  						//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  					} catch (Exception e) {  						//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  					}  				}  				;  				//build a response package  				BonCodeFilePathPacket pathResponse = null;  				pathResponse = new BonCodeFilePathPacket (adobePath);  				p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  				if (p_Logger != null)  					p_Logger.LogPacket (pathResponse);  				delayWriteIndicator = true;  				//prevent main process from writing to network stream  				break;  			default:  				//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 				p_PacketsReceived.Add (new TomcatReturn (userData));  				if (p_Logger != null) {  					p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  					p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  				}  				;  				break;  			}  			//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  			if (p_Logger != null)  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  			//reset new iStart  			iStart = iStart + 4 + packetLength - 1;  			//detect end package  			if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  				p_IsLastPacket = true;  				p_IsFlush = false;  			} else {  				//old flush check position  				/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  		} else {  			//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  			unalyzedBytes = new byte[receiveBuffer.Length - iStart];  			Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  			//set breakout conditions  			iStart = iStart + packetLength - 1;  			break;  		}  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: while (iStart >= 0 && iStart <= receiveBuffer.Length - 1 && iSafety <= 2050) {  	iSafety++;  	//find packet start bytes (41 42 or AB)  	iStart = ByteSearch (receiveBuffer' searchFor' iStart);  	if (iStart >= 0) {  		//determine end of packet if this is negative we need continue scanning   		try {  			packetLength = GetInt16B (receiveBuffer' iStart + 2);  		} catch (Exception e) {  			//log exception  			if (p_Logger != null)  				p_Logger.LogException (e' "packet length determination problem"' 1);  		}  		//check whether we have sufficient data in receive buffer to analyze package  		if (packetLength + iStart + 4 <= receiveBuffer.Length) {  			//TODO: check whether packet length is beyond maximum and throw error  			int packetType = (int)receiveBuffer [iStart + 4];  			byte[] userData = new byte[packetLength];  			string adobePath = "";  			string requestPath = "";  			//we skip 4-bytes:magic (AB) and packet length markers when determining user data  			Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  			//Detect Correct packet Type and create instance of store  			switch (packetType) {  			case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  				p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  				//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  				if (p_PacketsToSend.Count == 1) {  					p_SendTermPacket = true;  				}  				//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  				p_PacketsReceived.Add (new TomcatEndResponse (userData));  				//this is the termination indicator we need to stop processing from here on. This can happen   				//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  				p_PacketsReceived.Add (new TomcatSendHeaders (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  				p_PacketsReceived.Add (new TomcatCPongReply (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  				//only add user data if there is something so we don't create null packets (this condition may not occur)  				if (userData.Length > 0) {  					p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  					//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            					if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  						p_IsFlush = true;  					}  				} else {  					//warning  					if (p_Logger != null)  						p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  				}  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  				//this is Adobe specific we will need to send back a header  				p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  				requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  				adobePath = "";  				//this will contain the resolved absolute path  				//TODO: move the following into a response queue  				//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   				//The user did not ask for index.htm it is how CF marks docroot vs final path      				if (requestPath == "/index.htm") {  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  				} else {  					//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  					try {  						adobePath = ServerPath (requestPath);  						//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  					} catch (Exception e) {  						//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  					}  				}  				;  				//build a response package  				BonCodeFilePathPacket pathResponse = null;  				pathResponse = new BonCodeFilePathPacket (adobePath);  				p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  				if (p_Logger != null)  					p_Logger.LogPacket (pathResponse);  				delayWriteIndicator = true;  				//prevent main process from writing to network stream  				break;  			default:  				//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 				p_PacketsReceived.Add (new TomcatReturn (userData));  				if (p_Logger != null) {  					p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  					p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  				}  				;  				break;  			}  			//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  			if (p_Logger != null)  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  			//reset new iStart  			iStart = iStart + 4 + packetLength - 1;  			//detect end package  			if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  				p_IsLastPacket = true;  				p_IsFlush = false;  			} else {  				//old flush check position  				/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  		} else {  			//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  			unalyzedBytes = new byte[receiveBuffer.Length - iStart];  			Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  			//set breakout conditions  			iStart = iStart + packetLength - 1;  			break;  		}  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: while (iStart >= 0 && iStart <= receiveBuffer.Length - 1 && iSafety <= 2050) {  	iSafety++;  	//find packet start bytes (41 42 or AB)  	iStart = ByteSearch (receiveBuffer' searchFor' iStart);  	if (iStart >= 0) {  		//determine end of packet if this is negative we need continue scanning   		try {  			packetLength = GetInt16B (receiveBuffer' iStart + 2);  		} catch (Exception e) {  			//log exception  			if (p_Logger != null)  				p_Logger.LogException (e' "packet length determination problem"' 1);  		}  		//check whether we have sufficient data in receive buffer to analyze package  		if (packetLength + iStart + 4 <= receiveBuffer.Length) {  			//TODO: check whether packet length is beyond maximum and throw error  			int packetType = (int)receiveBuffer [iStart + 4];  			byte[] userData = new byte[packetLength];  			string adobePath = "";  			string requestPath = "";  			//we skip 4-bytes:magic (AB) and packet length markers when determining user data  			Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  			//Detect Correct packet Type and create instance of store  			switch (packetType) {  			case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  				p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  				//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  				if (p_PacketsToSend.Count == 1) {  					p_SendTermPacket = true;  				}  				//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  				p_PacketsReceived.Add (new TomcatEndResponse (userData));  				//this is the termination indicator we need to stop processing from here on. This can happen   				//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  				p_PacketsReceived.Add (new TomcatSendHeaders (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  				p_PacketsReceived.Add (new TomcatCPongReply (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  				//only add user data if there is something so we don't create null packets (this condition may not occur)  				if (userData.Length > 0) {  					p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  					//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            					if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  						p_IsFlush = true;  					}  				} else {  					//warning  					if (p_Logger != null)  						p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  				}  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  				//this is Adobe specific we will need to send back a header  				p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  				requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  				adobePath = "";  				//this will contain the resolved absolute path  				//TODO: move the following into a response queue  				//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   				//The user did not ask for index.htm it is how CF marks docroot vs final path      				if (requestPath == "/index.htm") {  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  				} else {  					//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  					try {  						adobePath = ServerPath (requestPath);  						//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  					} catch (Exception e) {  						//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  					}  				}  				;  				//build a response package  				BonCodeFilePathPacket pathResponse = null;  				pathResponse = new BonCodeFilePathPacket (adobePath);  				p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  				if (p_Logger != null)  					p_Logger.LogPacket (pathResponse);  				delayWriteIndicator = true;  				//prevent main process from writing to network stream  				break;  			default:  				//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 				p_PacketsReceived.Add (new TomcatReturn (userData));  				if (p_Logger != null) {  					p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  					p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  				}  				;  				break;  			}  			//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  			if (p_Logger != null)  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  			//reset new iStart  			iStart = iStart + 4 + packetLength - 1;  			//detect end package  			if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  				p_IsLastPacket = true;  				p_IsFlush = false;  			} else {  				//old flush check position  				/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  		} else {  			//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  			unalyzedBytes = new byte[receiveBuffer.Length - iStart];  			Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  			//set breakout conditions  			iStart = iStart + packetLength - 1;  			break;  		}  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: while (iStart >= 0 && iStart <= receiveBuffer.Length - 1 && iSafety <= 2050) {  	iSafety++;  	//find packet start bytes (41 42 or AB)  	iStart = ByteSearch (receiveBuffer' searchFor' iStart);  	if (iStart >= 0) {  		//determine end of packet if this is negative we need continue scanning   		try {  			packetLength = GetInt16B (receiveBuffer' iStart + 2);  		} catch (Exception e) {  			//log exception  			if (p_Logger != null)  				p_Logger.LogException (e' "packet length determination problem"' 1);  		}  		//check whether we have sufficient data in receive buffer to analyze package  		if (packetLength + iStart + 4 <= receiveBuffer.Length) {  			//TODO: check whether packet length is beyond maximum and throw error  			int packetType = (int)receiveBuffer [iStart + 4];  			byte[] userData = new byte[packetLength];  			string adobePath = "";  			string requestPath = "";  			//we skip 4-bytes:magic (AB) and packet length markers when determining user data  			Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  			//Detect Correct packet Type and create instance of store  			switch (packetType) {  			case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  				p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  				//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  				if (p_PacketsToSend.Count == 1) {  					p_SendTermPacket = true;  				}  				//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  				p_PacketsReceived.Add (new TomcatEndResponse (userData));  				//this is the termination indicator we need to stop processing from here on. This can happen   				//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  				p_PacketsReceived.Add (new TomcatSendHeaders (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  				p_PacketsReceived.Add (new TomcatCPongReply (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  				//only add user data if there is something so we don't create null packets (this condition may not occur)  				if (userData.Length > 0) {  					p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  					//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            					if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  						p_IsFlush = true;  					}  				} else {  					//warning  					if (p_Logger != null)  						p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  				}  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  				//this is Adobe specific we will need to send back a header  				p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  				requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  				adobePath = "";  				//this will contain the resolved absolute path  				//TODO: move the following into a response queue  				//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   				//The user did not ask for index.htm it is how CF marks docroot vs final path      				if (requestPath == "/index.htm") {  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  				} else {  					//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  					try {  						adobePath = ServerPath (requestPath);  						//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  					} catch (Exception e) {  						//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  					}  				}  				;  				//build a response package  				BonCodeFilePathPacket pathResponse = null;  				pathResponse = new BonCodeFilePathPacket (adobePath);  				p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  				if (p_Logger != null)  					p_Logger.LogPacket (pathResponse);  				delayWriteIndicator = true;  				//prevent main process from writing to network stream  				break;  			default:  				//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 				p_PacketsReceived.Add (new TomcatReturn (userData));  				if (p_Logger != null) {  					p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  					p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  				}  				;  				break;  			}  			//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  			if (p_Logger != null)  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  			//reset new iStart  			iStart = iStart + 4 + packetLength - 1;  			//detect end package  			if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  				p_IsLastPacket = true;  				p_IsFlush = false;  			} else {  				//old flush check position  				/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  		} else {  			//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  			unalyzedBytes = new byte[receiveBuffer.Length - iStart];  			Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  			//set breakout conditions  			iStart = iStart + packetLength - 1;  			break;  		}  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: while (iStart >= 0 && iStart <= receiveBuffer.Length - 1 && iSafety <= 2050) {  	iSafety++;  	//find packet start bytes (41 42 or AB)  	iStart = ByteSearch (receiveBuffer' searchFor' iStart);  	if (iStart >= 0) {  		//determine end of packet if this is negative we need continue scanning   		try {  			packetLength = GetInt16B (receiveBuffer' iStart + 2);  		} catch (Exception e) {  			//log exception  			if (p_Logger != null)  				p_Logger.LogException (e' "packet length determination problem"' 1);  		}  		//check whether we have sufficient data in receive buffer to analyze package  		if (packetLength + iStart + 4 <= receiveBuffer.Length) {  			//TODO: check whether packet length is beyond maximum and throw error  			int packetType = (int)receiveBuffer [iStart + 4];  			byte[] userData = new byte[packetLength];  			string adobePath = "";  			string requestPath = "";  			//we skip 4-bytes:magic (AB) and packet length markers when determining user data  			Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  			//Detect Correct packet Type and create instance of store  			switch (packetType) {  			case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  				p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  				//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  				if (p_PacketsToSend.Count == 1) {  					p_SendTermPacket = true;  				}  				//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  				p_PacketsReceived.Add (new TomcatEndResponse (userData));  				//this is the termination indicator we need to stop processing from here on. This can happen   				//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  				p_PacketsReceived.Add (new TomcatSendHeaders (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  				p_PacketsReceived.Add (new TomcatCPongReply (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  				//only add user data if there is something so we don't create null packets (this condition may not occur)  				if (userData.Length > 0) {  					p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  					//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            					if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  						p_IsFlush = true;  					}  				} else {  					//warning  					if (p_Logger != null)  						p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  				}  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  				//this is Adobe specific we will need to send back a header  				p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  				requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  				adobePath = "";  				//this will contain the resolved absolute path  				//TODO: move the following into a response queue  				//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   				//The user did not ask for index.htm it is how CF marks docroot vs final path      				if (requestPath == "/index.htm") {  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  				} else {  					//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  					try {  						adobePath = ServerPath (requestPath);  						//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  					} catch (Exception e) {  						//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  					}  				}  				;  				//build a response package  				BonCodeFilePathPacket pathResponse = null;  				pathResponse = new BonCodeFilePathPacket (adobePath);  				p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  				if (p_Logger != null)  					p_Logger.LogPacket (pathResponse);  				delayWriteIndicator = true;  				//prevent main process from writing to network stream  				break;  			default:  				//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 				p_PacketsReceived.Add (new TomcatReturn (userData));  				if (p_Logger != null) {  					p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  					p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  				}  				;  				break;  			}  			//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  			if (p_Logger != null)  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  			//reset new iStart  			iStart = iStart + 4 + packetLength - 1;  			//detect end package  			if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  				p_IsLastPacket = true;  				p_IsFlush = false;  			} else {  				//old flush check position  				/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  		} else {  			//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  			unalyzedBytes = new byte[receiveBuffer.Length - iStart];  			Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  			//set breakout conditions  			iStart = iStart + packetLength - 1;  			break;  		}  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: while (iStart >= 0 && iStart <= receiveBuffer.Length - 1 && iSafety <= 2050) {  	iSafety++;  	//find packet start bytes (41 42 or AB)  	iStart = ByteSearch (receiveBuffer' searchFor' iStart);  	if (iStart >= 0) {  		//determine end of packet if this is negative we need continue scanning   		try {  			packetLength = GetInt16B (receiveBuffer' iStart + 2);  		} catch (Exception e) {  			//log exception  			if (p_Logger != null)  				p_Logger.LogException (e' "packet length determination problem"' 1);  		}  		//check whether we have sufficient data in receive buffer to analyze package  		if (packetLength + iStart + 4 <= receiveBuffer.Length) {  			//TODO: check whether packet length is beyond maximum and throw error  			int packetType = (int)receiveBuffer [iStart + 4];  			byte[] userData = new byte[packetLength];  			string adobePath = "";  			string requestPath = "";  			//we skip 4-bytes:magic (AB) and packet length markers when determining user data  			Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  			//Detect Correct packet Type and create instance of store  			switch (packetType) {  			case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  				p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  				//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  				if (p_PacketsToSend.Count == 1) {  					p_SendTermPacket = true;  				}  				//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  				p_PacketsReceived.Add (new TomcatEndResponse (userData));  				//this is the termination indicator we need to stop processing from here on. This can happen   				//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  				p_PacketsReceived.Add (new TomcatSendHeaders (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  				p_PacketsReceived.Add (new TomcatCPongReply (userData));  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  				//only add user data if there is something so we don't create null packets (this condition may not occur)  				if (userData.Length > 0) {  					p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  					//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            					if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  						p_IsFlush = true;  					}  				} else {  					//warning  					if (p_Logger != null)  						p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  				}  				break;  			case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  				//this is Adobe specific we will need to send back a header  				p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  				requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  				adobePath = "";  				//this will contain the resolved absolute path  				//TODO: move the following into a response queue  				//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   				//The user did not ask for index.htm it is how CF marks docroot vs final path      				if (requestPath == "/index.htm") {  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  				} else {  					//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  					try {  						adobePath = ServerPath (requestPath);  						//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  					} catch (Exception e) {  						//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  						if (p_Logger != null)  							p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  						adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  					}  				}  				;  				//build a response package  				BonCodeFilePathPacket pathResponse = null;  				pathResponse = new BonCodeFilePathPacket (adobePath);  				p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  				if (p_Logger != null)  					p_Logger.LogPacket (pathResponse);  				delayWriteIndicator = true;  				//prevent main process from writing to network stream  				break;  			default:  				//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 				p_PacketsReceived.Add (new TomcatReturn (userData));  				if (p_Logger != null) {  					p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  					p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  				}  				;  				break;  			}  			//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  			if (p_Logger != null)  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  			//reset new iStart  			iStart = iStart + 4 + packetLength - 1;  			//detect end package  			if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  				p_IsLastPacket = true;  				p_IsFlush = false;  			} else {  				//old flush check position  				/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  		} else {  			//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  			unalyzedBytes = new byte[receiveBuffer.Length - iStart];  			Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  			//set breakout conditions  			iStart = iStart + packetLength - 1;  			break;  		}  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (iStart >= 0) {  	//determine end of packet if this is negative we need continue scanning   	try {  		packetLength = GetInt16B (receiveBuffer' iStart + 2);  	} catch (Exception e) {  		//log exception  		if (p_Logger != null)  			p_Logger.LogException (e' "packet length determination problem"' 1);  	}  	//check whether we have sufficient data in receive buffer to analyze package  	if (packetLength + iStart + 4 <= receiveBuffer.Length) {  		//TODO: check whether packet length is beyond maximum and throw error  		int packetType = (int)receiveBuffer [iStart + 4];  		byte[] userData = new byte[packetLength];  		string adobePath = "";  		string requestPath = "";  		//we skip 4-bytes:magic (AB) and packet length markers when determining user data  		Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  		//Detect Correct packet Type and create instance of store  		switch (packetType) {  		case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  			p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  			//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  			if (p_PacketsToSend.Count == 1) {  				p_SendTermPacket = true;  			}  			//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  			p_PacketsReceived.Add (new TomcatEndResponse (userData));  			//this is the termination indicator we need to stop processing from here on. This can happen   			//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  			p_PacketsReceived.Add (new TomcatSendHeaders (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  			p_PacketsReceived.Add (new TomcatCPongReply (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  			//only add user data if there is something so we don't create null packets (this condition may not occur)  			if (userData.Length > 0) {  				p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  				//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            				if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  					p_IsFlush = true;  				}  			} else {  				//warning  				if (p_Logger != null)  					p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  			}  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  			//this is Adobe specific we will need to send back a header  			p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  			requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  			adobePath = "";  			//this will contain the resolved absolute path  			//TODO: move the following into a response queue  			//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   			//The user did not ask for index.htm it is how CF marks docroot vs final path      			if (requestPath == "/index.htm") {  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  			} else {  				//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  				try {  					adobePath = ServerPath (requestPath);  					//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  				} catch (Exception e) {  					//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  					if (p_Logger != null)  						p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  				}  			}  			;  			//build a response package  			BonCodeFilePathPacket pathResponse = null;  			pathResponse = new BonCodeFilePathPacket (adobePath);  			p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  			if (p_Logger != null)  				p_Logger.LogPacket (pathResponse);  			delayWriteIndicator = true;  			//prevent main process from writing to network stream  			break;  		default:  			//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 			p_PacketsReceived.Add (new TomcatReturn (userData));  			if (p_Logger != null) {  				p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  			}  			;  			break;  		}  		//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  		if (p_Logger != null)  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  		//reset new iStart  		iStart = iStart + 4 + packetLength - 1;  		//detect end package  		if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  			p_IsLastPacket = true;  			p_IsFlush = false;  		} else {  			//old flush check position  			/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  	} else {  		//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  		unalyzedBytes = new byte[receiveBuffer.Length - iStart];  		Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  		//set breakout conditions  		iStart = iStart + packetLength - 1;  		break;  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (iStart >= 0) {  	//determine end of packet if this is negative we need continue scanning   	try {  		packetLength = GetInt16B (receiveBuffer' iStart + 2);  	} catch (Exception e) {  		//log exception  		if (p_Logger != null)  			p_Logger.LogException (e' "packet length determination problem"' 1);  	}  	//check whether we have sufficient data in receive buffer to analyze package  	if (packetLength + iStart + 4 <= receiveBuffer.Length) {  		//TODO: check whether packet length is beyond maximum and throw error  		int packetType = (int)receiveBuffer [iStart + 4];  		byte[] userData = new byte[packetLength];  		string adobePath = "";  		string requestPath = "";  		//we skip 4-bytes:magic (AB) and packet length markers when determining user data  		Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  		//Detect Correct packet Type and create instance of store  		switch (packetType) {  		case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  			p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  			//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  			if (p_PacketsToSend.Count == 1) {  				p_SendTermPacket = true;  			}  			//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  			p_PacketsReceived.Add (new TomcatEndResponse (userData));  			//this is the termination indicator we need to stop processing from here on. This can happen   			//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  			p_PacketsReceived.Add (new TomcatSendHeaders (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  			p_PacketsReceived.Add (new TomcatCPongReply (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  			//only add user data if there is something so we don't create null packets (this condition may not occur)  			if (userData.Length > 0) {  				p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  				//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            				if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  					p_IsFlush = true;  				}  			} else {  				//warning  				if (p_Logger != null)  					p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  			}  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  			//this is Adobe specific we will need to send back a header  			p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  			requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  			adobePath = "";  			//this will contain the resolved absolute path  			//TODO: move the following into a response queue  			//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   			//The user did not ask for index.htm it is how CF marks docroot vs final path      			if (requestPath == "/index.htm") {  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  			} else {  				//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  				try {  					adobePath = ServerPath (requestPath);  					//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  				} catch (Exception e) {  					//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  					if (p_Logger != null)  						p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  				}  			}  			;  			//build a response package  			BonCodeFilePathPacket pathResponse = null;  			pathResponse = new BonCodeFilePathPacket (adobePath);  			p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  			if (p_Logger != null)  				p_Logger.LogPacket (pathResponse);  			delayWriteIndicator = true;  			//prevent main process from writing to network stream  			break;  		default:  			//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 			p_PacketsReceived.Add (new TomcatReturn (userData));  			if (p_Logger != null) {  				p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  			}  			;  			break;  		}  		//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  		if (p_Logger != null)  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  		//reset new iStart  		iStart = iStart + 4 + packetLength - 1;  		//detect end package  		if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  			p_IsLastPacket = true;  			p_IsFlush = false;  		} else {  			//old flush check position  			/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  	} else {  		//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  		unalyzedBytes = new byte[receiveBuffer.Length - iStart];  		Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  		//set breakout conditions  		iStart = iStart + packetLength - 1;  		break;  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (iStart >= 0) {  	//determine end of packet if this is negative we need continue scanning   	try {  		packetLength = GetInt16B (receiveBuffer' iStart + 2);  	} catch (Exception e) {  		//log exception  		if (p_Logger != null)  			p_Logger.LogException (e' "packet length determination problem"' 1);  	}  	//check whether we have sufficient data in receive buffer to analyze package  	if (packetLength + iStart + 4 <= receiveBuffer.Length) {  		//TODO: check whether packet length is beyond maximum and throw error  		int packetType = (int)receiveBuffer [iStart + 4];  		byte[] userData = new byte[packetLength];  		string adobePath = "";  		string requestPath = "";  		//we skip 4-bytes:magic (AB) and packet length markers when determining user data  		Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  		//Detect Correct packet Type and create instance of store  		switch (packetType) {  		case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  			p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  			//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  			if (p_PacketsToSend.Count == 1) {  				p_SendTermPacket = true;  			}  			//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  			p_PacketsReceived.Add (new TomcatEndResponse (userData));  			//this is the termination indicator we need to stop processing from here on. This can happen   			//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  			p_PacketsReceived.Add (new TomcatSendHeaders (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  			p_PacketsReceived.Add (new TomcatCPongReply (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  			//only add user data if there is something so we don't create null packets (this condition may not occur)  			if (userData.Length > 0) {  				p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  				//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            				if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  					p_IsFlush = true;  				}  			} else {  				//warning  				if (p_Logger != null)  					p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  			}  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  			//this is Adobe specific we will need to send back a header  			p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  			requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  			adobePath = "";  			//this will contain the resolved absolute path  			//TODO: move the following into a response queue  			//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   			//The user did not ask for index.htm it is how CF marks docroot vs final path      			if (requestPath == "/index.htm") {  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  			} else {  				//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  				try {  					adobePath = ServerPath (requestPath);  					//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  				} catch (Exception e) {  					//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  					if (p_Logger != null)  						p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  				}  			}  			;  			//build a response package  			BonCodeFilePathPacket pathResponse = null;  			pathResponse = new BonCodeFilePathPacket (adobePath);  			p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  			if (p_Logger != null)  				p_Logger.LogPacket (pathResponse);  			delayWriteIndicator = true;  			//prevent main process from writing to network stream  			break;  		default:  			//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 			p_PacketsReceived.Add (new TomcatReturn (userData));  			if (p_Logger != null) {  				p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  			}  			;  			break;  		}  		//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  		if (p_Logger != null)  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  		//reset new iStart  		iStart = iStart + 4 + packetLength - 1;  		//detect end package  		if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  			p_IsLastPacket = true;  			p_IsFlush = false;  		} else {  			//old flush check position  			/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  	} else {  		//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  		unalyzedBytes = new byte[receiveBuffer.Length - iStart];  		Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  		//set breakout conditions  		iStart = iStart + packetLength - 1;  		break;  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (iStart >= 0) {  	//determine end of packet if this is negative we need continue scanning   	try {  		packetLength = GetInt16B (receiveBuffer' iStart + 2);  	} catch (Exception e) {  		//log exception  		if (p_Logger != null)  			p_Logger.LogException (e' "packet length determination problem"' 1);  	}  	//check whether we have sufficient data in receive buffer to analyze package  	if (packetLength + iStart + 4 <= receiveBuffer.Length) {  		//TODO: check whether packet length is beyond maximum and throw error  		int packetType = (int)receiveBuffer [iStart + 4];  		byte[] userData = new byte[packetLength];  		string adobePath = "";  		string requestPath = "";  		//we skip 4-bytes:magic (AB) and packet length markers when determining user data  		Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  		//Detect Correct packet Type and create instance of store  		switch (packetType) {  		case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  			p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  			//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  			if (p_PacketsToSend.Count == 1) {  				p_SendTermPacket = true;  			}  			//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  			p_PacketsReceived.Add (new TomcatEndResponse (userData));  			//this is the termination indicator we need to stop processing from here on. This can happen   			//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  			p_PacketsReceived.Add (new TomcatSendHeaders (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  			p_PacketsReceived.Add (new TomcatCPongReply (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  			//only add user data if there is something so we don't create null packets (this condition may not occur)  			if (userData.Length > 0) {  				p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  				//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            				if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  					p_IsFlush = true;  				}  			} else {  				//warning  				if (p_Logger != null)  					p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  			}  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  			//this is Adobe specific we will need to send back a header  			p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  			requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  			adobePath = "";  			//this will contain the resolved absolute path  			//TODO: move the following into a response queue  			//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   			//The user did not ask for index.htm it is how CF marks docroot vs final path      			if (requestPath == "/index.htm") {  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  			} else {  				//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  				try {  					adobePath = ServerPath (requestPath);  					//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  				} catch (Exception e) {  					//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  					if (p_Logger != null)  						p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  				}  			}  			;  			//build a response package  			BonCodeFilePathPacket pathResponse = null;  			pathResponse = new BonCodeFilePathPacket (adobePath);  			p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  			if (p_Logger != null)  				p_Logger.LogPacket (pathResponse);  			delayWriteIndicator = true;  			//prevent main process from writing to network stream  			break;  		default:  			//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 			p_PacketsReceived.Add (new TomcatReturn (userData));  			if (p_Logger != null) {  				p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  			}  			;  			break;  		}  		//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  		if (p_Logger != null)  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  		//reset new iStart  		iStart = iStart + 4 + packetLength - 1;  		//detect end package  		if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  			p_IsLastPacket = true;  			p_IsFlush = false;  		} else {  			//old flush check position  			/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  	} else {  		//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  		unalyzedBytes = new byte[receiveBuffer.Length - iStart];  		Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  		//set breakout conditions  		iStart = iStart + packetLength - 1;  		break;  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (iStart >= 0) {  	//determine end of packet if this is negative we need continue scanning   	try {  		packetLength = GetInt16B (receiveBuffer' iStart + 2);  	} catch (Exception e) {  		//log exception  		if (p_Logger != null)  			p_Logger.LogException (e' "packet length determination problem"' 1);  	}  	//check whether we have sufficient data in receive buffer to analyze package  	if (packetLength + iStart + 4 <= receiveBuffer.Length) {  		//TODO: check whether packet length is beyond maximum and throw error  		int packetType = (int)receiveBuffer [iStart + 4];  		byte[] userData = new byte[packetLength];  		string adobePath = "";  		string requestPath = "";  		//we skip 4-bytes:magic (AB) and packet length markers when determining user data  		Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  		//Detect Correct packet Type and create instance of store  		switch (packetType) {  		case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  			p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  			//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  			if (p_PacketsToSend.Count == 1) {  				p_SendTermPacket = true;  			}  			//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  			p_PacketsReceived.Add (new TomcatEndResponse (userData));  			//this is the termination indicator we need to stop processing from here on. This can happen   			//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  			p_PacketsReceived.Add (new TomcatSendHeaders (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  			p_PacketsReceived.Add (new TomcatCPongReply (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  			//only add user data if there is something so we don't create null packets (this condition may not occur)  			if (userData.Length > 0) {  				p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  				//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            				if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  					p_IsFlush = true;  				}  			} else {  				//warning  				if (p_Logger != null)  					p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  			}  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  			//this is Adobe specific we will need to send back a header  			p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  			requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  			adobePath = "";  			//this will contain the resolved absolute path  			//TODO: move the following into a response queue  			//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   			//The user did not ask for index.htm it is how CF marks docroot vs final path      			if (requestPath == "/index.htm") {  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  			} else {  				//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  				try {  					adobePath = ServerPath (requestPath);  					//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  				} catch (Exception e) {  					//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  					if (p_Logger != null)  						p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  				}  			}  			;  			//build a response package  			BonCodeFilePathPacket pathResponse = null;  			pathResponse = new BonCodeFilePathPacket (adobePath);  			p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  			if (p_Logger != null)  				p_Logger.LogPacket (pathResponse);  			delayWriteIndicator = true;  			//prevent main process from writing to network stream  			break;  		default:  			//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 			p_PacketsReceived.Add (new TomcatReturn (userData));  			if (p_Logger != null) {  				p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  			}  			;  			break;  		}  		//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  		if (p_Logger != null)  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  		//reset new iStart  		iStart = iStart + 4 + packetLength - 1;  		//detect end package  		if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  			p_IsLastPacket = true;  			p_IsFlush = false;  		} else {  			//old flush check position  			/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  	} else {  		//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  		unalyzedBytes = new byte[receiveBuffer.Length - iStart];  		Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  		//set breakout conditions  		iStart = iStart + packetLength - 1;  		break;  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (iStart >= 0) {  	//determine end of packet if this is negative we need continue scanning   	try {  		packetLength = GetInt16B (receiveBuffer' iStart + 2);  	} catch (Exception e) {  		//log exception  		if (p_Logger != null)  			p_Logger.LogException (e' "packet length determination problem"' 1);  	}  	//check whether we have sufficient data in receive buffer to analyze package  	if (packetLength + iStart + 4 <= receiveBuffer.Length) {  		//TODO: check whether packet length is beyond maximum and throw error  		int packetType = (int)receiveBuffer [iStart + 4];  		byte[] userData = new byte[packetLength];  		string adobePath = "";  		string requestPath = "";  		//we skip 4-bytes:magic (AB) and packet length markers when determining user data  		Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  		//Detect Correct packet Type and create instance of store  		switch (packetType) {  		case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  			p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  			//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  			if (p_PacketsToSend.Count == 1) {  				p_SendTermPacket = true;  			}  			//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  			p_PacketsReceived.Add (new TomcatEndResponse (userData));  			//this is the termination indicator we need to stop processing from here on. This can happen   			//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  			p_PacketsReceived.Add (new TomcatSendHeaders (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  			p_PacketsReceived.Add (new TomcatCPongReply (userData));  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  			//only add user data if there is something so we don't create null packets (this condition may not occur)  			if (userData.Length > 0) {  				p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  				//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            				if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  					p_IsFlush = true;  				}  			} else {  				//warning  				if (p_Logger != null)  					p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  			}  			break;  		case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  			//this is Adobe specific we will need to send back a header  			p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  			requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  			adobePath = "";  			//this will contain the resolved absolute path  			//TODO: move the following into a response queue  			//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   			//The user did not ask for index.htm it is how CF marks docroot vs final path      			if (requestPath == "/index.htm") {  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  			} else {  				//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  				try {  					adobePath = ServerPath (requestPath);  					//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  				} catch (Exception e) {  					//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  					if (p_Logger != null)  						p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  					adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  				}  			}  			;  			//build a response package  			BonCodeFilePathPacket pathResponse = null;  			pathResponse = new BonCodeFilePathPacket (adobePath);  			p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  			if (p_Logger != null)  				p_Logger.LogPacket (pathResponse);  			delayWriteIndicator = true;  			//prevent main process from writing to network stream  			break;  		default:  			//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 			p_PacketsReceived.Add (new TomcatReturn (userData));  			if (p_Logger != null) {  				p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  				p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  			}  			;  			break;  		}  		//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  		if (p_Logger != null)  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  		//reset new iStart  		iStart = iStart + 4 + packetLength - 1;  		//detect end package  		if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  			p_IsLastPacket = true;  			p_IsFlush = false;  		} else {  			//old flush check position  			/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  	} else {  		//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  		unalyzedBytes = new byte[receiveBuffer.Length - iStart];  		Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  		//set breakout conditions  		iStart = iStart + packetLength - 1;  		break;  	}  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: try {  	packetLength = GetInt16B (receiveBuffer' iStart + 2);  } catch (Exception e) {  	//log exception  	if (p_Logger != null)  		p_Logger.LogException (e' "packet length determination problem"' 1);  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: packetLength = GetInt16B (receiveBuffer' iStart + 2);  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (packetLength + iStart + 4 <= receiveBuffer.Length) {  	//TODO: check whether packet length is beyond maximum and throw error  	int packetType = (int)receiveBuffer [iStart + 4];  	byte[] userData = new byte[packetLength];  	string adobePath = "";  	string requestPath = "";  	//we skip 4-bytes:magic (AB) and packet length markers when determining user data  	Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  	//Detect Correct packet Type and create instance of store  	switch (packetType) {  	case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  		p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  		//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  		if (p_PacketsToSend.Count == 1) {  			p_SendTermPacket = true;  		}  		//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  		p_PacketsReceived.Add (new TomcatEndResponse (userData));  		//this is the termination indicator we need to stop processing from here on. This can happen   		//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  		p_PacketsReceived.Add (new TomcatSendHeaders (userData));  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  		p_PacketsReceived.Add (new TomcatCPongReply (userData));  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  		//only add user data if there is something so we don't create null packets (this condition may not occur)  		if (userData.Length > 0) {  			p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  			//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            			if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  				p_IsFlush = true;  			}  		} else {  			//warning  			if (p_Logger != null)  				p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  		}  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  		//this is Adobe specific we will need to send back a header  		p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  		requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  		adobePath = "";  		//this will contain the resolved absolute path  		//TODO: move the following into a response queue  		//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   		//The user did not ask for index.htm it is how CF marks docroot vs final path      		if (requestPath == "/index.htm") {  			adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  		} else {  			//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  			try {  				adobePath = ServerPath (requestPath);  				//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  			} catch (Exception e) {  				//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  				if (p_Logger != null)  					p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  			}  		}  		;  		//build a response package  		BonCodeFilePathPacket pathResponse = null;  		pathResponse = new BonCodeFilePathPacket (adobePath);  		p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  		if (p_Logger != null)  			p_Logger.LogPacket (pathResponse);  		delayWriteIndicator = true;  		//prevent main process from writing to network stream  		break;  	default:  		//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 		p_PacketsReceived.Add (new TomcatReturn (userData));  		if (p_Logger != null) {  			p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  		}  		;  		break;  	}  	//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  	if (p_Logger != null)  		p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  	//reset new iStart  	iStart = iStart + 4 + packetLength - 1;  	//detect end package  	if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  		p_IsLastPacket = true;  		p_IsFlush = false;  	} else {  		//old flush check position  		/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  } else {  	//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  	unalyzedBytes = new byte[receiveBuffer.Length - iStart];  	Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  	//set breakout conditions  	iStart = iStart + packetLength - 1;  	break;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (packetLength + iStart + 4 <= receiveBuffer.Length) {  	//TODO: check whether packet length is beyond maximum and throw error  	int packetType = (int)receiveBuffer [iStart + 4];  	byte[] userData = new byte[packetLength];  	string adobePath = "";  	string requestPath = "";  	//we skip 4-bytes:magic (AB) and packet length markers when determining user data  	Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  	//Detect Correct packet Type and create instance of store  	switch (packetType) {  	case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  		p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  		//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  		if (p_PacketsToSend.Count == 1) {  			p_SendTermPacket = true;  		}  		//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  		p_PacketsReceived.Add (new TomcatEndResponse (userData));  		//this is the termination indicator we need to stop processing from here on. This can happen   		//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  		p_PacketsReceived.Add (new TomcatSendHeaders (userData));  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  		p_PacketsReceived.Add (new TomcatCPongReply (userData));  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  		//only add user data if there is something so we don't create null packets (this condition may not occur)  		if (userData.Length > 0) {  			p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  			//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            			if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  				p_IsFlush = true;  			}  		} else {  			//warning  			if (p_Logger != null)  				p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  		}  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  		//this is Adobe specific we will need to send back a header  		p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  		requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  		adobePath = "";  		//this will contain the resolved absolute path  		//TODO: move the following into a response queue  		//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   		//The user did not ask for index.htm it is how CF marks docroot vs final path      		if (requestPath == "/index.htm") {  			adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  		} else {  			//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  			try {  				adobePath = ServerPath (requestPath);  				//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  			} catch (Exception e) {  				//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  				if (p_Logger != null)  					p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  			}  		}  		;  		//build a response package  		BonCodeFilePathPacket pathResponse = null;  		pathResponse = new BonCodeFilePathPacket (adobePath);  		p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  		if (p_Logger != null)  			p_Logger.LogPacket (pathResponse);  		delayWriteIndicator = true;  		//prevent main process from writing to network stream  		break;  	default:  		//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 		p_PacketsReceived.Add (new TomcatReturn (userData));  		if (p_Logger != null) {  			p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  		}  		;  		break;  	}  	//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  	if (p_Logger != null)  		p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  	//reset new iStart  	iStart = iStart + 4 + packetLength - 1;  	//detect end package  	if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  		p_IsLastPacket = true;  		p_IsFlush = false;  	} else {  		//old flush check position  		/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  } else {  	//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  	unalyzedBytes = new byte[receiveBuffer.Length - iStart];  	Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  	//set breakout conditions  	iStart = iStart + packetLength - 1;  	break;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (packetLength + iStart + 4 <= receiveBuffer.Length) {  	//TODO: check whether packet length is beyond maximum and throw error  	int packetType = (int)receiveBuffer [iStart + 4];  	byte[] userData = new byte[packetLength];  	string adobePath = "";  	string requestPath = "";  	//we skip 4-bytes:magic (AB) and packet length markers when determining user data  	Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  	//Detect Correct packet Type and create instance of store  	switch (packetType) {  	case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  		p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  		//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  		if (p_PacketsToSend.Count == 1) {  			p_SendTermPacket = true;  		}  		//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  		p_PacketsReceived.Add (new TomcatEndResponse (userData));  		//this is the termination indicator we need to stop processing from here on. This can happen   		//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  		p_PacketsReceived.Add (new TomcatSendHeaders (userData));  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  		p_PacketsReceived.Add (new TomcatCPongReply (userData));  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  		//only add user data if there is something so we don't create null packets (this condition may not occur)  		if (userData.Length > 0) {  			p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  			//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            			if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  				p_IsFlush = true;  			}  		} else {  			//warning  			if (p_Logger != null)  				p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  		}  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  		//this is Adobe specific we will need to send back a header  		p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  		requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  		adobePath = "";  		//this will contain the resolved absolute path  		//TODO: move the following into a response queue  		//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   		//The user did not ask for index.htm it is how CF marks docroot vs final path      		if (requestPath == "/index.htm") {  			adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  		} else {  			//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  			try {  				adobePath = ServerPath (requestPath);  				//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  			} catch (Exception e) {  				//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  				if (p_Logger != null)  					p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  			}  		}  		;  		//build a response package  		BonCodeFilePathPacket pathResponse = null;  		pathResponse = new BonCodeFilePathPacket (adobePath);  		p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  		if (p_Logger != null)  			p_Logger.LogPacket (pathResponse);  		delayWriteIndicator = true;  		//prevent main process from writing to network stream  		break;  	default:  		//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 		p_PacketsReceived.Add (new TomcatReturn (userData));  		if (p_Logger != null) {  			p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  		}  		;  		break;  	}  	//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  	if (p_Logger != null)  		p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  	//reset new iStart  	iStart = iStart + 4 + packetLength - 1;  	//detect end package  	if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  		p_IsLastPacket = true;  		p_IsFlush = false;  	} else {  		//old flush check position  		/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  } else {  	//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  	unalyzedBytes = new byte[receiveBuffer.Length - iStart];  	Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  	//set breakout conditions  	iStart = iStart + packetLength - 1;  	break;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (packetLength + iStart + 4 <= receiveBuffer.Length) {  	//TODO: check whether packet length is beyond maximum and throw error  	int packetType = (int)receiveBuffer [iStart + 4];  	byte[] userData = new byte[packetLength];  	string adobePath = "";  	string requestPath = "";  	//we skip 4-bytes:magic (AB) and packet length markers when determining user data  	Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  	//Detect Correct packet Type and create instance of store  	switch (packetType) {  	case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  		p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  		//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  		if (p_PacketsToSend.Count == 1) {  			p_SendTermPacket = true;  		}  		//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  		p_PacketsReceived.Add (new TomcatEndResponse (userData));  		//this is the termination indicator we need to stop processing from here on. This can happen   		//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  		p_PacketsReceived.Add (new TomcatSendHeaders (userData));  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  		p_PacketsReceived.Add (new TomcatCPongReply (userData));  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  		//only add user data if there is something so we don't create null packets (this condition may not occur)  		if (userData.Length > 0) {  			p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  			//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            			if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  				p_IsFlush = true;  			}  		} else {  			//warning  			if (p_Logger != null)  				p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  		}  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  		//this is Adobe specific we will need to send back a header  		p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  		requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  		adobePath = "";  		//this will contain the resolved absolute path  		//TODO: move the following into a response queue  		//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   		//The user did not ask for index.htm it is how CF marks docroot vs final path      		if (requestPath == "/index.htm") {  			adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  		} else {  			//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  			try {  				adobePath = ServerPath (requestPath);  				//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  			} catch (Exception e) {  				//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  				if (p_Logger != null)  					p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  			}  		}  		;  		//build a response package  		BonCodeFilePathPacket pathResponse = null;  		pathResponse = new BonCodeFilePathPacket (adobePath);  		p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  		if (p_Logger != null)  			p_Logger.LogPacket (pathResponse);  		delayWriteIndicator = true;  		//prevent main process from writing to network stream  		break;  	default:  		//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 		p_PacketsReceived.Add (new TomcatReturn (userData));  		if (p_Logger != null) {  			p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  		}  		;  		break;  	}  	//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  	if (p_Logger != null)  		p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  	//reset new iStart  	iStart = iStart + 4 + packetLength - 1;  	//detect end package  	if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  		p_IsLastPacket = true;  		p_IsFlush = false;  	} else {  		//old flush check position  		/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  } else {  	//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  	unalyzedBytes = new byte[receiveBuffer.Length - iStart];  	Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  	//set breakout conditions  	iStart = iStart + packetLength - 1;  	break;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (packetLength + iStart + 4 <= receiveBuffer.Length) {  	//TODO: check whether packet length is beyond maximum and throw error  	int packetType = (int)receiveBuffer [iStart + 4];  	byte[] userData = new byte[packetLength];  	string adobePath = "";  	string requestPath = "";  	//we skip 4-bytes:magic (AB) and packet length markers when determining user data  	Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  	//Detect Correct packet Type and create instance of store  	switch (packetType) {  	case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  		p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  		//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  		if (p_PacketsToSend.Count == 1) {  			p_SendTermPacket = true;  		}  		//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  		p_PacketsReceived.Add (new TomcatEndResponse (userData));  		//this is the termination indicator we need to stop processing from here on. This can happen   		//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  		p_PacketsReceived.Add (new TomcatSendHeaders (userData));  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  		p_PacketsReceived.Add (new TomcatCPongReply (userData));  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  		//only add user data if there is something so we don't create null packets (this condition may not occur)  		if (userData.Length > 0) {  			p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  			//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            			if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  				p_IsFlush = true;  			}  		} else {  			//warning  			if (p_Logger != null)  				p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  		}  		break;  	case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  		//this is Adobe specific we will need to send back a header  		p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  		requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  		adobePath = "";  		//this will contain the resolved absolute path  		//TODO: move the following into a response queue  		//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   		//The user did not ask for index.htm it is how CF marks docroot vs final path      		if (requestPath == "/index.htm") {  			adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  		} else {  			//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  			try {  				adobePath = ServerPath (requestPath);  				//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  			} catch (Exception e) {  				//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  				if (p_Logger != null)  					p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  				adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  			}  		}  		;  		//build a response package  		BonCodeFilePathPacket pathResponse = null;  		pathResponse = new BonCodeFilePathPacket (adobePath);  		p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  		if (p_Logger != null)  			p_Logger.LogPacket (pathResponse);  		delayWriteIndicator = true;  		//prevent main process from writing to network stream  		break;  	default:  		//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 		p_PacketsReceived.Add (new TomcatReturn (userData));  		if (p_Logger != null) {  			p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  			p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  		}  		;  		break;  	}  	//Log packets Received. Whether the packet will actually be logged depends on log level chosen.  	if (p_Logger != null)  		p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]);  	//reset new iStart  	iStart = iStart + 4 + packetLength - 1;  	//detect end package  	if (packetType == BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE) {  		p_IsLastPacket = true;  		p_IsFlush = false;  	} else {  		//old flush check position  		/*                             //check whether we need monitor for tomcat flush signs                               if (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0)                             {                                 long elapsedTicks = p_StopWatch.ElapsedTicks;                                 p_TickDelta = elapsedTicks - p_LastTick;                                 p_LastTick = elapsedTicks;                                 if (p_TickDelta > BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS)                                 {                                     //flush has been detected set the flag. We should flush after this receiveBuffer has been processed.                                     //no flush is needed if we see end marker during receiveBuffer processing                                                                       p_IsFlush = true;                                 }                             }                             */}  } else {  	//we need to read more data before we can process. For now mark these bytes as unanalyzed and return to stream reader  	unalyzedBytes = new byte[receiveBuffer.Length - iStart];  	Array.Copy (receiveBuffer' iStart' unalyzedBytes' 0' receiveBuffer.Length - iStart);  	//set breakout conditions  	iStart = iStart + packetLength - 1;  	break;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: Array.Copy (receiveBuffer' iStart + 4' userData' 0' packetLength);  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: switch (packetType) {  case BonCodeAJP13TomcatPacketType.TOMCAT_GETBODYCHUNK:  	p_PacketsReceived.Add (new TomcatGetBodyChunk (userData));  	//if this command is encountered when only one GET package was previously send (no multi-packets) we need to send a terminator body package  	if (p_PacketsToSend.Count == 1) {  		p_SendTermPacket = true;  	}  	//p_NetworkStream.Write(sendPacket.GetDataBytes()' 0' sendPacket.PacketLength);  	break;  case BonCodeAJP13TomcatPacketType.TOMCAT_ENDRESPONSE:  	p_PacketsReceived.Add (new TomcatEndResponse (userData));  	//this is the termination indicator we need to stop processing from here on. This can happen   	//when we post data as well. Tomcat can indicate a connection stop and we need to stop processing as well.  	break;  case BonCodeAJP13TomcatPacketType.TOMCAT_SENDHEADERS:  	p_PacketsReceived.Add (new TomcatSendHeaders (userData));  	break;  case BonCodeAJP13TomcatPacketType.TOMCAT_CPONGREPLY:  	p_PacketsReceived.Add (new TomcatCPongReply (userData));  	break;  case BonCodeAJP13TomcatPacketType.TOMCAT_SENDBODYCHUNK:  	//only add user data if there is something so we don't create null packets (this condition may not occur)  	if (userData.Length > 0) {  		p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  		//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            		if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  			p_IsFlush = true;  		}  	} else {  		//warning  		if (p_Logger != null)  			p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  	}  	break;  case BonCodeAJP13TomcatPacketType.TOMCAT_CFPATHREQUEST:  	//this is Adobe specific we will need to send back a header  	p_PacketsReceived.Add (new TomcatPhysicalPathRequest (userData));  	requestPath = ((TomcatPhysicalPathRequest)p_PacketsReceived [p_PacketsReceived.Count - 1]).GetFilePath ();  	adobePath = "";  	//this will contain the resolved absolute path  	//TODO: move the following into a response queue  	//prep response and return now CF will ask for two paths one for index.htm one for the actual URI   	//The user did not ask for index.htm it is how CF marks docroot vs final path      	if (requestPath == "/index.htm") {  		adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + "index.htm";  	} else {  		//if we get bogus requests to paths that don't exist or have fake data this will error. Adobe CF just appends the request to doc root when error. We will do the same.  		try {  			adobePath = ServerPath (requestPath);  			//System.Web.HttpContext.Current.Server.MapPath("/yeah") ;//BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath;                                  		} catch (Exception e) {  			//if (p_Logger != null) p_Logger.LogException(e' "Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly.");  			if (p_Logger != null)  				p_Logger.LogMessageAndType ("Problem determining absolute path [" + adobePath + "] for provided relative path: [" + requestPath + "]. Please ensure that provided path is a relative path and there is a virtual mapping and you have spelled correctly."' "warning"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_BASIC);  			adobePath = BonCodeAJP13Settings.BonCodeAjp13_DocRoot + requestPath;  		}  	}  	;  	//build a response package  	BonCodeFilePathPacket pathResponse = null;  	pathResponse = new BonCodeFilePathPacket (adobePath);  	p_NetworkStream.Write (pathResponse.GetDataBytes ()' 0' pathResponse.PacketLength);  	if (p_Logger != null)  		p_Logger.LogPacket (pathResponse);  	delayWriteIndicator = true;  	//prevent main process from writing to network stream  	break;  default:  	//we don't know this type of package; add to collection anyway and log it' we will not raise error but continue processing                                 	p_PacketsReceived.Add (new TomcatReturn (userData));  	if (p_Logger != null) {  		p_Logger.LogMessage ("Unknown Packet Type Received' see next log entry:"' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_ERRORS);  		p_Logger.LogPacket (p_PacketsReceived [p_PacketsReceived.Count - 1]' true);  	}  	;  	break;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (userData.Length > 0) {  	p_PacketsReceived.Add (new TomcatSendBodyChunk (userData));  	//check whether we have an AJP flush and whether we will accept it. In that case we have only four bytes in the packet. No user payload.                            	if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  		p_IsFlush = true;  	}  } else {  	//warning  	if (p_Logger != null)  		p_Logger.LogMessage ("Received empty user packet in TOMCAT_SENDBODYCHUNK' skipping."' BonCodeAJP13LogLevels.BONCODEAJP13_LOG_DEBUG);  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: if (userData.Length == 4 && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) {  	p_IsFlush = true;  }  
Magic Number,BonCodeAJP13,BonCodeAJP13ServerConnection,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\BonCodeAJP13ServerConnection.cs,AnalyzePackage,The following statement contains a magic number: iStart = iStart + 4 + packetLength - 1;  
Magic Number,BonCodeAJP13,Test,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\Test.cs,fConfTest,The following statement contains a magic number: a = a + 2;  
Magic Number,BonCodeAJP13,Test,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\Test.cs,fHeaderTest,The following statement contains a magic number: a = a + 2;  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length > 0 && transferContent.Length <= BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH) {  	p_ByteStore = new byte[transferContent.Length + 6];  	int pos = 2;  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length + 2)' pos);  	//overall length  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length)' pos);  	//user data length  	pos = SetSimpleByteArray (p_ByteStore' transferContent' pos);  	p_PacketLength = p_ByteStore.Length;  } else if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length > 0 && transferContent.Length <= BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH) {  	p_ByteStore = new byte[transferContent.Length + 6];  	int pos = 2;  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length + 2)' pos);  	//overall length  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length)' pos);  	//user data length  	pos = SetSimpleByteArray (p_ByteStore' transferContent' pos);  	p_PacketLength = p_ByteStore.Length;  } else if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length > 0 && transferContent.Length <= BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH) {  	p_ByteStore = new byte[transferContent.Length + 6];  	int pos = 2;  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length + 2)' pos);  	//overall length  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length)' pos);  	//user data length  	pos = SetSimpleByteArray (p_ByteStore' transferContent' pos);  	p_PacketLength = p_ByteStore.Length;  } else if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length > 0 && transferContent.Length <= BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH) {  	p_ByteStore = new byte[transferContent.Length + 6];  	int pos = 2;  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length + 2)' pos);  	//overall length  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length)' pos);  	//user data length  	pos = SetSimpleByteArray (p_ByteStore' transferContent' pos);  	p_PacketLength = p_ByteStore.Length;  } else if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length > 0 && transferContent.Length <= BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH) {  	p_ByteStore = new byte[transferContent.Length + 6];  	int pos = 2;  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length + 2)' pos);  	//overall length  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length)' pos);  	//user data length  	pos = SetSimpleByteArray (p_ByteStore' transferContent' pos);  	p_PacketLength = p_ByteStore.Length;  } else if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length > 0 && transferContent.Length <= BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH) {  	p_ByteStore = new byte[transferContent.Length + 6];  	int pos = 2;  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length + 2)' pos);  	//overall length  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length)' pos);  	//user data length  	pos = SetSimpleByteArray (p_ByteStore' transferContent' pos);  	p_PacketLength = p_ByteStore.Length;  } else if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length > 0 && transferContent.Length <= BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH) {  	p_ByteStore = new byte[transferContent.Length + 6];  	int pos = 2;  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length + 2)' pos);  	//overall length  	pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length)' pos);  	//user data length  	pos = SetSimpleByteArray (p_ByteStore' transferContent' pos);  	p_PacketLength = p_ByteStore.Length;  } else if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: p_ByteStore = new byte[transferContent.Length + 6];  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: pos = SetInt16 (p_ByteStore' Convert.ToUInt16 (transferContent.Length + 2)' pos);  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (transferContent.Length == 0) {  	//create empty package' this has four bytes (acts as string terminator)  	p_ByteStore = new byte[4];  	p_ByteStore [0] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START;  	p_ByteStore [1] = BonCodeAJP13Markers.BONCODEAJP13_PACKET_START2;  	p_ByteStore [2] = 0x00;  	p_ByteStore [3] = 0x00;  	p_PacketLength = 4;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: p_ByteStore = new byte[4];  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: p_ByteStore [2] = 0x00;  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: p_ByteStore [3] = 0x00;  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: p_PacketLength = 4;  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (BonCodeAJP13Settings.BONCODEAJP13_HEADER_SUPPORT)// "X-Tomcat-DocRoot";   {  	addlHeaders.Add ("x-tomcat-docroot"' BonCodeAJP13Settings.BonCodeAjp13_DocRoot);  	// System.Web.HttpContext.Current.Server.MapPath("~"); alternatly we could use "appl-physical-path" http var  	if (vDirs.Length > 3) {  		addlHeaders.Add ("x-vdirs"' vDirs);  	}  	//instance id  	addlHeaders.Add ("x-webserver-context"' "W3SVC" + httpHeaders ["INSTANCE_ID"]);  	//if we have a shared key send it  	if (BonCodeAJP13Settings.BONCODE_MODCFML_SECRET.Length > 0) {  		addlHeaders.Add ("X-ModCFML-SharedKey"' BonCodeAJP13Settings.BONCODE_MODCFML_SECRET);  	}  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (vDirs.Length > 3) {  	addlHeaders.Add ("x-vdirs"' vDirs);  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: if (BonCodeAJP13Settings.BONCODEAJP13_PATH_PREFIX.Length > 2 && !BonCodeAJP13Settings.BONCODEAJP13_PATH_PREFIX.Equals (req_uri.Substring (0' BonCodeAJP13Settings.BONCODEAJP13_PATH_PREFIX.Length - 1)' StringComparison.Ordinal)) {  	req_uri = BonCodeAJP13Settings.BONCODEAJP13_PATH_PREFIX + req_uri;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: p_ByteStore = new byte[pos + 4];  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacket,The following statement contains a magic number: Array.Copy (aUserData' 0' p_ByteStore' 4' pos);  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,CheckHeaders,The following statement contains a magic number: if (BonCodeAJP13Settings.BONCODEAJP13_WHITELIST_HEADERS.Length > 5) {  	lstUserWhitelist = BonCodeAJP13Settings.BONCODEAJP13_WHITELIST_HEADERS.Split (new char[] {  		'''  	});  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,CheckHeaders,The following statement contains a magic number: if ((BonCodeAJP13Settings.BONCODEAJP13_BLACKLIST_HEADERS.Length) > 5) {  	string[] lstUserBlacklist = BonCodeAJP13Settings.BONCODEAJP13_BLACKLIST_HEADERS.Split (new char[] {  		'''  	});  	int lshOriginalSize = lstSystemBlacklist.Length;  	Array.Resize<string> (ref lstSystemBlacklist' lshOriginalSize + lstUserBlacklist.Length);  	Array.Copy (lstUserBlacklist' 0' lstSystemBlacklist' lshOriginalSize' lstUserBlacklist.Length);  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacketTest,The following statement contains a magic number: if (BonCodeAJP13Settings.BONCODEAJP13_PATH_PREFIX.Length > 2) {  	req_uri = BonCodeAJP13Settings.BONCODEAJP13_PATH_PREFIX.Length + "/" + req_uri;  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacketTest,The following statement contains a magic number: p_ByteStore = new byte[pos + 4];  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,WritePacketTest,The following statement contains a magic number: Array.Copy (aUserData' 0' p_ByteStore' 4' pos);  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,GetCorrectHeaderName,The following statement contains a magic number: if (retVal.StartsWith ("http_"))  	retVal = retVal.Remove (0' 5);  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,GetCorrectHeaderName,The following statement contains a magic number: retVal = retVal.Remove (0' 5);  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeAJP13ForwardRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeAJP13ForwardRequest.cs,GetFingerprint,The following statement contains a magic number: if (lstFPHeaders.Length < 5) {  	lstFPHeaders = "REMOTE_ADDR'HTTP_ACCEPT'HTTP_ACCEPT_CHARSET'HTTP_ACCEPT_ENCODING'HTTP_ACCEPT_LANGUAGE'HTTP_USER_AGENT'UA_CPU'REMOTE_HOST";  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeFilePathPacket,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeFilePathPacket.cs,GetUserDataString,The following statement contains a magic number: if (p_ByteStore.Length > 3) {  	return System.Text.Encoding.UTF8.GetString (p_ByteStore' 3' p_ByteStore.Length - 3);  } else {  	return "";  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeFilePathPacket,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeFilePathPacket.cs,GetUserDataString,The following statement contains a magic number: if (p_ByteStore.Length > 3) {  	return System.Text.Encoding.UTF8.GetString (p_ByteStore' 3' p_ByteStore.Length - 3);  } else {  	return "";  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeFilePathPacket,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeFilePathPacket.cs,GetUserDataString,The following statement contains a magic number: if (p_ByteStore.Length > 3) {  	return System.Text.Encoding.UTF8.GetString (p_ByteStore' 3' p_ByteStore.Length - 3);  } else {  	return "";  }  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeFilePathPacket,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeFilePathPacket.cs,GetUserDataString,The following statement contains a magic number: return System.Text.Encoding.UTF8.GetString (p_ByteStore' 3' p_ByteStore.Length - 3);  
Magic Number,BonCodeAJP13.ServerPackets,BonCodeFilePathPacket,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\ServerPackets\BonCodeFilePathPacket.cs,GetUserDataString,The following statement contains a magic number: return System.Text.Encoding.UTF8.GetString (p_ByteStore' 3' p_ByteStore.Length - 3);  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatCPongReply,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatCPongReply.cs,TomcatCPongReply,The following statement contains a magic number: try {  	p_PacketLength = content.Length;  	p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  } catch {  	//do nothing for now  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatCPongReply,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatCPongReply.cs,TomcatCPongReply,The following statement contains a magic number: p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatGetBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatGetBodyChunk.cs,TomcatGetBodyChunk,The following statement contains a magic number: try {  	p_PacketLength = content.Length;  	p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  } catch {  	//do nothing for now  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatGetBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatGetBodyChunk.cs,TomcatGetBodyChunk,The following statement contains a magic number: p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatGetBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatGetBodyChunk.cs,GetRequestedLength,The following statement contains a magic number: if (p_UserDataLength == 3) {  	ushort tempLength = 0;  	GetInt16 (p_ByteStore' ref tempLength' 5);  	RLEN = tempLength;  	//implicit cast  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatGetBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatGetBodyChunk.cs,GetRequestedLength,The following statement contains a magic number: if (p_UserDataLength == 3) {  	ushort tempLength = 0;  	GetInt16 (p_ByteStore' ref tempLength' 5);  	RLEN = tempLength;  	//implicit cast  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatGetBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatGetBodyChunk.cs,GetRequestedLength,The following statement contains a magic number: GetInt16 (p_ByteStore' ref tempLength' 5);  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatPhysicalPathRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatPhysicalPathRequest.cs,TomcatPhysicalPathRequest,The following statement contains a magic number: try {  	p_PacketLength = content.Length;  	p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  } catch {  	//do nothing for now  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatPhysicalPathRequest,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatPhysicalPathRequest.cs,TomcatPhysicalPathRequest,The following statement contains a magic number: p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatReturn,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatReturn.cs,TomcatReturn,The following statement contains a magic number: try {  	p_PacketLength = content.Length;  	p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  } catch {  	//do nothing for now  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatReturn,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatReturn.cs,TomcatReturn,The following statement contains a magic number: p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendBodyChunk.cs,TomcatSendBodyChunk,The following statement contains a magic number: try {  	p_PacketLength = content.Length;  	p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  } catch {  	//do nothing for now  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendBodyChunk.cs,TomcatSendBodyChunk,The following statement contains a magic number: p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendBodyChunk.cs,TomcatSendBodyChunk,The following statement contains a magic number: try {  	p_PacketLength = content.Length;  	p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  } catch {  	//do nothing for now  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendBodyChunk,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendBodyChunk.cs,TomcatSendBodyChunk,The following statement contains a magic number: p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendHeaders.cs,TomcatSendHeaders,The following statement contains a magic number: try {  	p_PacketLength = content.Length;  	p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  } catch {  	//do nothing for now  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendHeaders.cs,TomcatSendHeaders,The following statement contains a magic number: p_UserDataLength = System.Convert.ToUInt16 (content.Length - 4);  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendHeaders.cs,GetHeaders,The following statement contains a magic number: if (p_ByteStore.Length > 2)//first two bytes are for code and status   {  	pos = GetString (p_ByteStore' ref requestMessage' pos);  	//get number of headers  	pos = GetUInt16 (p_ByteStore' ref numOfHeaders' pos);  	//loop through headers as pairs  	for (int i = 0; i < numOfHeaders; i++) {  		if (p_ByteStore [pos] == BonCodeAJP13Markers.BONCODEAJP13_BYTE_HEADER_MARKER) {  			//translate byte header to string header and advance byte pointer  			keyName = BonCodeAJP13PacketHeaders.GetTomcatHeaderString (p_ByteStore [pos + 1]);  			pos = pos + 2;  		} else {  			//get string header  			pos = GetString (p_ByteStore' ref keyName' pos);  		}  		//get value string  		pos = GetString (p_ByteStore' ref keyValue' pos);  		//set into return  		if (keyName != "") {  			retHeaders.Add (keyName' keyValue + "|");  			//we are adding as a NameValue collection does not allow for duplicate keys' it will turn them into a   		}  	}  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendHeaders.cs,GetHeaders,The following statement contains a magic number: if (p_ByteStore.Length > 2)//first two bytes are for code and status   {  	pos = GetString (p_ByteStore' ref requestMessage' pos);  	//get number of headers  	pos = GetUInt16 (p_ByteStore' ref numOfHeaders' pos);  	//loop through headers as pairs  	for (int i = 0; i < numOfHeaders; i++) {  		if (p_ByteStore [pos] == BonCodeAJP13Markers.BONCODEAJP13_BYTE_HEADER_MARKER) {  			//translate byte header to string header and advance byte pointer  			keyName = BonCodeAJP13PacketHeaders.GetTomcatHeaderString (p_ByteStore [pos + 1]);  			pos = pos + 2;  		} else {  			//get string header  			pos = GetString (p_ByteStore' ref keyName' pos);  		}  		//get value string  		pos = GetString (p_ByteStore' ref keyValue' pos);  		//set into return  		if (keyName != "") {  			retHeaders.Add (keyName' keyValue + "|");  			//we are adding as a NameValue collection does not allow for duplicate keys' it will turn them into a   		}  	}  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendHeaders.cs,GetHeaders,The following statement contains a magic number: for (int i = 0; i < numOfHeaders; i++) {  	if (p_ByteStore [pos] == BonCodeAJP13Markers.BONCODEAJP13_BYTE_HEADER_MARKER) {  		//translate byte header to string header and advance byte pointer  		keyName = BonCodeAJP13PacketHeaders.GetTomcatHeaderString (p_ByteStore [pos + 1]);  		pos = pos + 2;  	} else {  		//get string header  		pos = GetString (p_ByteStore' ref keyName' pos);  	}  	//get value string  	pos = GetString (p_ByteStore' ref keyValue' pos);  	//set into return  	if (keyName != "") {  		retHeaders.Add (keyName' keyValue + "|");  		//we are adding as a NameValue collection does not allow for duplicate keys' it will turn them into a   	}  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendHeaders.cs,GetHeaders,The following statement contains a magic number: if (p_ByteStore [pos] == BonCodeAJP13Markers.BONCODEAJP13_BYTE_HEADER_MARKER) {  	//translate byte header to string header and advance byte pointer  	keyName = BonCodeAJP13PacketHeaders.GetTomcatHeaderString (p_ByteStore [pos + 1]);  	pos = pos + 2;  } else {  	//get string header  	pos = GetString (p_ByteStore' ref keyName' pos);  }  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendHeaders.cs,GetHeaders,The following statement contains a magic number: pos = pos + 2;  
Magic Number,BonCodeAJP13.TomcatPackets,TomcatSendHeaders,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeAJP13\TomcatPackets\TomcatSendHeaders.cs,GetStatus,The following statement contains a magic number: if (p_ByteStore.Length > 2)//byte 1 and 2 are status bytes   {  	GetInt16 (p_ByteStore' ref retVal' 1);  }  
