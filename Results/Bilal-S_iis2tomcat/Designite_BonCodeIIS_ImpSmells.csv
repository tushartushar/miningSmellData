Implementation smell,Namespace,Class,File,Method,Description
Long Method,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The method has 205 lines of code.
Long Method,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The method has 127 lines of code.
Long Method,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,CheckExecution,The method has 133 lines of code.
Complex Method,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,Cyclomatic complexity of the method is 25
Complex Method,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,Cyclomatic complexity of the method is 25
Complex Method,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,Cyclomatic complexity of the method is 8
Complex Method,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,CheckExecution,Cyclomatic complexity of the method is 25
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "	//TODO: application scope move: need to see whether config data is better saved in app scope after initial reading. Would need a reset mechanism if cached this way " is 163.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "			//in some circumstances invalid path data can be supplied by client if so we will set the path to blank when exception occurs' e.g. http://project/group:master...master " is 168.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "			//check whether we are resuable' we discard and re-establish connections if MAX_BONCODEAJP13_CONCURRENT_CONNECTIONS is set to zero " is 130.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "					string errMsg = "Error connecting to Apache Tomcat instance.<hr>Please check that a Tomcat server is running at given location and port.<br>Details:<br>" + e.Message + "<br><small><small><br>You can change this message by changing TomcatConnectErrorURL setting in setting file.</small></small>"; " is 295.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "				//check whether existing TCP/IP connection is still working. If tomcat is restarted the connection needs to be reset here as well " is 129.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "				if (context.Request.ServerVariables ["HTTP_TRANSFER_ENCODING"] != null && context.Request.ServerVariables ["HTTP_TRANSFER_ENCODING"] == "chunked") { " is 148.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "					FR = new BonCodeAJP13ForwardRequest (context.Request.ServerVariables' context.Request.PathInfo' sourcePort' virPaths' GetClientCert (context)); " is 143.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "				//TODO: think about streaming support. The reading would be posted to a different thread that continues the reading process while " is 129.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "					int numOfPackets = Convert.ToInt32 (Math.Ceiling (Convert.ToDouble (context.Request.ContentLength / Convert.ToDouble (maxPacketSize)))); " is 136.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "		//if we have web exception display reasonsa maxRequest length exception' e.g. 3004 then display different message otherwise normal message " is 138.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The length of the statement  "		string strErr = "IIS Web Processing Exception (" + e.GetHttpCode ().ToString () + "):<hr>" + e.Message + "<br><small>For maximum request size limit errors please have administrator adjust maxRequestLength and/or maxAllowedContentLength.</small><br>"; " is 250.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The length of the statement  "						//check whether we can represent a given header in native IIS Response context (currently only used for server side redirects) " is 126.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The length of the statement  "						//we will mark this as to be killed if status indicates error to ensure that stream cache is removed and cannot be reused by other connections " is 142.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The length of the statement  "				//if servlet container did not set content length' we were not flushing and we have non-binary content avoid chunked transfer by setting actual content-length (given no flush)                        " is 175.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The length of the statement  "				if (!isBinary && contentLength == 0 && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES == 0 && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS == 0 && transferredBytes > 0) { " is 196.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The length of the statement  "		if (p_Context.Response.IsClientConnected && (BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS > 0 || BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES > 0)) { " is 177.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The length of the statement  "		//do nothing. Mostly this occurs if the browser already closed connection with server or headers were already transferred  " is 121.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The length of the statement  "		RecordSysEvent ("Error during spool to client (browser may have navigated away): " + e.Message + " " + e.StackTrace' EventLogEntryType.Warning); " is 144.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,IISNativeHeaders,The length of the statement  "			//in cases where we are restricted from writing status codes we will do a server side redirect when we detect the right headers " is 127.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The length of the statement  "	//we use the Bad Gateway HTTP error code to indicate that we had a connection issue with Tomcat' in the future an error code could be passed in. " is 144.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The length of the statement  "		strPublicErr = "Generic Connector Communication Error: <hr>Please check and adjust your setup:<br>Ensure that Tomcat is running on given host and port.<br>If this is a timeout error consider adjusting IIS timeout by changing executionTimeout attribute in web.config (see manual)."; " is 281.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The length of the statement  "	//we will need to redirect to alternate URL if we have connect error URL setting defined -- we will add an errorcode and detail " is 127.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The length of the statement  "			//truncate error message to 1200 characters for now' this will grow a bit with encoding but we want to be below 2000 characters as many gateways restrict URL parameters " is 168.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The length of the statement  "			strPublicErr = HttpUtility.UrlEncode (HttpUtility.HtmlEncode (strPublicErr.Substring (0' Math.Min (strPublicErr.Length' 1199)))); " is 129.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The length of the statement  "			strFullUrl = BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL + strBindChar + "errorcode=" + strErrorCode + "&detail=" + strPublicErr; " is 135.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The length of the statement  "			strFullUrl = BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL + strBindChar + "errorcode=" + strErrorCode + "&detail="; " is 120.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The length of the statement  "				RecordSysEvent ("PrintError setting Statuscode: " + exp.Message + " Trace:" + exp.StackTrace' EventLogEntryType.Warning); " is 121.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,CheckExecution,The length of the statement  "						if (uriPath.Substring (0' BonCodeAJP13Settings.BONCODEAJP13_MANAGER_URLS [i].Length).ToLower () == BonCodeAJP13Settings.BONCODEAJP13_MANAGER_URLS [i]) { " is 152.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,CheckExecution,The length of the statement  "					retVal += "<pre>" + dispPaths.Length.ToString () + " virtual directories for site (" + siteInstanceId.ToString () + ") <br>"; " is 125.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,CheckExecution,The length of the statement  "				retVal += "<br>Windows Application Event log preparation succeeded. Please filter for 'BonCodeConnector' or EventID 417 events."; " is 129.
Long Statement,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,CheckExecution,The length of the statement  "				retVal += "<br>Cannot access Windows Application Event log. Please change the Application Pool Identity to LocalSystem and retry. Once successfull' you can revert the Application pool identity."; " is 195.
Complex Conditional,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The conditional expression  "!isBinary && contentLength == 0 && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES == 0 && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS == 0 && transferredBytes > 0"  is complex.
Empty Catch Block,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,IsLocalIP,The method has an empty catch block.
Empty Catch Block,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,GetRemoteAddr,The method has an empty catch block.
Empty Catch Block,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,RecordSysEvent,The method has an empty catch block.
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The following statement contains a magic number: try {  	if (executionFeedback.Length == 0) {  		//determine web doc root if needed                      		//set shared settings (global mutable variables). Not ideal solution. Will need to refactor later.  		if (BonCodeAJP13Settings.BONCODE_DOCROOT_OVERRIDE.Length > 0) {  			BonCodeAJP13Settings.BonCodeAjp13_DocRoot = BonCodeAJP13Settings.BONCODE_DOCROOT_OVERRIDE;  		} else {  			BonCodeAJP13Settings.BonCodeAjp13_DocRoot = System.Web.HttpContext.Current.Server.MapPath ("~");  		}  		//in some circumstances invalid path data can be supplied by client if so we will set the path to blank when exception occurs' e.g. http://project/group:master...master  		try {  			BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath = context.Request.PhysicalPath;  		} catch (Exception exp) {  			BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath = "";  			// remove recording for now since this can fill up the log unnecessarily  			// RecordSysEvent("Setting blank AJP physical path: " + exp.Message' EventLogEntryType.Warning);  		}  		//check whether we are resuable' we discard and re-establish connections if MAX_BONCODEAJP13_CONCURRENT_CONNECTIONS is set to zero  		if (BonCodeAJP13Settings.MAX_BONCODEAJP13_CONCURRENT_CONNECTIONS == 0) {  			p_isReusable = false;  		}  		//determine whether we are declaring ourself as part of a reusable pool. If not we need to also take steps to   		//kill connections if we are close to the max of pool we maintain a ten thread margin  		//this allows limited processing to continue even if we are close to maxed out on connections  		if (p_isReusable && BonCodeAJP13Settings.MAX_BONCODEAJP13_CONCURRENT_CONNECTIONS < (p_InstanceCount + 10)) {  			p_isReusable = false;  			//new connections will be dropped immediatly  		}  		;  		//assign reference to context to an instance handler  		p_Context = context;  		long streamLen = context.Request.InputStream.Length;  		//create TcpClient to pass to AJP13 processor' this will re-use connection until this instance is destroyed  		if (p_TcpClient == null) {  			try {  				p_TcpClient = new TcpClient (BonCodeAJP13Settings.BONCODEAJP13_SERVER' BonCodeAJP13Settings.BONCODEAJP13_PORT);  			} catch (Exception e) {  				//check whether we had issues connecting to tomcat  				blnProceed = false;  				string errMsg = "Error connecting to Apache Tomcat instance.<hr>Please check that a Tomcat server is running at given location and port.<br>Details:<br>" + e.Message + "<br><small><small><br>You can change this message by changing TomcatConnectErrorURL setting in setting file.</small></small>";  				//use the PrintEror function' it will check for redirect already  				RecordSysEvent ("Connection error 1: " + e.Message + " " + e.StackTrace' EventLogEntryType.Error);  				PrintError (context' errMsg' e.Message + " " + e.StackTrace);  			}  			//determine whether we will need to remove the connection later  			if (!p_isReusable) {  				p_FlagKillConnection = true;  			} else {  				p_FlagKillConnection = false;  			}  		} else {  			//check whether existing TCP/IP connection is still working. If tomcat is restarted the connection needs to be reset here as well  			if (!p_TcpClient.Connected) {  				KillConnection ();  				p_TcpClient = new TcpClient (BonCodeAJP13Settings.BONCODEAJP13_SERVER' BonCodeAJP13Settings.BONCODEAJP13_PORT);  			}  		}  		if (blnProceed) {  			//check for chunked transfer  			if (context.Request.ServerVariables ["HTTP_TRANSFER_ENCODING"] != null && context.Request.ServerVariables ["HTTP_TRANSFER_ENCODING"] == "chunked") {  				isChunkedTransfer = true;  			}  			//determine instance id  			/*                         UInt32 instanceId = 0;                                                try                         {                             //instanceId = Convert.ToInt16(context.Request.ServerVariables["INSTANCE_ID"]);                             instanceId = Convert.ToUInt32(System.Web.Hosting.HostingEnvironment.ApplicationHost.GetSiteID());                                                     }                         catch (Exception err) {                             instanceId = 0;                                                         RecordSysEvent("Cannot set instanceId setting to zero instead: " + err.Message' EventLogEntryType.Warning);                         } // empty catch instanceId of zero indicates error                         *///initialize AJP13 protocol connection  			string logFilePostFix = "_" + context.Request.ServerVariables ["INSTANCE_ID"] + "_" + context.Server.MachineName + "_";  			string clientIp = GetRemoteAddr (context.Request.ServerVariables);  			BonCodeAJP13ServerConnection sconn = new BonCodeAJP13ServerConnection (logFilePostFix' clientIp);  			sconn.FlushDelegateFunction = PrintFlush;  			//this function will do the transfer to browser if we use Flush detection' we pass as delegate  			sconn.FlushStatusFunction = IsFlushing;  			//will let the implementation know if flushing is still in progress  			sconn.SetTcpClient = p_TcpClient;  			sconn.ChunkedTransfer = isChunkedTransfer;  			//TODO: bind this into log file name    			//check for header data support and retrieve virtual directories if needed  			String virPaths = "";  			if (BonCodeAJP13Settings.BONCODEAJP13_HEADER_SUPPORT) {  				virPaths = GetVDirs ();  			}  			//check for Adobe support  			if (BonCodeAJP13Settings.BONCODEAJP13_ADOBE_SUPPORT) {  				sconn.ServerPathFunction = ServerPath;  			}  			//setup basic information (base ForwardRequest package)              			sourcePort = ((IPEndPoint)p_TcpClient.Client.LocalEndPoint).Port;  			BonCodeAJP13ForwardRequest FR = null;  			//if we are in SSL mode we need to check for client certificates  			if (context.Request.IsSecureConnection && context.Request.ClientCertificate.IsPresent) {  				FR = new BonCodeAJP13ForwardRequest (context.Request.ServerVariables' context.Request.PathInfo' sourcePort' virPaths' GetClientCert (context));  			} else {  				FR = new BonCodeAJP13ForwardRequest (context.Request.ServerVariables' context.Request.PathInfo' sourcePort' virPaths);  			}  			sconn.AddPacketToSendQueue (FR);  			//determine if extra ForwardRequests are needed.   			//We need to create a collection of Requests (for form data and file uploads etc.)   			//TODO: think about streaming support. The reading would be posted to a different thread that continues the reading process while  			//      the AJP handler continues writing the packets back to tomcat  			if (context.Request.ContentLength > 0 || isChunkedTransfer) {  				// need to create a collection of forward requests to package data in        				int maxPacketSize = BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH - 1;  				int numOfPackets = Convert.ToInt32 (Math.Ceiling (Convert.ToDouble (context.Request.ContentLength / Convert.ToDouble (maxPacketSize))));  				int iStart = 0;  				int iCount = 0;  				//for chunked transfer we use stream length to determine number of packets  				if (isChunkedTransfer) {  					numOfPackets = Convert.ToInt32 (Math.Ceiling (Convert.ToDouble (streamLen / Convert.ToDouble (maxPacketSize))));  					;  				}  				for (int i = 1; i <= numOfPackets; i++) {  					//we need to breakdown data into multiple FR packages to tomcat  					if (i * maxPacketSize <= streamLen) {  						//we are in the middle of transferring data grab next 8188 (if default packet size) bytes and create package  						iStart = (i - 1) * (maxPacketSize);  						iCount = Convert.ToInt32 (maxPacketSize);  					} else {  						//last user package  						iStart = (i - 1) * (maxPacketSize);  						iCount = Convert.ToInt32 (streamLen) - iStart;  					}  					//add package to collection  					byte[] streamInput = new byte[iCount];  					context.Request.InputStream.Read (streamInput' 0' iCount);  					//stream pointer moves with each read so we allways start at zero position  					sconn.AddPacketToSendQueue (new BonCodeAJP13ForwardRequest (streamInput));  				}  				//add an empty Forward Request packet as terminator to collection if multiple packets are used  				//sconn.AddPacketToSendQueue(new BonCodeAJP13ForwardRequest(new byte[] { }));  			}  			//run connection (send and receive cycle)  			try {  				sconn.BeginConnection ();  			} catch (Exception e) {  				//we have an error do the dump on screen since we are not logging but allso kill connection   				RecordSysEvent ("Connection error 2: " + e.Message + " " + e.StackTrace' EventLogEntryType.Error);  				PrintError (context' "."' e.Message + " " + e.StackTrace);  				KillConnection ();  				//remove TCP cache good after timeouts  			}  			//write the response to browser (if not already flushed)  			PrintFlush (sconn.ReceivedDataCollection);  			//kill connections if we are not reusing connections or other problems occurred  			if (p_FlagKillConnection) {  				KillConnection ();  			}  			//dispose the sconn explictily  			sconn = null;  		}  		;  		// proceed is true  		//dispose of context explicity  		p_Context = null;  	} else {  		//execution was denied by logic' only print message  		context.Response.Write (executionFeedback);  	}  } catch (InvalidOperationException e) {  	//TODO: check with Dominic whether the behavior is correct here  	//this is where we set the status code to 500  	//context.Response.StatusCode = 500;  	KillConnection ();  	//remove TCP connection and cache  	RecordSysEvent ("InvalidOperationsException: " + e.Message + " " + e.StackTrace' EventLogEntryType.Error);  	PrintError (context' "."' e.Message + " " + e.StackTrace);  } catch (HttpException e) {  	//if we have web exception display reasonsa maxRequest length exception' e.g. 3004 then display different message otherwise normal message  	KillConnection ();  	//remove TCP connection and cache  	string strErr = "IIS Web Processing Exception (" + e.GetHttpCode ().ToString () + "):<hr>" + e.Message + "<br><small>For maximum request size limit errors please have administrator adjust maxRequestLength and/or maxAllowedContentLength.</small><br>";  	RecordSysEvent ("HttpException: " + e.Message + " " + e.StackTrace' EventLogEntryType.Error);  	PrintError (context' strErr' e.StackTrace);  } catch (Exception e)//Global Exception catcher   {  	KillConnection ();  	//remove TCP connection and cache  	RecordSysEvent ("ProcessRequest: " + e.Message + " " + e.StackTrace' EventLogEntryType.Error);  	PrintError (context' "."' e.Message + " " + e.StackTrace);  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The following statement contains a magic number: if (executionFeedback.Length == 0) {  	//determine web doc root if needed                      	//set shared settings (global mutable variables). Not ideal solution. Will need to refactor later.  	if (BonCodeAJP13Settings.BONCODE_DOCROOT_OVERRIDE.Length > 0) {  		BonCodeAJP13Settings.BonCodeAjp13_DocRoot = BonCodeAJP13Settings.BONCODE_DOCROOT_OVERRIDE;  	} else {  		BonCodeAJP13Settings.BonCodeAjp13_DocRoot = System.Web.HttpContext.Current.Server.MapPath ("~");  	}  	//in some circumstances invalid path data can be supplied by client if so we will set the path to blank when exception occurs' e.g. http://project/group:master...master  	try {  		BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath = context.Request.PhysicalPath;  	} catch (Exception exp) {  		BonCodeAJP13Settings.BonCodeAjp13_PhysicalFilePath = "";  		// remove recording for now since this can fill up the log unnecessarily  		// RecordSysEvent("Setting blank AJP physical path: " + exp.Message' EventLogEntryType.Warning);  	}  	//check whether we are resuable' we discard and re-establish connections if MAX_BONCODEAJP13_CONCURRENT_CONNECTIONS is set to zero  	if (BonCodeAJP13Settings.MAX_BONCODEAJP13_CONCURRENT_CONNECTIONS == 0) {  		p_isReusable = false;  	}  	//determine whether we are declaring ourself as part of a reusable pool. If not we need to also take steps to   	//kill connections if we are close to the max of pool we maintain a ten thread margin  	//this allows limited processing to continue even if we are close to maxed out on connections  	if (p_isReusable && BonCodeAJP13Settings.MAX_BONCODEAJP13_CONCURRENT_CONNECTIONS < (p_InstanceCount + 10)) {  		p_isReusable = false;  		//new connections will be dropped immediatly  	}  	;  	//assign reference to context to an instance handler  	p_Context = context;  	long streamLen = context.Request.InputStream.Length;  	//create TcpClient to pass to AJP13 processor' this will re-use connection until this instance is destroyed  	if (p_TcpClient == null) {  		try {  			p_TcpClient = new TcpClient (BonCodeAJP13Settings.BONCODEAJP13_SERVER' BonCodeAJP13Settings.BONCODEAJP13_PORT);  		} catch (Exception e) {  			//check whether we had issues connecting to tomcat  			blnProceed = false;  			string errMsg = "Error connecting to Apache Tomcat instance.<hr>Please check that a Tomcat server is running at given location and port.<br>Details:<br>" + e.Message + "<br><small><small><br>You can change this message by changing TomcatConnectErrorURL setting in setting file.</small></small>";  			//use the PrintEror function' it will check for redirect already  			RecordSysEvent ("Connection error 1: " + e.Message + " " + e.StackTrace' EventLogEntryType.Error);  			PrintError (context' errMsg' e.Message + " " + e.StackTrace);  		}  		//determine whether we will need to remove the connection later  		if (!p_isReusable) {  			p_FlagKillConnection = true;  		} else {  			p_FlagKillConnection = false;  		}  	} else {  		//check whether existing TCP/IP connection is still working. If tomcat is restarted the connection needs to be reset here as well  		if (!p_TcpClient.Connected) {  			KillConnection ();  			p_TcpClient = new TcpClient (BonCodeAJP13Settings.BONCODEAJP13_SERVER' BonCodeAJP13Settings.BONCODEAJP13_PORT);  		}  	}  	if (blnProceed) {  		//check for chunked transfer  		if (context.Request.ServerVariables ["HTTP_TRANSFER_ENCODING"] != null && context.Request.ServerVariables ["HTTP_TRANSFER_ENCODING"] == "chunked") {  			isChunkedTransfer = true;  		}  		//determine instance id  		/*                         UInt32 instanceId = 0;                                                try                         {                             //instanceId = Convert.ToInt16(context.Request.ServerVariables["INSTANCE_ID"]);                             instanceId = Convert.ToUInt32(System.Web.Hosting.HostingEnvironment.ApplicationHost.GetSiteID());                                                     }                         catch (Exception err) {                             instanceId = 0;                                                         RecordSysEvent("Cannot set instanceId setting to zero instead: " + err.Message' EventLogEntryType.Warning);                         } // empty catch instanceId of zero indicates error                         *///initialize AJP13 protocol connection  		string logFilePostFix = "_" + context.Request.ServerVariables ["INSTANCE_ID"] + "_" + context.Server.MachineName + "_";  		string clientIp = GetRemoteAddr (context.Request.ServerVariables);  		BonCodeAJP13ServerConnection sconn = new BonCodeAJP13ServerConnection (logFilePostFix' clientIp);  		sconn.FlushDelegateFunction = PrintFlush;  		//this function will do the transfer to browser if we use Flush detection' we pass as delegate  		sconn.FlushStatusFunction = IsFlushing;  		//will let the implementation know if flushing is still in progress  		sconn.SetTcpClient = p_TcpClient;  		sconn.ChunkedTransfer = isChunkedTransfer;  		//TODO: bind this into log file name    		//check for header data support and retrieve virtual directories if needed  		String virPaths = "";  		if (BonCodeAJP13Settings.BONCODEAJP13_HEADER_SUPPORT) {  			virPaths = GetVDirs ();  		}  		//check for Adobe support  		if (BonCodeAJP13Settings.BONCODEAJP13_ADOBE_SUPPORT) {  			sconn.ServerPathFunction = ServerPath;  		}  		//setup basic information (base ForwardRequest package)              		sourcePort = ((IPEndPoint)p_TcpClient.Client.LocalEndPoint).Port;  		BonCodeAJP13ForwardRequest FR = null;  		//if we are in SSL mode we need to check for client certificates  		if (context.Request.IsSecureConnection && context.Request.ClientCertificate.IsPresent) {  			FR = new BonCodeAJP13ForwardRequest (context.Request.ServerVariables' context.Request.PathInfo' sourcePort' virPaths' GetClientCert (context));  		} else {  			FR = new BonCodeAJP13ForwardRequest (context.Request.ServerVariables' context.Request.PathInfo' sourcePort' virPaths);  		}  		sconn.AddPacketToSendQueue (FR);  		//determine if extra ForwardRequests are needed.   		//We need to create a collection of Requests (for form data and file uploads etc.)   		//TODO: think about streaming support. The reading would be posted to a different thread that continues the reading process while  		//      the AJP handler continues writing the packets back to tomcat  		if (context.Request.ContentLength > 0 || isChunkedTransfer) {  			// need to create a collection of forward requests to package data in        			int maxPacketSize = BonCodeAJP13Settings.MAX_BONCODEAJP13_USERDATA_LENGTH - 1;  			int numOfPackets = Convert.ToInt32 (Math.Ceiling (Convert.ToDouble (context.Request.ContentLength / Convert.ToDouble (maxPacketSize))));  			int iStart = 0;  			int iCount = 0;  			//for chunked transfer we use stream length to determine number of packets  			if (isChunkedTransfer) {  				numOfPackets = Convert.ToInt32 (Math.Ceiling (Convert.ToDouble (streamLen / Convert.ToDouble (maxPacketSize))));  				;  			}  			for (int i = 1; i <= numOfPackets; i++) {  				//we need to breakdown data into multiple FR packages to tomcat  				if (i * maxPacketSize <= streamLen) {  					//we are in the middle of transferring data grab next 8188 (if default packet size) bytes and create package  					iStart = (i - 1) * (maxPacketSize);  					iCount = Convert.ToInt32 (maxPacketSize);  				} else {  					//last user package  					iStart = (i - 1) * (maxPacketSize);  					iCount = Convert.ToInt32 (streamLen) - iStart;  				}  				//add package to collection  				byte[] streamInput = new byte[iCount];  				context.Request.InputStream.Read (streamInput' 0' iCount);  				//stream pointer moves with each read so we allways start at zero position  				sconn.AddPacketToSendQueue (new BonCodeAJP13ForwardRequest (streamInput));  			}  			//add an empty Forward Request packet as terminator to collection if multiple packets are used  			//sconn.AddPacketToSendQueue(new BonCodeAJP13ForwardRequest(new byte[] { }));  		}  		//run connection (send and receive cycle)  		try {  			sconn.BeginConnection ();  		} catch (Exception e) {  			//we have an error do the dump on screen since we are not logging but allso kill connection   			RecordSysEvent ("Connection error 2: " + e.Message + " " + e.StackTrace' EventLogEntryType.Error);  			PrintError (context' "."' e.Message + " " + e.StackTrace);  			KillConnection ();  			//remove TCP cache good after timeouts  		}  		//write the response to browser (if not already flushed)  		PrintFlush (sconn.ReceivedDataCollection);  		//kill connections if we are not reusing connections or other problems occurred  		if (p_FlagKillConnection) {  			KillConnection ();  		}  		//dispose the sconn explictily  		sconn = null;  	}  	;  	// proceed is true  	//dispose of context explicity  	p_Context = null;  } else {  	//execution was denied by logic' only print message  	context.Response.Write (executionFeedback);  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,ProcessRequest,The following statement contains a magic number: if (p_isReusable && BonCodeAJP13Settings.MAX_BONCODEAJP13_CONCURRENT_CONNECTIONS < (p_InstanceCount + 10)) {  	p_isReusable = false;  	//new connections will be dropped immediatly  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The following statement contains a magic number: foreach (TomcatReturn flushPacket in flushCollection.ToArray ()) {  	try {  		//check by packet type and do different processing before calling flush                  		if (flushPacket is TomcatSendHeaders) {  			TomcatSendHeaders tcshPackage = (TomcatSendHeaders)flushPacket;  			//get Headers  			NameValueCollection tomcatHeaders = tcshPackage.GetHeaders ();  			try {  				//iterate through headers and set  				for (int i = 0; i < tomcatHeaders.AllKeys.Length; i++) {  					keyName = tomcatHeaders.AllKeys [i];  					keyValue = tomcatHeaders [keyName];  					//check for repeated headers of the same type they are seperated by pipe+comma combination  					string[] sHeaders = keyValue.Split (new string[] {  						"|'"  					}' StringSplitOptions.None);  					string tempValue = "";  					if (sHeaders.Length > 1) {  						//check for multiple headers of same type returned' e.g. cookies                                  						for (int i2 = 0; i2 < sHeaders.Length; i2++) {  							if (i2 == sHeaders.Length - 1) {  								tempValue = sHeaders [i2].Substring (0' sHeaders [i2].Length - 1);  								//last array element  							} else {  								tempValue = sHeaders [i2];  								//regular array element  							}  							p_Context.Response.AddHeader (keyName' tempValue);  						}  					} else {  						//single header remove pipe character at the end     						tempValue = keyValue.Substring (0' keyValue.Length - 1);  						p_Context.Response.AddHeader (keyName' tempValue);  					}  					//check for binary or text disposition  					if (!isBinary && (keyName == "Content-Type" || keyName == "Content-Encoding")) {  						//set encoding seperatly if needed  						if (keyName == "Content-Encoding" && (tempValue.Contains ("gzip") || tempValue.Contains ("deflate"))) {  							isBinary = true;  						} else {  							isBinary = TestBinary (keyValue);  						}  					}  					//check for known content length  					if (keyName == "Content-Length") {  						try {  							contentLength = System.Convert.ToInt64 (tempValue);  						} catch (Exception e) {  							contentLength = 0;  							RecordSysEvent ("Setting content-length to zero: " + e.Message' EventLogEntryType.Warning);  						}  						;  					}  					//check whether we can represent a given header in native IIS Response context (currently only used for server side redirects)  					IISNativeHeaders (keyName' tempValue);  				}  				//end for  				//set response status code  				if (BonCodeAJP13Settings.BONCODEAJP13_ENABLE_HTTPSTATUSCODES) {  					int respStatus = tcshPackage.GetStatus ();  					//is the status to be returned is an error status >=400 then we need set the response flag and kill conn flags  					//we will mark this as to be killed if status indicates error to ensure that stream cache is removed and cannot be reused by other connections  					if (respStatus >= 400) {  						if (BonCodeAJP13Settings.BONCODEAJP13_SKIP_IISCUSTOMERRORS) {  							p_Context.Response.TrySkipIisCustomErrors = true;  						}  						p_FlagKillConnection = true;  						//we are only marking here to ensure that we finish writing as much as possible to stream before closing  					}  					//set the actual Status code on the response  					p_Context.Response.StatusCode = respStatus;  				}  			} catch (Exception e) {  				RecordSysEvent ("Error writing headers: " + e.Message' EventLogEntryType.Warning);  			}  		} else if (flushPacket is TomcatEndResponse) {  			//if this is the last package and we know the content length we need to write empty strings  			//this is a fix if content-length is misrepresented by tomcat  			if (contentLength > 0 && transferredBytes < contentLength) {  				string fillEmpty = new string (' '' System.Convert.ToInt32 (contentLength - transferredBytes));  				p_Context.Response.Write (fillEmpty);  			}  			//if servlet container did not set content length' we were not flushing and we have non-binary content avoid chunked transfer by setting actual content-length (given no flush)                         			if (!isBinary && contentLength == 0 && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES == 0 && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS == 0 && transferredBytes > 0) {  				try {  					p_Context.Response.AddHeader ("Content-Length"' transferredBytes.ToString ());  				} catch (Exception e) {  					RecordSysEvent ("Error missing final content-length: " + e.Message' EventLogEntryType.Error);  				}  			}  		} else if (flushPacket is TomcatPhysicalPathRequest) {  			//do nothing here Adobe introduced this package' other parts of code respond to this packet when it is detected  		} else if (flushPacket is TomcatSendBodyChunk) {  			transferredBytes = transferredBytes + flushPacket.Length;  			if (flushPacket.Length > 0)  				p_Context.Response.BinaryWrite (flushPacket.GetUserDataBytes ());  		}  	} catch (Exception e) {  		//display error  		RecordSysEvent ("Error flushing data: " + e.Message + " " + e.StackTrace' EventLogEntryType.Error);  		PrintError (p_Context' "."' e.Message + " " + e.StackTrace);  	}  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The following statement contains a magic number: try {  	//check by packet type and do different processing before calling flush                  	if (flushPacket is TomcatSendHeaders) {  		TomcatSendHeaders tcshPackage = (TomcatSendHeaders)flushPacket;  		//get Headers  		NameValueCollection tomcatHeaders = tcshPackage.GetHeaders ();  		try {  			//iterate through headers and set  			for (int i = 0; i < tomcatHeaders.AllKeys.Length; i++) {  				keyName = tomcatHeaders.AllKeys [i];  				keyValue = tomcatHeaders [keyName];  				//check for repeated headers of the same type they are seperated by pipe+comma combination  				string[] sHeaders = keyValue.Split (new string[] {  					"|'"  				}' StringSplitOptions.None);  				string tempValue = "";  				if (sHeaders.Length > 1) {  					//check for multiple headers of same type returned' e.g. cookies                                  					for (int i2 = 0; i2 < sHeaders.Length; i2++) {  						if (i2 == sHeaders.Length - 1) {  							tempValue = sHeaders [i2].Substring (0' sHeaders [i2].Length - 1);  							//last array element  						} else {  							tempValue = sHeaders [i2];  							//regular array element  						}  						p_Context.Response.AddHeader (keyName' tempValue);  					}  				} else {  					//single header remove pipe character at the end     					tempValue = keyValue.Substring (0' keyValue.Length - 1);  					p_Context.Response.AddHeader (keyName' tempValue);  				}  				//check for binary or text disposition  				if (!isBinary && (keyName == "Content-Type" || keyName == "Content-Encoding")) {  					//set encoding seperatly if needed  					if (keyName == "Content-Encoding" && (tempValue.Contains ("gzip") || tempValue.Contains ("deflate"))) {  						isBinary = true;  					} else {  						isBinary = TestBinary (keyValue);  					}  				}  				//check for known content length  				if (keyName == "Content-Length") {  					try {  						contentLength = System.Convert.ToInt64 (tempValue);  					} catch (Exception e) {  						contentLength = 0;  						RecordSysEvent ("Setting content-length to zero: " + e.Message' EventLogEntryType.Warning);  					}  					;  				}  				//check whether we can represent a given header in native IIS Response context (currently only used for server side redirects)  				IISNativeHeaders (keyName' tempValue);  			}  			//end for  			//set response status code  			if (BonCodeAJP13Settings.BONCODEAJP13_ENABLE_HTTPSTATUSCODES) {  				int respStatus = tcshPackage.GetStatus ();  				//is the status to be returned is an error status >=400 then we need set the response flag and kill conn flags  				//we will mark this as to be killed if status indicates error to ensure that stream cache is removed and cannot be reused by other connections  				if (respStatus >= 400) {  					if (BonCodeAJP13Settings.BONCODEAJP13_SKIP_IISCUSTOMERRORS) {  						p_Context.Response.TrySkipIisCustomErrors = true;  					}  					p_FlagKillConnection = true;  					//we are only marking here to ensure that we finish writing as much as possible to stream before closing  				}  				//set the actual Status code on the response  				p_Context.Response.StatusCode = respStatus;  			}  		} catch (Exception e) {  			RecordSysEvent ("Error writing headers: " + e.Message' EventLogEntryType.Warning);  		}  	} else if (flushPacket is TomcatEndResponse) {  		//if this is the last package and we know the content length we need to write empty strings  		//this is a fix if content-length is misrepresented by tomcat  		if (contentLength > 0 && transferredBytes < contentLength) {  			string fillEmpty = new string (' '' System.Convert.ToInt32 (contentLength - transferredBytes));  			p_Context.Response.Write (fillEmpty);  		}  		//if servlet container did not set content length' we were not flushing and we have non-binary content avoid chunked transfer by setting actual content-length (given no flush)                         		if (!isBinary && contentLength == 0 && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES == 0 && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS == 0 && transferredBytes > 0) {  			try {  				p_Context.Response.AddHeader ("Content-Length"' transferredBytes.ToString ());  			} catch (Exception e) {  				RecordSysEvent ("Error missing final content-length: " + e.Message' EventLogEntryType.Error);  			}  		}  	} else if (flushPacket is TomcatPhysicalPathRequest) {  		//do nothing here Adobe introduced this package' other parts of code respond to this packet when it is detected  	} else if (flushPacket is TomcatSendBodyChunk) {  		transferredBytes = transferredBytes + flushPacket.Length;  		if (flushPacket.Length > 0)  			p_Context.Response.BinaryWrite (flushPacket.GetUserDataBytes ());  	}  } catch (Exception e) {  	//display error  	RecordSysEvent ("Error flushing data: " + e.Message + " " + e.StackTrace' EventLogEntryType.Error);  	PrintError (p_Context' "."' e.Message + " " + e.StackTrace);  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The following statement contains a magic number: if (flushPacket is TomcatSendHeaders) {  	TomcatSendHeaders tcshPackage = (TomcatSendHeaders)flushPacket;  	//get Headers  	NameValueCollection tomcatHeaders = tcshPackage.GetHeaders ();  	try {  		//iterate through headers and set  		for (int i = 0; i < tomcatHeaders.AllKeys.Length; i++) {  			keyName = tomcatHeaders.AllKeys [i];  			keyValue = tomcatHeaders [keyName];  			//check for repeated headers of the same type they are seperated by pipe+comma combination  			string[] sHeaders = keyValue.Split (new string[] {  				"|'"  			}' StringSplitOptions.None);  			string tempValue = "";  			if (sHeaders.Length > 1) {  				//check for multiple headers of same type returned' e.g. cookies                                  				for (int i2 = 0; i2 < sHeaders.Length; i2++) {  					if (i2 == sHeaders.Length - 1) {  						tempValue = sHeaders [i2].Substring (0' sHeaders [i2].Length - 1);  						//last array element  					} else {  						tempValue = sHeaders [i2];  						//regular array element  					}  					p_Context.Response.AddHeader (keyName' tempValue);  				}  			} else {  				//single header remove pipe character at the end     				tempValue = keyValue.Substring (0' keyValue.Length - 1);  				p_Context.Response.AddHeader (keyName' tempValue);  			}  			//check for binary or text disposition  			if (!isBinary && (keyName == "Content-Type" || keyName == "Content-Encoding")) {  				//set encoding seperatly if needed  				if (keyName == "Content-Encoding" && (tempValue.Contains ("gzip") || tempValue.Contains ("deflate"))) {  					isBinary = true;  				} else {  					isBinary = TestBinary (keyValue);  				}  			}  			//check for known content length  			if (keyName == "Content-Length") {  				try {  					contentLength = System.Convert.ToInt64 (tempValue);  				} catch (Exception e) {  					contentLength = 0;  					RecordSysEvent ("Setting content-length to zero: " + e.Message' EventLogEntryType.Warning);  				}  				;  			}  			//check whether we can represent a given header in native IIS Response context (currently only used for server side redirects)  			IISNativeHeaders (keyName' tempValue);  		}  		//end for  		//set response status code  		if (BonCodeAJP13Settings.BONCODEAJP13_ENABLE_HTTPSTATUSCODES) {  			int respStatus = tcshPackage.GetStatus ();  			//is the status to be returned is an error status >=400 then we need set the response flag and kill conn flags  			//we will mark this as to be killed if status indicates error to ensure that stream cache is removed and cannot be reused by other connections  			if (respStatus >= 400) {  				if (BonCodeAJP13Settings.BONCODEAJP13_SKIP_IISCUSTOMERRORS) {  					p_Context.Response.TrySkipIisCustomErrors = true;  				}  				p_FlagKillConnection = true;  				//we are only marking here to ensure that we finish writing as much as possible to stream before closing  			}  			//set the actual Status code on the response  			p_Context.Response.StatusCode = respStatus;  		}  	} catch (Exception e) {  		RecordSysEvent ("Error writing headers: " + e.Message' EventLogEntryType.Warning);  	}  } else if (flushPacket is TomcatEndResponse) {  	//if this is the last package and we know the content length we need to write empty strings  	//this is a fix if content-length is misrepresented by tomcat  	if (contentLength > 0 && transferredBytes < contentLength) {  		string fillEmpty = new string (' '' System.Convert.ToInt32 (contentLength - transferredBytes));  		p_Context.Response.Write (fillEmpty);  	}  	//if servlet container did not set content length' we were not flushing and we have non-binary content avoid chunked transfer by setting actual content-length (given no flush)                         	if (!isBinary && contentLength == 0 && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_BYTES == 0 && BonCodeAJP13Settings.BONCODEAJP13_AUTOFLUSHDETECTION_TICKS == 0 && transferredBytes > 0) {  		try {  			p_Context.Response.AddHeader ("Content-Length"' transferredBytes.ToString ());  		} catch (Exception e) {  			RecordSysEvent ("Error missing final content-length: " + e.Message' EventLogEntryType.Error);  		}  	}  } else if (flushPacket is TomcatPhysicalPathRequest) {  	//do nothing here Adobe introduced this package' other parts of code respond to this packet when it is detected  } else if (flushPacket is TomcatSendBodyChunk) {  	transferredBytes = transferredBytes + flushPacket.Length;  	if (flushPacket.Length > 0)  		p_Context.Response.BinaryWrite (flushPacket.GetUserDataBytes ());  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The following statement contains a magic number: try {  	//iterate through headers and set  	for (int i = 0; i < tomcatHeaders.AllKeys.Length; i++) {  		keyName = tomcatHeaders.AllKeys [i];  		keyValue = tomcatHeaders [keyName];  		//check for repeated headers of the same type they are seperated by pipe+comma combination  		string[] sHeaders = keyValue.Split (new string[] {  			"|'"  		}' StringSplitOptions.None);  		string tempValue = "";  		if (sHeaders.Length > 1) {  			//check for multiple headers of same type returned' e.g. cookies                                  			for (int i2 = 0; i2 < sHeaders.Length; i2++) {  				if (i2 == sHeaders.Length - 1) {  					tempValue = sHeaders [i2].Substring (0' sHeaders [i2].Length - 1);  					//last array element  				} else {  					tempValue = sHeaders [i2];  					//regular array element  				}  				p_Context.Response.AddHeader (keyName' tempValue);  			}  		} else {  			//single header remove pipe character at the end     			tempValue = keyValue.Substring (0' keyValue.Length - 1);  			p_Context.Response.AddHeader (keyName' tempValue);  		}  		//check for binary or text disposition  		if (!isBinary && (keyName == "Content-Type" || keyName == "Content-Encoding")) {  			//set encoding seperatly if needed  			if (keyName == "Content-Encoding" && (tempValue.Contains ("gzip") || tempValue.Contains ("deflate"))) {  				isBinary = true;  			} else {  				isBinary = TestBinary (keyValue);  			}  		}  		//check for known content length  		if (keyName == "Content-Length") {  			try {  				contentLength = System.Convert.ToInt64 (tempValue);  			} catch (Exception e) {  				contentLength = 0;  				RecordSysEvent ("Setting content-length to zero: " + e.Message' EventLogEntryType.Warning);  			}  			;  		}  		//check whether we can represent a given header in native IIS Response context (currently only used for server side redirects)  		IISNativeHeaders (keyName' tempValue);  	}  	//end for  	//set response status code  	if (BonCodeAJP13Settings.BONCODEAJP13_ENABLE_HTTPSTATUSCODES) {  		int respStatus = tcshPackage.GetStatus ();  		//is the status to be returned is an error status >=400 then we need set the response flag and kill conn flags  		//we will mark this as to be killed if status indicates error to ensure that stream cache is removed and cannot be reused by other connections  		if (respStatus >= 400) {  			if (BonCodeAJP13Settings.BONCODEAJP13_SKIP_IISCUSTOMERRORS) {  				p_Context.Response.TrySkipIisCustomErrors = true;  			}  			p_FlagKillConnection = true;  			//we are only marking here to ensure that we finish writing as much as possible to stream before closing  		}  		//set the actual Status code on the response  		p_Context.Response.StatusCode = respStatus;  	}  } catch (Exception e) {  	RecordSysEvent ("Error writing headers: " + e.Message' EventLogEntryType.Warning);  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The following statement contains a magic number: if (BonCodeAJP13Settings.BONCODEAJP13_ENABLE_HTTPSTATUSCODES) {  	int respStatus = tcshPackage.GetStatus ();  	//is the status to be returned is an error status >=400 then we need set the response flag and kill conn flags  	//we will mark this as to be killed if status indicates error to ensure that stream cache is removed and cannot be reused by other connections  	if (respStatus >= 400) {  		if (BonCodeAJP13Settings.BONCODEAJP13_SKIP_IISCUSTOMERRORS) {  			p_Context.Response.TrySkipIisCustomErrors = true;  		}  		p_FlagKillConnection = true;  		//we are only marking here to ensure that we finish writing as much as possible to stream before closing  	}  	//set the actual Status code on the response  	p_Context.Response.StatusCode = respStatus;  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintFlush,The following statement contains a magic number: if (respStatus >= 400) {  	if (BonCodeAJP13Settings.BONCODEAJP13_SKIP_IISCUSTOMERRORS) {  		p_Context.Response.TrySkipIisCustomErrors = true;  	}  	p_FlagKillConnection = true;  	//we are only marking here to ensure that we finish writing as much as possible to stream before closing  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The following statement contains a magic number: if (BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL.Length > 5) {  	string strFullUrl = "";  	//does the connect error URL contain URL parameters already change the bind character  	if (BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL.IndexOf ('?') >= 0) {  		strBindChar = "&";  	}  	//create composite error data for URL                  	if (IsLocalIP (GetKeyValue (context.Request.ServerVariables' "REMOTE_ADDR"))) {  		strPublicErr = strPublicErr + "-" + strLocalErr;  		//truncate error message to 1200 characters for now' this will grow a bit with encoding but we want to be below 2000 characters as many gateways restrict URL parameters  		//strPublicErr = HttpUtility.UrlPathEncode(strPublicErr.Substring(0' Math.Min(strPublicErr.Length' 1199)));  		strPublicErr = HttpUtility.UrlEncode (HttpUtility.HtmlEncode (strPublicErr.Substring (0' Math.Min (strPublicErr.Length' 1199))));  		//create fully formed URL  		strFullUrl = BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL + strBindChar + "errorcode=" + strErrorCode + "&detail=" + strPublicErr;  	} else {  		// non local IP use redirect without detail message  		strFullUrl = BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL + strBindChar + "errorcode=" + strErrorCode + "&detail=";  	}  	//redirect to fully formed URL  	context.Response.Redirect (strFullUrl);  } else {  	//we have no redirect setting defined --> request we will output error code 502 to client  	try {  		context.Response.TrySkipIisCustomErrors = true;  		context.Response.Write (strPublicErr);  		if (IsLocalIP (GetKeyValue (context.Request.ServerVariables' "REMOTE_ADDR"))) {  			context.Response.Write ("<br><pre>" + strLocalErr + "</pre>");  		}  		//we might get an error during HTTP status code change when flushing is enabled or headers have already been sent  		try {  			context.Response.StatusCode = 502;  		} catch (Exception exp) {  			RecordSysEvent ("PrintError setting Statuscode: " + exp.Message + " Trace:" + exp.StackTrace' EventLogEntryType.Warning);  		}  		;  	} catch (Exception e) {  		RecordSysEvent ("PrintError failed: " + e.Message + " Trace:" + e.StackTrace' EventLogEntryType.Error);  	}  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The following statement contains a magic number: if (BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL.Length > 5) {  	string strFullUrl = "";  	//does the connect error URL contain URL parameters already change the bind character  	if (BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL.IndexOf ('?') >= 0) {  		strBindChar = "&";  	}  	//create composite error data for URL                  	if (IsLocalIP (GetKeyValue (context.Request.ServerVariables' "REMOTE_ADDR"))) {  		strPublicErr = strPublicErr + "-" + strLocalErr;  		//truncate error message to 1200 characters for now' this will grow a bit with encoding but we want to be below 2000 characters as many gateways restrict URL parameters  		//strPublicErr = HttpUtility.UrlPathEncode(strPublicErr.Substring(0' Math.Min(strPublicErr.Length' 1199)));  		strPublicErr = HttpUtility.UrlEncode (HttpUtility.HtmlEncode (strPublicErr.Substring (0' Math.Min (strPublicErr.Length' 1199))));  		//create fully formed URL  		strFullUrl = BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL + strBindChar + "errorcode=" + strErrorCode + "&detail=" + strPublicErr;  	} else {  		// non local IP use redirect without detail message  		strFullUrl = BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL + strBindChar + "errorcode=" + strErrorCode + "&detail=";  	}  	//redirect to fully formed URL  	context.Response.Redirect (strFullUrl);  } else {  	//we have no redirect setting defined --> request we will output error code 502 to client  	try {  		context.Response.TrySkipIisCustomErrors = true;  		context.Response.Write (strPublicErr);  		if (IsLocalIP (GetKeyValue (context.Request.ServerVariables' "REMOTE_ADDR"))) {  			context.Response.Write ("<br><pre>" + strLocalErr + "</pre>");  		}  		//we might get an error during HTTP status code change when flushing is enabled or headers have already been sent  		try {  			context.Response.StatusCode = 502;  		} catch (Exception exp) {  			RecordSysEvent ("PrintError setting Statuscode: " + exp.Message + " Trace:" + exp.StackTrace' EventLogEntryType.Warning);  		}  		;  	} catch (Exception e) {  		RecordSysEvent ("PrintError failed: " + e.Message + " Trace:" + e.StackTrace' EventLogEntryType.Error);  	}  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The following statement contains a magic number: if (BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL.Length > 5) {  	string strFullUrl = "";  	//does the connect error URL contain URL parameters already change the bind character  	if (BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL.IndexOf ('?') >= 0) {  		strBindChar = "&";  	}  	//create composite error data for URL                  	if (IsLocalIP (GetKeyValue (context.Request.ServerVariables' "REMOTE_ADDR"))) {  		strPublicErr = strPublicErr + "-" + strLocalErr;  		//truncate error message to 1200 characters for now' this will grow a bit with encoding but we want to be below 2000 characters as many gateways restrict URL parameters  		//strPublicErr = HttpUtility.UrlPathEncode(strPublicErr.Substring(0' Math.Min(strPublicErr.Length' 1199)));  		strPublicErr = HttpUtility.UrlEncode (HttpUtility.HtmlEncode (strPublicErr.Substring (0' Math.Min (strPublicErr.Length' 1199))));  		//create fully formed URL  		strFullUrl = BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL + strBindChar + "errorcode=" + strErrorCode + "&detail=" + strPublicErr;  	} else {  		// non local IP use redirect without detail message  		strFullUrl = BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL + strBindChar + "errorcode=" + strErrorCode + "&detail=";  	}  	//redirect to fully formed URL  	context.Response.Redirect (strFullUrl);  } else {  	//we have no redirect setting defined --> request we will output error code 502 to client  	try {  		context.Response.TrySkipIisCustomErrors = true;  		context.Response.Write (strPublicErr);  		if (IsLocalIP (GetKeyValue (context.Request.ServerVariables' "REMOTE_ADDR"))) {  			context.Response.Write ("<br><pre>" + strLocalErr + "</pre>");  		}  		//we might get an error during HTTP status code change when flushing is enabled or headers have already been sent  		try {  			context.Response.StatusCode = 502;  		} catch (Exception exp) {  			RecordSysEvent ("PrintError setting Statuscode: " + exp.Message + " Trace:" + exp.StackTrace' EventLogEntryType.Warning);  		}  		;  	} catch (Exception e) {  		RecordSysEvent ("PrintError failed: " + e.Message + " Trace:" + e.StackTrace' EventLogEntryType.Error);  	}  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The following statement contains a magic number: if (IsLocalIP (GetKeyValue (context.Request.ServerVariables' "REMOTE_ADDR"))) {  	strPublicErr = strPublicErr + "-" + strLocalErr;  	//truncate error message to 1200 characters for now' this will grow a bit with encoding but we want to be below 2000 characters as many gateways restrict URL parameters  	//strPublicErr = HttpUtility.UrlPathEncode(strPublicErr.Substring(0' Math.Min(strPublicErr.Length' 1199)));  	strPublicErr = HttpUtility.UrlEncode (HttpUtility.HtmlEncode (strPublicErr.Substring (0' Math.Min (strPublicErr.Length' 1199))));  	//create fully formed URL  	strFullUrl = BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL + strBindChar + "errorcode=" + strErrorCode + "&detail=" + strPublicErr;  } else {  	// non local IP use redirect without detail message  	strFullUrl = BonCodeAJP13Settings.BONCODEAJP13_TOMCAT_DOWN_URL + strBindChar + "errorcode=" + strErrorCode + "&detail=";  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The following statement contains a magic number: strPublicErr = HttpUtility.UrlEncode (HttpUtility.HtmlEncode (strPublicErr.Substring (0' Math.Min (strPublicErr.Length' 1199))));  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The following statement contains a magic number: try {  	context.Response.TrySkipIisCustomErrors = true;  	context.Response.Write (strPublicErr);  	if (IsLocalIP (GetKeyValue (context.Request.ServerVariables' "REMOTE_ADDR"))) {  		context.Response.Write ("<br><pre>" + strLocalErr + "</pre>");  	}  	//we might get an error during HTTP status code change when flushing is enabled or headers have already been sent  	try {  		context.Response.StatusCode = 502;  	} catch (Exception exp) {  		RecordSysEvent ("PrintError setting Statuscode: " + exp.Message + " Trace:" + exp.StackTrace' EventLogEntryType.Warning);  	}  	;  } catch (Exception e) {  	RecordSysEvent ("PrintError failed: " + e.Message + " Trace:" + e.StackTrace' EventLogEntryType.Error);  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The following statement contains a magic number: try {  	context.Response.StatusCode = 502;  } catch (Exception exp) {  	RecordSysEvent ("PrintError setting Statuscode: " + exp.Message + " Trace:" + exp.StackTrace' EventLogEntryType.Warning);  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,PrintError,The following statement contains a magic number: context.Response.StatusCode = 502;  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,RecordSysEvent,The following statement contains a magic number: try {  	if (EventLog.SourceExists (sSource)) {  		//record in event log          		EventLog.WriteEntry (sSource' sEvent' eType' 417);  	}  } catch {  	//do nothing for now  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,RecordSysEvent,The following statement contains a magic number: if (EventLog.SourceExists (sSource)) {  	//record in event log          	EventLog.WriteEntry (sSource' sEvent' eType' 417);  }  
Magic Number,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,RecordSysEvent,The following statement contains a magic number: EventLog.WriteEntry (sSource' sEvent' eType' 417);  
Missing Default,BonCodeIIS,BonCodeCallHandler,F:\newReposMay17\Bilal-S_iis2tomcat\BonCodeIIS\CallHandler.cs,IISNativeHeaders,The following switch statement is missing a default case: switch (headerName) {  case "Location":  case "Content-Location":  	//in cases where we are restricted from writing status codes we will do a server side redirect when we detect the right headers  	if (!BonCodeAJP13Settings.BONCODEAJP13_ENABLE_HTTPSTATUSCODES) {  		p_Context.Response.Redirect (headerValue);  	}  	break;  }  
